(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd)
    define([], factory);
  else if (typeof exports === 'object')
    exports['videojs-hlsjs-plugin'] = factory();
  else
    root['videojs-hlsjs-plugin'] = factory();
})(this, function() {
  return /******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ 	// The require function
    /******/
    function __webpack_require__(moduleId) {
      /******/
      /******/ 		// Check if module is in cache
      /******/
      if (installedModules[moduleId]) {
        /******/
        return installedModules[moduleId].exports;
        /******/
      }
      /******/ 		// Create a new module (and put it into the cache)
      /******/
      var module = installedModules[moduleId] = {
        /******/      i: moduleId,
        /******/      l: false,
        /******/      exports: {},
        /******/
      };
      /******/
      /******/ 		// Execute the module function
      /******/
      modules[moduleId].call(module.exports, module, module.exports,
          __webpack_require__);
      /******/
      /******/ 		// Flag the module as loaded
      /******/
      module.l = true;
      /******/
      /******/ 		// Return the exports of the module
      /******/
      return module.exports;
      /******/
    }

    /******/
    /******/
    /******/ 	// expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ 	// expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ 	// define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
      /******/
      if (!__webpack_require__.o(exports, name)) {
        /******/
        Object.defineProperty(exports, name, {
          /******/        configurable: false,
          /******/        enumerable: true,
          /******/        get: getter,
          /******/
        });
        /******/
      }
      /******/
    };
    /******/
    /******/ 	// getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
      /******/
      var getter = module && module.__esModule ?
          /******/      function getDefault() { return module['default']; } :
          /******/      function getModuleExports() { return module; };
      /******/
      __webpack_require__.d(getter, 'a', getter);
      /******/
      return getter;
      /******/
    };
    /******/
    /******/ 	// Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(
        object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ 	// __webpack_public_path__
    /******/
    __webpack_require__.p = '/dist';
    /******/
    /******/ 	// Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 34);
    /******/
  })
      /************************************************************************/
      /******/ ([
        /* 0 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return isFiniteNumber; });
          var isFiniteNumber = Number.isFinite || function(value) {
            return typeof value === 'number' && isFinite(value);
          };

          /***/
        }),
        /* 1 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return enableLogs; });
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'b',
              function() { return logger; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__get_self_scope__ = __webpack_require__(
              5);

          function noop() {}

          var fakeLogger = {
            trace: noop,
            debug: noop,
            log: noop,
            warn: noop,
            info: noop,
            error: noop,
          };
          var exportedLogger = fakeLogger; // let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

          function formatMsg(type, msg) {
            msg = '[' + type + '] > ' + msg;
            return msg;
          }

          var global = Object(
              __WEBPACK_IMPORTED_MODULE_0__get_self_scope__['a' /* getSelfScope */])();

          function consolePrintFn(type) {
            var func = global.console[type];

            if (func) {
              return function() {
                for (var _len = arguments.length, args = new Array(
                    _len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                if (args[0]) {
                  args[0] = formatMsg(type, args[0]);
                }

                func.apply(global.console, args);
              };
            }

            return noop;
          }

          function exportLoggerFunctions(debugConfig) {
            for (var _len2 = arguments.length, functions = new Array(
                _len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              functions[_key2 - 1] = arguments[_key2];
            }

            functions.forEach(function(type) {
              exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(
                  debugConfig) : consolePrintFn(type);
            });
          }

          var enableLogs = function enableLogs(debugConfig) {
            // check that console is available
            if (global.console && debugConfig === true || typeof debugConfig ===
                'object') {
              exportLoggerFunctions(debugConfig, // Remove out from list here to hard-disable a log-level
                  // 'trace',
                  'debug', 'log', 'info', 'warn', 'error'); // Some browsers don't allow to use bind on console object anyway
              // fallback to default if needed

              try {
                exportedLogger.log();
              } catch (e) {
                exportedLogger = fakeLogger;
              }
            } else {
              exportedLogger = fakeLogger;
            }
          };
          var logger = exportedLogger;

          /***/
        }),
        /* 2 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /**
           * @readonly
           * @enum {string}
           */
          var HlsEvents = {
            // fired before MediaSource is attaching to media element - data: { media }
            MEDIA_ATTACHING: 'hlsMediaAttaching',
            // fired when MediaSource has been succesfully attached to media element - data: { }
            MEDIA_ATTACHED: 'hlsMediaAttached',
            // fired before detaching MediaSource from media element - data: { }
            MEDIA_DETACHING: 'hlsMediaDetaching',
            // fired when MediaSource has been detached from media element - data: { }
            MEDIA_DETACHED: 'hlsMediaDetached',
            // fired when we buffer is going to be reset - data: { }
            BUFFER_RESET: 'hlsBufferReset',
            // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
            BUFFER_CODECS: 'hlsBufferCodecs',
            // fired when sourcebuffers have been created - data: { tracks : tracks }
            BUFFER_CREATED: 'hlsBufferCreated',
            // fired when we append a segment to the buffer - data: { segment: segment object }
            BUFFER_APPENDING: 'hlsBufferAppending',
            // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
            BUFFER_APPENDED: 'hlsBufferAppended',
            // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
            BUFFER_EOS: 'hlsBufferEos',
            // fired when the media buffer should be flushed - data { startOffset, endOffset }
            BUFFER_FLUSHING: 'hlsBufferFlushing',
            // fired when the media buffer has been flushed - data: { }
            BUFFER_FLUSHED: 'hlsBufferFlushed',
            // fired to signal that a manifest loading starts - data: { url : manifestURL}
            MANIFEST_LOADING: 'hlsManifestLoading',
            // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
            MANIFEST_LOADED: 'hlsManifestLoaded',
            // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
            MANIFEST_PARSED: 'hlsManifestParsed',
            // fired when a level switch is requested - data: { level : id of new level }
            LEVEL_SWITCHING: 'hlsLevelSwitching',
            // fired when a level switch is effective - data: { level : id of new level }
            LEVEL_SWITCHED: 'hlsLevelSwitched',
            // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
            LEVEL_LOADING: 'hlsLevelLoading',
            // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
            LEVEL_LOADED: 'hlsLevelLoaded',
            // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
            LEVEL_UPDATED: 'hlsLevelUpdated',
            // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
            LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
            // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
            AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
            // fired when an audio track switching is requested - data: { id : audio track id }
            AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
            // fired when an audio track switch actually occurs - data: { id : audio track id }
            AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
            // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
            AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
            // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
            AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
            // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
            SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
            // fired when an subtitle track switch occurs - data: { id : subtitle track id }
            SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
            // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
            SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
            // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
            SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
            // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
            SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
            // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
            INIT_PTS_FOUND: 'hlsInitPtsFound',
            // fired when a fragment loading starts - data: { frag : fragment object }
            FRAG_LOADING: 'hlsFragLoading',
            // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
            FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
            // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
            FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
            // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
            FRAG_LOADED: 'hlsFragLoaded',
            // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
            FRAG_DECRYPTED: 'hlsFragDecrypted',
            // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
            FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
            // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
            FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
            // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
            FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
            // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
            FRAG_PARSING_DATA: 'hlsFragParsingData',
            // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
            FRAG_PARSED: 'hlsFragParsed',
            // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
            FRAG_BUFFERED: 'hlsFragBuffered',
            // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
            FRAG_CHANGED: 'hlsFragChanged',
            // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
            FPS_DROP: 'hlsFpsDrop',
            // triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
            FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
            // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
            ERROR: 'hlsError',
            // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
            DESTROYING: 'hlsDestroying',
            // fired when a decrypt key loading starts - data: { frag : fragment object }
            KEY_LOADING: 'hlsKeyLoading',
            // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
            KEY_LOADED: 'hlsKeyLoaded',
            // fired upon stream controller state transitions - data: { previousState, nextState }
            STREAM_STATE_TRANSITION: 'hlsStreamStateTransition',
            // fired when the live back buffer is reached defined by the liveBackBufferLength config option - data : { bufferEnd: number }
            LIVE_BACK_BUFFER_REACHED: 'hlsLiveBackBufferReached',
          };
          /* harmony default export */
          __webpack_exports__['a'] = (HlsEvents);

          /***/
        }),
        /* 3 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'b',
              function() { return ErrorTypes; });
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return ErrorDetails; });
          var ErrorTypes;
          /**
           * @enum {ErrorDetails}
           * @typedef {string} ErrorDetail
           */

          (function(ErrorTypes) {
            ErrorTypes['NETWORK_ERROR'] = 'networkError';
            ErrorTypes['MEDIA_ERROR'] = 'mediaError';
            ErrorTypes['KEY_SYSTEM_ERROR'] = 'keySystemError';
            ErrorTypes['MUX_ERROR'] = 'muxError';
            ErrorTypes['OTHER_ERROR'] = 'otherError';
          })(ErrorTypes || (ErrorTypes = {}));

          var ErrorDetails;

          (function(ErrorDetails) {
            ErrorDetails['KEY_SYSTEM_NO_KEYS'] = 'keySystemNoKeys';
            ErrorDetails['KEY_SYSTEM_NO_ACCESS'] = 'keySystemNoAccess';
            ErrorDetails['KEY_SYSTEM_NO_SESSION'] = 'keySystemNoSession';
            ErrorDetails['KEY_SYSTEM_LICENSE_REQUEST_FAILED'] = 'keySystemLicenseRequestFailed';
            ErrorDetails['KEY_SYSTEM_NO_INIT_DATA'] = 'keySystemNoInitData';
            ErrorDetails['MANIFEST_LOAD_ERROR'] = 'manifestLoadError';
            ErrorDetails['MANIFEST_LOAD_TIMEOUT'] = 'manifestLoadTimeOut';
            ErrorDetails['MANIFEST_PARSING_ERROR'] = 'manifestParsingError';
            ErrorDetails['MANIFEST_INCOMPATIBLE_CODECS_ERROR'] = 'manifestIncompatibleCodecsError';
            ErrorDetails['LEVEL_LOAD_ERROR'] = 'levelLoadError';
            ErrorDetails['LEVEL_LOAD_TIMEOUT'] = 'levelLoadTimeOut';
            ErrorDetails['LEVEL_SWITCH_ERROR'] = 'levelSwitchError';
            ErrorDetails['AUDIO_TRACK_LOAD_ERROR'] = 'audioTrackLoadError';
            ErrorDetails['AUDIO_TRACK_LOAD_TIMEOUT'] = 'audioTrackLoadTimeOut';
            ErrorDetails['FRAG_LOAD_ERROR'] = 'fragLoadError';
            ErrorDetails['FRAG_LOAD_TIMEOUT'] = 'fragLoadTimeOut';
            ErrorDetails['FRAG_DECRYPT_ERROR'] = 'fragDecryptError';
            ErrorDetails['FRAG_PARSING_ERROR'] = 'fragParsingError';
            ErrorDetails['REMUX_ALLOC_ERROR'] = 'remuxAllocError';
            ErrorDetails['KEY_LOAD_ERROR'] = 'keyLoadError';
            ErrorDetails['KEY_LOAD_TIMEOUT'] = 'keyLoadTimeOut';
            ErrorDetails['BUFFER_ADD_CODEC_ERROR'] = 'bufferAddCodecError';
            ErrorDetails['BUFFER_APPEND_ERROR'] = 'bufferAppendError';
            ErrorDetails['BUFFER_APPENDING_ERROR'] = 'bufferAppendingError';
            ErrorDetails['BUFFER_STALLED_ERROR'] = 'bufferStalledError';
            ErrorDetails['BUFFER_FULL_ERROR'] = 'bufferFullError';
            ErrorDetails['BUFFER_SEEK_OVER_HOLE'] = 'bufferSeekOverHole';
            ErrorDetails['BUFFER_NUDGE_ON_STALL'] = 'bufferNudgeOnStall';
            ErrorDetails['INTERNAL_EXCEPTION'] = 'internalException';
          })(ErrorDetails || (ErrorDetails = {}));

          /***/
        }),
        /* 4 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__events__ = __webpack_require__(2);
          /*
*
* All objects in the event handling chain should inherit from this class
*
*/

          var FORBIDDEN_EVENT_NAMES = {
            'hlsEventGeneric': true,
            'hlsHandlerDestroying': true,
            'hlsHandlerDestroyed': true,
          };

          var EventHandler =
              /*#__PURE__*/
              function() {
                function EventHandler(hls) {
                  this.hls = void 0;
                  this.handledEvents = void 0;
                  this.useGenericHandler = void 0;
                  this.hls = hls;
                  this.onEvent = this.onEvent.bind(this);

                  for (var _len = arguments.length, events = new Array(
                      _len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    events[_key - 1] = arguments[_key];
                  }

                  this.handledEvents = events;
                  this.useGenericHandler = true;
                  this.registerListeners();
                }

                var _proto = EventHandler.prototype;

                _proto.destroy = function destroy() {
                  this.onHandlerDestroying();
                  this.unregisterListeners();
                  this.onHandlerDestroyed();
                };

                _proto.onHandlerDestroying = function onHandlerDestroying() {};

                _proto.onHandlerDestroyed = function onHandlerDestroyed() {};

                _proto.isEventHandler = function isEventHandler() {
                  return typeof this.handledEvents === 'object' &&
                      this.handledEvents.length && typeof this.onEvent ===
                      'function';
                };

                _proto.registerListeners = function registerListeners() {
                  if (this.isEventHandler()) {
                    this.handledEvents.forEach(function(event) {
                      if (FORBIDDEN_EVENT_NAMES[event]) {
                        throw new Error('Forbidden event-name: ' + event);
                      }

                      this.hls.on(event, this.onEvent);
                    }, this);
                  }
                };

                _proto.unregisterListeners = function unregisterListeners() {
                  if (this.isEventHandler()) {
                    this.handledEvents.forEach(function(event) {
                      this.hls.off(event, this.onEvent);
                    }, this);
                  }
                }
                /**
                 * arguments: event (string), data (any)
                 */
                ;

                _proto.onEvent = function onEvent(event, data) {
                  this.onEventGeneric(event, data);
                };

                _proto.onEventGeneric = function onEventGeneric(event, data) {
                  var eventToFunction = function eventToFunction(event, data) {
                    var funcName = 'on' + event.replace('hls', '');

                    if (typeof this[funcName] !== 'function') {
                      throw new Error('Event ' + event +
                          ' has no generic handler in this ' +
                          this.constructor.name + ' class (tried ' + funcName +
                          ')');
                    }

                    return this[funcName].bind(this, data);
                  };

                  try {
                    eventToFunction.call(this, event, data).call();
                  } catch (err) {
                    __WEBPACK_IMPORTED_MODULE_0__utils_logger__['b' /* logger */].error(
                        'An internal error happened while handling event ' +
                        event + '. Error message: "' + err.message +
                        '". Here is a stacktrace:', err);
                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_1__errors__['b' /* ErrorTypes */].OTHER_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_1__errors__['a' /* ErrorDetails */].INTERNAL_EXCEPTION,
                          fatal: false,
                          event: event,
                          err: err,
                        });
                  }
                };

                return EventHandler;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (EventHandler);

          /***/
        }),
        /* 5 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (immutable) */
          __webpack_exports__['a'] = getSelfScope;

          function getSelfScope() {
            // see https://stackoverflow.com/a/11237259/589493
            if (typeof window === 'undefined') {
              /* eslint-disable-next-line no-undef */
              return self;
            } else {
              return window;
            }
          }

          /***/
        }),
        /* 6 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return BufferHelper; });
          /**
           * @module BufferHelper
           *
           * Providing methods dealing with buffer length retrieval for example.
           *
           * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.
           *
           * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered
           */
          var BufferHelper =
              /*#__PURE__*/
              function() {
                function BufferHelper() {}

                /**
                 * Return true if `media`'s buffered include `position`
                 * @param {Bufferable} media
                 * @param {number} position
                 * @returns {boolean}
                 */
                BufferHelper.isBuffered = function isBuffered(media, position) {
                  try {
                    if (media) {
                      var buffered = media.buffered;

                      for (var i = 0; i < buffered.length; i++) {
                        if (position >= buffered.start(i) && position <=
                            buffered.end(i)) {
                          return true;
                        }
                      }
                    }
                  } catch (error) {// this is to catch
                    // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
                    // This SourceBuffer has been removed from the parent media source
                  }

                  return false;
                };

                BufferHelper.bufferInfo = function bufferInfo(
                    media, pos, maxHoleDuration) {
                  try {
                    if (media) {
                      var vbuffered = media.buffered;
                      var buffered = [];
                      var i;

                      for (i = 0; i < vbuffered.length; i++) {
                        buffered.push({
                          start: vbuffered.start(i),
                          end: vbuffered.end(i),
                        });
                      }

                      return this.bufferedInfo(buffered, pos, maxHoleDuration);
                    }
                  } catch (error) {// this is to catch
                    // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
                    // This SourceBuffer has been removed from the parent media source
                  }

                  return {
                    len: 0,
                    start: pos,
                    end: pos,
                    nextStart: undefined,
                  };
                };

                BufferHelper.bufferedInfo = function bufferedInfo(
                    buffered, pos, maxHoleDuration) {
                  // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
                  buffered.sort(function(a, b) {
                    var diff = a.start - b.start;

                    if (diff) {
                      return diff;
                    } else {
                      return b.end - a.end;
                    }
                  });
                  var buffered2 = [];

                  if (maxHoleDuration) {
                    // there might be some small holes between buffer time range
                    // consider that holes smaller than maxHoleDuration are irrelevant and build another
                    // buffer time range representations that discards those holes
                    for (var i = 0; i < buffered.length; i++) {
                      var buf2len = buffered2.length;

                      if (buf2len) {
                        var buf2end = buffered2[buf2len - 1].end; // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)

                        if (buffered[i].start - buf2end < maxHoleDuration) {
                          // merge overlapping time ranges
                          // update lastRange.end only if smaller than item.end
                          // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
                          // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
                          if (buffered[i].end > buf2end) {
                            buffered2[buf2len - 1].end = buffered[i].end;
                          }
                        } else {
                          // big hole
                          buffered2.push(buffered[i]);
                        }
                      } else {
                        // first value
                        buffered2.push(buffered[i]);
                      }
                    }
                  } else {
                    buffered2 = buffered;
                  }

                  var bufferLen = 0; // bufferStartNext can possibly be undefined based on the conditional logic below

                  var bufferStartNext; // bufferStart and bufferEnd are buffer boundaries around current video position

                  var bufferStart = pos;
                  var bufferEnd = pos;

                  for (var _i = 0; _i < buffered2.length; _i++) {
                    var start = buffered2[_i].start,
                        end = buffered2[_i].end; // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));

                    if (pos + maxHoleDuration >= start && pos < end) {
                      // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
                      bufferStart = start;
                      bufferEnd = end;
                      bufferLen = bufferEnd - pos;
                    } else if (pos + maxHoleDuration < start) {
                      bufferStartNext = start;
                      break;
                    }
                  }

                  return {
                    len: bufferLen,
                    start: bufferStart,
                    end: bufferEnd,
                    nextStart: bufferStartNext,
                  };
                };

                return BufferHelper;
              }();

          /***/
        }),
        /* 7 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return FragmentState; });
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'b',
              function() { return FragmentTracker; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__event_handler__ = __webpack_require__(
              4);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__events__ = __webpack_require__(2);

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          var FragmentState = {
            NOT_LOADED: 'NOT_LOADED',
            APPENDING: 'APPENDING',
            PARTIAL: 'PARTIAL',
            OK: 'OK',
          };
          var FragmentTracker =
              /*#__PURE__*/
              function(_EventHandler) {
                _inheritsLoose(FragmentTracker, _EventHandler);

                function FragmentTracker(hls) {
                  var _this;

                  _this = _EventHandler.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].BUFFER_APPENDED,
                      __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].FRAG_BUFFERED,
                      __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].FRAG_LOADED) ||
                      this;
                  _this.bufferPadding = 0.2;
                  _this.fragments = Object.create(null);
                  _this.timeRanges = Object.create(null);
                  _this.config = hls.config;
                  return _this;
                }

                var _proto = FragmentTracker.prototype;

                _proto.destroy = function destroy() {
                  this.fragments = Object.create(null);
                  this.timeRanges = Object.create(null);
                  this.config = null;
                  __WEBPACK_IMPORTED_MODULE_1__event_handler__['a' /* default */].prototype.destroy.call(
                      this);

                  _EventHandler.prototype.destroy.call(this);
                }
                /**
                 * Return a Fragment that match the position and levelType.
                 * If not found any Fragment, return null
                 * @param {number} position
                 * @param {LevelType} levelType
                 * @returns {Fragment|null}
                 */
                ;

                _proto.getBufferedFrag = function getBufferedFrag(
                    position, levelType) {
                  var fragments = this.fragments;
                  var bufferedFrags = Object.keys(fragments).
                      filter(function(key) {
                        var fragmentEntity = fragments[key];

                        if (fragmentEntity.body.type !== levelType) {
                          return false;
                        }

                        if (!fragmentEntity.buffered) {
                          return false;
                        }

                        var frag = fragmentEntity.body;
                        return frag.startPTS <= position && position <=
                            frag.endPTS;
                      });

                  if (bufferedFrags.length === 0) {
                    return null;
                  } else {
                    // https://github.com/video-dev/hls.js/pull/1545#discussion_r166229566
                    var bufferedFragKey = bufferedFrags.pop();
                    return fragments[bufferedFragKey].body;
                  }
                }
                /**
                 * Partial fragments effected by coded frame eviction will be removed
                 * The browser will unload parts of the buffer to free up memory for new buffer data
                 * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
                 * @param {String} elementaryStream The elementaryStream of media this is (eg. video/audio)
                 * @param {TimeRanges} timeRange TimeRange object from a sourceBuffer
                 */
                ;

                _proto.detectEvictedFragments = function detectEvictedFragments(
                    elementaryStream, timeRange) {
                  var _this2 = this;

                  var fragmentTimes, time; // Check if any flagged fragments have been unloaded

                  Object.keys(this.fragments).forEach(function(key) {
                    var fragmentEntity = _this2.fragments[key];

                    if (fragmentEntity.buffered === true) {
                      var esData = fragmentEntity.range[elementaryStream];

                      if (esData) {
                        fragmentTimes = esData.time;

                        for (var i = 0; i < fragmentTimes.length; i++) {
                          time = fragmentTimes[i];

                          if (_this2.isTimeBuffered(time.startPTS, time.endPTS,
                              timeRange) === false) {
                            // Unregister partial fragment as it needs to load again to be reused
                            _this2.removeFragment(fragmentEntity.body);

                            break;
                          }
                        }
                      }
                    }
                  });
                }
                /**
                 * Checks if the fragment passed in is loaded in the buffer properly
                 * Partially loaded fragments will be registered as a partial fragment
                 * @param {Object} fragment Check the fragment against all sourceBuffers loaded
                 */
                ;

                _proto.detectPartialFragments = function detectPartialFragments(fragment) {
                  var _this3 = this;

                  var fragKey = this.getFragmentKey(fragment);
                  var fragmentEntity = this.fragments[fragKey];

                  if (fragmentEntity) {
                    fragmentEntity.buffered = true;
                    Object.keys(this.timeRanges).
                        forEach(function(elementaryStream) {
                          if (fragment.hasElementaryStream(elementaryStream)) {
                            var timeRange = _this3.timeRanges[elementaryStream]; // Check for malformed fragments
                            // Gaps need to be calculated for each elementaryStream

                            fragmentEntity.range[elementaryStream] = _this3.getBufferedTimes(
                                fragment.startPTS, fragment.endPTS, timeRange);
                          }
                        });
                  }
                };

                _proto.getBufferedTimes = function getBufferedTimes(
                    startPTS, endPTS, timeRange) {
                  var fragmentTimes = [];
                  var startTime, endTime;
                  var fragmentPartial = false;

                  for (var i = 0; i < timeRange.length; i++) {
                    startTime = timeRange.start(i) - this.bufferPadding;
                    endTime = timeRange.end(i) + this.bufferPadding;

                    if (startPTS >= startTime && endPTS <= endTime) {
                      // Fragment is entirely contained in buffer
                      // No need to check the other timeRange times since it's completely playable
                      fragmentTimes.push({
                        startPTS: Math.max(startPTS, timeRange.start(i)),
                        endPTS: Math.min(endPTS, timeRange.end(i)),
                      });
                      break;
                    } else if (startPTS < endTime && endPTS > startTime) {
                      // Check for intersection with buffer
                      // Get playable sections of the fragment
                      fragmentTimes.push({
                        startPTS: Math.max(startPTS, timeRange.start(i)),
                        endPTS: Math.min(endPTS, timeRange.end(i)),
                      });
                      fragmentPartial = true;
                    } else if (endPTS <= startTime) {
                      // No need to check the rest of the timeRange as it is in order
                      break;
                    }
                  }

                  return {
                    time: fragmentTimes,
                    partial: fragmentPartial,
                  };
                };

                _proto.getFragmentKey = function getFragmentKey(fragment) {
                  return fragment.type + '_' + fragment.level + '_' +
                      fragment.urlId + '_' + fragment.sn;
                }
                /**
                 * Gets the partial fragment for a certain time
                 * @param {Number} time
                 * @returns {Object} fragment Returns a partial fragment at a time or null if there is no partial fragment
                 */
                ;

                _proto.getPartialFragment = function getPartialFragment(time) {
                  var _this4 = this;

                  var timePadding, startTime, endTime;
                  var bestFragment = null;
                  var bestOverlap = 0;
                  Object.keys(this.fragments).forEach(function(key) {
                    var fragmentEntity = _this4.fragments[key];

                    if (_this4.isPartial(fragmentEntity)) {
                      startTime = fragmentEntity.body.startPTS -
                          _this4.bufferPadding;
                      endTime = fragmentEntity.body.endPTS +
                          _this4.bufferPadding;

                      if (time >= startTime && time <= endTime) {
                        // Use the fragment that has the most padding from start and end time
                        timePadding = Math.min(time - startTime,
                            endTime - time);

                        if (bestOverlap <= timePadding) {
                          bestFragment = fragmentEntity.body;
                          bestOverlap = timePadding;
                        }
                      }
                    }
                  });
                  return bestFragment;
                }
                /**
                 * @param {Object} fragment The fragment to check
                 * @returns {String} Returns the fragment state when a fragment never loaded or if it partially loaded
                 */
                ;

                _proto.getState = function getState(fragment) {
                  var fragKey = this.getFragmentKey(fragment);
                  var fragmentEntity = this.fragments[fragKey];
                  var state = FragmentState.NOT_LOADED;

                  if (fragmentEntity !== undefined) {
                    if (!fragmentEntity.buffered) {
                      state = FragmentState.APPENDING;
                    } else if (this.isPartial(fragmentEntity) === true) {
                      state = FragmentState.PARTIAL;
                    } else {
                      state = FragmentState.OK;
                    }
                  }

                  return state;
                };

                _proto.isPartial = function isPartial(fragmentEntity) {
                  return fragmentEntity.buffered === true &&
                      (fragmentEntity.range.video !== undefined &&
                          fragmentEntity.range.video.partial === true ||
                          fragmentEntity.range.audio !== undefined &&
                          fragmentEntity.range.audio.partial === true);
                };

                _proto.isTimeBuffered = function isTimeBuffered(
                    startPTS, endPTS, timeRange) {
                  var startTime, endTime;

                  for (var i = 0; i < timeRange.length; i++) {
                    startTime = timeRange.start(i) - this.bufferPadding;
                    endTime = timeRange.end(i) + this.bufferPadding;

                    if (startPTS >= startTime && endPTS <= endTime) {
                      return true;
                    }

                    if (endPTS <= startTime) {
                      // No need to check the rest of the timeRange as it is in order
                      return false;
                    }
                  }

                  return false;
                }
                /**
                 * Fires when a fragment loading is completed
                 */
                ;

                _proto.onFragLoaded = function onFragLoaded(e) {
                  var fragment = e.frag; // don't track initsegment (for which sn is not a number)
                  // don't track frags used for bitrateTest, they're irrelevant.

                  if (!Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      fragment.sn) || fragment.bitrateTest) {
                    return;
                  }

                  this.fragments[this.getFragmentKey(fragment)] = {
                    body: fragment,
                    range: Object.create(null),
                    buffered: false,
                  };
                }
                /**
                 * Fires when the buffer is updated
                 */
                ;

                _proto.onBufferAppended = function onBufferAppended(e) {
                  var _this5 = this;

                  // Store the latest timeRanges loaded in the buffer
                  this.timeRanges = e.timeRanges;
                  Object.keys(this.timeRanges).
                      forEach(function(elementaryStream) {
                        var timeRange = _this5.timeRanges[elementaryStream];

                        _this5.detectEvictedFragments(elementaryStream,
                            timeRange);
                      });
                }
                /**
                 * Fires after a fragment has been loaded into the source buffer
                 */
                ;

                _proto.onFragBuffered = function onFragBuffered(e) {
                  this.detectPartialFragments(e.frag);
                }
                /**
                 * Return true if fragment tracker has the fragment.
                 * @param {Object} fragment
                 * @returns {boolean}
                 */
                ;

                _proto.hasFragment = function hasFragment(fragment) {
                  var fragKey = this.getFragmentKey(fragment);
                  return this.fragments[fragKey] !== undefined;
                }
                /**
                 * Remove a fragment from fragment tracker until it is loaded again
                 * @param {Object} fragment The fragment to remove
                 */
                ;

                _proto.removeFragment = function removeFragment(fragment) {
                  var fragKey = this.getFragmentKey(fragment);
                  delete this.fragments[fragKey];
                }
                /**
                 * Remove all fragments from fragment tracker.
                 */
                ;

                _proto.removeAllFragments = function removeAllFragments() {
                  this.fragments = Object.create(null);
                };

                return FragmentTracker;
              }(__WEBPACK_IMPORTED_MODULE_1__event_handler__['a' /* default */]);

          /***/
        }),
        /* 8 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'b',
              function() { return utf8ArrayToStr; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__utils_get_self_scope__ = __webpack_require__(
              5);

          /**
           * ID3 parser
           */

          var ID3 =
              /*#__PURE__*/
              function() {
                function ID3() {}

                /**
                 * Returns true if an ID3 header can be found at offset in data
                 * @param {Uint8Array} data - The data to search in
                 * @param {number} offset - The offset at which to start searching
                 * @return {boolean} - True if an ID3 header is found
                 */
                ID3.isHeader = function isHeader(data, offset) {
                  /*
    * http://id3.org/id3v2.3.0
    * [0]     = 'I'
    * [1]     = 'D'
    * [2]     = '3'
    * [3,4]   = {Version}
    * [5]     = {Flags}
    * [6-9]   = {ID3 Size}
    *
    * An ID3v2 tag can be detected with the following pattern:
    *  $49 44 33 yy yy xx zz zz zz zz
    * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80
    */
                  if (offset + 10 <= data.length) {
                    // look for 'ID3' identifier
                    if (data[offset] === 0x49 && data[offset + 1] === 0x44 &&
                        data[offset + 2] === 0x33) {
                      // check version is within range
                      if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
                        // check size is within range
                        if (data[offset + 6] < 0x80 && data[offset + 7] <
                            0x80 && data[offset + 8] < 0x80 &&
                            data[offset + 9] < 0x80) {
                          return true;
                        }
                      }
                    }
                  }

                  return false;
                }
                /**
                 * Returns true if an ID3 footer can be found at offset in data
                 * @param {Uint8Array} data - The data to search in
                 * @param {number} offset - The offset at which to start searching
                 * @return {boolean} - True if an ID3 footer is found
                 */
                ;

                ID3.isFooter = function isFooter(data, offset) {
                  /*
    * The footer is a copy of the header, but with a different identifier
    */
                  if (offset + 10 <= data.length) {
                    // look for '3DI' identifier
                    if (data[offset] === 0x33 && data[offset + 1] === 0x44 &&
                        data[offset + 2] === 0x49) {
                      // check version is within range
                      if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
                        // check size is within range
                        if (data[offset + 6] < 0x80 && data[offset + 7] <
                            0x80 && data[offset + 8] < 0x80 &&
                            data[offset + 9] < 0x80) {
                          return true;
                        }
                      }
                    }
                  }

                  return false;
                }
                /**
                 * Returns any adjacent ID3 tags found in data starting at offset, as one block of data
                 * @param {Uint8Array} data - The data to search in
                 * @param {number} offset - The offset at which to start searching
                 * @return {Uint8Array} - The block of data containing any ID3 tags found
                 */
                ;

                ID3.getID3Data = function getID3Data(data, offset) {
                  var front = offset;
                  var length = 0;

                  while (ID3.isHeader(data, offset)) {
                    // ID3 header is 10 bytes
                    length += 10;

                    var size = ID3._readSize(data, offset + 6);

                    length += size;

                    if (ID3.isFooter(data, offset + 10)) {
                      // ID3 footer is 10 bytes
                      length += 10;
                    }

                    offset += length;
                  }

                  if (length > 0) {
                    return data.subarray(front, front + length);
                  }

                  return undefined;
                };

                ID3._readSize = function _readSize(data, offset) {
                  var size = 0;
                  size = (data[offset] & 0x7f) << 21;
                  size |= (data[offset + 1] & 0x7f) << 14;
                  size |= (data[offset + 2] & 0x7f) << 7;
                  size |= data[offset + 3] & 0x7f;
                  return size;
                }
                /**
                 * Searches for the Elementary Stream timestamp found in the ID3 data chunk
                 * @param {Uint8Array} data - Block of data containing one or more ID3 tags
                 * @return {number} - The timestamp
                 */
                ;

                ID3.getTimeStamp = function getTimeStamp(data) {
                  var frames = ID3.getID3Frames(data);

                  for (var i = 0; i < frames.length; i++) {
                    var frame = frames[i];

                    if (ID3.isTimeStampFrame(frame)) {
                      return ID3._readTimeStamp(frame);
                    }
                  }

                  return undefined;
                }
                /**
                 * Returns true if the ID3 frame is an Elementary Stream timestamp frame
                 * @param {ID3 frame} frame
                 */
                ;

                ID3.isTimeStampFrame = function isTimeStampFrame(frame) {
                  return frame && frame.key === 'PRIV' && frame.info ===
                      'com.apple.streaming.transportStreamTimestamp';
                };

                ID3._getFrameData = function _getFrameData(data) {
                  /*
    Frame ID       $xx xx xx xx (four characters)
    Size           $xx xx xx xx
    Flags          $xx xx
    */
                  var type = String.fromCharCode(data[0], data[1], data[2],
                      data[3]);

                  var size = ID3._readSize(data, 4); // skip frame id, size, and flags

                  var offset = 10;
                  return {
                    type: type,
                    size: size,
                    data: data.subarray(offset, offset + size),
                  };
                }
                /**
                 * Returns an array of ID3 frames found in all the ID3 tags in the id3Data
                 * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags
                 * @return {ID3 frame[]} - Array of ID3 frame objects
                 */
                ;

                ID3.getID3Frames = function getID3Frames(id3Data) {
                  var offset = 0;
                  var frames = [];

                  while (ID3.isHeader(id3Data, offset)) {
                    var size = ID3._readSize(id3Data, offset + 6); // skip past ID3 header

                    offset += 10;
                    var end = offset + size; // loop through frames in the ID3 tag

                    while (offset + 8 < end) {
                      var frameData = ID3._getFrameData(
                          id3Data.subarray(offset));

                      var frame = ID3._decodeFrame(frameData);

                      if (frame) {
                        frames.push(frame);
                      } // skip frame header and frame data

                      offset += frameData.size + 10;
                    }

                    if (ID3.isFooter(id3Data, offset)) {
                      offset += 10;
                    }
                  }

                  return frames;
                };

                ID3._decodeFrame = function _decodeFrame(frame) {
                  if (frame.type === 'PRIV') {
                    return ID3._decodePrivFrame(frame);
                  } else if (frame.type[0] === 'T') {
                    return ID3._decodeTextFrame(frame);
                  } else if (frame.type[0] === 'W') {
                    return ID3._decodeURLFrame(frame);
                  }

                  return undefined;
                };

                ID3._readTimeStamp = function _readTimeStamp(timeStampFrame) {
                  if (timeStampFrame.data.byteLength === 8) {
                    var data = new Uint8Array(timeStampFrame.data); // timestamp is 33 bit expressed as a big-endian eight-octet number,
                    // with the upper 31 bits set to zero.

                    var pts33Bit = data[3] & 0x1;
                    var timestamp = (data[4] << 23) + (data[5] << 15) +
                        (data[6] << 7) + data[7];
                    timestamp /= 45;

                    if (pts33Bit) {
                      timestamp += 47721858.84;
                    } // 2^32 / 90

                    return Math.round(timestamp);
                  }

                  return undefined;
                };

                ID3._decodePrivFrame = function _decodePrivFrame(frame) {
                  /*
    Format: <text string>\0<binary data>
    */
                  if (frame.size < 2) {
                    return undefined;
                  }

                  var owner = ID3._utf8ArrayToStr(frame.data, true);

                  var privateData = new Uint8Array(
                      frame.data.subarray(owner.length + 1));
                  return {
                    key: frame.type,
                    info: owner,
                    data: privateData.buffer,
                  };
                };

                ID3._decodeTextFrame = function _decodeTextFrame(frame) {
                  if (frame.size < 2) {
                    return undefined;
                  }

                  if (frame.type === 'TXXX') {
                    /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Description}\0{Value}
      */
                    var index = 1;

                    var description = ID3._utf8ArrayToStr(
                        frame.data.subarray(index), true);

                    index += description.length + 1;

                    var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

                    return {
                      key: frame.type,
                      info: description,
                      data: value,
                    };
                  } else {
                    /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Value}
      */
                    var text = ID3._utf8ArrayToStr(frame.data.subarray(1));

                    return {
                      key: frame.type,
                      data: text,
                    };
                  }
                };

                ID3._decodeURLFrame = function _decodeURLFrame(frame) {
                  if (frame.type === 'WXXX') {
                    /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Description}\0{URL}
      */
                    if (frame.size < 2) {
                      return undefined;
                    }

                    var index = 1;

                    var description = ID3._utf8ArrayToStr(
                        frame.data.subarray(index));

                    index += description.length + 1;

                    var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

                    return {
                      key: frame.type,
                      info: description,
                      data: value,
                    };
                  } else {
                    /*
      Format:
      [0-?] = {URL}
      */
                    var url = ID3._utf8ArrayToStr(frame.data);

                    return {
                      key: frame.type,
                      data: url,
                    };
                  }
                } // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
                // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt

                /* utf.js - UTF-8 <=> UTF-16 convertion
   *
   * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
   * Version: 1.0
   * LastModified: Dec 25 1999
   * This library is free.  You can redistribute it and/or modify it.
   */
                ;

                ID3._utf8ArrayToStr = function _utf8ArrayToStr(
                    array, exitOnNull) {
                  if (exitOnNull === void 0) {
                    exitOnNull = false;
                  }

                  var decoder = getTextDecoder();

                  if (decoder) {
                    var decoded = decoder.decode(array);

                    if (exitOnNull) {
                      // grab up to the first null
                      var idx = decoded.indexOf('\0');
                      return idx !== -1 ? decoded.substring(0, idx) : decoded;
                    } // remove any null characters

                    return decoded.replace(/\0/g, '');
                  }

                  var len = array.length;
                  var c;
                  var char2;
                  var char3;
                  var out = '';
                  var i = 0;

                  while (i < len) {
                    c = array[i++];

                    if (c === 0x00 && exitOnNull) {
                      return out;
                    } else if (c === 0x00 || c === 0x03) {
                      // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it
                      continue;
                    }

                    switch (c >> 4) {
                      case 0:
                      case 1:
                      case 2:
                      case 3:
                      case 4:
                      case 5:
                      case 6:
                      case 7:
                        // 0xxxxxxx
                        out += String.fromCharCode(c);
                        break;

                      case 12:
                      case 13:
                        // 110x xxxx   10xx xxxx
                        char2 = array[i++];
                        out += String.fromCharCode(
                            (c & 0x1F) << 6 | char2 & 0x3F);
                        break;

                      case 14:
                        // 1110 xxxx  10xx xxxx  10xx xxxx
                        char2 = array[i++];
                        char3 = array[i++];
                        out += String.fromCharCode(
                            (c & 0x0F) << 12 | (char2 & 0x3F) << 6 |
                            (char3 & 0x3F) << 0);
                        break;

                      default:
                    }
                  }

                  return out;
                };

                return ID3;
              }();

          var decoder;

          function getTextDecoder() {
            var global = Object(
                __WEBPACK_IMPORTED_MODULE_0__utils_get_self_scope__['a' /* getSelfScope */])(); // safeguard for code that might run both on worker and main thread

            if (!decoder && typeof global.TextDecoder !== 'undefined') {
              decoder = new global.TextDecoder('utf-8');
            }

            return decoder;
          }

          var utf8ArrayToStr = ID3._utf8ArrayToStr;
          /* harmony default export */
          __webpack_exports__['a'] = (ID3);

          /***/
        }),
        /* 9 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (immutable) */
          __webpack_exports__['a'] = addGroupId;
          /* unused harmony export updatePTS */
          /* harmony export (immutable) */
          __webpack_exports__['e'] = updateFragPTSDTS;
          /* harmony export (immutable) */
          __webpack_exports__['c'] = mergeDetails;
          /* harmony export (immutable) */
          __webpack_exports__['d'] = mergeSubtitlePlaylists;
          /* unused harmony export mapFragmentIntersection */
          /* unused harmony export adjustSliding */
          /* harmony export (immutable) */
          __webpack_exports__['b'] = computeReloadInterval;
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__utils_logger__ = __webpack_require__(
              1);

          /**
           * @module LevelHelper
           *
           * Providing methods dealing with playlist sliding and drift
           *
           * TODO: Create an actual `Level` class/model that deals with all this logic in an object-oriented-manner.
           *
           * */

          function addGroupId(level, type, id) {
            switch (type) {
              case 'audio':
                if (!level.audioGroupIds) {
                  level.audioGroupIds = [];
                }

                level.audioGroupIds.push(id);
                break;

              case 'text':
                if (!level.textGroupIds) {
                  level.textGroupIds = [];
                }

                level.textGroupIds.push(id);
                break;
            }
          }

          function updatePTS(fragments, fromIdx, toIdx) {
            var fragFrom = fragments[fromIdx],
                fragTo = fragments[toIdx],
                fragToPTS = fragTo.startPTS; // if we know startPTS[toIdx]

            if (Object(
                __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                fragToPTS)) {
              // update fragment duration.
              // it helps to fix drifts between playlist reported duration and fragment real duration
              if (toIdx > fromIdx) {
                fragFrom.duration = fragToPTS - fragFrom.start;

                if (fragFrom.duration < 0) {
                  __WEBPACK_IMPORTED_MODULE_1__utils_logger__['b' /* logger */].warn(
                      'negative duration computed for frag ' + fragFrom.sn +
                      ',level ' + fragFrom.level +
                      ', there should be some duration drift between playlist and fragment!');
                }
              } else {
                fragTo.duration = fragFrom.start - fragToPTS;

                if (fragTo.duration < 0) {
                  __WEBPACK_IMPORTED_MODULE_1__utils_logger__['b' /* logger */].warn(
                      'negative duration computed for frag ' + fragTo.sn +
                      ',level ' + fragTo.level +
                      ', there should be some duration drift between playlist and fragment!');
                }
              }
            } else {
              // we dont know startPTS[toIdx]
              if (toIdx > fromIdx) {
                fragTo.start = fragFrom.start + fragFrom.duration;
              } else {
                fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
              }
            }
          }

          function updateFragPTSDTS(
              details, frag, startPTS, endPTS, startDTS, endDTS) {
            // update frag PTS/DTS
            var maxStartPTS = startPTS;

            if (Object(
                __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                frag.startPTS)) {
              // delta PTS between audio and video
              var deltaPTS = Math.abs(frag.startPTS - startPTS);

              if (!Object(
                  __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                  frag.deltaPTS)) {
                frag.deltaPTS = deltaPTS;
              } else {
                frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
              }

              maxStartPTS = Math.max(startPTS, frag.startPTS);
              startPTS = Math.min(startPTS, frag.startPTS);
              endPTS = Math.max(endPTS, frag.endPTS);
              startDTS = Math.min(startDTS, frag.startDTS);
              endDTS = Math.max(endDTS, frag.endDTS);
            }

            var drift = startPTS - frag.start;
            frag.start = frag.startPTS = startPTS;
            frag.maxStartPTS = maxStartPTS;
            frag.endPTS = endPTS;
            frag.startDTS = startDTS;
            frag.endDTS = endDTS;
            frag.duration = endPTS - startPTS;
            var sn = frag.sn; // exit if sn out of range

            if (!details || sn < details.startSN || sn > details.endSN) {
              return 0;
            }

            var fragIdx, fragments, i;
            fragIdx = sn - details.startSN;
            fragments = details.fragments; // update frag reference in fragments array
            // rationale is that fragments array might not contain this frag object.
            // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()
            // if we don't update frag, we won't be able to propagate PTS info on the playlist
            // resulting in invalid sliding computation

            fragments[fragIdx] = frag; // adjust fragment PTS/duration from seqnum-1 to frag 0

            for (i = fragIdx; i > 0; i--) {
              updatePTS(fragments, i, i - 1);
            } // adjust fragment PTS/duration from seqnum to last frag

            for (i = fragIdx; i < fragments.length - 1; i++) {
              updatePTS(fragments, i, i + 1);
            }

            details.PTSKnown = true;
            return drift;
          }

          function mergeDetails(oldDetails, newDetails) {
            // potentially retrieve cached initsegment
            if (newDetails.initSegment && oldDetails.initSegment) {
              newDetails.initSegment = oldDetails.initSegment;
            } // check if old/new playlists have fragments in common
            // loop through overlapping SN and update startPTS , cc, and duration if any found

            var ccOffset = 0;
            var PTSFrag;
            mapFragmentIntersection(oldDetails, newDetails,
                function(oldFrag, newFrag) {
                  ccOffset = oldFrag.cc - newFrag.cc;

                  if (Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      oldFrag.startPTS)) {
                    newFrag.start = newFrag.startPTS = oldFrag.startPTS;
                    newFrag.endPTS = oldFrag.endPTS;
                    newFrag.duration = oldFrag.duration;
                    newFrag.backtracked = oldFrag.backtracked;
                    newFrag.dropped = oldFrag.dropped;
                    PTSFrag = newFrag;
                  } // PTS is known when there are overlapping segments

                  newDetails.PTSKnown = true;
                });

            if (!newDetails.PTSKnown) {
              return;
            }

            if (ccOffset) {
              __WEBPACK_IMPORTED_MODULE_1__utils_logger__['b' /* logger */].log(
                  'discontinuity sliding from playlist, take drift into account');
              var newFragments = newDetails.fragments;

              for (var i = 0; i < newFragments.length; i++) {
                newFragments[i].cc += ccOffset;
              }
            } // if at least one fragment contains PTS info, recompute PTS information for all fragments

            if (PTSFrag) {
              updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS,
                  PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
            } else {
              // ensure that delta is within oldFragments range
              // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
              // in that case we also need to adjust start offset of all fragments
              adjustSliding(oldDetails, newDetails);
            } // if we are here, it means we have fragments overlapping between
            // old and new level. reliable PTS info is thus relying on old level

            newDetails.PTSKnown = oldDetails.PTSKnown;
          }

          function mergeSubtitlePlaylists(
              oldPlaylist, newPlaylist, referenceStart) {
            if (referenceStart === void 0) {
              referenceStart = 0;
            }

            var lastIndex = -1;
            mapFragmentIntersection(oldPlaylist, newPlaylist,
                function(oldFrag, newFrag, index) {
                  newFrag.start = oldFrag.start;
                  lastIndex = index;
                });
            var frags = newPlaylist.fragments;

            if (lastIndex < 0) {
              frags.forEach(function(frag) {
                frag.start += referenceStart;
              });
              return;
            }

            for (var i = lastIndex + 1; i < frags.length; i++) {
              frags[i].start = frags[i - 1].start + frags[i - 1].duration;
            }
          }

          function mapFragmentIntersection(
              oldPlaylist, newPlaylist, intersectionFn) {
            if (!oldPlaylist || !newPlaylist) {
              return;
            }

            var start = Math.max(oldPlaylist.startSN, newPlaylist.startSN) -
                newPlaylist.startSN;
            var end = Math.min(oldPlaylist.endSN, newPlaylist.endSN) -
                newPlaylist.startSN;
            var delta = newPlaylist.startSN - oldPlaylist.startSN;

            for (var i = start; i <= end; i++) {
              var oldFrag = oldPlaylist.fragments[delta + i];
              var newFrag = newPlaylist.fragments[i];

              if (!oldFrag || !newFrag) {
                break;
              }

              intersectionFn(oldFrag, newFrag, i);
            }
          }

          function adjustSliding(oldPlaylist, newPlaylist) {
            var delta = newPlaylist.startSN - oldPlaylist.startSN;
            var oldFragments = oldPlaylist.fragments;
            var newFragments = newPlaylist.fragments;

            if (delta < 0 || delta > oldFragments.length) {
              return;
            }

            for (var i = 0; i < newFragments.length; i++) {
              newFragments[i].start += oldFragments[delta].start;
            }
          }

          function computeReloadInterval(
              currentPlaylist, newPlaylist, lastRequestTime) {
            var reloadInterval = 1000 * (newPlaylist.averagetargetduration
                ? newPlaylist.averagetargetduration
                : newPlaylist.targetduration);
            var minReloadInterval = reloadInterval / 2;

            if (currentPlaylist && newPlaylist.endSN ===
                currentPlaylist.endSN) {
              // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
              // changed then it MUST wait for a period of one-half the target
              // duration before retrying.
              reloadInterval = minReloadInterval;
            }

            if (lastRequestTime) {
              reloadInterval = Math.max(minReloadInterval, reloadInterval -
                  (window.performance.now() - lastRequestTime));
            } // in any case, don't reload more than half of target duration

            return Math.round(reloadInterval);
          }

          /***/
        }),
        /* 10 */
        /***/ (function(module, exports, __webpack_require__) {

// see https://tools.ietf.org/html/rfc1808

          /* jshint ignore:start */
          (function(root) {
            /* jshint ignore:end */
            var URL_REGEX = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/\?#]*\/)*.*?)??(;.*?)?(\?.*?)?(#.*?)?$/;
            var FIRST_SEGMENT_REGEX = /^([^\/?#]*)(.*)$/;
            var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
            var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g;
            var URLToolkit = {
              // jshint ignore:line
              // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
              // E.g
              // With opts.alwaysNormalize = false (default, spec compliant)
              // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
              // With opts.alwaysNormalize = true (not spec compliant)
              // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
              buildAbsoluteURL: function buildAbsoluteURL(
                  baseURL, relativeURL, opts) {
                opts = opts || {}; // remove any remaining space and CRLF

                baseURL = baseURL.trim();
                relativeURL = relativeURL.trim();

                if (!relativeURL) {
                  // 2a) If the embedded URL is entirely empty, it inherits the
                  // entire base URL (i.e., is set equal to the base URL)
                  // and we are done.
                  if (!opts.alwaysNormalize) {
                    return baseURL;
                  }

                  var basePartsForNormalise = URLToolkit.parseURL(baseURL);

                  if (!basePartsForNormalise) {
                    throw new Error('Error trying to parse base URL.');
                  }

                  basePartsForNormalise.path = URLToolkit.normalizePath(
                      basePartsForNormalise.path);
                  return URLToolkit.buildURLFromParts(basePartsForNormalise);
                }

                var relativeParts = URLToolkit.parseURL(relativeURL);

                if (!relativeParts) {
                  throw new Error('Error trying to parse relative URL.');
                }

                if (relativeParts.scheme) {
                  // 2b) If the embedded URL starts with a scheme name, it is
                  // interpreted as an absolute URL and we are done.
                  if (!opts.alwaysNormalize) {
                    return relativeURL;
                  }

                  relativeParts.path = URLToolkit.normalizePath(
                      relativeParts.path);
                  return URLToolkit.buildURLFromParts(relativeParts);
                }

                var baseParts = URLToolkit.parseURL(baseURL);

                if (!baseParts) {
                  throw new Error('Error trying to parse base URL.');
                }

                if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !==
                    '/') {
                  // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
                  // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
                  var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
                  baseParts.netLoc = pathParts[1];
                  baseParts.path = pathParts[2];
                }

                if (baseParts.netLoc && !baseParts.path) {
                  baseParts.path = '/';
                }

                var builtParts = {
                  // 2c) Otherwise, the embedded URL inherits the scheme of
                  // the base URL.
                  scheme: baseParts.scheme,
                  netLoc: relativeParts.netLoc,
                  path: null,
                  params: relativeParts.params,
                  query: relativeParts.query,
                  fragment: relativeParts.fragment,
                };

                if (!relativeParts.netLoc) {
                  // 3) If the embedded URL's <net_loc> is non-empty, we skip to
                  // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
                  // (if any) of the base URL.
                  builtParts.netLoc = baseParts.netLoc; // 4) If the embedded URL path is preceded by a slash "/", the
                  // path is not relative and we skip to Step 7.

                  if (relativeParts.path[0] !== '/') {
                    if (!relativeParts.path) {
                      // 5) If the embedded URL path is empty (and not preceded by a
                      // slash), then the embedded URL inherits the base URL path
                      builtParts.path = baseParts.path; // 5a) if the embedded URL's <params> is non-empty, we skip to
                      // step 7; otherwise, it inherits the <params> of the base
                      // URL (if any) and

                      if (!relativeParts.params) {
                        builtParts.params = baseParts.params; // 5b) if the embedded URL's <query> is non-empty, we skip to
                        // step 7; otherwise, it inherits the <query> of the base
                        // URL (if any) and we skip to step 7.

                        if (!relativeParts.query) {
                          builtParts.query = baseParts.query;
                        }
                      }
                    } else {
                      // 6) The last segment of the base URL's path (anything
                      // following the rightmost slash "/", or the entire path if no
                      // slash is present) is removed and the embedded URL's path is
                      // appended in its place.
                      var baseURLPath = baseParts.path;
                      var newPath = baseURLPath.substring(0,
                          baseURLPath.lastIndexOf('/') + 1) +
                          relativeParts.path;
                      builtParts.path = URLToolkit.normalizePath(newPath);
                    }
                  }
                }

                if (builtParts.path === null) {
                  builtParts.path = opts.alwaysNormalize
                      ? URLToolkit.normalizePath(relativeParts.path)
                      : relativeParts.path;
                }

                return URLToolkit.buildURLFromParts(builtParts);
              },
              parseURL: function parseURL(url) {
                var parts = URL_REGEX.exec(url);

                if (!parts) {
                  return null;
                }

                return {
                  scheme: parts[1] || '',
                  netLoc: parts[2] || '',
                  path: parts[3] || '',
                  params: parts[4] || '',
                  query: parts[5] || '',
                  fragment: parts[6] || '',
                };
              },
              normalizePath: function normalizePath(path) {
                // The following operations are
                // then applied, in order, to the new path:
                // 6a) All occurrences of "./", where "." is a complete path
                // segment, are removed.
                // 6b) If the path ends with "." as a complete path segment,
                // that "." is removed.
                path = path.split('').
                    reverse().
                    join('').
                    replace(SLASH_DOT_REGEX, ''); // 6c) All occurrences of "<segment>/../", where <segment> is a
                // complete path segment not equal to "..", are removed.
                // Removal of these path segments is performed iteratively,
                // removing the leftmost matching pattern on each iteration,
                // until no matching pattern remains.
                // 6d) If the path ends with "<segment>/..", where <segment> is a
                // complete path segment not equal to "..", that
                // "<segment>/.." is removed.

                while (path.length !==
                (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line

                return path.split('').reverse().join('');
              },
              buildURLFromParts: function buildURLFromParts(parts) {
                return parts.scheme + parts.netLoc + parts.path + parts.params +
                    parts.query + parts.fragment;
              },
            };
            /* jshint ignore:start */

            if (true) module.exports = URLToolkit; else if (typeof define ===
                'function' && define.amd) define([], function() {
              return URLToolkit;
            }); else if (typeof exports ===
                'object') exports['URLToolkit'] = URLToolkit; else root['URLToolkit'] = URLToolkit;
          })(this);
          /* jshint ignore:end */

          /***/
        }),
        /* 11 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          var BinarySearch = {
            /**
             * Searches for an item in an array which matches a certain condition.
             * This requires the condition to only match one item in the array,
             * and for the array to be ordered.
             *
             * @param {Array<T>} list The array to search.
             * @param {BinarySearchComparison<T>} comparisonFn
             *      Called and provided a candidate item as the first argument.
             *      Should return:
             *          > -1 if the item should be located at a lower index than the provided item.
             *          > 1 if the item should be located at a higher index than the provided item.
             *          > 0 if the item is the item you're looking for.
             *
             * @return {T | null} The object if it is found or null otherwise.
             */
            search: function search(list, comparisonFn) {
              var minIndex = 0;
              var maxIndex = list.length - 1;
              var currentIndex = null;
              var currentElement = null;

              while (minIndex <= maxIndex) {
                currentIndex = (minIndex + maxIndex) / 2 | 0;
                currentElement = list[currentIndex];
                var comparisonResult = comparisonFn(currentElement);

                if (comparisonResult > 0) {
                  minIndex = currentIndex + 1;
                } else if (comparisonResult < 0) {
                  maxIndex = currentIndex - 1;
                } else {
                  return currentElement;
                }
              }

              return null;
            },
          };
          /* harmony default export */
          __webpack_exports__['a'] = (BinarySearch);

          /***/
        }),
        /* 12 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__aes_crypto__ = __webpack_require__(
              45);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__fast_aes_key__ = __webpack_require__(
              46);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__aes_decryptor__ = __webpack_require__(
              47);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_6__utils_get_self_scope__ = __webpack_require__(
              5);

          // see https://stackoverflow.com/a/11237259/589493

          var global = Object(
              __WEBPACK_IMPORTED_MODULE_6__utils_get_self_scope__['a' /* getSelfScope */])(); // safeguard for code that might run both on worker and main thread

          var Decrypter =
              /*#__PURE__*/
              function() {
                function Decrypter(observer, config, _temp) {
                  var _ref = _temp === void 0 ? {} : _temp,
                      _ref$removePKCS7Paddi = _ref.removePKCS7Padding,
                      removePKCS7Padding = _ref$removePKCS7Paddi === void 0
                          ? true
                          : _ref$removePKCS7Paddi;

                  this.logEnabled = true;
                  this.observer = observer;
                  this.config = config;
                  this.removePKCS7Padding = removePKCS7Padding; // built in decryptor expects PKCS7 padding

                  if (removePKCS7Padding) {
                    try {
                      var browserCrypto = global.crypto;

                      if (browserCrypto) {
                        this.subtle = browserCrypto.subtle ||
                            browserCrypto.webkitSubtle;
                      }
                    } catch (e) {}
                  }

                  this.disableWebCrypto = !this.subtle;
                }

                var _proto = Decrypter.prototype;

                _proto.isSync = function isSync() {
                  return this.disableWebCrypto && this.config.enableSoftwareAES;
                };

                _proto.decrypt = function decrypt(data, key, iv, callback) {
                  var _this = this;

                  if (this.disableWebCrypto && this.config.enableSoftwareAES) {
                    if (this.logEnabled) {
                      __WEBPACK_IMPORTED_MODULE_4__utils_logger__['b' /* logger */].log(
                          'JS AES decrypt');
                      this.logEnabled = false;
                    }

                    var decryptor = this.decryptor;

                    if (!decryptor) {
                      this.decryptor = decryptor = new __WEBPACK_IMPORTED_MODULE_2__aes_decryptor__['a' /* default */]();
                    }

                    decryptor.expandKey(key);
                    callback(decryptor.decrypt(data, 0, iv,
                        this.removePKCS7Padding));
                  } else {
                    if (this.logEnabled) {
                      __WEBPACK_IMPORTED_MODULE_4__utils_logger__['b' /* logger */].log(
                          'WebCrypto AES decrypt');
                      this.logEnabled = false;
                    }

                    var subtle = this.subtle;

                    if (this.key !== key) {
                      this.key = key;
                      this.fastAesKey = new __WEBPACK_IMPORTED_MODULE_1__fast_aes_key__['a' /* default */](
                          subtle, key);
                    }

                    this.fastAesKey.expandKey().then(function(aesKey) {
                      // decrypt using web crypto
                      var crypto = new __WEBPACK_IMPORTED_MODULE_0__aes_crypto__['a' /* default */](
                          subtle, iv);
                      crypto.decrypt(data, aesKey).catch(function(err) {
                        _this.onWebCryptoError(err, data, key, iv, callback);
                      }).then(function(result) {
                        callback(result);
                      });
                    }).catch(function(err) {
                      _this.onWebCryptoError(err, data, key, iv, callback);
                    });
                  }
                };

                _proto.onWebCryptoError = function onWebCryptoError(
                    err, data, key, iv, callback) {
                  if (this.config.enableSoftwareAES) {
                    __WEBPACK_IMPORTED_MODULE_4__utils_logger__['b' /* logger */].log(
                        'WebCrypto Error, disable WebCrypto API');
                    this.disableWebCrypto = true;
                    this.logEnabled = true;
                    this.decrypt(data, key, iv, callback);
                  } else {
                    __WEBPACK_IMPORTED_MODULE_4__utils_logger__['b' /* logger */].error(
                        'decrypting error : ' + err.message);
                    this.observer.trigger(
                        __WEBPACK_IMPORTED_MODULE_5__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_3__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].FRAG_DECRYPT_ERROR,
                          fatal: true,
                          reason: err.message,
                        });
                  }
                };

                _proto.destroy = function destroy() {
                  var decryptor = this.decryptor;

                  if (decryptor) {
                    decryptor.destroy();
                    this.decryptor = undefined;
                  }
                };

                return Decrypter;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (Decrypter);

          /***/
        }),
        /* 13 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return ElementaryStreamTypes; });
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'b',
              function() { return Fragment; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1_url_toolkit__ = __webpack_require__(
              10);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1_url_toolkit___default = __webpack_require__.n(
              __WEBPACK_IMPORTED_MODULE_1_url_toolkit__);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__level_key__ = __webpack_require__(
              21);

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(
              Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype,
                protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          var ElementaryStreamTypes;

          (function(ElementaryStreamTypes) {
            ElementaryStreamTypes['AUDIO'] = 'audio';
            ElementaryStreamTypes['VIDEO'] = 'video';
          })(ElementaryStreamTypes || (ElementaryStreamTypes = {}));

          var Fragment =
              /*#__PURE__*/
              function() {
                function Fragment() {
                  var _this$_elementaryStre;

                  this._url = null;
                  this._byteRange = null;
                  this._decryptdata = null;
                  this._elementaryStreams = (_this$_elementaryStre = {}, _this$_elementaryStre[ElementaryStreamTypes.AUDIO] = false, _this$_elementaryStre[ElementaryStreamTypes.VIDEO] = false, _this$_elementaryStre);
                  this.deltaPTS = 0;
                  this.rawProgramDateTime = null;
                  this.programDateTime = null;
                  this.title = null;
                  this.tagList = [];
                  this.cc = void 0;
                  this.type = void 0;
                  this.relurl = void 0;
                  this.baseurl = void 0;
                  this.duration = void 0;
                  this.start = void 0;
                  this.sn = 0;
                  this.urlId = 0;
                  this.level = 0;
                  this.levelkey = void 0;
                  this.loader = void 0;
                }

                var _proto = Fragment.prototype;

                // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array
                _proto.setByteRange = function setByteRange(
                    value, previousFrag) {
                  var params = value.split('@', 2);
                  var byteRange = [];

                  if (params.length === 1) {
                    byteRange[0] = previousFrag
                        ? previousFrag.byteRangeEndOffset
                        : 0;
                  } else {
                    byteRange[0] = parseInt(params[1]);
                  }

                  byteRange[1] = parseInt(params[0]) + byteRange[0];
                  this._byteRange = byteRange;
                };

                /**
                 * @param {ElementaryStreamTypes} type
                 */
                _proto.addElementaryStream = function addElementaryStream(type) {
                  this._elementaryStreams[type] = true;
                }
                /**
                 * @param {ElementaryStreamTypes} type
                 */
                ;

                _proto.hasElementaryStream = function hasElementaryStream(type) {
                  return this._elementaryStreams[type] === true;
                }
                /**
                 * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
                 * @param {number} segmentNumber - segment number to generate IV with
                 * @returns {Uint8Array}
                 */
                ;

                _proto.createInitializationVector = function createInitializationVector(segmentNumber) {
                  var uint8View = new Uint8Array(16);

                  for (var i = 12; i < 16; i++) {
                    uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
                  }

                  return uint8View;
                }
                /**
                 * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
                 * @param levelkey - a playlist's encryption info
                 * @param segmentNumber - the fragment's segment number
                 * @returns {LevelKey} - an object to be applied as a fragment's decryptdata
                 */
                ;

                _proto.setDecryptDataFromLevelKey = function setDecryptDataFromLevelKey(
                    levelkey, segmentNumber) {
                  var decryptdata = levelkey;

                  if (levelkey && levelkey.method && levelkey.uri &&
                      !levelkey.iv) {
                    decryptdata = new __WEBPACK_IMPORTED_MODULE_3__level_key__['a' /* default */](
                        levelkey.baseuri, levelkey.reluri);
                    decryptdata.method = levelkey.method;
                    decryptdata.iv = this.createInitializationVector(
                        segmentNumber);
                  }

                  return decryptdata;
                };

                _createClass(Fragment, [
                  {
                    key: 'url',
                    get: function get() {
                      if (!this._url && this.relurl) {
                        this._url = Object(
                            __WEBPACK_IMPORTED_MODULE_1_url_toolkit__['buildAbsoluteURL'])(
                            this.baseurl, this.relurl, {
                              alwaysNormalize: true,
                            });
                      }

                      return this._url;
                    },
                    set: function set(value) {
                      this._url = value;
                    },
                  }, {
                    key: 'byteRange',
                    get: function get() {
                      if (!this._byteRange) {
                        return [];
                      }

                      return this._byteRange;
                    },
                    /**
                     * @type {number}
                     */

                  }, {
                    key: 'byteRangeStartOffset',
                    get: function get() {
                      return this.byteRange[0];
                    },
                  }, {
                    key: 'byteRangeEndOffset',
                    get: function get() {
                      return this.byteRange[1];
                    },
                  }, {
                    key: 'decryptdata',
                    get: function get() {
                      if (!this.levelkey && !this._decryptdata) {
                        return null;
                      }

                      if (!this._decryptdata && this.levelkey) {
                        var sn = this.sn;

                        if (typeof sn !== 'number') {
                          // We are fetching decryption data for a initialization segment
                          // If the segment was encrypted with AES-128
                          // It must have an IV defined. We cannot substitute the Segment Number in.
                          if (this.levelkey && this.levelkey.method ===
                              'AES-128' && !this.levelkey.iv) {
                            __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].warn(
                                'missing IV for initialization segment with method="' +
                                this.levelkey.method + '" - compliance issue');
                          }
                          /*
          Be converted to a Number.
          'initSegment' will become NaN.
          NaN, which when converted through ToInt32() -> +0.
          ---
          Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.
          */

                          sn = 0;
                        }

                        this._decryptdata = this.setDecryptDataFromLevelKey(
                            this.levelkey, sn);
                      }

                      return this._decryptdata;
                    },
                  }, {
                    key: 'endProgramDateTime',
                    get: function get() {
                      if (this.programDateTime === null) {
                        return null;
                      }

                      if (!Object(
                          __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                          this.programDateTime)) {
                        return null;
                      }

                      var duration = !Object(
                          __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                          this.duration) ? 0 : this.duration;
                      return this.programDateTime + duration * 1000;
                    },
                  }, {
                    key: 'encrypted',
                    get: function get() {
                      return !!(this.decryptdata && this.decryptdata.uri !==
                          null && this.decryptdata.key === null);
                    },
                  }]);

                return Fragment;
              }();

          /***/
        }),
        /* 14 */
        /***/ (function(module, exports, __webpack_require__) {

          'use strict';

          var has = Object.prototype.hasOwnProperty,
              prefix = '~';

          /**
           * Constructor to create a storage for our `EE` objects.
           * An `Events` instance is a plain object whose properties are event names.
           *
           * @constructor
           * @private
           */

          function Events() {} //
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//

          if (Object.create) {
            Events.prototype = Object.create(null); //
            // This hack is needed because the `__proto__` property is still inherited in
            // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
            //

            if (!new Events().__proto__) prefix = false;
          }

          /**
           * Representation of a single event listener.
           *
           * @param {Function} fn The listener function.
           * @param {*} context The context to invoke the listener with.
           * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
           * @constructor
           * @private
           */


          function EE(fn, context, once) {
            this.fn = fn;
            this.context = context;
            this.once = once || false;
          }

          /**
           * Add a listener for a given event.
           *
           * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
           * @param {(String|Symbol)} event The event name.
           * @param {Function} fn The listener function.
           * @param {*} context The context to invoke the listener with.
           * @param {Boolean} once Specify if the listener is a one-time listener.
           * @returns {EventEmitter}
           * @private
           */


          function addListener(emitter, event, fn, context, once) {
            if (typeof fn !== 'function') {
              throw new TypeError('The listener must be a function');
            }

            var listener = new EE(fn, context || emitter, once),
                evt = prefix ? prefix + event : event;
            if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++; else if (!emitter._events[evt].fn) emitter._events[evt].push(
                listener); else emitter._events[evt] = [
              emitter._events[evt],
              listener];
            return emitter;
          }

          /**
           * Clear event by name.
           *
           * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
           * @param {(String|Symbol)} evt The Event name.
           * @private
           */


          function clearEvent(emitter, evt) {
            if (--emitter._eventsCount ===
                0) emitter._events = new Events(); else delete emitter._events[evt];
          }

          /**
           * Minimal `EventEmitter` interface that is molded against the Node.js
           * `EventEmitter` interface.
           *
           * @constructor
           * @public
           */


          function EventEmitter() {
            this._events = new Events();
            this._eventsCount = 0;
          }

          /**
           * Return an array listing the events for which the emitter has registered
           * listeners.
           *
           * @returns {Array}
           * @public
           */

          EventEmitter.prototype.eventNames = function eventNames() {
            var names = [],
                events,
                name;
            if (this._eventsCount === 0) return names;

            for (name in events = this._events) {
              if (has.call(events, name)) names.push(
                  prefix ? name.slice(1) : name);
            }

            if (Object.getOwnPropertySymbols) {
              return names.concat(Object.getOwnPropertySymbols(events));
            }

            return names;
          };
          /**
           * Return the listeners registered for a given event.
           *
           * @param {(String|Symbol)} event The event name.
           * @returns {Array} The registered listeners.
           * @public
           */

          EventEmitter.prototype.listeners = function listeners(event) {
            var evt = prefix ? prefix + event : event,
                handlers = this._events[evt];
            if (!handlers) return [];
            if (handlers.fn) return [handlers.fn];

            for (var i = 0, l = handlers.length, ee = new Array(l); i <
            l; i++) {
              ee[i] = handlers[i].fn;
            }

            return ee;
          };
          /**
           * Return the number of listeners listening to a given event.
           *
           * @param {(String|Symbol)} event The event name.
           * @returns {Number} The number of listeners.
           * @public
           */

          EventEmitter.prototype.listenerCount = function listenerCount(event) {
            var evt = prefix ? prefix + event : event,
                listeners = this._events[evt];
            if (!listeners) return 0;
            if (listeners.fn) return 1;
            return listeners.length;
          };
          /**
           * Calls each of the listeners registered for a given event.
           *
           * @param {(String|Symbol)} event The event name.
           * @returns {Boolean} `true` if the event had listeners, else `false`.
           * @public
           */

          EventEmitter.prototype.emit = function emit(
              event, a1, a2, a3, a4, a5) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt]) return false;
            var listeners = this._events[evt],
                len = arguments.length,
                args,
                i;

            if (listeners.fn) {
              if (listeners.once) this.removeListener(event, listeners.fn,
                  undefined, true);

              switch (len) {
                case 1:
                  return listeners.fn.call(listeners.context), true;

                case 2:
                  return listeners.fn.call(listeners.context, a1), true;

                case 3:
                  return listeners.fn.call(listeners.context, a1, a2), true;

                case 4:
                  return listeners.fn.call(listeners.context, a1, a2, a3), true;

                case 5:
                  return listeners.fn.call(listeners.context, a1, a2, a3,
                      a4), true;

                case 6:
                  return listeners.fn.call(listeners.context, a1, a2, a3, a4,
                      a5), true;
              }

              for (i = 1, args = new Array(len - 1); i < len; i++) {
                args[i - 1] = arguments[i];
              }

              listeners.fn.apply(listeners.context, args);
            } else {
              var length = listeners.length,
                  j;

              for (i = 0; i < length; i++) {
                if (listeners[i].once) this.removeListener(event,
                    listeners[i].fn, undefined, true);

                switch (len) {
                  case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;

                  case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;

                  case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;

                  case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;

                  default:
                    if (!args) for (j = 1, args = new Array(len - 1); j <
                    len; j++) {
                      args[j - 1] = arguments[j];
                    }
                    listeners[i].fn.apply(listeners[i].context, args);
                }
              }
            }

            return true;
          };
          /**
           * Add a listener for a given event.
           *
           * @param {(String|Symbol)} event The event name.
           * @param {Function} fn The listener function.
           * @param {*} [context=this] The context to invoke the listener with.
           * @returns {EventEmitter} `this`.
           * @public
           */

          EventEmitter.prototype.on = function on(event, fn, context) {
            return addListener(this, event, fn, context, false);
          };
          /**
           * Add a one-time listener for a given event.
           *
           * @param {(String|Symbol)} event The event name.
           * @param {Function} fn The listener function.
           * @param {*} [context=this] The context to invoke the listener with.
           * @returns {EventEmitter} `this`.
           * @public
           */

          EventEmitter.prototype.once = function once(event, fn, context) {
            return addListener(this, event, fn, context, true);
          };
          /**
           * Remove the listeners of a given event.
           *
           * @param {(String|Symbol)} event The event name.
           * @param {Function} fn Only remove the listeners that match this function.
           * @param {*} context Only remove the listeners that have this context.
           * @param {Boolean} once Only remove one-time listeners.
           * @returns {EventEmitter} `this`.
           * @public
           */

          EventEmitter.prototype.removeListener = function removeListener(
              event, fn, context, once) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt]) return this;

            if (!fn) {
              clearEvent(this, evt);
              return this;
            }

            var listeners = this._events[evt];

            if (listeners.fn) {
              if (listeners.fn === fn && (!once || listeners.once) &&
                  (!context || listeners.context === context)) {
                clearEvent(this, evt);
              }
            } else {
              for (var i = 0, events = [], length = listeners.length; i <
              length; i++) {
                if (listeners[i].fn !== fn || once && !listeners[i].once ||
                    context && listeners[i].context !== context) {
                  events.push(listeners[i]);
                }
              } //
              // Reset the array, or remove it completely if we have no more listeners.
              //

              if (events.length) this._events[evt] = events.length === 1
                  ? events[0]
                  : events; else clearEvent(this, evt);
            }

            return this;
          };
          /**
           * Remove all listeners, or those of the specified event.
           *
           * @param {(String|Symbol)} [event] The event name.
           * @returns {EventEmitter} `this`.
           * @public
           */

          EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
            var evt;

            if (event) {
              evt = prefix ? prefix + event : event;
              if (this._events[evt]) clearEvent(this, evt);
            } else {
              this._events = new Events();
              this._eventsCount = 0;
            }

            return this;
          }; //
// Alias methods names because people roll like that.
//

          EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
          EventEmitter.prototype.addListener = EventEmitter.prototype.on; //
// Expose the prefix.
//

          EventEmitter.prefixed = prefix; //
// Allow `EventEmitter` to be imported as module namespace.
//

          EventEmitter.EventEmitter = EventEmitter; //
// Expose the module.
//

          if (true) {
            module.exports = EventEmitter;
          }

          /***/
        }),
        /* 15 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (immutable) */
          __webpack_exports__['a'] = getMediaSource;

          /**
           * MediaSource helper
           */
          function getMediaSource() {
            return window.MediaSource || window.WebKitMediaSource;
          }

          /***/
        }),
        /* 16 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return Observer; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_eventemitter3__ = __webpack_require__(
              14);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_eventemitter3___default = __webpack_require__.n(
              __WEBPACK_IMPORTED_MODULE_0_eventemitter3__);

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /**
           * Simple adapter sub-class of Nodejs-like EventEmitter.
           */

          var Observer =
              /*#__PURE__*/
              function(_EventEmitter) {
                _inheritsLoose(Observer, _EventEmitter);

                function Observer() {
                  return _EventEmitter.apply(this, arguments) || this;
                }

                var _proto = Observer.prototype;

                /**
                 * We simply want to pass along the event-name itself
                 * in every call to a handler, which is the purpose of our `trigger` method
                 * extending the standard API.
                 */
                _proto.trigger = function trigger(event) {
                  for (var _len = arguments.length, data = new Array(
                      _len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    data[_key - 1] = arguments[_key];
                  }

                  this.emit.apply(this, [event, event].concat(data));
                };

                return Observer;
              }(__WEBPACK_IMPORTED_MODULE_0_eventemitter3__['EventEmitter']);

          /***/
        }),
        /* 17 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return State; });
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'b',
              function() { return BaseStreamController; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__task_loop__ = __webpack_require__(
              30);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__fragment_tracker__ = __webpack_require__(
              7);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__utils_buffer_helper__ = __webpack_require__(
              6);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__utils_logger__ = __webpack_require__(
              1);

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          var State = {
            STOPPED: 'STOPPED',
            STARTING: 'STARTING',
            IDLE: 'IDLE',
            PAUSED: 'PAUSED',
            KEY_LOADING: 'KEY_LOADING',
            FRAG_LOADING: 'FRAG_LOADING',
            FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
            WAITING_TRACK: 'WAITING_TRACK',
            PARSING: 'PARSING',
            PARSED: 'PARSED',
            BUFFER_FLUSHING: 'BUFFER_FLUSHING',
            ENDED: 'ENDED',
            ERROR: 'ERROR',
            WAITING_INIT_PTS: 'WAITING_INIT_PTS',
            WAITING_LEVEL: 'WAITING_LEVEL',
          };

          var BaseStreamController =
              /*#__PURE__*/
              function(_TaskLoop) {
                _inheritsLoose(BaseStreamController, _TaskLoop);

                function BaseStreamController() {
                  return _TaskLoop.apply(this, arguments) || this;
                }

                var _proto = BaseStreamController.prototype;

                _proto.doTick = function doTick() {};

                _proto.startLoad = function startLoad() {};

                _proto.stopLoad = function stopLoad() {
                  var frag = this.fragCurrent;

                  if (frag) {
                    if (frag.loader) {
                      frag.loader.abort();
                    }

                    this.fragmentTracker.removeFragment(frag);
                  }

                  if (this.demuxer) {
                    this.demuxer.destroy();
                    this.demuxer = null;
                  }

                  this.fragCurrent = null;
                  this.fragPrevious = null;
                  this.clearInterval();
                  this.clearNextTick();
                  this.state = State.STOPPED;
                };

                _proto._streamEnded = function _streamEnded(
                    bufferInfo, levelDetails) {
                  var fragCurrent = this.fragCurrent,
                      fragmentTracker = this.fragmentTracker; // we just got done loading the final fragment and there is no other buffered range after ...
                  // rationale is that in case there are any buffered ranges after, it means that there are unbuffered portion in between
                  // so we should not switch to ENDED in that case, to be able to buffer them
                  // dont switch to ENDED if we need to backtrack last fragment

                  if (!levelDetails.live && fragCurrent &&
                      !fragCurrent.backtracked && fragCurrent.sn ===
                      levelDetails.endSN && !bufferInfo.nextStart) {
                    var fragState = fragmentTracker.getState(fragCurrent);
                    return fragState ===
                        __WEBPACK_IMPORTED_MODULE_2__fragment_tracker__['a' /* FragmentState */].PARTIAL ||
                        fragState ===
                        __WEBPACK_IMPORTED_MODULE_2__fragment_tracker__['a' /* FragmentState */].OK;
                  }

                  return false;
                };

                _proto.onMediaSeeking = function onMediaSeeking() {
                  var config = this.config,
                      media = this.media,
                      mediaBuffer = this.mediaBuffer,
                      state = this.state;
                  var currentTime = media ? media.currentTime : null;
                  var bufferInfo = __WEBPACK_IMPORTED_MODULE_3__utils_buffer_helper__['a' /* BufferHelper */].bufferInfo(
                      mediaBuffer || media, currentTime,
                      this.config.maxBufferHole);

                  if (Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      currentTime)) {
                    __WEBPACK_IMPORTED_MODULE_4__utils_logger__['b' /* logger */].log(
                        'media seeking to ' + currentTime.toFixed(3));
                  }

                  if (state === State.FRAG_LOADING) {
                    var fragCurrent = this.fragCurrent; // check if we are seeking to a unbuffered area AND if frag loading is in progress

                    if (bufferInfo.len === 0 && fragCurrent) {
                      var tolerance = config.maxFragLookUpTolerance;
                      var fragStartOffset = fragCurrent.start - tolerance;
                      var fragEndOffset = fragCurrent.start +
                          fragCurrent.duration + tolerance; // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything

                      if (currentTime < fragStartOffset || currentTime >
                          fragEndOffset) {
                        if (fragCurrent.loader) {
                          __WEBPACK_IMPORTED_MODULE_4__utils_logger__['b' /* logger */].log(
                              'seeking outside of buffer while fragment load in progress, cancel fragment load');
                          fragCurrent.loader.abort();
                        }

                        this.fragCurrent = null;
                        this.fragPrevious = null; // switch to IDLE state to load new fragment

                        this.state = State.IDLE;
                      } else {
                        __WEBPACK_IMPORTED_MODULE_4__utils_logger__['b' /* logger */].log(
                            'seeking outside of buffer but within currently loaded fragment range');
                      }
                    }
                  } else if (state === State.ENDED) {
                    // if seeking to unbuffered area, clean up fragPrevious
                    if (bufferInfo.len === 0) {
                      this.fragPrevious = null;
                      this.fragCurrent = null;
                    } // switch to IDLE state to check for potential new fragment

                    this.state = State.IDLE;
                  }

                  if (media) {
                    this.lastCurrentTime = currentTime;
                  } // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target

                  if (!this.loadedmetadata) {
                    this.nextLoadPosition = this.startPosition = currentTime;
                  } // tick to speed up processing

                  this.tick();
                };

                _proto.onMediaEnded = function onMediaEnded() {
                  // reset startPosition and lastCurrentTime to restart playback @ stream beginning
                  this.startPosition = this.lastCurrentTime = 0;
                };

                _proto.onHandlerDestroying = function onHandlerDestroying() {
                  this.stopLoad();

                  _TaskLoop.prototype.onHandlerDestroying.call(this);
                };

                _proto.onHandlerDestroyed = function onHandlerDestroyed() {
                  this.state = State.STOPPED;
                  this.fragmentTracker = null;
                };

                _proto.computeLivePosition = function computeLivePosition(
                    sliding, levelDetails) {
                  var targetLatency = this.config.liveSyncDuration !== undefined
                      ? this.config.liveSyncDuration
                      : this.config.liveSyncDurationCount *
                      levelDetails.targetduration;
                  return sliding +
                      Math.max(0, levelDetails.totalduration - targetLatency);
                };

                return BaseStreamController;
              }(__WEBPACK_IMPORTED_MODULE_1__task_loop__['a' /* default */]);

          /***/
        }),
        /* 18 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (immutable) */
          __webpack_exports__['c'] = sendAddTrackEvent;
          /* harmony export (immutable) */
          __webpack_exports__['a'] = clearCurrentCues;
          /* harmony export (immutable) */
          __webpack_exports__['b'] = getClosestCue;

          function sendAddTrackEvent(track, videoEl) {
            var event;

            try {
              event = new Event('addtrack');
            } catch (err) {
              // for IE11
              event = document.createEvent('Event');
              event.initEvent('addtrack', false, false);
            }

            event.track = track;
            videoEl.dispatchEvent(event);
          }

          function clearCurrentCues(track) {
            if (track && track.cues) {
              while (track.cues.length > 0) {
                track.removeCue(track.cues[0]);
              }
            }
          }

          /**
           *  Given a list of Cues, finds the closest cue matching the given time.
           *  Modified verison of binary search O(log(n)).
           *
           * @export
           * @param {(TextTrackCueList | TextTrackCue[])} cues - List of cues.
           * @param {number} time - Target time, to find closest cue to.
           * @returns {TextTrackCue}
           */

          function getClosestCue(cues, time) {
            // If the offset is less than the first element, the first element is the closest.
            if (time < cues[0].endTime) {
              return cues[0];
            } // If the offset is greater than the last cue, the last is the closest.

            if (time > cues[cues.length - 1].endTime) {
              return cues[cues.length - 1];
            }

            var left = 0;
            var right = cues.length - 1;

            while (left <= right) {
              var mid = Math.floor((right + left) / 2);

              if (time < cues[mid].endTime) {
                right = mid - 1;
              } else if (time > cues[mid].endTime) {
                left = mid + 1;
              } else {
                // If it's not lower or higher, it must be equal.
                return cues[mid];
              }
            } // At this point, left and right have swapped.
            // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.

            return cues[left].endTime - time < time - cues[right].endTime
                ? cues[left]
                : cues[right];
          }

          /***/
        }),
        /* 19 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return PlaylistContextType; });
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'b',
              function() { return PlaylistLevelType; });
          /**
           * `type` property values for this loaders' context object
           * @enum
           *
           */
          var PlaylistContextType;
          /**
           * @enum {string}
           */

          (function(PlaylistContextType) {
            PlaylistContextType['MANIFEST'] = 'manifest';
            PlaylistContextType['LEVEL'] = 'level';
            PlaylistContextType['AUDIO_TRACK'] = 'audioTrack';
            PlaylistContextType['SUBTITLE_TRACK'] = 'subtitleTrack';
          })(PlaylistContextType || (PlaylistContextType = {}));

          var PlaylistLevelType;

          (function(PlaylistLevelType) {
            PlaylistLevelType['MAIN'] = 'main';
            PlaylistLevelType['AUDIO'] = 'audio';
            PlaylistLevelType['SUBTITLE'] = 'subtitle';
          })(PlaylistLevelType || (PlaylistLevelType = {}));

          /***/
        }),
        /* 20 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(2);
          /**
           * MP4 demuxer
           */


          var UINT32_MAX = Math.pow(2, 32) - 1;

          var MP4Demuxer =
              /*#__PURE__*/
              function() {
                function MP4Demuxer(observer, remuxer) {
                  this.observer = observer;
                  this.remuxer = remuxer;
                }

                var _proto = MP4Demuxer.prototype;

                _proto.resetTimeStamp = function resetTimeStamp(initPTS) {
                  this.initPTS = initPTS;
                };

                _proto.resetInitSegment = function resetInitSegment(
                    initSegment, audioCodec, videoCodec, duration) {
                  // jshint unused:false
                  if (initSegment && initSegment.byteLength) {
                    var initData = this.initData = MP4Demuxer.parseInitSegment(
                        initSegment); // default audio codec if nothing specified
                    // TODO : extract that from initsegment

                    if (audioCodec == null) {
                      audioCodec = 'mp4a.40.5';
                    }

                    if (videoCodec == null) {
                      videoCodec = 'avc1.42e01e';
                    }

                    var tracks = {};

                    if (initData.audio && initData.video) {
                      tracks.audiovideo = {
                        container: 'video/mp4',
                        codec: audioCodec + ',' + videoCodec,
                        initSegment: duration ? initSegment : null,
                      };
                    } else {
                      if (initData.audio) {
                        tracks.audio = {
                          container: 'audio/mp4',
                          codec: audioCodec,
                          initSegment: duration ? initSegment : null,
                        };
                      }

                      if (initData.video) {
                        tracks.video = {
                          container: 'video/mp4',
                          codec: videoCodec,
                          initSegment: duration ? initSegment : null,
                        };
                      }
                    }

                    this.observer.trigger(
                        __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_PARSING_INIT_SEGMENT,
                        {
                          tracks: tracks,
                        });
                  } else {
                    if (audioCodec) {
                      this.audioCodec = audioCodec;
                    }

                    if (videoCodec) {
                      this.videoCodec = videoCodec;
                    }
                  }
                };

                MP4Demuxer.probe = function probe(data) {
                  // ensure we find a moof box in the first 16 kB
                  return MP4Demuxer.findBox({
                    data: data,
                    start: 0,
                    end: Math.min(data.length, 16384),
                  }, ['moof']).length > 0;
                };

                MP4Demuxer.bin2str = function bin2str(buffer) {
                  return String.fromCharCode.apply(null, buffer);
                };

                MP4Demuxer.readUint16 = function readUint16(buffer, offset) {
                  if (buffer.data) {
                    offset += buffer.start;
                    buffer = buffer.data;
                  }

                  var val = buffer[offset] << 8 | buffer[offset + 1];
                  return val < 0 ? 65536 + val : val;
                };

                MP4Demuxer.readUint32 = function readUint32(buffer, offset) {
                  if (buffer.data) {
                    offset += buffer.start;
                    buffer = buffer.data;
                  }

                  var val = buffer[offset] << 24 | buffer[offset + 1] << 16 |
                      buffer[offset + 2] << 8 | buffer[offset + 3];
                  return val < 0 ? 4294967296 + val : val;
                };

                MP4Demuxer.writeUint32 = function writeUint32(
                    buffer, offset, value) {
                  if (buffer.data) {
                    offset += buffer.start;
                    buffer = buffer.data;
                  }

                  buffer[offset] = value >> 24;
                  buffer[offset + 1] = value >> 16 & 0xff;
                  buffer[offset + 2] = value >> 8 & 0xff;
                  buffer[offset + 3] = value & 0xff;
                } // Find the data for a box specified by its path
                ;

                MP4Demuxer.findBox = function findBox(data, path) {
                  var results = [],
                      i,
                      size,
                      type,
                      end,
                      subresults,
                      start,
                      endbox;

                  if (data.data) {
                    start = data.start;
                    end = data.end;
                    data = data.data;
                  } else {
                    start = 0;
                    end = data.byteLength;
                  }

                  if (!path.length) {
                    // short-circuit the search for empty paths
                    return null;
                  }

                  for (i = start; i < end;) {
                    size = MP4Demuxer.readUint32(data, i);
                    type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));
                    endbox = size > 1 ? i + size : end;

                    if (type === path[0]) {
                      if (path.length === 1) {
                        // this is the end of the path and we've found the box we were
                        // looking for
                        results.push({
                          data: data,
                          start: i + 8,
                          end: endbox,
                        });
                      } else {
                        // recursively search for the next box along the path
                        subresults = MP4Demuxer.findBox({
                          data: data,
                          start: i + 8,
                          end: endbox,
                        }, path.slice(1));

                        if (subresults.length) {
                          results = results.concat(subresults);
                        }
                      }
                    }

                    i = endbox;
                  } // we've finished searching all of data

                  return results;
                };

                MP4Demuxer.parseSegmentIndex = function parseSegmentIndex(initSegment) {
                  var moov = MP4Demuxer.findBox(initSegment, ['moov'])[0];
                  var moovEndOffset = moov ? moov.end : null; // we need this in case we need to chop of garbage of the end of current data

                  var index = 0;
                  var sidx = MP4Demuxer.findBox(initSegment, ['sidx']);
                  var references;

                  if (!sidx || !sidx[0]) {
                    return null;
                  }

                  references = [];
                  sidx = sidx[0];
                  var version = sidx.data[0]; // set initial offset, we skip the reference ID (not needed)

                  index = version === 0 ? 8 : 16;
                  var timescale = MP4Demuxer.readUint32(sidx, index);
                  index += 4; // TODO: parse earliestPresentationTime and firstOffset
                  // usually zero in our case

                  var earliestPresentationTime = 0;
                  var firstOffset = 0;

                  if (version === 0) {
                    index += 8;
                  } else {
                    index += 16;
                  } // skip reserved

                  index += 2;
                  var startByte = sidx.end + firstOffset;
                  var referencesCount = MP4Demuxer.readUint16(sidx, index);
                  index += 2;

                  for (var i = 0; i < referencesCount; i++) {
                    var referenceIndex = index;
                    var referenceInfo = MP4Demuxer.readUint32(sidx,
                        referenceIndex);
                    referenceIndex += 4;
                    var referenceSize = referenceInfo & 0x7FFFFFFF;
                    var referenceType = (referenceInfo & 0x80000000) >>> 31;

                    if (referenceType === 1) {
                      console.warn(
                          'SIDX has hierarchical references (not supported)');
                      return;
                    }

                    var subsegmentDuration = MP4Demuxer.readUint32(sidx,
                        referenceIndex);
                    referenceIndex += 4;
                    references.push({
                      referenceSize: referenceSize,
                      subsegmentDuration: subsegmentDuration,
                      // unscaled
                      info: {
                        duration: subsegmentDuration / timescale,
                        start: startByte,
                        end: startByte + referenceSize - 1,
                      },
                    });
                    startByte += referenceSize; // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits
                    // for |sapDelta|.

                    referenceIndex += 4; // skip to next ref

                    index = referenceIndex;
                  }

                  return {
                    earliestPresentationTime: earliestPresentationTime,
                    timescale: timescale,
                    version: version,
                    referencesCount: referencesCount,
                    references: references,
                    moovEndOffset: moovEndOffset,
                  };
                }
                /**
                 * Parses an MP4 initialization segment and extracts stream type and
                 * timescale values for any declared tracks. Timescale values indicate the
                 * number of clock ticks per second to assume for time-based values
                 * elsewhere in the MP4.
                 *
                 * To determine the start time of an MP4, you need two pieces of
                 * information: the timescale unit and the earliest base media decode
                 * time. Multiple timescales can be specified within an MP4 but the
                 * base media decode time is always expressed in the timescale from
                 * the media header box for the track:
                 * ```
                 * moov > trak > mdia > mdhd.timescale
                 * moov > trak > mdia > hdlr
                 * ```
                 * @param init {Uint8Array} the bytes of the init segment
                 * @return {object} a hash of track type to timescale values or null if
                 * the init segment is malformed.
                 */
                ;

                MP4Demuxer.parseInitSegment = function parseInitSegment(initSegment) {
                  var result = [];
                  var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);
                  traks.forEach(function(trak) {
                    var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];

                    if (tkhd) {
                      var version = tkhd.data[tkhd.start];
                      var index = version === 0 ? 12 : 20;
                      var trackId = MP4Demuxer.readUint32(tkhd, index);
                      var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];

                      if (mdhd) {
                        version = mdhd.data[mdhd.start];
                        index = version === 0 ? 12 : 20;
                        var timescale = MP4Demuxer.readUint32(mdhd, index);
                        var hdlr = MP4Demuxer.findBox(trak,
                            ['mdia', 'hdlr'])[0];

                        if (hdlr) {
                          var hdlrType = MP4Demuxer.bin2str(
                              hdlr.data.subarray(hdlr.start + 8,
                                  hdlr.start + 12));
                          var type = {
                            'soun': 'audio',
                            'vide': 'video',
                          }[hdlrType];

                          if (type) {
                            // extract codec info. TODO : parse codec details to be able to build MIME type
                            var codecBox = MP4Demuxer.findBox(trak,
                                ['mdia', 'minf', 'stbl', 'stsd']);

                            if (codecBox.length) {
                              codecBox = codecBox[0];
                              var codecType = MP4Demuxer.bin2str(
                                  codecBox.data.subarray(codecBox.start + 12,
                                      codecBox.start + 16));
                              __WEBPACK_IMPORTED_MODULE_0__utils_logger__['b' /* logger */].log(
                                  'MP4Demuxer:' + type + ':' + codecType +
                                  ' found');
                            }

                            result[trackId] = {
                              timescale: timescale,
                              type: type,
                            };
                            result[type] = {
                              timescale: timescale,
                              id: trackId,
                            };
                          }
                        }
                      }
                    }
                  });
                  return result;
                }
                /**
                 * Determine the base media decode start time, in seconds, for an MP4
                 * fragment. If multiple fragments are specified, the earliest time is
                 * returned.
                 *
                 * The base media decode time can be parsed from track fragment
                 * metadata:
                 * ```
                 * moof > traf > tfdt.baseMediaDecodeTime
                 * ```
                 * It requires the timescale value from the mdhd to interpret.
                 *
                 * @param timescale {object} a hash of track ids to timescale values.
                 * @return {number} the earliest base media decode start time for the
                 * fragment, in seconds
                 */
                ;

                MP4Demuxer.getStartDTS = function getStartDTS(
                    initData, fragment) {
                  var trafs, baseTimes, result; // we need info from two childrend of each track fragment box

                  trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']); // determine the start times for each track

                  baseTimes = [].concat.apply([], trafs.map(function(traf) {
                    return MP4Demuxer.findBox(traf, ['tfhd']).
                        map(function(tfhd) {
                          var id, scale, baseTime; // get the track id from the tfhd

                          id = MP4Demuxer.readUint32(tfhd, 4); // assume a 90kHz clock if no timescale was specified

                          scale = initData[id].timescale || 90e3; // get the base media decode time from the tfdt

                          baseTime = MP4Demuxer.findBox(traf, ['tfdt']).
                              map(function(tfdt) {
                                var version, result;
                                version = tfdt.data[tfdt.start];
                                result = MP4Demuxer.readUint32(tfdt, 4);

                                if (version === 1) {
                                  result *= Math.pow(2, 32);
                                  result += MP4Demuxer.readUint32(tfdt, 8);
                                }

                                return result;
                              })[0]; // convert base time to seconds

                          return baseTime / scale;
                        });
                  })); // return the minimum

                  result = Math.min.apply(null, baseTimes);
                  return isFinite(result) ? result : 0;
                };

                MP4Demuxer.offsetStartDTS = function offsetStartDTS(
                    initData, fragment, timeOffset) {
                  MP4Demuxer.findBox(fragment, ['moof', 'traf']).
                      map(function(traf) {
                        return MP4Demuxer.findBox(traf, ['tfhd']).
                            map(function(tfhd) {
                              // get the track id from the tfhd
                              var id = MP4Demuxer.readUint32(tfhd, 4); // assume a 90kHz clock if no timescale was specified

                              var timescale = initData[id].timescale || 90e3; // get the base media decode time from the tfdt

                              MP4Demuxer.findBox(traf, ['tfdt']).
                                  map(function(tfdt) {
                                    var version = tfdt.data[tfdt.start];
                                    var baseMediaDecodeTime = MP4Demuxer.readUint32(
                                        tfdt, 4);

                                    if (version === 0) {
                                      MP4Demuxer.writeUint32(tfdt, 4,
                                          baseMediaDecodeTime - timeOffset *
                                          timescale);
                                    } else {
                                      baseMediaDecodeTime *= Math.pow(2, 32);
                                      baseMediaDecodeTime += MP4Demuxer.readUint32(
                                          tfdt, 8);
                                      baseMediaDecodeTime -= timeOffset *
                                          timescale;
                                      baseMediaDecodeTime = Math.max(
                                          baseMediaDecodeTime, 0);
                                      var upper = Math.floor(
                                          baseMediaDecodeTime /
                                          (UINT32_MAX + 1));
                                      var lower = Math.floor(
                                          baseMediaDecodeTime %
                                          (UINT32_MAX + 1));
                                      MP4Demuxer.writeUint32(tfdt, 4, upper);
                                      MP4Demuxer.writeUint32(tfdt, 8, lower);
                                    }
                                  });
                            });
                      });
                } // feed incoming data to the front of the parsing pipeline
                ;

                _proto.append = function append(
                    data, timeOffset, contiguous, accurateTimeOffset) {
                  var initData = this.initData;

                  if (!initData) {
                    this.resetInitSegment(data, this.audioCodec,
                        this.videoCodec, false);
                    initData = this.initData;
                  }

                  var startDTS,
                      initPTS = this.initPTS;

                  if (initPTS === undefined) {
                    var _startDTS = MP4Demuxer.getStartDTS(initData, data);

                    this.initPTS = initPTS = _startDTS - timeOffset;
                    this.observer.trigger(
                        __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].INIT_PTS_FOUND,
                        {
                          initPTS: initPTS,
                        });
                  }

                  MP4Demuxer.offsetStartDTS(initData, data, initPTS);
                  startDTS = MP4Demuxer.getStartDTS(initData, data);
                  this.remuxer.remux(initData.audio, initData.video, null, null,
                      startDTS, contiguous, accurateTimeOffset, data);
                };

                _proto.destroy = function destroy() {};

                return MP4Demuxer;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (MP4Demuxer);

          /***/
        }),
        /* 21 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return LevelKey; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_url_toolkit__ = __webpack_require__(
              10);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_url_toolkit___default = __webpack_require__.n(
              __WEBPACK_IMPORTED_MODULE_0_url_toolkit__);

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(
              Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype,
                protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          var LevelKey =
              /*#__PURE__*/
              function() {
                function LevelKey(baseURI, relativeURI) {
                  this._uri = null;
                  this.baseuri = void 0;
                  this.reluri = void 0;
                  this.method = null;
                  this.key = null;
                  this.iv = null;
                  this.baseuri = baseURI;
                  this.reluri = relativeURI;
                }

                _createClass(LevelKey, [
                  {
                    key: 'uri',
                    get: function get() {
                      if (!this._uri && this.reluri) {
                        this._uri = Object(
                            __WEBPACK_IMPORTED_MODULE_0_url_toolkit__['buildAbsoluteURL'])(
                            this.baseuri, this.reluri, {
                              alwaysNormalize: true,
                            });
                      }

                      return this._uri;
                    },
                  }]);

                return LevelKey;
              }();

          /***/
        }),
        /* 22 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'b',
              function() { return isCodecType; });
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return isCodecSupportedInMp4; });
// from http://mp4ra.org/codecs.html
          var sampleEntryCodesISO = {
            audio: {
              'a3ds': true,
              'ac-3': true,
              'ac-4': true,
              'alac': true,
              'alaw': true,
              'dra1': true,
              'dts+': true,
              'dts-': true,
              'dtsc': true,
              'dtse': true,
              'dtsh': true,
              'ec-3': true,
              'enca': true,
              'g719': true,
              'g726': true,
              'm4ae': true,
              'mha1': true,
              'mha2': true,
              'mhm1': true,
              'mhm2': true,
              'mlpa': true,
              'mp4a': true,
              'raw ': true,
              'Opus': true,
              'samr': true,
              'sawb': true,
              'sawp': true,
              'sevc': true,
              'sqcp': true,
              'ssmv': true,
              'twos': true,
              'ulaw': true,
            },
            video: {
              'avc1': true,
              'avc2': true,
              'avc3': true,
              'avc4': true,
              'avcp': true,
              'drac': true,
              'dvav': true,
              'dvhe': true,
              'encv': true,
              'hev1': true,
              'hvc1': true,
              'mjp2': true,
              'mp4v': true,
              'mvc1': true,
              'mvc2': true,
              'mvc3': true,
              'mvc4': true,
              'resv': true,
              'rv60': true,
              's263': true,
              'svc1': true,
              'svc2': true,
              'vc-1': true,
              'vp08': true,
              'vp09': true,
            },
          };

          function isCodecType(codec, type) {
            var typeCodes = sampleEntryCodesISO[type];
            return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
          }

          function isCodecSupportedInMp4(codec, type) {
            return MediaSource.isTypeSupported(
                (type || 'video') + '/mp4;codecs="' + codec + '"');
          }

          /***/
        }),
        /* 23 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1_eventemitter3__ = __webpack_require__(
              14);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1_eventemitter3___default = __webpack_require__.n(
              __WEBPACK_IMPORTED_MODULE_1_eventemitter3__);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2_webworkify_webpack__ = __webpack_require__(
              44);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2_webworkify_webpack___default = __webpack_require__.n(
              __WEBPACK_IMPORTED_MODULE_2_webworkify_webpack__);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__demux_demuxer_inline__ = __webpack_require__(
              24);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_6__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_7__utils_mediasource_helper__ = __webpack_require__(
              15);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_8__utils_get_self_scope__ = __webpack_require__(
              5);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_9__observer__ = __webpack_require__(16);

          // see https://stackoverflow.com/a/11237259/589493

          var global = Object(
              __WEBPACK_IMPORTED_MODULE_8__utils_get_self_scope__['a' /* getSelfScope */])(); // safeguard for code that might run both on worker and main thread

          var MediaSource = Object(
              __WEBPACK_IMPORTED_MODULE_7__utils_mediasource_helper__['a' /* getMediaSource */])() ||
              {
                isTypeSupported: function isTypeSupported() {
                  return false;
                },
              };

          var Demuxer =
              /*#__PURE__*/
              function() {
                function Demuxer(hls, id) {
                  var _this = this;

                  this.hls = hls;
                  this.id = id;
                  var observer = this.observer = new __WEBPACK_IMPORTED_MODULE_9__observer__['a' /* Observer */]();
                  var config = hls.config;

                  var forwardMessage = function forwardMessage(ev, data) {
                    data = data || {};
                    data.frag = _this.frag;
                    data.id = _this.id;
                    hls.trigger(ev, data);
                  }; // forward events to main thread

                  observer.on(
                      __WEBPACK_IMPORTED_MODULE_3__events__['a' /* default */].FRAG_DECRYPTED,
                      forwardMessage);
                  observer.on(
                      __WEBPACK_IMPORTED_MODULE_3__events__['a' /* default */].FRAG_PARSING_INIT_SEGMENT,
                      forwardMessage);
                  observer.on(
                      __WEBPACK_IMPORTED_MODULE_3__events__['a' /* default */].FRAG_PARSING_DATA,
                      forwardMessage);
                  observer.on(
                      __WEBPACK_IMPORTED_MODULE_3__events__['a' /* default */].FRAG_PARSED,
                      forwardMessage);
                  observer.on(
                      __WEBPACK_IMPORTED_MODULE_3__events__['a' /* default */].ERROR,
                      forwardMessage);
                  observer.on(
                      __WEBPACK_IMPORTED_MODULE_3__events__['a' /* default */].FRAG_PARSING_METADATA,
                      forwardMessage);
                  observer.on(
                      __WEBPACK_IMPORTED_MODULE_3__events__['a' /* default */].FRAG_PARSING_USERDATA,
                      forwardMessage);
                  observer.on(
                      __WEBPACK_IMPORTED_MODULE_3__events__['a' /* default */].INIT_PTS_FOUND,
                      forwardMessage);
                  var typeSupported = {
                    mp4: MediaSource.isTypeSupported('video/mp4'),
                    mpeg: MediaSource.isTypeSupported('audio/mpeg'),
                    mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"'),
                  }; // navigator.vendor is not always available in Web Worker
                  // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator

                  var vendor = navigator.vendor;

                  if (config.enableWorker && typeof Worker !== 'undefined') {
                    __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                        'demuxing in webworker');
                    var w;

                    try {
                      w = this.w = __WEBPACK_IMPORTED_MODULE_2_webworkify_webpack__(/*require.resolve*/
                          (58));
                      this.onwmsg = this.onWorkerMessage.bind(this);
                      w.addEventListener('message', this.onwmsg);

                      w.onerror = function(event) {
                        hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_3__events__['a' /* default */].ERROR,
                            {
                              type: __WEBPACK_IMPORTED_MODULE_6__errors__['b' /* ErrorTypes */].OTHER_ERROR,
                              details: __WEBPACK_IMPORTED_MODULE_6__errors__['a' /* ErrorDetails */].INTERNAL_EXCEPTION,
                              fatal: true,
                              event: 'demuxerWorker',
                              err: {
                                message: event.message + ' (' + event.filename +
                                    ':' + event.lineno + ')',
                              },
                            });
                      };

                      w.postMessage({
                        cmd: 'init',
                        typeSupported: typeSupported,
                        vendor: vendor,
                        id: id,
                        config: JSON.stringify(config),
                      });
                    } catch (err) {
                      __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].warn(
                          'Error in worker:', err);
                      __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].error(
                          'Error while initializing DemuxerWorker, fallback on DemuxerInline');

                      if (w) {
                        // revoke the Object URL that was used to create demuxer worker, so as not to leak it
                        global.URL.revokeObjectURL(w.objectURL);
                      }

                      this.demuxer = new __WEBPACK_IMPORTED_MODULE_4__demux_demuxer_inline__['a' /* default */](
                          observer, typeSupported, config, vendor);
                      this.w = undefined;
                    }
                  } else {
                    this.demuxer = new __WEBPACK_IMPORTED_MODULE_4__demux_demuxer_inline__['a' /* default */](
                        observer, typeSupported, config, vendor);
                  }
                }

                var _proto = Demuxer.prototype;

                _proto.destroy = function destroy() {
                  var w = this.w;

                  if (w) {
                    w.removeEventListener('message', this.onwmsg);
                    w.terminate();
                    this.w = null;
                  } else {
                    var demuxer = this.demuxer;

                    if (demuxer) {
                      demuxer.destroy();
                      this.demuxer = null;
                    }
                  }

                  var observer = this.observer;

                  if (observer) {
                    observer.removeAllListeners();
                    this.observer = null;
                  }
                };

                _proto.push = function push(
                    data, initSegment, audioCodec, videoCodec, frag, duration,
                    accurateTimeOffset, defaultInitPTS) {
                  var w = this.w;
                  var timeOffset = Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      frag.startPTS) ? frag.startPTS : frag.start;
                  var decryptdata = frag.decryptdata;
                  var lastFrag = this.frag;
                  var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
                  var trackSwitch = !(lastFrag && frag.level ===
                      lastFrag.level);
                  var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;
                  var contiguous = !trackSwitch && nextSN;

                  if (discontinuity) {
                    __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                        this.id + ':discontinuity detected');
                  }

                  if (trackSwitch) {
                    __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                        this.id + ':switch detected');
                  }

                  this.frag = frag;

                  if (w) {
                    // post fragment payload as transferable objects for ArrayBuffer (no copy)
                    w.postMessage({
                      cmd: 'demux',
                      data: data,
                      decryptdata: decryptdata,
                      initSegment: initSegment,
                      audioCodec: audioCodec,
                      videoCodec: videoCodec,
                      timeOffset: timeOffset,
                      discontinuity: discontinuity,
                      trackSwitch: trackSwitch,
                      contiguous: contiguous,
                      duration: duration,
                      accurateTimeOffset: accurateTimeOffset,
                      defaultInitPTS: defaultInitPTS,
                    }, data instanceof ArrayBuffer ? [data] : []);
                  } else {
                    var demuxer = this.demuxer;

                    if (demuxer) {
                      demuxer.push(data, decryptdata, initSegment, audioCodec,
                          videoCodec, timeOffset, discontinuity, trackSwitch,
                          contiguous, duration, accurateTimeOffset,
                          defaultInitPTS);
                    }
                  }
                };

                _proto.onWorkerMessage = function onWorkerMessage(ev) {
                  var data = ev.data,
                      hls = this.hls;

                  switch (data.event) {
                    case 'init':
                      // revoke the Object URL that was used to create demuxer worker, so as not to leak it
                      global.URL.revokeObjectURL(this.w.objectURL);
                      break;
                      // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects

                    case __WEBPACK_IMPORTED_MODULE_3__events__['a' /* default */].FRAG_PARSING_DATA:
                      data.data.data1 = new Uint8Array(data.data1);

                      if (data.data2) {
                        data.data.data2 = new Uint8Array(data.data2);
                      }

                      /* falls through */

                    default:
                      data.data = data.data || {};
                      data.data.frag = this.frag;
                      data.data.id = this.id;
                      hls.trigger(data.event, data.data);
                      break;
                  }
                };

                return Demuxer;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (Demuxer);

          /***/
        }),
        /* 24 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__crypt_decrypter__ = __webpack_require__(
              12);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__demux_aacdemuxer__ = __webpack_require__(
              48);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__demux_mp4demuxer__ = __webpack_require__(
              20);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__demux_tsdemuxer__ = __webpack_require__(
              49);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_6__demux_mp3demuxer__ = __webpack_require__(
              52);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_7__remux_mp4_remuxer__ = __webpack_require__(
              53);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_8__remux_passthrough_remuxer__ = __webpack_require__(
              57);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_9__utils_get_self_scope__ = __webpack_require__(
              5);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_10__utils_logger__ = __webpack_require__(
              1);
          /**
           *
           * inline demuxer: probe fragments and instantiate
           * appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
           *
           */










              // see https://stackoverflow.com/a/11237259/589493

          var global = Object(
              __WEBPACK_IMPORTED_MODULE_9__utils_get_self_scope__['a' /* getSelfScope */])(); // safeguard for code that might run both on worker and main thread

          var now; // performance.now() not available on WebWorker, at least on Safari Desktop

          try {
            now = global.performance.now.bind(global.performance);
          } catch (err) {
            __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].debug(
                'Unable to use Performance API on this environment');
            now = global.Date.now;
          }

          var DemuxerInline =
              /*#__PURE__*/
              function() {
                function DemuxerInline(
                    observer, typeSupported, config, vendor) {
                  this.observer = observer;
                  this.typeSupported = typeSupported;
                  this.config = config;
                  this.vendor = vendor;
                }

                var _proto = DemuxerInline.prototype;

                _proto.destroy = function destroy() {
                  var demuxer = this.demuxer;

                  if (demuxer) {
                    demuxer.destroy();
                  }
                };

                _proto.push = function push(
                    data, decryptdata, initSegment, audioCodec, videoCodec,
                    timeOffset, discontinuity, trackSwitch, contiguous,
                    duration, accurateTimeOffset, defaultInitPTS) {
                  var _this = this;

                  if (data.byteLength > 0 && decryptdata != null &&
                      decryptdata.key != null && decryptdata.method ===
                      'AES-128') {
                    var decrypter = this.decrypter;

                    if (decrypter == null) {
                      decrypter = this.decrypter = new __WEBPACK_IMPORTED_MODULE_2__crypt_decrypter__['a' /* default */](
                          this.observer, this.config);
                    }

                    var startTime = now();
                    decrypter.decrypt(data, decryptdata.key.buffer,
                        decryptdata.iv.buffer, function(decryptedData) {
                          var endTime = now();

                          _this.observer.trigger(
                              __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].FRAG_DECRYPTED,
                              {
                                stats: {
                                  tstart: startTime,
                                  tdecrypt: endTime,
                                },
                              });

                          _this.pushDecrypted(new Uint8Array(decryptedData),
                              decryptdata, new Uint8Array(initSegment),
                              audioCodec, videoCodec, timeOffset, discontinuity,
                              trackSwitch, contiguous, duration,
                              accurateTimeOffset, defaultInitPTS);
                        });
                  } else {
                    this.pushDecrypted(new Uint8Array(data), decryptdata,
                        new Uint8Array(initSegment), audioCodec, videoCodec,
                        timeOffset, discontinuity, trackSwitch, contiguous,
                        duration, accurateTimeOffset, defaultInitPTS);
                  }
                };

                _proto.pushDecrypted = function pushDecrypted(
                    data, decryptdata, initSegment, audioCodec, videoCodec,
                    timeOffset, discontinuity, trackSwitch, contiguous,
                    duration, accurateTimeOffset, defaultInitPTS) {
                  var demuxer = this.demuxer;

                  if (!demuxer || // in case of continuity change, or track switch
                      // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)
                      // so let's check that current demuxer is still valid
                      (discontinuity || trackSwitch) && !this.probe(data)) {
                    var observer = this.observer;
                    var typeSupported = this.typeSupported;
                    var config = this.config; // probing order is TS/MP4/AAC/MP3

                    var muxConfig = [
                      {
                        demux: __WEBPACK_IMPORTED_MODULE_5__demux_tsdemuxer__['a' /* default */],
                        remux: __WEBPACK_IMPORTED_MODULE_7__remux_mp4_remuxer__['a' /* default */],
                      }, {
                        demux: __WEBPACK_IMPORTED_MODULE_4__demux_mp4demuxer__['a' /* default */],
                        remux: __WEBPACK_IMPORTED_MODULE_8__remux_passthrough_remuxer__['a' /* default */],
                      }, {
                        demux: __WEBPACK_IMPORTED_MODULE_3__demux_aacdemuxer__['a' /* default */],
                        remux: __WEBPACK_IMPORTED_MODULE_7__remux_mp4_remuxer__['a' /* default */],
                      }, {
                        demux: __WEBPACK_IMPORTED_MODULE_6__demux_mp3demuxer__['a' /* default */],
                        remux: __WEBPACK_IMPORTED_MODULE_7__remux_mp4_remuxer__['a' /* default */],
                      }]; // probe for content type

                    for (var i = 0, len = muxConfig.length; i < len; i++) {
                      var mux = muxConfig[i];
                      var probe = mux.demux.probe;

                      if (probe(data)) {
                        var _remuxer = this.remuxer = new mux.remux(observer,
                            config, typeSupported, this.vendor);

                        demuxer = new mux.demux(observer, _remuxer, config,
                            typeSupported);
                        this.probe = probe;
                        break;
                      }
                    }

                    if (!demuxer) {
                      observer.trigger(
                          __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].ERROR,
                          {
                            type: __WEBPACK_IMPORTED_MODULE_1__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                            details: __WEBPACK_IMPORTED_MODULE_1__errors__['a' /* ErrorDetails */].FRAG_PARSING_ERROR,
                            fatal: true,
                            reason: 'no demux matching with content found',
                          });
                      return;
                    }

                    this.demuxer = demuxer;
                  }

                  var remuxer = this.remuxer;

                  if (discontinuity || trackSwitch) {
                    demuxer.resetInitSegment(initSegment, audioCodec,
                        videoCodec, duration);
                    remuxer.resetInitSegment();
                  }

                  if (discontinuity) {
                    demuxer.resetTimeStamp(defaultInitPTS);
                    remuxer.resetTimeStamp(defaultInitPTS);
                  }

                  if (typeof demuxer.setDecryptData === 'function') {
                    demuxer.setDecryptData(decryptdata);
                  }

                  demuxer.append(data, timeOffset, contiguous,
                      accurateTimeOffset);
                };

                return DemuxerInline;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (DemuxerInline);

          /***/
        }),
        /* 25 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* unused harmony export getAudioConfig */
          /* unused harmony export isHeaderPattern */
          /* unused harmony export getHeaderLength */
          /* unused harmony export getFullFrameLength */
          /* harmony export (immutable) */
          __webpack_exports__['d'] = isHeader;
          /* harmony export (immutable) */
          __webpack_exports__['e'] = probe;
          /* harmony export (immutable) */
          __webpack_exports__['c'] = initTrackConfig;
          /* harmony export (immutable) */
          __webpack_exports__['b'] = getFrameDuration;
          /* unused harmony export parseFrameHeader */
          /* harmony export (immutable) */
          __webpack_exports__['a'] = appendFrame;
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__utils_get_self_scope__ = __webpack_require__(
              5);

          /**
           * ADTS parser helper
           * @link https://wiki.multimedia.cx/index.php?title=ADTS
           */




          function getAudioConfig(observer, data, offset, audioCodec) {
            var adtsObjectType,
                // :int
                adtsSampleingIndex,
                // :int
                adtsExtensionSampleingIndex,
                // :int
                adtsChanelConfig,
                // :int
                config,
                userAgent = navigator.userAgent.toLowerCase(),
                manifestCodec = audioCodec,
                adtsSampleingRates = [
                  96000,
                  88200,
                  64000,
                  48000,
                  44100,
                  32000,
                  24000,
                  22050,
                  16000,
                  12000,
                  11025,
                  8000,
                  7350]; // byte 2

            adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
            adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;

            if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
              observer.trigger(
                  __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].ERROR,
                  {
                    type: __WEBPACK_IMPORTED_MODULE_1__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                    details: __WEBPACK_IMPORTED_MODULE_1__errors__['a' /* ErrorDetails */].FRAG_PARSING_ERROR,
                    fatal: true,
                    reason: 'invalid ADTS sampling index:' + adtsSampleingIndex,
                  });
              return;
            }

            adtsChanelConfig = (data[offset + 2] & 0x01) << 2; // byte 3

            adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
            __WEBPACK_IMPORTED_MODULE_0__utils_logger__['b' /* logger */].log(
                'manifest codec:' + audioCodec + ',ADTS data:type:' +
                adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' +
                adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' +
                adtsChanelConfig); // firefox: freq less than 24kHz = AAC SBR (HE-AAC)

            if (/firefox/i.test(userAgent)) {
              if (adtsSampleingIndex >= 6) {
                adtsObjectType = 5;
                config = new Array(4); // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
                // there is a factor 2 between frame sample rate and output sample rate
                // multiply frequency by 2 (see table below, equivalent to substract 3)

                adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
              } else {
                adtsObjectType = 2;
                config = new Array(2);
                adtsExtensionSampleingIndex = adtsSampleingIndex;
              } // Android : always use AAC

            } else if (userAgent.indexOf('android') !== -1) {
              adtsObjectType = 2;
              config = new Array(2);
              adtsExtensionSampleingIndex = adtsSampleingIndex;
            } else {
              /*  for other browsers (Chrome/Vivaldi/Opera ...)
        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
    */
              adtsObjectType = 5;
              config = new Array(4); // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)

              if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 ||
                  audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec &&
                  adtsSampleingIndex >= 6) {
                // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
                // there is a factor 2 between frame sample rate and output sample rate
                // multiply frequency by 2 (see table below, equivalent to substract 3)
                adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
              } else {
                // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
                // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
                if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 &&
                    (adtsSampleingIndex >= 6 && adtsChanelConfig === 1 ||
                        /vivaldi/i.test(userAgent)) || !audioCodec &&
                    adtsChanelConfig === 1) {
                  adtsObjectType = 2;
                  config = new Array(2);
                }

                adtsExtensionSampleingIndex = adtsSampleingIndex;
              }
            }
            /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
      ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()
    Audio Profile / Audio Object Type
    0: Null
    1: AAC Main
    2: AAC LC (Low Complexity)
    3: AAC SSR (Scalable Sample Rate)
    4: AAC LTP (Long Term Prediction)
    5: SBR (Spectral Band Replication)
    6: AAC Scalable
   sampling freq
    0: 96000 Hz
    1: 88200 Hz
    2: 64000 Hz
    3: 48000 Hz
    4: 44100 Hz
    5: 32000 Hz
    6: 24000 Hz
    7: 22050 Hz
    8: 16000 Hz
    9: 12000 Hz
    10: 11025 Hz
    11: 8000 Hz
    12: 7350 Hz
    13: Reserved
    14: Reserved
    15: frequency is written explictly
    Channel Configurations
    These are the channel configurations:
    0: Defined in AOT Specifc Config
    1: 1 channel: front-center
    2: 2 channels: front-left, front-right
  */
            // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1

            config[0] = adtsObjectType << 3; // samplingFrequencyIndex

            config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
            config[1] |= (adtsSampleingIndex & 0x01) << 7; // channelConfiguration

            config[1] |= adtsChanelConfig << 3;

            if (adtsObjectType === 5) {
              // adtsExtensionSampleingIndex
              config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
              config[2] = (adtsExtensionSampleingIndex & 0x01) << 7; // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
              //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc

              config[2] |= 2 << 2;
              config[3] = 0;
            }

            return {
              config: config,
              samplerate: adtsSampleingRates[adtsSampleingIndex],
              channelCount: adtsChanelConfig,
              codec: 'mp4a.40.' + adtsObjectType,
              manifestCodec: manifestCodec,
            };
          }

          function isHeaderPattern(data, offset) {
            return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;
          }

          function getHeaderLength(data, offset) {
            return data[offset + 1] & 0x01 ? 7 : 9;
          }

          function getFullFrameLength(data, offset) {
            return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 |
                (data[offset + 5] & 0xE0) >>> 5;
          }

          function isHeader(data, offset) {
            // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
            // Layer bits (position 14 and 15) in header should be always 0 for ADTS
            // More info https://wiki.multimedia.cx/index.php?title=ADTS
            if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
              return true;
            }

            return false;
          }

          function probe(data, offset) {
            // same as isHeader but we also check that ADTS frame follows last ADTS frame
            // or end of data is reached
            if (isHeader(data, offset)) {
              // ADTS header Length
              var headerLength = getHeaderLength(data, offset); // ADTS frame Length

              var frameLength = headerLength;

              if (offset + 5 < data.length) {
                frameLength = getFullFrameLength(data, offset);
              }

              var newOffset = offset + frameLength;

              if (newOffset === data.length || newOffset + 1 < data.length &&
                  isHeaderPattern(data, newOffset)) {
                return true;
              }
            }

            return false;
          }

          function initTrackConfig(track, observer, data, offset, audioCodec) {
            if (!track.samplerate) {
              var config = getAudioConfig(observer, data, offset, audioCodec);
              track.config = config.config;
              track.samplerate = config.samplerate;
              track.channelCount = config.channelCount;
              track.codec = config.codec;
              track.manifestCodec = config.manifestCodec;
              __WEBPACK_IMPORTED_MODULE_0__utils_logger__['b' /* logger */].log(
                  'parsed codec:' + track.codec + ',rate:' + config.samplerate +
                  ',nb channel:' + config.channelCount);
            }
          }

          function getFrameDuration(samplerate) {
            return 1024 * 90000 / samplerate;
          }

          function parseFrameHeader(
              data, offset, pts, frameIndex, frameDuration) {
            var headerLength, frameLength, stamp;
            var length = data.length; // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header

            headerLength = getHeaderLength(data, offset); // retrieve frame size

            frameLength = getFullFrameLength(data, offset);
            frameLength -= headerLength;

            if (frameLength > 0 && offset + headerLength + frameLength <=
                length) {
              stamp = pts + frameIndex * frameDuration; // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);

              return {
                headerLength: headerLength,
                frameLength: frameLength,
                stamp: stamp,
              };
            }

            return undefined;
          }

          function appendFrame(track, data, offset, pts, frameIndex) {
            var frameDuration = getFrameDuration(track.samplerate);
            var header = parseFrameHeader(data, offset, pts, frameIndex,
                frameDuration);

            if (header) {
              var stamp = header.stamp;
              var headerLength = header.headerLength;
              var frameLength = header.frameLength; // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);

              var aacSample = {
                unit: data.subarray(offset + headerLength,
                    offset + headerLength + frameLength),
                pts: stamp,
                dts: stamp,
              };
              track.samples.push(aacSample);
              return {
                sample: aacSample,
                length: frameLength + headerLength,
              };
            }

            return undefined;
          }

          /***/
        }),
        /* 26 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /**
           *  MPEG parser helper
           */
          var MpegAudio = {
            BitratesMap: [
              32,
              64,
              96,
              128,
              160,
              192,
              224,
              256,
              288,
              320,
              352,
              384,
              416,
              448,
              32,
              48,
              56,
              64,
              80,
              96,
              112,
              128,
              160,
              192,
              224,
              256,
              320,
              384,
              32,
              40,
              48,
              56,
              64,
              80,
              96,
              112,
              128,
              160,
              192,
              224,
              256,
              320,
              32,
              48,
              56,
              64,
              80,
              96,
              112,
              128,
              144,
              160,
              176,
              192,
              224,
              256,
              8,
              16,
              24,
              32,
              40,
              48,
              56,
              64,
              80,
              96,
              112,
              128,
              144,
              160],
            SamplingRateMap: [
              44100,
              48000,
              32000,
              22050,
              24000,
              16000,
              11025,
              12000,
              8000],
            SamplesCoefficients: [// MPEG 2.5
              [
                0, // Reserved
                72, // Layer3
                144, // Layer2
                12, // Layer1
              ], // Reserved
              [
                0, // Reserved
                0, // Layer3
                0, // Layer2
                0, // Layer1
              ], // MPEG 2
              [
                0, // Reserved
                72, // Layer3
                144, // Layer2
                12, // Layer1
              ], // MPEG 1
              [
                0, // Reserved
                144, // Layer3
                144, // Layer2
                12, // Layer1
              ]],
            BytesInSlot: [
              0, // Reserved
              1, // Layer3
              1, // Layer2
              4, // Layer1
            ],
            appendFrame: function appendFrame(
                track, data, offset, pts, frameIndex) {
              // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
              if (offset + 24 > data.length) {
                return undefined;
              }

              var header = this.parseHeader(data, offset);

              if (header && offset + header.frameLength <= data.length) {
                var frameDuration = header.samplesPerFrame * 90000 /
                    header.sampleRate;
                var stamp = pts + frameIndex * frameDuration;
                var sample = {
                  unit: data.subarray(offset, offset + header.frameLength),
                  pts: stamp,
                  dts: stamp,
                };
                track.config = [];
                track.channelCount = header.channelCount;
                track.samplerate = header.sampleRate;
                track.samples.push(sample);
                return {
                  sample: sample,
                  length: header.frameLength,
                };
              }

              return undefined;
            },
            parseHeader: function parseHeader(data, offset) {
              var headerB = data[offset + 1] >> 3 & 3;
              var headerC = data[offset + 1] >> 1 & 3;
              var headerE = data[offset + 2] >> 4 & 15;
              var headerF = data[offset + 2] >> 2 & 3;
              var headerG = data[offset + 2] >> 1 & 1;

              if (headerB !== 1 && headerE !== 0 && headerE !== 15 &&
                  headerF !== 3) {
                var columnInBitrates = headerB === 3 ? 3 - headerC : headerC ===
                3 ? 3 : 4;
                var bitRate = MpegAudio.BitratesMap[columnInBitrates * 14 +
                headerE - 1] * 1000;
                var columnInSampleRates = headerB === 3 ? 0 : headerB === 2
                    ? 1
                    : 2;
                var sampleRate = MpegAudio.SamplingRateMap[columnInSampleRates *
                3 + headerF];
                var channelCount = data[offset + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)

                var sampleCoefficient = MpegAudio.SamplesCoefficients[headerB][headerC];
                var bytesInSlot = MpegAudio.BytesInSlot[headerC];
                var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
                var frameLength = parseInt(
                    sampleCoefficient * bitRate / sampleRate + headerG, 10) *
                    bytesInSlot;
                return {
                  sampleRate: sampleRate,
                  channelCount: channelCount,
                  frameLength: frameLength,
                  samplesPerFrame: samplesPerFrame,
                };
              }

              return undefined;
            },
            isHeaderPattern: function isHeaderPattern(data, offset) {
              return data[offset] === 0xff && (data[offset + 1] & 0xe0) ===
                  0xe0 && (data[offset + 1] & 0x06) !== 0x00;
            },
            isHeader: function isHeader(data, offset) {
              // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
              // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
              // More info http://www.mp3-tech.org/programmer/frame_header.html
              if (offset + 1 < data.length &&
                  this.isHeaderPattern(data, offset)) {
                return true;
              }

              return false;
            },
            probe: function probe(data, offset) {
              // same as isHeader but we also check that MPEG frame follows last MPEG frame
              // or end of data is reached
              if (offset + 1 < data.length &&
                  this.isHeaderPattern(data, offset)) {
                // MPEG header Length
                var headerLength = 4; // MPEG frame Length

                var header = this.parseHeader(data, offset);
                var frameLength = headerLength;

                if (header && header.frameLength) {
                  frameLength = header.frameLength;
                }

                var newOffset = offset + frameLength;

                if (newOffset === data.length || newOffset + 1 < data.length &&
                    this.isHeaderPattern(data, newOffset)) {
                  return true;
                }
              }

              return false;
            },
          };
          /* harmony default export */
          __webpack_exports__['a'] = (MpegAudio);

          /***/
        }),
        /* 27 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /**
           *  TimeRanges to string helper
           */
          var TimeRanges = {
            toString: function toString(r) {
              var log = '';
              var len = r.length;

              for (var i = 0; i < len; i++) {
                log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) +
                    ']';
              }

              return log;
            },
          };
          /* harmony default export */
          __webpack_exports__['a'] = (TimeRanges);

          /***/
        }),
        /* 28 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* unused harmony export findFirstFragWithCC */
          /* harmony export (immutable) */
          __webpack_exports__['b'] = findFragWithCC;
          /* unused harmony export shouldAlignOnDiscontinuities */
          /* unused harmony export findDiscontinuousReferenceFrag */
          /* unused harmony export adjustPts */
          /* harmony export (immutable) */
          __webpack_exports__['a'] = alignStream;
          /* unused harmony export alignDiscontinuities */
          /* unused harmony export alignPDT */
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__binary_search__ = __webpack_require__(
              11);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__utils_logger__ = __webpack_require__(
              1);

          function findFirstFragWithCC(fragments, cc) {
            var firstFrag = null;

            for (var i = 0; i < fragments.length; i += 1) {
              var currentFrag = fragments[i];

              if (currentFrag && currentFrag.cc === cc) {
                firstFrag = currentFrag;
                break;
              }
            }

            return firstFrag;
          }

          function findFragWithCC(fragments, CC) {
            return __WEBPACK_IMPORTED_MODULE_1__binary_search__['a' /* default */].search(
                fragments, function(candidate) {
                  if (candidate.cc < CC) {
                    return 1;
                  } else if (candidate.cc > CC) {
                    return -1;
                  } else {
                    return 0;
                  }
                });
          }

          function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
            var shouldAlign = false;

            if (lastLevel && lastLevel.details && details) {
              if (details.endCC > details.startCC || lastFrag && lastFrag.cc <
                  details.startCC) {
                shouldAlign = true;
              }
            }

            return shouldAlign;
          } // Find the first frag in the previous level which matches the CC of the first frag of the new level

          function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
            var prevFrags = prevDetails.fragments;
            var curFrags = curDetails.fragments;

            if (!curFrags.length || !prevFrags.length) {
              __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                  'No fragments to align');
              return;
            }

            var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);

            if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
              __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                  'No frag in previous level to align on');
              return;
            }

            return prevStartFrag;
          }

          function adjustPts(sliding, details) {
            details.fragments.forEach(function(frag) {
              if (frag) {
                var start = frag.start + sliding;
                frag.start = frag.startPTS = start;
                frag.endPTS = start + frag.duration;
              }
            });
            details.PTSKnown = true;
          }

          /**
           * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a
           * contiguous stream with the last fragments.
           * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to
           * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time
           * and an extra download.
           * @param lastFrag
           * @param lastLevel
           * @param details
           */

          function alignStream(lastFrag, lastLevel, details) {
            alignDiscontinuities(lastFrag, details, lastLevel);

            if (!details.PTSKnown && lastLevel) {
              // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.
              // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same
              // discontinuity sequence.
              alignPDT(details, lastLevel.details);
            }
          }

          /**
           * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same
           * discontinuity sequence.
           * @param lastLevel - The details of the last loaded level
           * @param details - The details of the new level
           */

          function alignDiscontinuities(lastFrag, details, lastLevel) {
            if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
              var referenceFrag = findDiscontinuousReferenceFrag(
                  lastLevel.details, details);

              if (referenceFrag) {
                __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                    'Adjusting PTS using last level due to CC increase within current level');
                adjustPts(referenceFrag.start, details);
              }
            }
          }

          /**
           * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.
           * @param details - The details of the new level
           * @param lastDetails - The details of the last loaded level
           */

          function alignPDT(details, lastDetails) {
            if (lastDetails && lastDetails.fragments.length) {
              if (!details.hasProgramDateTime ||
                  !lastDetails.hasProgramDateTime) {
                return;
              } // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM
              // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM
              // then we can deduce that playlist B sliding is 1000+8 = 1008s

              var lastPDT = lastDetails.fragments[0].programDateTime;
              var newPDT = details.fragments[0].programDateTime; // date diff is in ms. frag.start is in seconds

              var sliding = (newPDT - lastPDT) / 1000 +
                  lastDetails.fragments[0].start;

              if (Object(
                  __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                  sliding)) {
                __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                    'adjusting PTS using programDateTime delta, sliding:' +
                    sliding.toFixed(3));
                adjustPts(sliding, details);
              }
            }
          }

          /***/
        }),
        /* 29 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (immutable) */
          __webpack_exports__['a'] = findFragmentByPDT;
          /* harmony export (immutable) */
          __webpack_exports__['b'] = findFragmentByPTS;
          /* unused harmony export fragmentWithinToleranceTest */
          /* unused harmony export pdtWithinToleranceTest */
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__utils_binary_search__ = __webpack_require__(
              11);

          /**
           * Returns first fragment whose endPdt value exceeds the given PDT.
           * @param {Array<Fragment>} fragments - The array of candidate fragments
           * @param {number|null} [PDTValue = null] - The PDT value which must be exceeded
           * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start/end can be within in order to be considered contiguous
           * @returns {*|null} fragment - The best matching fragment
           */
          function findFragmentByPDT(
              fragments, PDTValue, maxFragLookUpTolerance) {
            if (PDTValue === null || !Array.isArray(fragments) ||
                !fragments.length || !Object(
                    __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                    PDTValue)) {
              return null;
            } // if less than start

            var startPDT = fragments[0].programDateTime;

            if (PDTValue < (startPDT || 0)) {
              return null;
            }

            var endPDT = fragments[fragments.length - 1].endProgramDateTime;

            if (PDTValue >= (endPDT || 0)) {
              return null;
            }

            maxFragLookUpTolerance = maxFragLookUpTolerance || 0;

            for (var seg = 0; seg < fragments.length; ++seg) {
              var frag = fragments[seg];

              if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance,
                  frag)) {
                return frag;
              }
            }

            return null;
          }

          /**
           * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.
           * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus
           * breaking any traps which would cause the same fragment to be continuously selected within a small range.
           * @param {*} fragPrevious - The last frag successfully appended
           * @param {Array<Fragment>} fragments - The array of candidate fragments
           * @param {number} [bufferEnd = 0] - The end of the contiguous buffered range the playhead is currently within
           * @param {number} maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous
           * @returns {*} foundFrag - The best matching fragment
           */

          function findFragmentByPTS(
              fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance) {
            if (bufferEnd === void 0) {
              bufferEnd = 0;
            }

            if (maxFragLookUpTolerance === void 0) {
              maxFragLookUpTolerance = 0;
            }

            var fragNext = fragPrevious ? fragments[fragPrevious.sn -
            fragments[0].sn + 1] : null; // Prefer the next fragment if it's within tolerance

            if (fragNext &&
                !fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance,
                    fragNext)) {
              return fragNext;
            }

            return __WEBPACK_IMPORTED_MODULE_1__utils_binary_search__['a' /* default */].search(
                fragments, fragmentWithinToleranceTest.bind(null, bufferEnd,
                    maxFragLookUpTolerance));
          }

          /**
           * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.
           * @param {*} candidate - The fragment to test
           * @param {number} [bufferEnd = 0] - The end of the current buffered range the playhead is currently within
           * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
           * @returns {number} - 0 if it matches, 1 if too low, -1 if too high
           */

          function fragmentWithinToleranceTest(
              bufferEnd, maxFragLookUpTolerance, candidate) {
            if (bufferEnd === void 0) {
              bufferEnd = 0;
            }

            if (maxFragLookUpTolerance === void 0) {
              maxFragLookUpTolerance = 0;
            }

            // offset should be within fragment boundary - config.maxFragLookUpTolerance
            // this is to cope with situations like
            // bufferEnd = 9.991
            // frag[] : [0,10]
            // frag[1] : [10,20]
            // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
            //              frag start               frag start+duration
            //                  |-----------------------------|
            //              <--->                         <--->
            //  ...--------><-----------------------------><---------....
            // previous frag         matching fragment         next frag
            //  return -1             return 0                 return 1
            // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
            // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
            var candidateLookupTolerance = Math.min(maxFragLookUpTolerance,
                candidate.duration +
                (candidate.deltaPTS ? candidate.deltaPTS : 0));

            if (candidate.start + candidate.duration -
                candidateLookupTolerance <= bufferEnd) {
              return 1;
            } else if (candidate.start - candidateLookupTolerance > bufferEnd &&
                candidate.start) {
              // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
              return -1;
            }

            return 0;
          }

          /**
           * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.
           * This function tests the candidate's program date time values, as represented in Unix time
           * @param {*} candidate - The fragment to test
           * @param {number} [pdtBufferEnd = 0] - The Unix time representing the end of the current buffered range
           * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
           * @returns {boolean} True if contiguous, false otherwise
           */

          function pdtWithinToleranceTest(
              pdtBufferEnd, maxFragLookUpTolerance, candidate) {
            var candidateLookupTolerance = Math.min(maxFragLookUpTolerance,
                candidate.duration +
                (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000; // endProgramDateTime can be null, default to zero

            var endProgramDateTime = candidate.endProgramDateTime || 0;
            return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
          }

          /***/
        }),
        /* 30 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return TaskLoop; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__event_handler__ = __webpack_require__(
              4);

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError(
                  'this hasn\'t been initialised - super() hasn\'t been called');
            }
            return self;
          }

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /**
           * Sub-class specialization of EventHandler base class.
           *
           * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,
           * scheduled asynchroneously, avoiding recursive calls in the same tick.
           *
           * The task itself is implemented in `doTick`. It can be requested and called for single execution
           * using the `tick` method.
           *
           * It will be assured that the task execution method (`tick`) only gets called once per main loop "tick",
           * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.
           *
           * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,
           * and cancelled with `clearNextTick`.
           *
           * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).
           *
           * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.
           *
           * Further explanations:
           *
           * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously
           * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.
           *
           * When the task execution (`tick` method) is called in re-entrant way this is detected and
           * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further
           * task processing on the next main loop iteration (also known as "next tick" in the Node/JS runtime lingo).
           */
          var TaskLoop =
              /*#__PURE__*/
              function(_EventHandler) {
                _inheritsLoose(TaskLoop, _EventHandler);

                function TaskLoop(hls) {
                  var _this;

                  for (var _len = arguments.length, events = new Array(
                      _len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    events[_key - 1] = arguments[_key];
                  }

                  _this = _EventHandler.call.apply(_EventHandler,
                      [this, hls].concat(events)) || this;
                  _this._boundTick = void 0;
                  _this._tickTimer = null;
                  _this._tickInterval = null;
                  _this._tickCallCount = 0;
                  _this._boundTick = _this.tick.bind(
                      _assertThisInitialized(_this));
                  return _this;
                }

                /**
                 * @override
                 */


                var _proto = TaskLoop.prototype;

                _proto.onHandlerDestroying = function onHandlerDestroying() {
                  // clear all timers before unregistering from event bus
                  this.clearNextTick();
                  this.clearInterval();
                }
                /**
                 * @returns {boolean}
                 */
                ;

                _proto.hasInterval = function hasInterval() {
                  return !!this._tickInterval;
                }
                /**
                 * @returns {boolean}
                 */
                ;

                _proto.hasNextTick = function hasNextTick() {
                  return !!this._tickTimer;
                }
                /**
                 * @param {number} millis Interval time (ms)
                 * @returns {boolean} True when interval has been scheduled, false when already scheduled (no effect)
                 */
                ;

                _proto.setInterval = function setInterval(millis) {
                  if (!this._tickInterval) {
                    this._tickInterval = self.setInterval(this._boundTick,
                        millis);
                    return true;
                  }

                  return false;
                }
                /**
                 * @returns {boolean} True when interval was cleared, false when none was set (no effect)
                 */
                ;

                _proto.clearInterval = function clearInterval() {
                  if (this._tickInterval) {
                    self.clearInterval(this._tickInterval);
                    this._tickInterval = null;
                    return true;
                  }

                  return false;
                }
                /**
                 * @returns {boolean} True when timeout was cleared, false when none was set (no effect)
                 */
                ;

                _proto.clearNextTick = function clearNextTick() {
                  if (this._tickTimer) {
                    self.clearTimeout(this._tickTimer);
                    this._tickTimer = null;
                    return true;
                  }

                  return false;
                }
                /**
                 * Will call the subclass doTick implementation in this main loop tick
                 * or in the next one (via setTimeout(,0)) in case it has already been called
                 * in this tick (in case this is a re-entrant call).
                 */
                ;

                _proto.tick = function tick() {
                  this._tickCallCount++;

                  if (this._tickCallCount === 1) {
                    this.doTick(); // re-entrant call to tick from previous doTick call stack
                    // -> schedule a call on the next main loop iteration to process this task processing request

                    if (this._tickCallCount > 1) {
                      // make sure only one timer exists at any time at max
                      this.clearNextTick();
                      this._tickTimer = self.setTimeout(this._boundTick, 0);
                    }

                    this._tickCallCount = 0;
                  }
                }
                /**
                 * For subclass to implement task logic
                 * @abstract
                 */
                ;

                _proto.doTick = function doTick() {};

                return TaskLoop;
              }(__WEBPACK_IMPORTED_MODULE_0__event_handler__['a' /* default */]);

          /***/
        }),
        /* 31 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__utils_logger__ = __webpack_require__(
              1);
          /**
           * XHR based logger
           */

          var _window = window,
              performance = _window.performance,
              XMLHttpRequest = _window.XMLHttpRequest;

          var XhrLoader =
              /*#__PURE__*/
              function() {
                function XhrLoader(config) {
                  if (config && config.xhrSetup) {
                    this.xhrSetup = config.xhrSetup;
                  }
                }

                var _proto = XhrLoader.prototype;

                _proto.destroy = function destroy() {
                  this.abort();
                  this.loader = null;
                };

                _proto.abort = function abort() {
                  var loader = this.loader;

                  if (loader && loader.readyState !== 4) {
                    this.stats.aborted = true;
                    loader.abort();
                  }

                  window.clearTimeout(this.requestTimeout);
                  this.requestTimeout = null;
                  window.clearTimeout(this.retryTimeout);
                  this.retryTimeout = null;
                };

                _proto.load = function load(context, config, callbacks) {
                  this.context = context;
                  this.config = config;
                  this.callbacks = callbacks;
                  this.stats = {
                    trequest: performance.now(),
                    retry: 0,
                  };
                  this.retryDelay = config.retryDelay;
                  this.loadInternal();
                };

                _proto.loadInternal = function loadInternal() {
                  var xhr,
                      context = this.context;
                  xhr = this.loader = new XMLHttpRequest();
                  var stats = this.stats;
                  stats.tfirst = 0;
                  stats.loaded = 0;
                  var xhrSetup = this.xhrSetup;

                  try {
                    if (xhrSetup) {
                      try {
                        xhrSetup(xhr, context.url);
                      } catch (e) {
                        // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
                        // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
                        xhr.open('GET', context.url, true);
                        xhrSetup(xhr, context.url);
                      }
                    }

                    if (!xhr.readyState) {
                      xhr.open('GET', context.url, true);
                    }
                  } catch (e) {
                    // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
                    this.callbacks.onError({
                      code: xhr.status,
                      text: e.message,
                    }, context, xhr);
                    return;
                  }

                  if (context.rangeEnd) {
                    xhr.setRequestHeader('Range',
                        'bytes=' + context.rangeStart + '-' +
                        (context.rangeEnd - 1));
                  }

                  xhr.onreadystatechange = this.readystatechange.bind(this);
                  xhr.onprogress = this.loadprogress.bind(this);
                  xhr.responseType = context.responseType; // setup timeout before we perform request

                  this.requestTimeout = window.setTimeout(
                      this.loadtimeout.bind(this), this.config.timeout);
                  xhr.send();
                };

                _proto.readystatechange = function readystatechange(event) {
                  var xhr = event.currentTarget,
                      readyState = xhr.readyState,
                      stats = this.stats,
                      context = this.context,
                      config = this.config; // don't proceed if xhr has been aborted

                  if (stats.aborted) {
                    return;
                  } // >= HEADERS_RECEIVED

                  if (readyState >= 2) {
                    // clear xhr timeout and rearm it if readyState less than 4
                    window.clearTimeout(this.requestTimeout);

                    if (stats.tfirst === 0) {
                      stats.tfirst = Math.max(performance.now(),
                          stats.trequest);
                    }

                    if (readyState === 4) {
                      var status = xhr.status; // http status between 200 to 299 are all successful

                      if (status >= 200 && status < 300) {
                        stats.tload = Math.max(stats.tfirst, performance.now());
                        var data, len;

                        if (context.responseType === 'arraybuffer') {
                          data = xhr.response;
                          len = data.byteLength;
                        } else {
                          data = xhr.responseText;
                          len = data.length;
                        }

                        stats.loaded = stats.total = len;
                        var response = {
                          url: xhr.responseURL,
                          data: data,
                        };
                        this.callbacks.onSuccess(response, stats, context, xhr);
                      } else {
                        // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
                        if (stats.retry >= config.maxRetry || status >= 400 &&
                            status < 499) {
                          __WEBPACK_IMPORTED_MODULE_0__utils_logger__['b' /* logger */].error(
                              status + ' while loading ' + context.url);
                          this.callbacks.onError({
                            code: status,
                            text: xhr.statusText,
                          }, context, xhr);
                        } else {
                          // retry
                          __WEBPACK_IMPORTED_MODULE_0__utils_logger__['b' /* logger */].warn(
                              status + ' while loading ' + context.url +
                              ', retrying in ' + this.retryDelay + '...'); // aborts and resets internal state

                          this.destroy(); // schedule retry

                          this.retryTimeout = window.setTimeout(
                              this.loadInternal.bind(this), this.retryDelay); // set exponential backoff

                          this.retryDelay = Math.min(2 * this.retryDelay,
                              config.maxRetryDelay);
                          stats.retry++;
                        }
                      }
                    } else {
                      // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
                      this.requestTimeout = window.setTimeout(
                          this.loadtimeout.bind(this), config.timeout);
                    }
                  }
                };

                _proto.loadtimeout = function loadtimeout() {
                  __WEBPACK_IMPORTED_MODULE_0__utils_logger__['b' /* logger */].warn(
                      'timeout while loading ' + this.context.url);
                  this.callbacks.onTimeout(this.stats, this.context, null);
                };

                _proto.loadprogress = function loadprogress(event) {
                  var xhr = event.currentTarget,
                      stats = this.stats;
                  stats.loaded = event.loaded;

                  if (event.lengthComputable) {
                    stats.total = event.total;
                  }

                  var onProgress = this.callbacks.onProgress;

                  if (onProgress) {
                    // third arg is to provide on progress data
                    onProgress(stats, this.context, null, xhr);
                  }
                };

                return XhrLoader;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (XhrLoader);

          /***/
        }),
        /* 32 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'b',
              function() { return fixLineBreaks; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__vttcue__ = __webpack_require__(73);
          /*
 * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
 */

          var StringDecoder = function StringDecoder() {
            return {
              decode: function decode(data) {
                if (!data) {
                  return '';
                }

                if (typeof data !== 'string') {
                  throw new Error('Error - expected string data.');
                }

                return decodeURIComponent(encodeURIComponent(data));
              },
            };
          };

          function VTTParser() {
            this.window = window;
            this.state = 'INITIAL';
            this.buffer = '';
            this.decoder = new StringDecoder();
            this.regionList = [];
          } // Try to parse input as a time stamp.

          function parseTimeStamp(input) {
            function computeSeconds(h, m, s, f) {
              return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
            }

            var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);

            if (!m) {
              return null;
            }

            if (m[3]) {
              // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
              return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);
            } else if (m[1] > 59) {
              // Timestamp takes the form of [hours]:[minutes].[milliseconds]
              // First position is hours as it's over 59.
              return computeSeconds(m[1], m[2], 0, m[4]);
            } else {
              // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
              return computeSeconds(0, m[1], m[2], m[4]);
            }
          } // A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.

          function Settings() {
            this.values = Object.create(null);
          }

          Settings.prototype = {
            // Only accept the first assignment to any key.
            set: function set(k, v) {
              if (!this.get(k) && v !== '') {
                this.values[k] = v;
              }
            },
            // Return the value for a key, or a default value.
            // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
            // a number of possible default values as properties where 'defaultKey' is
            // the key of the property that will be chosen; otherwise it's assumed to be
            // a single value.
            get: function get(k, dflt, defaultKey) {
              if (defaultKey) {
                return this.has(k) ? this.values[k] : dflt[defaultKey];
              }

              return this.has(k) ? this.values[k] : dflt;
            },
            // Check whether we have a value for a key.
            has: function has(k) {
              return k in this.values;
            },
            // Accept a setting if its one of the given alternatives.
            alt: function alt(k, v, a) {
              for (var n = 0; n < a.length; ++n) {
                if (v === a[n]) {
                  this.set(k, v);
                  break;
                }
              }
            },
            // Accept a setting if its a valid (signed) integer.
            integer: function integer(k, v) {
              if (/^-?\d+$/.test(v)) {
                // integer
                this.set(k, parseInt(v, 10));
              }
            },
            // Accept a setting if its a valid percentage.
            percent: function percent(k, v) {
              var m;

              if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
                v = parseFloat(v);

                if (v >= 0 && v <= 100) {
                  this.set(k, v);
                  return true;
                }
              }

              return false;
            },
          }; // Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.

          function parseOptions(input, callback, keyValueDelim, groupDelim) {
            var groups = groupDelim ? input.split(groupDelim) : [input];

            for (var i in groups) {
              if (typeof groups[i] !== 'string') {
                continue;
              }

              var kv = groups[i].split(keyValueDelim);

              if (kv.length !== 2) {
                continue;
              }

              var k = kv[0];
              var v = kv[1];
              callback(k, v);
            }
          }

          var defaults = new __WEBPACK_IMPORTED_MODULE_0__vttcue__['a' /* default */](
              0, 0, 0); // 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
//  Safari doesn't yet support this change, but FF and Chrome do.

          var center = defaults.align === 'middle' ? 'middle' : 'center';

          function parseCue(input, cue, regionList) {
            // Remember the original input if we need to throw an error.
            var oInput = input; // 4.1 WebVTT timestamp

            function consumeTimeStamp() {
              var ts = parseTimeStamp(input);

              if (ts === null) {
                throw new Error('Malformed timestamp: ' + oInput);
              } // Remove time stamp from input.

              input = input.replace(/^[^\sa-zA-Z-]+/, '');
              return ts;
            } // 4.4.2 WebVTT cue settings

            function consumeCueSettings(input, cue) {
              var settings = new Settings();
              parseOptions(input, function(k, v) {
                switch (k) {
                  case 'region':
                    // Find the last region we parsed with the same region id.
                    for (var i = regionList.length - 1; i >= 0; i--) {
                      if (regionList[i].id === v) {
                        settings.set(k, regionList[i].region);
                        break;
                      }
                    }

                    break;

                  case 'vertical':
                    settings.alt(k, v, ['rl', 'lr']);
                    break;

                  case 'line':
                    var vals = v.split(','),
                        vals0 = vals[0];
                    settings.integer(k, vals0);

                    if (settings.percent(k, vals0)) {
                      settings.set('snapToLines', false);
                    }

                    settings.alt(k, vals0, ['auto']);

                    if (vals.length === 2) {
                      settings.alt('lineAlign', vals[1],
                          ['start', center, 'end']);
                    }

                    break;

                  case 'position':
                    vals = v.split(',');
                    settings.percent(k, vals[0]);

                    if (vals.length === 2) {
                      settings.alt('positionAlign', vals[1], [
                        'start',
                        center,
                        'end',
                        'line-left',
                        'line-right',
                        'auto']);
                    }

                    break;

                  case 'size':
                    settings.percent(k, v);
                    break;

                  case 'align':
                    settings.alt(k, v,
                        ['start', center, 'end', 'left', 'right']);
                    break;
                }
              }, /:/, /\s/); // Apply default values for any missing fields.

              cue.region = settings.get('region', null);
              cue.vertical = settings.get('vertical', '');
              var line = settings.get('line', 'auto');

              if (line === 'auto' && defaults.line === -1) {
                // set numeric line number for Safari
                line = -1;
              }

              cue.line = line;
              cue.lineAlign = settings.get('lineAlign', 'start');
              cue.snapToLines = settings.get('snapToLines', true);
              cue.size = settings.get('size', 100);
              cue.align = settings.get('align', center);
              var position = settings.get('position', 'auto');

              if (position === 'auto' && defaults.position === 50) {
                // set numeric position for Safari
                position = cue.align === 'start' || cue.align === 'left'
                    ? 0
                    : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
              }

              cue.position = position;
            }

            function skipWhitespace() {
              input = input.replace(/^\s+/, '');
            } // 4.1 WebVTT cue timings.

            skipWhitespace();
            cue.startTime = consumeTimeStamp(); // (1) collect cue start time

            skipWhitespace();

            if (input.substr(0, 3) !== '-->') {
              // (3) next characters must match '-->'
              throw new Error(
                  'Malformed time stamp (time stamps must be separated by \'-->\'): ' +
                  oInput);
            }

            input = input.substr(3);
            skipWhitespace();
            cue.endTime = consumeTimeStamp(); // (5) collect cue end time
            // 4.1 WebVTT cue settings list.

            skipWhitespace();
            consumeCueSettings(input, cue);
          }

          function fixLineBreaks(input) {
            return input.replace(/<br(?: \/)?>/gi, '\n');
          }

          VTTParser.prototype = {
            parse: function parse(data) {
              var self = this; // If there is no data then we won't decode it, but will just try to parse
              // whatever is in buffer already. This may occur in circumstances, for
              // example when flush() is called.

              if (data) {
                // Try to decode the data that we received.
                self.buffer += self.decoder.decode(data, {
                  stream: true,
                });
              }

              function collectNextLine() {
                var buffer = self.buffer;
                var pos = 0;
                buffer = fixLineBreaks(buffer);

                while (pos < buffer.length && buffer[pos] !== '\r' &&
                buffer[pos] !== '\n') {
                  ++pos;
                }

                var line = buffer.substr(0, pos); // Advance the buffer early in case we fail below.

                if (buffer[pos] === '\r') {
                  ++pos;
                }

                if (buffer[pos] === '\n') {
                  ++pos;
                }

                self.buffer = buffer.substr(pos);
                return line;
              } // 3.2 WebVTT metadata header syntax

              function parseHeader(input) {
                parseOptions(input, function(k, v) {
                  switch (k) {
                    case 'Region':
                      // 3.3 WebVTT region metadata header syntax
                      // console.log('parse region', v);
                      // parseRegion(v);
                      break;
                  }
                }, /:/);
              } // 5.1 WebVTT file parsing.

              try {
                var line;

                if (self.state === 'INITIAL') {
                  // We can't start parsing until we have the first line.
                  if (!/\r\n|\n/.test(self.buffer)) {
                    return this;
                  }

                  line = collectNextLine(); // strip of UTF-8 BOM if any
                  // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8

                  var m = line.match(/^()?WEBVTT([ \t].*)?$/);

                  if (!m || !m[0]) {
                    throw new Error('Malformed WebVTT signature.');
                  }

                  self.state = 'HEADER';
                }

                var alreadyCollectedLine = false;

                while (self.buffer) {
                  // We can't parse a line until we have the full line.
                  if (!/\r\n|\n/.test(self.buffer)) {
                    return this;
                  }

                  if (!alreadyCollectedLine) {
                    line = collectNextLine();
                  } else {
                    alreadyCollectedLine = false;
                  }

                  switch (self.state) {
                    case 'HEADER':
                      // 13-18 - Allow a header (metadata) under the WEBVTT line.
                      if (/:/.test(line)) {
                        parseHeader(line);
                      } else if (!line) {
                        // An empty line terminates the header and starts the body (cues).
                        self.state = 'ID';
                      }

                      continue;

                    case 'NOTE':
                      // Ignore NOTE blocks.
                      if (!line) {
                        self.state = 'ID';
                      }

                      continue;

                    case 'ID':
                      // Check for the start of NOTE blocks.
                      if (/^NOTE($|[ \t])/.test(line)) {
                        self.state = 'NOTE';
                        break;
                      } // 19-29 - Allow any number of line terminators, then initialize new cue values.

                      if (!line) {
                        continue;
                      }

                      self.cue = new __WEBPACK_IMPORTED_MODULE_0__vttcue__['a' /* default */](
                          0, 0, '');
                      self.state = 'CUE'; // 30-39 - Check if self line contains an optional identifier or timing data.

                      if (line.indexOf('-->') === -1) {
                        self.cue.id = line;
                        continue;
                      }

                      // Process line as start of a cue.

                      /* falls through */

                    case 'CUE':
                      // 40 - Collect cue timings and settings.
                      try {
                        parseCue(line, self.cue, self.regionList);
                      } catch (e) {
                        // In case of an error ignore rest of the cue.
                        self.cue = null;
                        self.state = 'BADCUE';
                        continue;
                      }

                      self.state = 'CUETEXT';
                      continue;

                    case 'CUETEXT':
                      var hasSubstring = line.indexOf('-->') !== -1; // 34 - If we have an empty line then report the cue.
                      // 35 - If we have the special substring '-->' then report the cue,
                      // but do not collect the line as we need to process the current
                      // one as a new cue.

                      if (!line || hasSubstring &&
                          (alreadyCollectedLine = true)) {
                        // We are done parsing self cue.
                        if (self.oncue) {
                          self.oncue(self.cue);
                        }

                        self.cue = null;
                        self.state = 'ID';
                        continue;
                      }

                      if (self.cue.text) {
                        self.cue.text += '\n';
                      }

                      self.cue.text += line;
                      continue;

                    case 'BADCUE':
                      // BADCUE
                      // 54-62 - Collect and discard the remaining cue.
                      if (!line) {
                        self.state = 'ID';
                      }

                      continue;
                  }
                }
              } catch (e) {
                // If we are currently parsing a cue, report what we have.
                if (self.state === 'CUETEXT' && self.cue && self.oncue) {
                  self.oncue(self.cue);
                }

                self.cue = null; // Enter BADWEBVTT state if header was not parsed correctly otherwise
                // another exception occurred so enter BADCUE state.

                self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
              }

              return this;
            },
            flush: function flush() {
              var self = this;

              try {
                // Finish decoding the stream.
                self.buffer += self.decoder.decode(); // Synthesize the end of the current cue or region.

                if (self.cue || self.state === 'HEADER') {
                  self.buffer += '\n\n';
                  self.parse();
                } // If we've flushed, parsed, and we're still on the INITIAL state then
                // that means we don't have enough of the stream to parse the first
                // line.

                if (self.state === 'INITIAL') {
                  throw new Error('Malformed WebVTT signature.');
                }
              } catch (e) {
                throw e;
              }

              if (self.onflush) {
                self.onflush();
              }

              return this;
            },
          };

          /* harmony default export */
          __webpack_exports__['a'] = (VTTParser);

          /***/
        }),
        /* 33 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return KeySystems; });
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'b',
              function() { return requestMediaKeySystemAccess; });
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess
           */
          var KeySystems;

          (function(KeySystems) {
            KeySystems['WIDEVINE'] = 'com.widevine.alpha';
            KeySystems['PLAYREADY'] = 'com.microsoft.playready';
          })(KeySystems || (KeySystems = {}));

          var requestMediaKeySystemAccess = function() {
            if (typeof window !== 'undefined' && window.navigator &&
                window.navigator.requestMediaKeySystemAccess) {
              return window.navigator.requestMediaKeySystemAccess.bind(
                  window.navigator);
            } else {
              return null;
            }
          }();

          /***/
        }),
        /* 34 */
        /***/ (function(module, exports, __webpack_require__) {

          var vjsPlugin = __webpack_require__(35);

          if (window.videojs) {
            vjsPlugin.registerConfigPlugin(window.videojs);
            vjsPlugin.registerSourceHandler(window.videojs);
          }

          module.exports = {
            register: vjsPlugin.registerSourceHandler,
          };

          /***/
        }),
        /* 35 */
        /***/ (function(module, exports, __webpack_require__) {

          var Hlsjs = __webpack_require__(36).default;

          var XhrAesLoader = __webpack_require__(81).default;

          var registerSourceHandler = function registerSourceHandler(videojs) {
            var hooks = {};

            function Html5Hlsjs(source, tech) {
              tech.name_ = 'StreamrootHlsjs';

              var _video = tech.el();

              var _hls;

              var _errorCounts = {};
              var _duration = null;

              var _dvrcheck;

              var _metadata = null;

              var _player = videojs(tech.options_.playerId);

              function _executeHooksFor(type) {
                if (hooks[type] === undefined) {
                  return;
                } // ES3 and IE < 9

                for (var i = 0; i < hooks[type].length; i++) {
                  hooks[type][i](_player, _hls);
                }
              }

              function _handleMediaError(error) {
                if (!_errorCounts[Hlsjs.ErrorTypes.MEDIA_ERROR] ||
                    _errorCounts[Hlsjs.ErrorTypes.MEDIA_ERROR] <= 1) {
                  console.info('trying to recover media error');

                  _hls.destroy();

                  _hls.startLoad(-1);

                  _hls.recoverMediaError();
                } else if (_errorCounts[Hlsjs.ErrorTypes.MEDIA_ERROR] === 2) {
                  console.info(
                      '2nd try to recover media error (by swapping audio codec');

                  _hls.swapAudioCodec();

                  _hls.recoverMediaError();
                } else if (_errorCounts[Hlsjs.ErrorTypes.MEDIA_ERROR] > 2) {
                  console.info('bubbling media error up to VIDEOJS');

                  tech.error = function() {
                    return error;
                  };

                  tech.trigger('error');
                }
              }

              function _onError(event, data) {
                var error = {
                  message: 'HLS.js error: ' + data.type + ' - fatal: ' +
                    data.fatal + ' - ' + data.details,
                };

                if (data.networkDetails) {
                  Object.assign(error, {
                    responseText: data.networkDetails.responseText || '',
                    status: data.networkDetails.status
                  });
                }

                console.error(error.message); // increment/set error count

                if (_errorCounts[data.type]) {
                  _errorCounts[data.type] += 1;
                } else {
                  _errorCounts[data.type] = 1;
                } // implement simple error handling based on hls.js documentation (https://github.com/dailymotion/hls.js/blob/master/API.md#fifth-step-error-handling)

                if (data.fatal) {
                  switch (data.type) {
                    case Hlsjs.ErrorTypes.NETWORK_ERROR:
                      console.info('bubbling network error up to VIDEOJS');
                      error.code = 2;

                      tech.error = function() {
                        return error;
                      };

                      tech.trigger('error');
                      break;

                    case Hlsjs.ErrorTypes.MEDIA_ERROR:
                      error.code = 3;

                      _handleMediaError(error);

                      break;

                    default:
                      // cannot recover
                      _hls.destroy();

                      console.info('bubbling error up to VIDEOJS');

                      tech.error = function() {
                        return error;
                      };

                      tech.trigger('error');
                      break;
                  }
                }
              }

              function switchQuality(qualityId) {
                if (_hls.config.levelSwitchStrategy &&
                    _hls.config.levelSwitchStrategy === 'instant') {
                  _hls.currentLevel = qualityId;
                } else if (_hls.config.levelSwitchStrategy &&
                    _hls.config.levelSwitchStrategy === 'smooth') {
                  _hls.nextLevel = qualityId;
                } else {
                  _hls.loadLevel = qualityId;
                }
              }

              function _levelLabel(level) {
                if (level.height) return level.height +
                    'p'; else if (level.width) return Math.round(
                    level.width * 9 / 16) +
                    'p'; else if (level.bitrate) return level.bitrate / 1000 +
                    'kbps';
                return 0;
              }

              function _notifyVideoQualities() {
                if (_metadata) {
                  var cleanTracklist = [];

                  if (_metadata.levels.length > 1) {
                    var autoLevel = {
                      id: -1,
                      label: 'auto',
                      selected: _hls.manualLevel === -1,
                    };
                    cleanTracklist.push(autoLevel);
                  }

                  _metadata.levels.forEach(function(level, index) {
                    var quality = {}; // Don't write in level (shared reference with Hls.js)

                    quality.id = index;
                    quality.selected = index === _hls.manualLevel;
                    quality.label = _levelLabel(level);
                    cleanTracklist.push(quality);
                  });

                  var payload = {
                    qualityData: {
                      video: cleanTracklist,
                    },
                    qualitySwitchCallback: switchQuality,
                  };
                  tech.trigger('loadedqualitydata', payload); // Self-de-register so we don't raise the payload multiple times

                  _video.removeEventListener('playing', _notifyVideoQualities);
                }
              }

              function _updateHlsjsAudioTrack() {
                var playerAudioTracks = tech.audioTracks();

                for (var j = 0; j < playerAudioTracks.length; j++) {
                  if (playerAudioTracks[j].enabled) {
                    _hls.audioTrack = j;
                    break;
                  }
                }
              }

              function _onAudioTracks() {
                var hlsAudioTracks = _hls.audioTracks;
                var playerAudioTracks = tech.audioTracks();

                if (hlsAudioTracks.length > 1 && playerAudioTracks.length ===
                    0) {
                  // Add Hls.js audio tracks if not added yet
                  for (var i = 0; i < hlsAudioTracks.length; i++) {
                    playerAudioTracks.addTrack(new videojs.AudioTrack({
                      id: i,
                      kind: 'alternative',
                      label: hlsAudioTracks[i].name || hlsAudioTracks[i].lang,
                      language: hlsAudioTracks[i].lang,
                      enabled: i === _hls.audioTrack,
                    }));
                  } // Handle audio track change event

                  playerAudioTracks.addEventListener('change',
                      _updateHlsjsAudioTrack);
                }
              }

              function _updateHlsjsTextTrack() {
                var playerTextTracks = _player.textTracks();

                var activeTrack = null;

                for (var j = 0; j < playerTextTracks.length; j++) {
                  if (playerTextTracks[j].mode === 'showing') {
                    activeTrack = playerTextTracks[j];
                    break;
                  }
                }

                var hlsjsTracks = _video.textTracks;

                for (var k = 0; k < hlsjsTracks.length; k++) {
                  if (hlsjsTracks[k].kind === 'subtitles' ||
                      hlsjsTracks[k].kind === 'captions') {
                    // NOTE: label here is readable label and is optional (used in the UI so if it is there it has to be different)
                    var hlsTrackId = hlsjsTracks[k].label
                        ? hlsjsTracks[k].label
                        : hlsjsTracks[k].language;
                    var vjsTrackId = null;

                    if (activeTrack !== null) {
                      vjsTrackId = activeTrack.label
                          ? activeTrack.label
                          : activeTrack.language;
                    }

                    hlsjsTracks[k].mode = hlsTrackId === vjsTrackId
                        ? 'showing'
                        : 'hidden';
                  }
                }
              }

              function _stopLoadingChunks() {
                _hls.stopLoad();

                if (_video.isLive) {
                  // PLAYER-12: on play we need to load back hls chunks and move forward so we don't buffer
                  _video.addEventListener('play', _loadManifest);
                }
              }

              function _loadManifest() {
                // _initHlsjs()

                _hls.recoverMediaError();

                _video.play();

                _video.removeEventListener('play', _loadManifest);
              }

              function _startLoad() {
                _hls.startLoad(-1);

                _video.removeEventListener('play', _startLoad);
              }

              function _oneLevelObjClone(obj) {
                var result = {};
                var objKeys = Object.keys(obj);

                for (var i = 0; i < objKeys.length; i++) {
                  result[objKeys[i]] = obj[objKeys[i]];
                }

                return result;
              }

              function _filterTextTracks(textTracks) {
                var displayableTracks = []; // Filter out tracks that is displayable (captions or subtitltes)

                for (var idx = 0; idx < textTracks.length; idx++) {
                  if (textTracks[idx].kind === 'subtitles' ||
                      textTracks[idx].kind === 'captions') {
                    displayableTracks.push(textTracks[idx]);
                  }
                }

                return displayableTracks;
              }

              function _onAddTextTrack() {
                var displayableTracks = _filterTextTracks(_video.textTracks);

                var playerTextTracks = _player.textTracks();

                if (displayableTracks.length > 0 && playerTextTracks.length ===
                    0) {
                  // Add stubs to make the caption switcher shows up
                  // NOTE: Adding the Hls.js text track in will make us have double captions
                  for (var idx = 0; idx < displayableTracks.length; idx++) {
                    var hlsjsTextTrack = displayableTracks[idx];

                    _player.addRemoteTextTrack({
                      label: hlsjsTextTrack.label,
                      language: hlsjsTextTrack.language,
                      srclang: hlsjsTextTrack.language,
                    }, false);
                  } // Handle UI switching

                  playerTextTracks.addEventListener('change',
                      _updateHlsjsTextTrack);
                }
              }

              function _onLevelLoad(event, data) {
                tech.trigger('hlslevelloaded', data);
                _duration = data.details.live
                    ? Infinity
                    : data.details.totalduration;

                if (typeof _dvrcheck === 'undefined' && data.details.live &&
                    _hls.streamController.lastCurrentTime >
                    (_hls.streamController.nextLoadPosition -
                        _hls.streamController.lastCurrentTime) * 15) {
                  // If we have before more than 10 chunks - its DVR (live stream usually has 3 chuncks in m3u8)
                  tech.trigger('dvrsourcedetected');
                } else if (data.details.live && typeof _dvrcheck ===
                    'undefined') {
                  // PLAYER-12: we need to keep the minimum buffer possible for live like 30 seconds
                  _hls.config.maxMaxBufferLength = 30;
                  _hls.config.startPosition = 0;
                  _video.isLive = true;
                  _video.addEventListener('pause', _stopLoadingChunks); // Stop loading chunks on pause
                  _video.addEventListener('play', _loadManifest);
                }
                _dvrcheck = true;
              }

              function _onMetaData(event, data) {
                // This could arrive before 'loadedqualitydata' handlers is registered, remember it so we can raise it later
                _metadata = data; // But we can notify about qualitydata twice because "loadedqualitydata" mean that manifest was loaded. it must happen before play

                _notifyVideoQualities();
              }

              function _initHlsjs() {
                var hlsjsConfigRef = tech.options_.hlsjsConfig; // NOTE: Hls.js will write to the reference thus change the object for later streams

                var hlsjsConfig = hlsjsConfigRef ? _oneLevelObjClone(
                    hlsjsConfigRef) : {};

                if (hlsjsConfig.aesSetup && hlsjsConfig.aesSetup.key &&
                    hlsjsConfig.aesSetup.iv) {
                  hlsjsConfig.pLoader = XhrAesLoader;
                  hlsjsConfig.fLoader = XhrAesLoader;
                }

                if (['', 'auto'].indexOf(_video.preload) === -1 &&
                    !_video.autoplay && hlsjsConfig.autoStartLoad ===
                    undefined) {
                  hlsjsConfig.autoStartLoad = false;
                } // If the user explicitely sets autoStartLoad to false, we're not going to enter the if block above, that's why we have a separate if block here to set the 'play' listener

                if (hlsjsConfig.autoStartLoad === false) {
                  _video.addEventListener('play', _startLoad);
                } // For some reason running this after generating text track list will raise an error inside Hls.js (too early perhaps)

                _video.addEventListener('play', _updateHlsjsTextTrack); // _notifyVideoQualities sometimes runs before the quality picker event handler is registered -> no video switcher

                _video.addEventListener('playing', _notifyVideoQualities);

                _hls = new Hlsjs(hlsjsConfig);

                _executeHooksFor('beforeinitialize');

                _hls.on(Hlsjs.Events.ERROR, function(event, data) {
                  _onError(event, data, tech, _errorCounts);
                });

                _hls.on(Hlsjs.Events.AUDIO_TRACK_LOADED, _onAudioTracks);

                _hls.on(Hlsjs.Events.FRAG_PARSING_METADATA,
                    function(event, data) {
                      tech.trigger('hlsManifestParsed', data);
                    }); // for DAI needs

                _hls.on(Hlsjs.Events.MANIFEST_PARSED, _onMetaData);

                _hls.on(Hlsjs.Events.LEVEL_LOADED, _onLevelLoad);

                _hls.on(Hlsjs.Events.LEVEL_SWITCHED, function(event, data) {
                  tech.trigger('hlslevelswitched', data);
                }); // Handle text tracks

                _hls.on(Hlsjs.Events.SUBTITLE_TRACK_LOADED, _onAddTextTrack);

                _hls.attachMedia(_video);

                _hls.loadSource(source.src);
              }

              function initialize() {
                _initHlsjs();
              }

              this.getQuality = function() {
                return _hls.levelController.levels[_hls.levelController.level];
              };

              this.duration = function() {
                return _duration || _video.duration || 0;
              };

              this.config = function(config) {
                if (config === void 0) {
                  config = {};
                }

                Object.assign(_hls.config, config);
              }; // See comment for `initialize` method.

              this.dispose = function() {
                _video.removeEventListener('play', _startLoad);

                _video.removeEventListener('play', _updateHlsjsTextTrack);

                _video.removeEventListener('playing', _notifyVideoQualities);

                _player.textTracks().
                    removeEventListener('change', _updateHlsjsTextTrack);

                _player.audioTracks().
                    removeEventListener('change', _updateHlsjsAudioTrack);

                _hls.destroy();
              };

              _video.addEventListener('error', function(evt) {
                var errorTxt,
                    mediaError = evt.currentTarget.error;

                switch (mediaError.code) {
                  case mediaError.MEDIA_ERR_ABORTED:
                    errorTxt = 'You aborted the video playback';
                    break;

                  case mediaError.MEDIA_ERR_DECODE:
                    errorTxt = 'The video playback was aborted due to a corruption problem or because the video used features your browser did not support';

                    _handleMediaError(mediaError);

                    break;

                  case mediaError.MEDIA_ERR_NETWORK:
                    errorTxt = 'A network error caused the video download to fail part-way';
                    break;

                  case mediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                    errorTxt = 'The video could not be loaded, either because the server or network failed or because the format is not supported';
                    break;

                  default:
                    errorTxt = mediaError.message;
                }

                console.error('MEDIA_ERROR: ', errorTxt);
              });

              initialize();
            }

            Html5Hlsjs.addHook = function(type, callback) {
              hooks[type] = hooks[type] || [];
              hooks[type].push(callback);
            };

            Html5Hlsjs.removeHook = function(type, callback) {
              if (hooks[type] === undefined) {
                return false;
              }

              var index = hooks[type].indexOf(callback);

              if (index === -1) {
                return false;
              }

              hooks[type].splice(index, 1);
              return true;
            };

            if (Hlsjs.isSupported()) {
              var html5;

              if (typeof videojs.getTech === 'function') {
                html5 = videojs.getTech('Html5');
              } else if (typeof videojs.getComponent === 'function') {
                html5 = videojs.getComponent('Html5');
              } else {
                console.error('Not supported version if video.js');
                return;
              }

              if (!html5) {
                console.error('Not supported version if video.js');
                return;
              }

              html5.registerSourceHandler({
                canHandleSource: function canHandleSource(source) {
                  var hlsTypeRE = /^application\/x-mpegURL$/i;
                  var hlsExtRE = /\.m3u8/i;
                  var result;

                  if (hlsTypeRE.test(source.type)) {
                    result = 'probably';
                  } else if (hlsExtRE.test(source.src)) {
                    result = 'maybe';
                  } else {
                    result = '';
                  }

                  return result;
                },
                handleSource: function handleSource(source, tech) {
                  if (tech.hlsProvider) {
                    tech.hlsProvider.dispose();
                  }

                  tech.hlsProvider = new Html5Hlsjs(source, tech);
                  return tech.hlsProvider;
                },
              }, 0);
              videojs.Html5Hlsjs = Html5Hlsjs;
            } else {
              console.warn('Hls.js is not supported in this browser!');
            }
          };

          function streamrootHlsjsConfigHandler(options) {
            var player = this;

            if (!options) {
              return;
            }

            if (!player.options_.html5) {
              player.options_.html5 = {};
            }

            if (!player.options_.html5.hlsjsConfig) {
              player.options_.html5.hlsjsConfig = options.hlsjsConfig;
            }
          }

          var registerConfigPlugin = function registerConfigPlugin(videojs) {
            // Used in Brightcove since we don't pass options directly there
            var registerVjsPlugin = videojs.registerPlugin || videojs.plugin;
            registerVjsPlugin('streamrootHls', streamrootHlsjsConfigHandler);
          };

          module.exports = {
            registerSourceHandler: registerSourceHandler,
            registerConfigPlugin: registerConfigPlugin,
          };

          /***/
        }),
        /* 36 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          Object.defineProperty(__webpack_exports__, '__esModule',
              {value: true});
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'default',
              function() { return Hls; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_url_toolkit__ = __webpack_require__(
              10);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_url_toolkit___default = __webpack_require__.n(
              __WEBPACK_IMPORTED_MODULE_0_url_toolkit__);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__loader_playlist_loader__ = __webpack_require__(
              37);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__loader_fragment_loader__ = __webpack_require__(
              41);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__loader_key_loader__ = __webpack_require__(
              42);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__controller_fragment_tracker__ = __webpack_require__(
              7);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_6__controller_stream_controller__ = __webpack_require__(
              43);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_7__controller_level_controller__ = __webpack_require__(
              60);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_8__controller_id3_track_controller__ = __webpack_require__(
              61);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_9__is_supported__ = __webpack_require__(
              62);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_10__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_11__config__ = __webpack_require__(63);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_12__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_13__observer__ = __webpack_require__(
              16);

          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null
                  ? arguments[i]
                  : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === 'function') {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).
                    filter(function(sym) {
                      return Object.getOwnPropertyDescriptor(source,
                          sym).enumerable;
                    }));
              }
              ownKeys.forEach(
                  function(key) { _defineProperty(target, key, source[key]); });
            }
            return target;
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true,
              });
            } else { obj[key] = value; }
            return obj;
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError(
                  'this hasn\'t been initialised - super() hasn\'t been called');
            }
            return self;
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(
              Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype,
                protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /**
           * @module Hls
           * @class
           * @constructor
           */

          var Hls =
              /*#__PURE__*/
              function(_Observer) {
                _inheritsLoose(Hls, _Observer);

                /**
                 * @type {boolean}
                 */
                Hls.isSupported = function isSupported() {
                  return Object(
                      __WEBPACK_IMPORTED_MODULE_9__is_supported__['a' /* isSupported */])();
                }
                /**
                 * @type {HlsEvents}
                 */
                ;

                _createClass(Hls, null, [
                  {
                    key: 'version',

                    /**
                     * @type {string}
                     */
                    get: function get() {
                      return '0.4.0-beta.0';
                    },
                  }, {
                    key: 'Events',
                    get: function get() {
                      return __WEBPACK_IMPORTED_MODULE_12__events__['a' /* default */];
                    },
                    /**
                     * @type {HlsErrorTypes}
                     */

                  }, {
                    key: 'ErrorTypes',
                    get: function get() {
                      return __WEBPACK_IMPORTED_MODULE_1__errors__['b' /* ErrorTypes */];
                    },
                    /**
                     * @type {HlsErrorDetails}
                     */

                  }, {
                    key: 'ErrorDetails',
                    get: function get() {
                      return __WEBPACK_IMPORTED_MODULE_1__errors__['a' /* ErrorDetails */];
                    },
                    /**
                     * @type {HlsConfig}
                     */

                  }, {
                    key: 'DefaultConfig',
                    get: function get() {
                      if (!Hls.defaultConfig) {
                        return __WEBPACK_IMPORTED_MODULE_11__config__['a' /* hlsDefaultConfig */];
                      }

                      return Hls.defaultConfig;
                    }
                    /**
                     * @type {HlsConfig}
                     */
                    ,
                    set: function set(defaultConfig) {
                      Hls.defaultConfig = defaultConfig;
                    },
                    /**
                     * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
                     *
                     * @constructs Hls
                     * @param {HlsConfig} config
                     */

                  }]);

                function Hls(userConfig) {
                  var _this;

                  if (userConfig === void 0) {
                    userConfig = {};
                  }

                  _this = _Observer.call(this) || this;
                  _this.config = void 0;
                  _this._autoLevelCapping = void 0;
                  _this.abrController = void 0;
                  _this.capLevelController = void 0;
                  _this.levelController = void 0;
                  _this.streamController = void 0;
                  _this.networkControllers = void 0;
                  _this.audioTrackController = void 0;
                  _this.subtitleTrackController = void 0;
                  _this.emeController = void 0;
                  _this.coreComponents = void 0;
                  _this.media = null;
                  _this.url = null;
                  var defaultConfig = Hls.DefaultConfig;

                  if ((userConfig.liveSyncDurationCount ||
                      userConfig.liveMaxLatencyDurationCount) &&
                      (userConfig.liveSyncDuration ||
                          userConfig.liveMaxLatencyDuration)) {
                    throw new Error(
                        'Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
                  } // Shallow clone

                  _this.config = _objectSpread({}, defaultConfig, userConfig);

                  var _assertThisInitialize = _assertThisInitialized(_this),
                      config = _assertThisInitialize.config;

                  if (config.liveMaxLatencyDurationCount !== void 0 &&
                      config.liveMaxLatencyDurationCount <=
                      config.liveSyncDurationCount) {
                    throw new Error(
                        'Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
                  }

                  if (config.liveMaxLatencyDuration !== void 0 &&
                      (config.liveSyncDuration === void 0 ||
                          config.liveMaxLatencyDuration <=
                          config.liveSyncDuration)) {
                    throw new Error(
                        'Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
                  }

                  Object(
                      __WEBPACK_IMPORTED_MODULE_10__utils_logger__['a' /* enableLogs */])(
                      config.debug);
                  _this._autoLevelCapping = -1; // core controllers and network loaders

                  /**
                   * @member {AbrController} abrController
                   */

                  var abrController = _this.abrController = new config.abrController(
                      _assertThisInitialized(_this)); // eslint-disable-line new-cap

                  var bufferController = new config.bufferController(
                      _assertThisInitialized(_this)); // eslint-disable-line new-cap

                  var capLevelController = _this.capLevelController = new config.capLevelController(
                      _assertThisInitialized(_this)); // eslint-disable-line new-cap

                  var fpsController = new config.fpsController(
                      _assertThisInitialized(_this)); // eslint-disable-line new-cap

                  var playListLoader = new __WEBPACK_IMPORTED_MODULE_2__loader_playlist_loader__['a' /* default */](
                      _assertThisInitialized(_this));
                  var fragmentLoader = new __WEBPACK_IMPORTED_MODULE_3__loader_fragment_loader__['a' /* default */](
                      _assertThisInitialized(_this));
                  var keyLoader = new __WEBPACK_IMPORTED_MODULE_4__loader_key_loader__['a' /* default */](
                      _assertThisInitialized(_this));
                  var id3TrackController = new __WEBPACK_IMPORTED_MODULE_8__controller_id3_track_controller__['a' /* default */](
                      _assertThisInitialized(_this)); // network controllers

                  /**
                   * @member {LevelController} levelController
                   */

                  var levelController = _this.levelController = new __WEBPACK_IMPORTED_MODULE_7__controller_level_controller__['a' /* default */](
                      _assertThisInitialized(_this)); // FIXME: FragmentTracker must be defined before StreamController because the order of event handling is important

                  var fragmentTracker = new __WEBPACK_IMPORTED_MODULE_5__controller_fragment_tracker__['b' /* FragmentTracker */](
                      _assertThisInitialized(_this));
                  /**
                   * @member {StreamController} streamController
                   */

                  var streamController = _this.streamController = new __WEBPACK_IMPORTED_MODULE_6__controller_stream_controller__['a' /* default */](
                      _assertThisInitialized(_this), fragmentTracker);
                  var networkControllers = [levelController, streamController]; // optional audio stream controller

                  /**
                   * @var {ICoreComponent | Controller}
                   */

                  var Controller = config.audioStreamController;

                  if (Controller) {
                    networkControllers.push(
                        new Controller(_assertThisInitialized(_this),
                            fragmentTracker));
                  }
                  /**
                   * @member {INetworkController[]} networkControllers
                   */

                  _this.networkControllers = networkControllers;
                  /**
                   * @var {ICoreComponent[]}
                   */

                  var coreComponents = [
                    playListLoader,
                    fragmentLoader,
                    keyLoader,
                    abrController,
                    bufferController,
                    capLevelController,
                    fpsController,
                    id3TrackController,
                    fragmentTracker]; // optional audio track and subtitle controller

                  Controller = config.audioTrackController;

                  if (Controller) {
                    var audioTrackController = new Controller(
                        _assertThisInitialized(_this));
                    /**
                     * @member {AudioTrackController} audioTrackController
                     */

                    _this.audioTrackController = audioTrackController;
                    coreComponents.push(audioTrackController);
                  }

                  Controller = config.subtitleTrackController;

                  if (Controller) {
                    var subtitleTrackController = new Controller(
                        _assertThisInitialized(_this));
                    /**
                     * @member {SubtitleTrackController} subtitleTrackController
                     */

                    _this.subtitleTrackController = subtitleTrackController;
                    networkControllers.push(subtitleTrackController);
                  }

                  Controller = config.emeController;

                  if (Controller) {
                    var emeController = new Controller(
                        _assertThisInitialized(_this));
                    /**
                     * @member {EMEController} emeController
                     */

                    _this.emeController = emeController;
                    coreComponents.push(emeController);
                  } // optional subtitle controllers

                  Controller = config.subtitleStreamController;

                  if (Controller) {
                    networkControllers.push(
                        new Controller(_assertThisInitialized(_this),
                            fragmentTracker));
                  }

                  Controller = config.timelineController;

                  if (Controller) {
                    coreComponents.push(
                        new Controller(_assertThisInitialized(_this)));
                  }
                  /**
                   * @member {ICoreComponent[]}
                   */

                  _this.coreComponents = coreComponents;
                  return _this;
                }

                /**
                 * Dispose of the instance
                 */


                var _proto = Hls.prototype;

                _proto.destroy = function destroy() {
                  __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].log(
                      'destroy');
                  this.trigger(
                      __WEBPACK_IMPORTED_MODULE_12__events__['a' /* default */].DESTROYING);
                  this.detachMedia();
                  this.coreComponents.concat(this.networkControllers).
                      forEach(function(component) {
                        component.destroy();
                      });
                  this.url = null;
                  this.removeAllListeners();
                  this._autoLevelCapping = -1;
                }
                /**
                 * Attach a media element
                 * @param {HTMLMediaElement} media
                 */
                ;

                _proto.attachMedia = function attachMedia(media) {
                  __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].log(
                      'attachMedia');
                  this.media = media;
                  this.trigger(
                      __WEBPACK_IMPORTED_MODULE_12__events__['a' /* default */].MEDIA_ATTACHING,
                      {
                        media: media,
                      });
                }
                /**
                 * Detach from the media
                 */
                ;

                _proto.detachMedia = function detachMedia() {
                  __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].log(
                      'detachMedia');
                  this.trigger(
                      __WEBPACK_IMPORTED_MODULE_12__events__['a' /* default */].MEDIA_DETACHING);
                  this.media = null;
                }
                /**
                 * Set the source URL. Can be relative or absolute.
                 * @param {string} url
                 */
                ;

                _proto.loadSource = function loadSource(url) {
                  url = __WEBPACK_IMPORTED_MODULE_0_url_toolkit__['buildAbsoluteURL'](
                      window.location.href, url, {
                        alwaysNormalize: true,
                      });
                  __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].log(
                      'loadSource:' + url);
                  this.url = url; // when attaching to a source URL, trigger a playlist load

                  this.trigger(
                      __WEBPACK_IMPORTED_MODULE_12__events__['a' /* default */].MANIFEST_LOADING,
                      {
                        url: url,
                      });
                }
                /**
                 * Start loading data from the stream source.
                 * Depending on default config, client starts loading automatically when a source is set.
                 *
                 * @param {number} startPosition Set the start position to stream from
                 * @default -1 None (from earliest point)
                 */
                ;

                _proto.startLoad = function startLoad(startPosition) {
                  if (startPosition === void 0) {
                    startPosition = -1;
                  }

                  __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].log(
                      'startLoad(' + startPosition + ')');
                  this.networkControllers.forEach(function(controller) {
                    controller.startLoad(startPosition);
                  });
                }
                /**
                 * Stop loading of any stream data.
                 */
                ;

                _proto.stopLoad = function stopLoad() {
                  __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].log(
                      'stopLoad');
                  this.networkControllers.forEach(function(controller) {
                    controller.stopLoad();
                  });
                }
                /**
                 * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
                 */
                ;

                _proto.swapAudioCodec = function swapAudioCodec() {
                  __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].log(
                      'swapAudioCodec');
                  this.streamController.swapAudioCodec();
                }
                /**
                 * When the media-element fails, this allows to detach and then re-attach it
                 * as one call (convenience method).
                 *
                 * Automatic recovery of media-errors by this process is configurable.
                 */
                ;

                _proto.recoverMediaError = function recoverMediaError() {
                  __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].log(
                      'recoverMediaError');
                  var media = this.media;
                  this.detachMedia();

                  if (media) {
                    this.attachMedia(media);
                  }
                }
                /**
                 * @type {QualityLevel[]}
                 */
                // todo(typescript-levelController)
                ;

                _createClass(Hls, [
                  {
                    key: 'levels',
                    get: function get() {
                      return this.levelController.levels;
                    },
                    /**
                     * Index of quality level currently played
                     * @type {number}
                     */

                  }, {
                    key: 'currentLevel',
                    get: function get() {
                      return this.streamController.currentLevel;
                    }
                    /**
                     * Set quality level index immediately .
                     * This will flush the current buffer to replace the quality asap.
                     * That means playback will interrupt at least shortly to re-buffer and re-sync eventually.
                     * @type {number} -1 for automatic level selection
                     */
                    ,
                    set: function set(newLevel) {
                      __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].log(
                          'set currentLevel:' + newLevel);
                      this.loadLevel = newLevel;
                      this.streamController.immediateLevelSwitch();
                    },
                    /**
                     * Index of next quality level loaded as scheduled by stream controller.
                     * @type {number}
                     */

                  }, {
                    key: 'nextLevel',
                    get: function get() {
                      return this.streamController.nextLevel;
                    }
                    /**
                     * Set quality level index for next loaded data.
                     * This will switch the video quality asap, without interrupting playback.
                     * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
                     * @type {number} -1 for automatic level selection
                     */
                    ,
                    set: function set(newLevel) {
                      __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].log(
                          'set nextLevel:' + newLevel);
                      this.levelController.manualLevel = newLevel;
                      this.streamController.nextLevelSwitch();
                    },
                    /**
                     * Return the quality level of the currently or last (of none is loaded currently) segment
                     * @type {number}
                     */

                  }, {
                    key: 'loadLevel',
                    get: function get() {
                      return this.levelController.level;
                    }
                    /**
                     * Set quality level index for next loaded data in a conservative way.
                     * This will switch the quality without flushing, but interrupt current loading.
                     * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
                     * @type {number} newLevel -1 for automatic level selection
                     */
                    ,
                    set: function set(newLevel) {
                      __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].log(
                          'set loadLevel:' + newLevel);
                      this.levelController.manualLevel = newLevel;
                    },
                    /**
                     * get next quality level loaded
                     * @type {number}
                     */

                  }, {
                    key: 'nextLoadLevel',
                    get: function get() {
                      return this.levelController.nextLoadLevel;
                    }
                    /**
                     * Set quality level of next loaded segment in a fully "non-destructive" way.
                     * Same as `loadLevel` but will wait for next switch (until current loading is done).
                     * @type {number} level
                     */
                    ,
                    set: function set(level) {
                      this.levelController.nextLoadLevel = level;
                    },
                    /**
                     * Return "first level": like a default level, if not set,
                     * falls back to index of first level referenced in manifest
                     * @type {number}
                     */

                  }, {
                    key: 'firstLevel',
                    get: function get() {
                      return Math.max(this.levelController.firstLevel,
                          this.minAutoLevel);
                    }
                    /**
                     * Sets "first-level", see getter.
                     * @type {number}
                     */
                    ,
                    set: function set(newLevel) {
                      __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].log(
                          'set firstLevel:' + newLevel);
                      this.levelController.firstLevel = newLevel;
                    },
                    /**
                     * Return start level (level of first fragment that will be played back)
                     * if not overrided by user, first level appearing in manifest will be used as start level
                     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
                     * (determined from download of first segment)
                     * @type {number}
                     */

                  }, {
                    key: 'startLevel',
                    get: function get() {
                      return this.levelController.startLevel;
                    }
                    /**
                     * set  start level (level of first fragment that will be played back)
                     * if not overrided by user, first level appearing in manifest will be used as start level
                     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
                     * (determined from download of first segment)
                     * @type {number} newLevel
                     */
                    ,
                    set: function set(newLevel) {
                      __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].log(
                          'set startLevel:' + newLevel); // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel

                      if (newLevel !== -1) {
                        newLevel = Math.max(newLevel, this.minAutoLevel);
                      }

                      this.levelController.startLevel = newLevel;
                    },
                    /**
                     * set  dynamically set capLevelToPlayerSize against (`CapLevelController`)
                     *
                     * @type {boolean}
                     */

                  }, {
                    key: 'capLevelToPlayerSize',
                    set: function set(shouldStartCapping) {
                      var newCapLevelToPlayerSize = !!shouldStartCapping;

                      if (newCapLevelToPlayerSize !==
                          this.config.capLevelToPlayerSize) {
                        if (newCapLevelToPlayerSize) {
                          this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.
                        } else {
                          this.capLevelController.stopCapping();
                          this.autoLevelCapping = -1;
                          this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.
                        }

                        this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;
                      }
                    },
                    /**
                     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
                     * @type {number}
                     */

                  }, {
                    key: 'autoLevelCapping',
                    get: function get() {
                      return this._autoLevelCapping;
                    }
                    /**
                     * get bandwidth estimate
                     * @type {number}
                     */
                    ,

                    /**
                     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
                     * @type {number}
                     */
                    set: function set(newLevel) {
                      __WEBPACK_IMPORTED_MODULE_10__utils_logger__['b' /* logger */].log(
                          'set autoLevelCapping:' + newLevel);
                      this._autoLevelCapping = newLevel;
                    },
                    /**
                     * True when automatic level selection enabled
                     * @type {boolean}
                     */

                  }, {
                    key: 'bandwidthEstimate',
                    get: function get() {
                      var bwEstimator = this.abrController._bwEstimator;
                      return bwEstimator ? bwEstimator.getEstimate() : NaN;
                    },
                  }, {
                    key: 'autoLevelEnabled',
                    get: function get() {
                      return this.levelController.manualLevel === -1;
                    },
                    /**
                     * Level set manually (if any)
                     * @type {number}
                     */

                  }, {
                    key: 'manualLevel',
                    get: function get() {
                      return this.levelController.manualLevel;
                    },
                    /**
                     * min level selectable in auto mode according to config.minAutoBitrate
                     * @type {number}
                     */

                  }, {
                    key: 'minAutoLevel',
                    get: function get() {
                      var levels = this.levels,
                          minAutoBitrate = this.config.minAutoBitrate;
                      var len = levels ? levels.length : 0;

                      for (var i = 0; i < len; i++) {
                        var levelNextBitrate = levels[i].realBitrate
                            ? Math.max(levels[i].realBitrate, levels[i].bitrate)
                            : levels[i].bitrate;

                        if (levelNextBitrate > minAutoBitrate) {
                          return i;
                        }
                      }

                      return 0;
                    },
                    /**
                     * max level selectable in auto mode according to autoLevelCapping
                     * @type {number}
                     */

                  }, {
                    key: 'maxAutoLevel',
                    get: function get() {
                      var levels = this.levels,
                          autoLevelCapping = this.autoLevelCapping;
                      var maxAutoLevel;

                      if (autoLevelCapping === -1 && levels && levels.length) {
                        maxAutoLevel = levels.length - 1;
                      } else {
                        maxAutoLevel = autoLevelCapping;
                      }

                      return maxAutoLevel;
                    },
                    /**
                     * next automatically selected quality level
                     * @type {number}
                     */

                  }, {
                    key: 'nextAutoLevel',
                    get: function get() {
                      // ensure next auto level is between  min and max auto level
                      return Math.min(Math.max(this.abrController.nextAutoLevel,
                          this.minAutoLevel), this.maxAutoLevel);
                    }
                    /**
                     * this setter is used to force next auto level.
                     * this is useful to force a switch down in auto mode:
                     * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
                     * forced value is valid for one fragment. upon succesful frag loading at forced level,
                     * this value will be resetted to -1 by ABR controller.
                     * @type {number}
                     */
                    ,
                    set: function set(nextLevel) {
                      this.abrController.nextAutoLevel = Math.max(
                          this.minAutoLevel, nextLevel);
                    },
                    /**
                     * @type {AudioTrack[]}
                     */
                    // todo(typescript-audioTrackController)

                  }, {
                    key: 'audioTracks',
                    get: function get() {
                      var audioTrackController = this.audioTrackController;
                      return audioTrackController
                          ? audioTrackController.audioTracks
                          : [];
                    },
                    /**
                     * index of the selected audio track (index in audio track lists)
                     * @type {number}
                     */

                  }, {
                    key: 'audioTrack',
                    get: function get() {
                      var audioTrackController = this.audioTrackController;
                      return audioTrackController
                          ? audioTrackController.audioTrack
                          : -1;
                    }
                    /**
                     * selects an audio track, based on its index in audio track lists
                     * @type {number}
                     */
                    ,
                    set: function set(audioTrackId) {
                      var audioTrackController = this.audioTrackController;

                      if (audioTrackController) {
                        audioTrackController.audioTrack = audioTrackId;
                      }
                    },
                    /**
                     * @type {Seconds}
                     */

                  }, {
                    key: 'liveSyncPosition',
                    get: function get() {
                      return this.streamController.liveSyncPosition;
                    },
                    /**
                     * get alternate subtitle tracks list from playlist
                     * @type {SubtitleTrack[]}
                     */
                    // todo(typescript-subtitleTrackController)

                  }, {
                    key: 'subtitleTracks',
                    get: function get() {
                      var subtitleTrackController = this.subtitleTrackController;
                      return subtitleTrackController
                          ? subtitleTrackController.subtitleTracks
                          : [];
                    },
                    /**
                     * index of the selected subtitle track (index in subtitle track lists)
                     * @type {number}
                     */

                  }, {
                    key: 'subtitleTrack',
                    get: function get() {
                      var subtitleTrackController = this.subtitleTrackController;
                      return subtitleTrackController
                          ? subtitleTrackController.subtitleTrack
                          : -1;
                    }
                    /**
                     * select an subtitle track, based on its index in subtitle track lists
                     * @type {number}
                     */
                    ,
                    set: function set(subtitleTrackId) {
                      var subtitleTrackController = this.subtitleTrackController;

                      if (subtitleTrackController) {
                        subtitleTrackController.subtitleTrack = subtitleTrackId;
                      }
                    },
                    /**
                     * @type {boolean}
                     */

                  }, {
                    key: 'subtitleDisplay',
                    get: function get() {
                      var subtitleTrackController = this.subtitleTrackController;
                      return subtitleTrackController
                          ? subtitleTrackController.subtitleDisplay
                          : false;
                    }
                    /**
                     * Enable/disable subtitle display rendering
                     * @type {boolean}
                     */
                    ,
                    set: function set(value) {
                      var subtitleTrackController = this.subtitleTrackController;

                      if (subtitleTrackController) {
                        subtitleTrackController.subtitleDisplay = value;
                      }
                    },
                  }]);

                return Hls;
              }(__WEBPACK_IMPORTED_MODULE_13__observer__['a' /* Observer */]);

          Hls.defaultConfig = void 0;

          /***/
        }),
        /* 37 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__event_handler__ = __webpack_require__(
              4);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__types_loader__ = __webpack_require__(
              19);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_6__demux_mp4demuxer__ = __webpack_require__(
              20);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_7__m3u8_parser__ = __webpack_require__(
              38);

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /**
           * PlaylistLoader - delegate for media manifest/playlist loading tasks. Takes care of parsing media to internal data-models.
           *
           * Once loaded, dispatches events with parsed data-models of manifest/levels/audio/subtitle tracks.
           *
           * Uses loader(s) set in config to do actual internal loading of resource tasks.
           *
           * @module
           *
           */







          var _window = window,
              performance = _window.performance;
          /**
           * @constructor
           */

          var PlaylistLoader =
              /*#__PURE__*/
              function(_EventHandler) {
                _inheritsLoose(PlaylistLoader, _EventHandler);

                /**
                 * @constructs
                 * @param {Hls} hls
                 */
                function PlaylistLoader(hls) {
                  var _this;

                  _this = _EventHandler.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MANIFEST_LOADING,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].LEVEL_LOADING,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].AUDIO_TRACK_LOADING,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].SUBTITLE_TRACK_LOADING) ||
                      this;
                  _this.loaders = {};
                  return _this;
                }

                /**
                 * @param {PlaylistContextType} type
                 * @returns {boolean}
                 */

                PlaylistLoader.canHaveQualityLevels = function canHaveQualityLevels(type) {
                  return type !==
                      __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].AUDIO_TRACK &&
                      type !==
                      __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].SUBTITLE_TRACK;
                }
                /**
                 * Map context.type to LevelType
                 * @param {PlaylistLoaderContext} context
                 * @returns {LevelType}
                 */
                ;

                PlaylistLoader.mapContextToLevelType = function mapContextToLevelType(context) {
                  var type = context.type;

                  switch (type) {
                    case __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].AUDIO_TRACK:
                      return __WEBPACK_IMPORTED_MODULE_5__types_loader__['b' /* PlaylistLevelType */].AUDIO;

                    case __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].SUBTITLE_TRACK:
                      return __WEBPACK_IMPORTED_MODULE_5__types_loader__['b' /* PlaylistLevelType */].SUBTITLE;

                    default:
                      return __WEBPACK_IMPORTED_MODULE_5__types_loader__['b' /* PlaylistLevelType */].MAIN;
                  }
                };

                PlaylistLoader.getResponseUrl = function getResponseUrl(
                    response, context) {
                  var url = response.url; // responseURL not supported on some browsers (it is used to detect URL redirection)
                  // data-uri mode also not supported (but no need to detect redirection)

                  if (url === undefined || url.indexOf('data:') === 0) {
                    // fallback to initial URL
                    url = context.url;
                  }

                  return url;
                }
                /**
                 * Returns defaults or configured loader-type overloads (pLoader and loader config params)
                 * Default loader is XHRLoader (see utils)
                 * @param {PlaylistLoaderContext} context
                 * @returns {Loader} or other compatible configured overload
                 */
                ;

                var _proto = PlaylistLoader.prototype;

                _proto.createInternalLoader = function createInternalLoader(context) {
                  var config = this.hls.config;
                  var PLoader = config.pLoader;
                  var Loader = config.loader; // TODO(typescript-config): Verify once config is typed that InternalLoader always returns a Loader

                  var InternalLoader = PLoader || Loader;
                  var loader = new InternalLoader(config); // TODO - Do we really need to assign the instance or if the dep has been lost

                  context.loader = loader;
                  this.loaders[context.type] = loader;
                  return loader;
                };

                _proto.getInternalLoader = function getInternalLoader(context) {
                  return this.loaders[context.type];
                };

                _proto.resetInternalLoader = function resetInternalLoader(contextType) {
                  if (this.loaders[contextType]) {
                    delete this.loaders[contextType];
                  }
                }
                /**
                 * Call `destroy` on all internal loader instances mapped (one per context type)
                 */
                ;

                _proto.destroyInternalLoaders = function destroyInternalLoaders() {
                  for (var contextType in this.loaders) {
                    var loader = this.loaders[contextType];

                    if (loader) {
                      loader.destroy();
                    }

                    this.resetInternalLoader(contextType);
                  }
                };

                _proto.destroy = function destroy() {
                  this.destroyInternalLoaders();

                  _EventHandler.prototype.destroy.call(this);
                };

                _proto.onManifestLoading = function onManifestLoading(data) {
                  this.load({
                    url: data.url,
                    type: __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].MANIFEST,
                    level: 0,
                    id: null,
                    responseType: 'text',
                  });
                };

                _proto.onLevelLoading = function onLevelLoading(data) {
                  this.load({
                    url: data.url,
                    type: __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].LEVEL,
                    level: data.level,
                    id: data.id,
                    responseType: 'text',
                  });
                };

                _proto.onAudioTrackLoading = function onAudioTrackLoading(data) {
                  this.load({
                    url: data.url,
                    type: __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].AUDIO_TRACK,
                    level: null,
                    id: data.id,
                    responseType: 'text',
                  });
                };

                _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(data) {
                  this.load({
                    url: data.url,
                    type: __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].SUBTITLE_TRACK,
                    level: null,
                    id: data.id,
                    responseType: 'text',
                  });
                };

                _proto.load = function load(context) {
                  var config = this.hls.config;
                  __WEBPACK_IMPORTED_MODULE_4__utils_logger__['b' /* logger */].debug(
                      'Loading playlist of type ' + context.type + ', level: ' +
                      context.level + ', id: ' + context.id); // Check if a loader for this context already exists

                  var loader = this.getInternalLoader(context);

                  if (loader) {
                    var loaderContext = loader.context;

                    if (loaderContext && loaderContext.url === context.url) {
                      // same URL can't overlap
                      __WEBPACK_IMPORTED_MODULE_4__utils_logger__['b' /* logger */].trace(
                          'playlist request ongoing');
                      return false;
                    } else {
                      __WEBPACK_IMPORTED_MODULE_4__utils_logger__['b' /* logger */].warn(
                          'aborting previous loader for type: ' + context.type);
                      loader.abort();
                    }
                  }

                  var maxRetry;
                  var timeout;
                  var retryDelay;
                  var maxRetryDelay; // apply different configs for retries depending on
                  // context (manifest, level, audio/subs playlist)

                  switch (context.type) {
                    case __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].MANIFEST:
                      maxRetry = config.manifestLoadingMaxRetry;
                      timeout = config.manifestLoadingTimeOut;
                      retryDelay = config.manifestLoadingRetryDelay;
                      maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
                      break;

                    case __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].LEVEL:
                      // Disable internal loader retry logic, since we are managing retries in Level Controller
                      maxRetry = 0;
                      maxRetryDelay = 0;
                      retryDelay = 0;
                      timeout = config.levelLoadingTimeOut; // TODO Introduce retry settings for audio-track and subtitle-track, it should not use level retry config

                      break;

                    default:
                      maxRetry = config.levelLoadingMaxRetry;
                      timeout = config.levelLoadingTimeOut;
                      retryDelay = config.levelLoadingRetryDelay;
                      maxRetryDelay = config.levelLoadingMaxRetryTimeout;
                      break;
                  }

                  loader = this.createInternalLoader(context);
                  var loaderConfig = {
                    timeout: timeout,
                    maxRetry: maxRetry,
                    retryDelay: retryDelay,
                    maxRetryDelay: maxRetryDelay,
                  };
                  var loaderCallbacks = {
                    onSuccess: this.loadsuccess.bind(this),
                    onError: this.loaderror.bind(this),
                    onTimeout: this.loadtimeout.bind(this),
                  };
                  __WEBPACK_IMPORTED_MODULE_4__utils_logger__['b' /* logger */].debug(
                      'Calling internal loader delegate for URL: ' +
                      context.url);
                  loader.load(context, loaderConfig, loaderCallbacks);
                  return true;
                };

                _proto.loadsuccess = function loadsuccess(
                    response, stats, context, networkDetails) {
                  if (networkDetails === void 0) {
                    networkDetails = null;
                  }

                  if (context.isSidxRequest) {
                    this._handleSidxRequest(response, context);

                    this._handlePlaylistLoaded(response, stats, context,
                        networkDetails);

                    return;
                  }

                  this.resetInternalLoader(context.type);

                  if (typeof response.data !== 'string') {
                    throw new Error(
                        'expected responseType of "text" for PlaylistLoader');
                  }

                  var string = response.data;
                  stats.tload = performance.now(); // stats.mtime = new Date(target.getResponseHeader('Last-Modified'));
                  // Validate if it is an M3U8 at all

                  if (string.indexOf('#EXTM3U') !== 0) {
                    this._handleManifestParsingError(response, context,
                        'no EXTM3U delimiter', networkDetails);

                    return;
                  } // Check if chunk-list or master. handle empty chunk list case (first EXTINF not signaled, but TARGETDURATION present)

                  if (string.indexOf('#EXTINF:') > 0 ||
                      string.indexOf('#EXT-X-TARGETDURATION:') > 0) {
                    this._handleTrackOrLevelPlaylist(response, stats, context,
                        networkDetails);
                  } else {
                    this._handleMasterPlaylist(response, stats, context,
                        networkDetails);
                  }
                };

                _proto.loaderror = function loaderror(
                    response, context, networkDetails) {
                  if (networkDetails === void 0) {
                    networkDetails = null;
                  }

                  this._handleNetworkError(context, networkDetails, false,
                      response);
                };

                _proto.loadtimeout = function loadtimeout(
                    stats, context, networkDetails) {
                  if (networkDetails === void 0) {
                    networkDetails = null;
                  }

                  this._handleNetworkError(context, networkDetails, true);
                } // TODO(typescript-config): networkDetails can currently be a XHR or Fetch impl,
                // but with custom loaders it could be generic investigate this further when config is typed
                ;

                _proto._handleMasterPlaylist = function _handleMasterPlaylist(
                    response, stats, context, networkDetails) {
                  var hls = this.hls;
                  var string = response.data;
                  var url = PlaylistLoader.getResponseUrl(response, context);
                  var levels = __WEBPACK_IMPORTED_MODULE_7__m3u8_parser__['a' /* default */].parseMasterPlaylist(
                      string, url);

                  if (!levels.length) {
                    this._handleManifestParsingError(response, context,
                        'no level found in manifest', networkDetails);

                    return;
                  } // multi level playlist, parse level info

                  var audioGroups = levels.map(function(level) {
                    return {
                      id: level.attrs.AUDIO,
                      codec: level.audioCodec,
                    };
                  });
                  var audioTracks = __WEBPACK_IMPORTED_MODULE_7__m3u8_parser__['a' /* default */].parseMasterPlaylistMedia(
                      string, url, 'AUDIO', audioGroups);
                  var subtitles = __WEBPACK_IMPORTED_MODULE_7__m3u8_parser__['a' /* default */].parseMasterPlaylistMedia(
                      string, url, 'SUBTITLES');

                  if (audioTracks.length) {
                    // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
                    var embeddedAudioFound = false;
                    audioTracks.forEach(function(audioTrack) {
                      if (!audioTrack.url) {
                        embeddedAudioFound = true;
                      }
                    }); // if no embedded audio track defined, but audio codec signaled in quality level,
                    // we need to signal this main audio track this could happen with playlists with
                    // alt audio rendition in which quality levels (main)
                    // contains both audio+video. but with mixed audio track not signaled

                    if (embeddedAudioFound === false && levels[0].audioCodec &&
                        !levels[0].attrs.AUDIO) {
                      __WEBPACK_IMPORTED_MODULE_4__utils_logger__['b' /* logger */].log(
                          'audio codec signaled in quality level, but no embedded audio track signaled, create one');
                      audioTracks.unshift({
                        type: 'main',
                        name: 'main',
                        default: false,
                        autoselect: false,
                        forced: false,
                        id: -1,
                      });
                    }
                  }

                  hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MANIFEST_LOADED,
                      {
                        levels: levels,
                        audioTracks: audioTracks,
                        subtitles: subtitles,
                        url: url,
                        stats: stats,
                        networkDetails: networkDetails,
                      });
                };

                _proto._handleTrackOrLevelPlaylist = function _handleTrackOrLevelPlaylist(
                    response, stats, context, networkDetails) {
                  var hls = this.hls;
                  var id = context.id,
                      level = context.level,
                      type = context.type;
                  var url = PlaylistLoader.getResponseUrl(response, context); // if the values are null, they will result in the else conditional

                  var levelUrlId = Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      id) ? id : 0;
                  var levelId = Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      level) ? level : levelUrlId;
                  var levelType = PlaylistLoader.mapContextToLevelType(context);
                  var levelDetails = __WEBPACK_IMPORTED_MODULE_7__m3u8_parser__['a' /* default */].parseLevelPlaylist(
                      response.data, url, levelId, levelType, levelUrlId); // set stats on level structure
                  // TODO(jstackhouse): why? mixing concerns, is it just treated as value bag?

                  levelDetails.tload = stats.tload; // We have done our first request (Manifest-type) and receive
                  // not a master playlist but a chunk-list (track/level)
                  // We fire the manifest-loaded event anyway with the parsed level-details
                  // by creating a single-level structure for it.

                  if (type ===
                      __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].MANIFEST) {
                    var singleLevel = {
                      url: url,
                      details: levelDetails,
                    };
                    hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MANIFEST_LOADED,
                        {
                          levels: [singleLevel],
                          audioTracks: [],
                          url: url,
                          stats: stats,
                          networkDetails: networkDetails,
                        });
                  } // save parsing time

                  stats.tparsed = performance.now(); // in case we need SIDX ranges
                  // return early after calling load for
                  // the SIDX box.

                  if (levelDetails.needSidxRanges) {
                    var sidxUrl = levelDetails.initSegment.url;
                    this.load({
                      url: sidxUrl,
                      isSidxRequest: true,
                      type: type,
                      level: level,
                      levelDetails: levelDetails,
                      id: id,
                      rangeStart: 0,
                      rangeEnd: 2048,
                      responseType: 'arraybuffer',
                    });
                    return;
                  } // extend the context with the new levelDetails property

                  context.levelDetails = levelDetails;

                  this._handlePlaylistLoaded(response, stats, context,
                      networkDetails);
                };

                _proto._handleSidxRequest = function _handleSidxRequest(
                    response, context) {
                  if (typeof response.data === 'string') {
                    throw new Error(
                        'sidx request must be made with responseType of array buffer');
                  }

                  var sidxInfo = __WEBPACK_IMPORTED_MODULE_6__demux_mp4demuxer__['a' /* default */].parseSegmentIndex(
                      new Uint8Array(response.data)); // if provided fragment does not contain sidx, early return

                  if (!sidxInfo) {
                    return;
                  }

                  var sidxReferences = sidxInfo.references;
                  var levelDetails = context.levelDetails;
                  sidxReferences.forEach(function(segmentRef, index) {
                    var segRefInfo = segmentRef.info;

                    if (!levelDetails) {
                      return;
                    }

                    var frag = levelDetails.fragments[index];

                    if (frag.byteRange.length === 0) {
                      frag.setByteRange(
                          String(1 + segRefInfo.end - segRefInfo.start) + '@' +
                          String(segRefInfo.start));
                    }
                  });

                  if (levelDetails) {
                    levelDetails.initSegment.setByteRange(
                        String(sidxInfo.moovEndOffset) + '@0');
                  }
                };

                _proto._handleManifestParsingError = function _handleManifestParsingError(
                    response, context, reason, networkDetails) {
                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                      {
                        type: __WEBPACK_IMPORTED_MODULE_3__errors__['b' /* ErrorTypes */].NETWORK_ERROR,
                        details: __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].MANIFEST_PARSING_ERROR,
                        fatal: true,
                        url: response.url,
                        reason: reason,
                        networkDetails: networkDetails,
                      });
                };

                _proto._handleNetworkError = function _handleNetworkError(
                    context, networkDetails, timeout, response) {
                  if (timeout === void 0) {
                    timeout = false;
                  }

                  if (response === void 0) {
                    response = null;
                  }

                  __WEBPACK_IMPORTED_MODULE_4__utils_logger__['b' /* logger */].info(
                      'A network error occured while loading a ' +
                      context.type + '-type playlist');
                  var details;
                  var fatal;
                  var loader = this.getInternalLoader(context);

                  switch (context.type) {
                    case __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].MANIFEST:
                      details = timeout
                          ? __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].MANIFEST_LOAD_TIMEOUT
                          : __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].MANIFEST_LOAD_ERROR;
                      fatal = true;
                      break;

                    case __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].LEVEL:
                      details = timeout
                          ? __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].LEVEL_LOAD_TIMEOUT
                          : __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].LEVEL_LOAD_ERROR;
                      fatal = false;
                      break;

                    case __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].AUDIO_TRACK:
                      details = timeout
                          ? __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].AUDIO_TRACK_LOAD_TIMEOUT
                          : __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].AUDIO_TRACK_LOAD_ERROR;
                      fatal = false;
                      break;

                    default:
                      // details = ...?
                      fatal = false;
                  }

                  if (loader) {
                    loader.abort();
                    this.resetInternalLoader(context.type);
                  } // TODO(typescript-events): when error events are handled, type this

                  var errorData = {
                    type: __WEBPACK_IMPORTED_MODULE_3__errors__['b' /* ErrorTypes */].NETWORK_ERROR,
                    details: details,
                    fatal: fatal,
                    url: context.url,
                    loader: loader,
                    context: context,
                    networkDetails: networkDetails,
                  };

                  if (response) {
                    errorData.response = response;
                  }

                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                      errorData);
                };

                _proto._handlePlaylistLoaded = function _handlePlaylistLoaded(
                    response, stats, context, networkDetails) {
                  var type = context.type,
                      level = context.level,
                      id = context.id,
                      levelDetails = context.levelDetails;

                  if (!levelDetails || !levelDetails.targetduration) {
                    this._handleManifestParsingError(response, context,
                        'invalid target duration', networkDetails);

                    return;
                  }

                  var canHaveLevels = PlaylistLoader.canHaveQualityLevels(
                      context.type);

                  if (canHaveLevels) {
                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].LEVEL_LOADED,
                        {
                          details: levelDetails,
                          level: level || 0,
                          id: id || 0,
                          stats: stats,
                          networkDetails: networkDetails,
                        });
                  } else {
                    switch (type) {
                      case __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].AUDIO_TRACK:
                        this.hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].AUDIO_TRACK_LOADED,
                            {
                              details: levelDetails,
                              id: id,
                              stats: stats,
                              networkDetails: networkDetails,
                            });
                        break;

                      case __WEBPACK_IMPORTED_MODULE_5__types_loader__['a' /* PlaylistContextType */].SUBTITLE_TRACK:
                        this.hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].SUBTITLE_TRACK_LOADED,
                            {
                              details: levelDetails,
                              id: id,
                              stats: stats,
                              networkDetails: networkDetails,
                            });
                        break;
                    }
                  }
                };

                return PlaylistLoader;
              }(__WEBPACK_IMPORTED_MODULE_2__event_handler__['a' /* default */]);

          /* harmony default export */
          __webpack_exports__['a'] = (PlaylistLoader);

          /***/
        }),
        /* 38 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return M3U8Parser; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1_url_toolkit__ = __webpack_require__(
              10);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1_url_toolkit___default = __webpack_require__.n(
              __WEBPACK_IMPORTED_MODULE_1_url_toolkit__);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__fragment__ = __webpack_require__(13);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__level__ = __webpack_require__(39);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__level_key__ = __webpack_require__(
              21);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__utils_attr_list__ = __webpack_require__(
              40);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_6__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_7__utils_codecs__ = __webpack_require__(
              22);

          /**
           * M3U8 parser
           * @module
           */
// https://regex101.com is your friend
          var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
          var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
          var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([
            /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
            /|(?!#)([\S+ ?]+)/.source, // segment URI, group 3 => the URI (note newline is not eaten)
            /|#EXT-X-BYTERANGE:*(.+)/.source, // next segment's byterange, group 4 => range spec (x@y)
            /|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, // next segment's program date/time group 5 => the datetime spec
            /|#.*/.source, // All other non-segment oriented tags will match with all groups empty
          ].join(''), 'g');
          var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;
          var MP4_REGEX_SUFFIX = /\.(mp4|m4s|m4v|m4a)$/i;

          var M3U8Parser =
              /*#__PURE__*/
              function() {
                function M3U8Parser() {}

                M3U8Parser.findGroup = function findGroup(
                    groups, mediaGroupId) {
                  for (var i = 0; i < groups.length; i++) {
                    var group = groups[i];

                    if (group.id === mediaGroupId) {
                      return group;
                    }
                  }
                };

                M3U8Parser.convertAVC1ToAVCOTI = function convertAVC1ToAVCOTI(codec) {
                  var avcdata = codec.split('.');
                  var result;

                  if (avcdata.length > 2) {
                    result = avcdata.shift() + '.';
                    result += parseInt(avcdata.shift()).toString(16);
                    result += ('000' +
                        parseInt(avcdata.shift()).toString(16)).substr(-4);
                  } else {
                    result = codec;
                  }

                  return result;
                };

                M3U8Parser.resolve = function resolve(url, baseUrl) {
                  return __WEBPACK_IMPORTED_MODULE_1_url_toolkit__['buildAbsoluteURL'](
                      baseUrl, url, {
                        alwaysNormalize: true,
                      });
                };

                M3U8Parser.parseMasterPlaylist = function parseMasterPlaylist(
                    string, baseurl) {
                  // TODO(typescript-level)
                  var levels = [];
                  MASTER_PLAYLIST_REGEX.lastIndex = 0; // TODO(typescript-level)

                  function setCodecs(codecs, level) {
                    ['video', 'audio'].forEach(function(type) {
                      var filtered = codecs.filter(function(codec) {
                        return Object(
                            __WEBPACK_IMPORTED_MODULE_7__utils_codecs__['b' /* isCodecType */])(
                            codec, type);
                      });

                      if (filtered.length) {
                        var preferred = filtered.filter(function(codec) {
                          return codec.lastIndexOf('avc1', 0) === 0 ||
                              codec.lastIndexOf('mp4a', 0) === 0;
                        });
                        level[type + 'Codec'] = preferred.length > 0
                            ? preferred[0]
                            : filtered[0]; // remove from list

                        codecs = codecs.filter(function(codec) {
                          return filtered.indexOf(codec) === -1;
                        });
                      }
                    });
                    level.unknownCodecs = codecs;
                  }

                  var result;

                  while ((result = MASTER_PLAYLIST_REGEX.exec(string)) !=
                  null) {
                    // TODO(typescript-level)
                    var level = {};
                    var attrs = level.attrs = new __WEBPACK_IMPORTED_MODULE_5__utils_attr_list__['a' /* default */](
                        result[1]);
                    level.url = M3U8Parser.resolve(result[2], baseurl);
                    var resolution = attrs.decimalResolution('RESOLUTION');

                    if (resolution) {
                      level.width = resolution.width;
                      level.height = resolution.height;
                    }

                    level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') ||
                        attrs.decimalInteger('BANDWIDTH');
                    level.name = attrs.NAME;
                    setCodecs([].concat((attrs.CODECS || '').split(/[ ,]+/)),
                        level);

                    if (level.videoCodec && level.videoCodec.indexOf('avc1') !==
                        -1) {
                      level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(
                          level.videoCodec);
                    }

                    levels.push(level);
                  }

                  return levels;
                };

                M3U8Parser.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(
                    string, baseurl, type, audioGroups) {
                  if (audioGroups === void 0) {
                    audioGroups = [];
                  }

                  var result;
                  var medias = [];
                  var id = 0;
                  MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;

                  while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !==
                  null) {
                    var attrs = new __WEBPACK_IMPORTED_MODULE_5__utils_attr_list__['a' /* default */](
                        result[1]);

                    if (attrs.TYPE === type) {
                      var media = {
                        id: id++,
                        groupId: attrs['GROUP-ID'],
                        name: attrs.NAME || attrs.LANGUAGE,
                        type: type,
                        default: attrs.DEFAULT === 'YES',
                        autoselect: attrs.AUTOSELECT === 'YES',
                        forced: attrs.FORCED === 'YES',
                        lang: attrs.LANGUAGE,
                      };

                      if (attrs.URI) {
                        media.url = M3U8Parser.resolve(attrs.URI, baseurl);
                      }

                      if (audioGroups.length) {
                        // If there are audio groups signalled in the manifest, let's look for a matching codec string for this track
                        var groupCodec = M3U8Parser.findGroup(audioGroups,
                            media.groupId); // If we don't find the track signalled, lets use the first audio groups codec we have
                        // Acting as a best guess

                        media.audioCodec = groupCodec
                            ? groupCodec.codec
                            : audioGroups[0].codec;
                      }

                      medias.push(media);
                    }
                  }

                  return medias;
                };

                M3U8Parser.parseLevelPlaylist = function parseLevelPlaylist(
                    string, baseurl, id, type, levelUrlId) {
                  var currentSN = 0;
                  var totalduration = 0;
                  var level = new __WEBPACK_IMPORTED_MODULE_3__level__['a' /* default */](
                      baseurl);
                  var discontinuityCounter = 0;
                  var prevFrag = null;
                  var frag = new __WEBPACK_IMPORTED_MODULE_2__fragment__['b' /* default */]();
                  var result;
                  var i;
                  var levelkey;
                  var firstPdtIndex = null;
                  LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;

                  while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !==
                  null) {
                    var duration = result[1];

                    if (duration) {
                      // INF
                      frag.duration = parseFloat(duration); // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939

                      var title = (' ' + result[2]).slice(1);
                      frag.title = title || null;
                      frag.tagList.push(
                          title ? ['INF', duration, title] : ['INF', duration]);
                    } else if (result[3]) {
                      // url
                      if (Object(
                          __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                          frag.duration)) {
                        var sn = currentSN++;
                        frag.type = type;
                        frag.start = totalduration;

                        if (levelkey) {
                          frag.levelkey = levelkey;
                        }

                        frag.sn = sn;
                        frag.level = id;
                        frag.cc = discontinuityCounter;
                        frag.urlId = levelUrlId;
                        frag.baseurl = baseurl; // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939

                        frag.relurl = (' ' + result[3]).slice(1);
                        assignProgramDateTime(frag, prevFrag);
                        level.fragments.push(frag);
                        prevFrag = frag;
                        totalduration += frag.duration;
                        frag = new __WEBPACK_IMPORTED_MODULE_2__fragment__['b' /* default */]();
                      }
                    } else if (result[4]) {
                      // X-BYTERANGE
                      var data = (' ' + result[4]).slice(1);

                      if (prevFrag) {
                        frag.setByteRange(data, prevFrag);
                      } else {
                        frag.setByteRange(data);
                      }
                    } else if (result[5]) {
                      // PROGRAM-DATE-TIME
                      // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
                      frag.rawProgramDateTime = (' ' + result[5]).slice(1);
                      frag.tagList.push(
                          ['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);

                      if (firstPdtIndex === null) {
                        firstPdtIndex = level.fragments.length;
                      }
                    } else {
                      result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);

                      if (!result) {
                        __WEBPACK_IMPORTED_MODULE_6__utils_logger__['b' /* logger */].warn(
                            'No matches on slow regex match for level playlist!');
                        continue;
                      }

                      for (i = 1; i < result.length; i++) {
                        if (typeof result[i] !== 'undefined') {
                          break;
                        }
                      } // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939

                      var value1 = (' ' + result[i + 1]).slice(1);
                      var value2 = (' ' + result[i + 2]).slice(1);

                      switch (result[i]) {
                        case '#':
                          frag.tagList.push(
                              value2 ? [value1, value2] : [value1]);
                          break;

                        case 'PLAYLIST-TYPE':
                          level.type = value1.toUpperCase();
                          break;

                        case 'MEDIA-SEQUENCE':
                          currentSN = level.startSN = parseInt(value1);
                          break;

                        case 'TARGETDURATION':
                          level.targetduration = parseFloat(value1);
                          break;

                        case 'VERSION':
                          level.version = parseInt(value1);
                          break;

                        case 'EXTM3U':
                          break;

                        case 'ENDLIST':
                          level.live = false;
                          break;

                        case 'DIS':
                          discontinuityCounter++;
                          frag.tagList.push(['DIS']);
                          break;

                        case 'DISCONTINUITY-SEQ':
                          discontinuityCounter = parseInt(value1);
                          break;

                        case 'KEY': {
                          // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
                          var decryptparams = value1;
                          var keyAttrs = new __WEBPACK_IMPORTED_MODULE_5__utils_attr_list__['a' /* default */](
                              decryptparams);
                          var decryptmethod = keyAttrs.enumeratedString(
                              'METHOD');
                          var decrypturi = keyAttrs.URI;
                          var decryptiv = keyAttrs.hexadecimalInteger('IV');

                          if (decryptmethod) {
                            levelkey = new __WEBPACK_IMPORTED_MODULE_4__level_key__['a' /* default */](
                                baseurl, decrypturi);

                            if (decrypturi && [
                              'AES-128',
                              'SAMPLE-AES',
                              'SAMPLE-AES-CENC'].indexOf(decryptmethod) >= 0) {
                              levelkey.method = decryptmethod;
                              levelkey.key = null; // Initialization Vector (IV)

                              levelkey.iv = decryptiv;
                            }
                          }

                          break;
                        }

                        case 'START': {
                          var startAttrs = new __WEBPACK_IMPORTED_MODULE_5__utils_attr_list__['a' /* default */](
                              value1);
                          var startTimeOffset = startAttrs.decimalFloatingPoint(
                              'TIME-OFFSET'); // TIME-OFFSET can be 0

                          if (Object(
                              __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                              startTimeOffset)) {
                            level.startTimeOffset = startTimeOffset;
                          }

                          break;
                        }

                        case 'MAP': {
                          var mapAttrs = new __WEBPACK_IMPORTED_MODULE_5__utils_attr_list__['a' /* default */](
                              value1);
                          frag.relurl = mapAttrs.URI;

                          if (mapAttrs.BYTERANGE) {
                            frag.setByteRange(mapAttrs.BYTERANGE);
                          }

                          frag.baseurl = baseurl;
                          frag.level = id;
                          frag.type = type;
                          frag.sn = 'initSegment';
                          level.initSegment = frag;
                          frag = new __WEBPACK_IMPORTED_MODULE_2__fragment__['b' /* default */]();
                          frag.rawProgramDateTime = level.initSegment.rawProgramDateTime;
                          break;
                        }

                        default:
                          __WEBPACK_IMPORTED_MODULE_6__utils_logger__['b' /* logger */].warn(
                              'line parsed but not handled: ' + result);
                          break;
                      }
                    }
                  }

                  frag = prevFrag; // logger.log('found ' + level.fragments.length + ' fragments');

                  if (frag && !frag.relurl) {
                    level.fragments.pop();
                    totalduration -= frag.duration;
                  }

                  level.totalduration = totalduration;
                  level.averagetargetduration = totalduration /
                      level.fragments.length;
                  level.endSN = currentSN - 1;
                  level.startCC = level.fragments[0]
                      ? level.fragments[0].cc
                      : 0;
                  level.endCC = discontinuityCounter;

                  if (!level.initSegment && level.fragments.length) {
                    // this is a bit lurky but HLS really has no other way to tell us
                    // if the fragments are TS or MP4, except if we download them :/
                    // but this is to be able to handle SIDX.
                    if (level.fragments.every(function(frag) {
                      return MP4_REGEX_SUFFIX.test(frag.relurl);
                    })) {
                      __WEBPACK_IMPORTED_MODULE_6__utils_logger__['b' /* logger */].warn(
                          'MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX');
                      frag = new __WEBPACK_IMPORTED_MODULE_2__fragment__['b' /* default */]();
                      frag.relurl = level.fragments[0].relurl;
                      frag.baseurl = baseurl;
                      frag.level = id;
                      frag.type = type;
                      frag.sn = 'initSegment';
                      level.initSegment = frag;
                      level.needSidxRanges = true;
                    }
                  }
                  /**
                   * Backfill any missing PDT values
                   "If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after
                   one or more Media Segment URIs, the client SHOULD extrapolate
                   backward from that tag (using EXTINF durations and/or media
                   timestamps) to associate dates with those segments."
                   * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs
                   * computed.
                   */

                  if (firstPdtIndex) {
                    backfillProgramDateTimes(level.fragments, firstPdtIndex);
                  }

                  return level;
                };

                return M3U8Parser;
              }();

          function backfillProgramDateTimes(fragments, startIndex) {
            var fragPrev = fragments[startIndex];

            for (var i = startIndex - 1; i >= 0; i--) {
              var frag = fragments[i];
              frag.programDateTime = fragPrev.programDateTime - frag.duration *
                  1000;
              fragPrev = frag;
            }
          }

          function assignProgramDateTime(frag, prevFrag) {
            if (frag.rawProgramDateTime) {
              frag.programDateTime = Date.parse(frag.rawProgramDateTime);
            } else if (prevFrag && prevFrag.programDateTime) {
              frag.programDateTime = prevFrag.endProgramDateTime;
            }

            if (!Object(
                __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                frag.programDateTime)) {
              frag.programDateTime = null;
              frag.rawProgramDateTime = null;
            }
          }

          /***/
        }),
        /* 39 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return Level; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(
              Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype,
                protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          var Level =
              /*#__PURE__*/
              function() {
                function Level(baseUrl) {
                  // Please keep properties in alphabetical order
                  this.endCC = 0;
                  this.endSN = 0;
                  this.fragments = [];
                  this.initSegment = null;
                  this.live = true;
                  this.needSidxRanges = false;
                  this.startCC = 0;
                  this.startSN = 0;
                  this.startTimeOffset = null;
                  this.targetduration = 0;
                  this.totalduration = 0;
                  this.type = null;
                  this.url = baseUrl;
                  this.version = null;
                }

                _createClass(Level, [
                  {
                    key: 'hasProgramDateTime',
                    get: function get() {
                      return !!(this.fragments[0] && Object(
                          __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                          this.fragments[0].programDateTime));
                    },
                  }]);

                return Level;
              }();

          /***/
        }),
        /* 40 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/; // eslint-disable-line no-useless-escape

          var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g; // eslint-disable-line no-useless-escape
// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js

          var AttrList =
              /*#__PURE__*/
              function() {
                function AttrList(attrs) {
                  if (typeof attrs === 'string') {
                    attrs = AttrList.parseAttrList(attrs);
                  }

                  for (var attr in attrs) {
                    if (attrs.hasOwnProperty(attr)) {
                      this[attr] = attrs[attr];
                    }
                  }
                }

                var _proto = AttrList.prototype;

                _proto.decimalInteger = function decimalInteger(attrName) {
                  var intValue = parseInt(this[attrName], 10);

                  if (intValue > Number.MAX_SAFE_INTEGER) {
                    return Infinity;
                  }

                  return intValue;
                };

                _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {
                  if (this[attrName]) {
                    var stringValue = (this[attrName] || '0x').slice(2);
                    stringValue = (stringValue.length & 1 ? '0' : '') +
                        stringValue;
                    var value = new Uint8Array(stringValue.length / 2);

                    for (var i = 0; i < stringValue.length / 2; i++) {
                      value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2),
                          16);
                    }

                    return value;
                  } else {
                    return null;
                  }
                };

                _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {
                  var intValue = parseInt(this[attrName], 16);

                  if (intValue > Number.MAX_SAFE_INTEGER) {
                    return Infinity;
                  }

                  return intValue;
                };

                _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {
                  return parseFloat(this[attrName]);
                };

                _proto.enumeratedString = function enumeratedString(attrName) {
                  return this[attrName];
                };

                _proto.decimalResolution = function decimalResolution(attrName) {
                  var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);

                  if (res === null) {
                    return undefined;
                  }

                  return {
                    width: parseInt(res[1], 10),
                    height: parseInt(res[2], 10),
                  };
                };

                AttrList.parseAttrList = function parseAttrList(input) {
                  var match,
                      attrs = {};
                  ATTR_LIST_REGEX.lastIndex = 0;

                  while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
                    var value = match[2],
                        quote = '"';

                    if (value.indexOf(quote) === 0 &&
                        value.lastIndexOf(quote) === value.length - 1) {
                      value = value.slice(1, -1);
                    }

                    attrs[match[1]] = value;
                  }

                  return attrs;
                };

                return AttrList;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (AttrList);

          /***/
        }),
        /* 41 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__event_handler__ = __webpack_require__(
              4);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__utils_logger__ = __webpack_require__(
              1);

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /*
 * Fragment Loader
*/

          var FragmentLoader =
              /*#__PURE__*/
              function(_EventHandler) {
                _inheritsLoose(FragmentLoader, _EventHandler);

                function FragmentLoader(hls) {
                  var _this;

                  _this = _EventHandler.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_LOADING) ||
                      this;
                  _this.loaders = {};
                  return _this;
                }

                var _proto = FragmentLoader.prototype;

                _proto.destroy = function destroy() {
                  var loaders = this.loaders;

                  for (var loaderName in loaders) {
                    var loader = loaders[loaderName];

                    if (loader) {
                      loader.destroy();
                    }
                  }

                  this.loaders = {};

                  _EventHandler.prototype.destroy.call(this);
                };

                _proto.onFragLoading = function onFragLoading(data) {
                  var frag = data.frag,
                      type = frag.type,
                      loaders = this.loaders,
                      config = this.hls.config,
                      FragmentILoader = config.fLoader,
                      DefaultILoader = config.loader; // reset fragment state

                  frag.loaded = 0;
                  var loader = loaders[type];

                  if (loader) {
                    __WEBPACK_IMPORTED_MODULE_4__utils_logger__['b' /* logger */].warn(
                        'abort previous fragment loader for type: ' + type);
                    loader.abort();
                  }

                  loader = loaders[type] = frag.loader = config.fLoader
                      ? new FragmentILoader(config)
                      : new DefaultILoader(config);
                  var loaderContext, loaderConfig, loaderCallbacks;
                  loaderContext = {
                    url: frag.url,
                    frag: frag,
                    responseType: 'arraybuffer',
                    progressData: false,
                  };
                  var start = frag.byteRangeStartOffset,
                      end = frag.byteRangeEndOffset;

                  if (Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      start) && Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      end)) {
                    loaderContext.rangeStart = start;
                    loaderContext.rangeEnd = end;
                  }

                  loaderConfig = {
                    timeout: config.fragLoadingTimeOut,
                    maxRetry: 0,
                    retryDelay: 0,
                    maxRetryDelay: config.fragLoadingMaxRetryTimeout,
                  };
                  loaderCallbacks = {
                    onSuccess: this.loadsuccess.bind(this),
                    onError: this.loaderror.bind(this),
                    onTimeout: this.loadtimeout.bind(this),
                    onProgress: this.loadprogress.bind(this),
                  };
                  loader.load(loaderContext, loaderConfig, loaderCallbacks);
                };

                _proto.loadsuccess = function loadsuccess(
                    response, stats, context, networkDetails) {
                  if (networkDetails === void 0) {
                    networkDetails = null;
                  }

                  var payload = response.data,
                      frag = context.frag; // detach fragment loader on load success

                  frag.loader = undefined;
                  this.loaders[frag.type] = undefined;
                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_LOADED,
                      {
                        payload: payload,
                        frag: frag,
                        stats: stats,
                        networkDetails: networkDetails,
                      });
                };

                _proto.loaderror = function loaderror(
                    response, context, networkDetails) {
                  if (networkDetails === void 0) {
                    networkDetails = null;
                  }

                  var frag = context.frag;
                  var loader = frag.loader;

                  if (loader) {
                    loader.abort();
                  }

                  this.loaders[frag.type] = undefined;
                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                      {
                        type: __WEBPACK_IMPORTED_MODULE_3__errors__['b' /* ErrorTypes */].NETWORK_ERROR,
                        details: __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].FRAG_LOAD_ERROR,
                        fatal: false,
                        frag: context.frag,
                        response: response,
                        networkDetails: networkDetails,
                      });
                };

                _proto.loadtimeout = function loadtimeout(
                    stats, context, networkDetails) {
                  if (networkDetails === void 0) {
                    networkDetails = null;
                  }

                  var frag = context.frag;
                  var loader = frag.loader;

                  if (loader) {
                    loader.abort();
                  }

                  this.loaders[frag.type] = undefined;
                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                      {
                        type: __WEBPACK_IMPORTED_MODULE_3__errors__['b' /* ErrorTypes */].NETWORK_ERROR,
                        details: __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].FRAG_LOAD_TIMEOUT,
                        fatal: false,
                        frag: context.frag,
                        networkDetails: networkDetails,
                      });
                } // data will be used for progressive parsing
                ;

                _proto.loadprogress = function loadprogress(
                    stats, context, data, networkDetails) {
                  if (networkDetails === void 0) {
                    networkDetails = null;
                  }

                  // jshint ignore:line
                  var frag = context.frag;
                  frag.loaded = stats.loaded;
                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_LOAD_PROGRESS,
                      {
                        frag: frag,
                        stats: stats,
                        networkDetails: networkDetails,
                      });
                };

                return FragmentLoader;
              }(__WEBPACK_IMPORTED_MODULE_2__event_handler__['a' /* default */]);

          /* harmony default export */
          __webpack_exports__['a'] = (FragmentLoader);

          /***/
        }),
        /* 42 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__event_handler__ = __webpack_require__(
              4);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__utils_logger__ = __webpack_require__(
              1);

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /*
 * Decrypt key Loader
*/

          var KeyLoader =
              /*#__PURE__*/
              function(_EventHandler) {
                _inheritsLoose(KeyLoader, _EventHandler);

                function KeyLoader(hls) {
                  var _this;

                  _this = _EventHandler.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].KEY_LOADING) ||
                      this;
                  _this.loaders = {};
                  _this.decryptkey = null;
                  _this.decrypturl = null;
                  return _this;
                }

                var _proto = KeyLoader.prototype;

                _proto.destroy = function destroy() {
                  for (var loaderName in this.loaders) {
                    var loader = this.loaders[loaderName];

                    if (loader) {
                      loader.destroy();
                    }
                  }

                  this.loaders = {};

                  _EventHandler.prototype.destroy.call(this);
                };

                _proto.onKeyLoading = function onKeyLoading(data) {
                  var frag = data.frag;
                  var type = frag.type;
                  var loader = this.loaders[type];

                  if (!frag.decryptdata) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                        'Missing decryption data on fragment in onKeyLoading');
                    return;
                  } // Load the key if the uri is different from previous one, or if the decrypt key has not yet been retrieved

                  var uri = frag.decryptdata.uri;

                  if (uri !== this.decrypturl || this.decryptkey === null) {
                    var config = this.hls.config;

                    if (loader) {
                      __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                          'abort previous key loader for type:' + type);
                      loader.abort();
                    }

                    if (!uri) {
                      __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                          'key uri is falsy');
                      return;
                    }

                    frag.loader = this.loaders[type] = new config.loader(
                        config);
                    this.decrypturl = uri;
                    this.decryptkey = null;
                    var loaderContext = {
                      url: uri,
                      frag: frag,
                      responseType: 'arraybuffer',
                    }; // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,
                    // key-loader will trigger an error and rely on stream-controller to handle retry logic.
                    // this will also align retry logic with fragment-loader

                    var loaderConfig = {
                      timeout: config.fragLoadingTimeOut,
                      maxRetry: 0,
                      retryDelay: config.fragLoadingRetryDelay,
                      maxRetryDelay: config.fragLoadingMaxRetryTimeout,
                    };
                    var loaderCallbacks = {
                      onSuccess: this.loadsuccess.bind(this),
                      onError: this.loaderror.bind(this),
                      onTimeout: this.loadtimeout.bind(this),
                    };
                    frag.loader.load(loaderContext, loaderConfig,
                        loaderCallbacks);
                  } else if (this.decryptkey) {
                    // Return the key if it's already been loaded
                    frag.decryptdata.key = this.decryptkey;
                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].KEY_LOADED,
                        {
                          frag: frag,
                        });
                  }
                };

                _proto.loadsuccess = function loadsuccess(
                    response, stats, context) {
                  var frag = context.frag;

                  if (!frag.decryptdata) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                        'after key load, decryptdata unset');
                    return;
                  }

                  this.decryptkey = frag.decryptdata.key = new Uint8Array(
                      response.data); // detach fragment loader on load success

                  frag.loader = undefined;
                  delete this.loaders[frag.type];
                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].KEY_LOADED,
                      {
                        frag: frag,
                      });
                };

                _proto.loaderror = function loaderror(response, context) {
                  var frag = context.frag;
                  var loader = frag.loader;

                  if (loader) {
                    loader.abort();
                  }

                  delete this.loaders[frag.type];
                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].ERROR,
                      {
                        type: __WEBPACK_IMPORTED_MODULE_2__errors__['b' /* ErrorTypes */].NETWORK_ERROR,
                        details: __WEBPACK_IMPORTED_MODULE_2__errors__['a' /* ErrorDetails */].KEY_LOAD_ERROR,
                        fatal: false,
                        frag: frag,
                        response: response,
                      });
                };

                _proto.loadtimeout = function loadtimeout(stats, context) {
                  var frag = context.frag;
                  var loader = frag.loader;

                  if (loader) {
                    loader.abort();
                  }

                  delete this.loaders[frag.type];
                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].ERROR,
                      {
                        type: __WEBPACK_IMPORTED_MODULE_2__errors__['b' /* ErrorTypes */].NETWORK_ERROR,
                        details: __WEBPACK_IMPORTED_MODULE_2__errors__['a' /* ErrorDetails */].KEY_LOAD_TIMEOUT,
                        fatal: false,
                        frag: frag,
                      });
                };

                return KeyLoader;
              }(__WEBPACK_IMPORTED_MODULE_1__event_handler__['a' /* default */]);

          /* harmony default export */
          __webpack_exports__['a'] = (KeyLoader);

          /***/
        }),
        /* 43 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__utils_binary_search__ = __webpack_require__(
              11);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__utils_buffer_helper__ = __webpack_require__(
              6);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__demux_demuxer__ = __webpack_require__(
              23);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__fragment_tracker__ = __webpack_require__(
              7);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_6__loader_fragment__ = __webpack_require__(
              13);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_7__types_loader__ = __webpack_require__(
              19);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_8__level_helper__ = __webpack_require__(
              9);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_9__utils_time_ranges__ = __webpack_require__(
              27);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_10__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_11__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_12__utils_discontinuities__ = __webpack_require__(
              28);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_13__fragment_finders__ = __webpack_require__(
              29);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_14__gap_controller__ = __webpack_require__(
              59);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__ = __webpack_require__(
              17);

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(
              Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype,
                protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /*
 * Stream Controller
*/

          var TICK_INTERVAL = 100; // how often to tick in ms

          var StreamController =
              /*#__PURE__*/
              function(_BaseStreamController) {
                _inheritsLoose(StreamController, _BaseStreamController);

                function StreamController(hls, fragmentTracker) {
                  var _this;

                  _this = _BaseStreamController.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].MEDIA_ATTACHED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].MEDIA_DETACHING,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].MANIFEST_LOADING,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].MANIFEST_PARSED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].LEVEL_LOADED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].KEY_LOADED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_LOADED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_LOAD_EMERGENCY_ABORTED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_PARSING_INIT_SEGMENT,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_PARSING_DATA,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_PARSED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].ERROR,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].AUDIO_TRACK_SWITCHING,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].AUDIO_TRACK_SWITCHED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_CREATED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_APPENDED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_FLUSHED) ||
                      this;
                  _this.fragmentTracker = fragmentTracker;
                  _this.config = hls.config;
                  _this.audioCodecSwap = false;
                  _this._state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].STOPPED;
                  _this.stallReported = false;
                  _this.gapController = null;
                  _this.altAudio = false;
                  return _this;
                }

                var _proto = StreamController.prototype;

                _proto.startLoad = function startLoad(startPosition) {
                  if (this.levels) {
                    var lastCurrentTime = this.lastCurrentTime,
                        hls = this.hls;
                    this.stopLoad();
                    this.setInterval(TICK_INTERVAL);
                    this.level = -1;
                    this.fragLoadError = 0;

                    if (!this.startFragRequested) {
                      // determine load level
                      var startLevel = hls.startLevel;

                      if (startLevel === -1) {
                        // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
                        startLevel = 0;
                        this.bitrateTest = true;
                      } // set new level to playlist loader : this will trigger start level load
                      // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded

                      this.level = hls.nextLoadLevel = startLevel;
                      this.loadedmetadata = false;
                    } // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime

                    if (lastCurrentTime > 0 && startPosition === -1) {
                      __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                          'override startPosition with lastCurrentTime @' +
                          lastCurrentTime.toFixed(3));
                      startPosition = lastCurrentTime;
                    }

                    this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE;
                    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
                    this.tick();
                  } else {
                    this.forceStartLoad = true;
                    this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].STOPPED;
                  }
                };

                _proto.stopLoad = function stopLoad() {
                  this.forceStartLoad = false;

                  _BaseStreamController.prototype.stopLoad.call(this);
                };

                _proto.doTick = function doTick() {
                  switch (this.state) {
                    case __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].BUFFER_FLUSHING:
                      // in buffer flushing state, reset fragLoadError counter
                      this.fragLoadError = 0;
                      break;

                    case __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE:
                      this._doTickIdle();

                      break;

                    case __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].WAITING_LEVEL:
                      var level = this.levels[this.level]; // check if playlist is already loaded

                      if (level && level.details) {
                        this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE;
                      }

                      break;

                    case __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].FRAG_LOADING_WAITING_RETRY:
                      var now = window.performance.now();
                      var retryDate = this.retryDate; // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading

                      if (!retryDate || now >= retryDate || this.media &&
                          this.media.seeking) {
                        __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                            'mediaController: retryDate reached, switch back to IDLE state');
                        this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE;
                      }

                      break;

                    case __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].ERROR:
                    case __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].STOPPED:
                    case __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].FRAG_LOADING:
                    case __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].PARSING:
                    case __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].PARSED:
                    case __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].ENDED:
                      break;

                    default:
                      break;
                  } // check buffer

                  this._checkBuffer(); // check/update current fragment

                  this._checkFragmentChanged();
                } // Ironically the "idle" state is the on we do the most logic in it seems ....
                // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
                //       played segment, or on pause/play/seek instead of naively checking every 100ms?
                ;

                _proto._doTickIdle = function _doTickIdle() {
                  var hls = this.hls,
                      config = hls.config,
                      media = this.media; // if start level not parsed yet OR
                  // if video not attached AND start fragment already requested OR start frag prefetch disable
                  // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment

                  if (this.levelLastLoaded === undefined || !media &&
                      (this.startFragRequested || !config.startFragPrefetch)) {
                    return;
                  } // if we have not yet loaded any fragment, start loading from start position

                  var pos;

                  if (this.loadedmetadata) {
                    pos = media.currentTime;
                  } else {
                    pos = this.nextLoadPosition;
                  } // determine next load level

                  var level = hls.nextLoadLevel,
                      levelInfo = this.levels[level];

                  if (!levelInfo) {
                    return;
                  }

                  var levelBitrate = levelInfo.bitrate,
                      maxBufLen; // compute max Buffer Length that we could get from this load level, based on level bitrate.

                  if (levelBitrate) {
                    maxBufLen = Math.max(
                        8 * config.maxBufferSize / levelBitrate,
                        config.maxBufferLength);
                  } else {
                    maxBufLen = config.maxBufferLength;
                  }

                  maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength); // determine next candidate fragment to be loaded, based on current position and end of buffer position
                  // ensure up to `config.maxMaxBufferLength` of buffer upfront

                  var bufferInfo = __WEBPACK_IMPORTED_MODULE_2__utils_buffer_helper__['a' /* BufferHelper */].bufferInfo(
                      this.mediaBuffer ? this.mediaBuffer : media, pos,
                      config.maxBufferHole),
                      bufferLen = bufferInfo.len; // Stay idle if we are still with buffer margins

                  if (bufferLen >= maxBufLen) {
                    return;
                  } // if buffer length is less than maxBufLen try to load a new fragment ...

                  __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].trace(
                      'buffer length of ' + bufferLen.toFixed(3) +
                      ' is below max of ' + maxBufLen.toFixed(3) +
                      '. checking for more payload ...'); // set next load level : this will trigger a playlist load if needed

                  this.level = hls.nextLoadLevel = level;
                  var levelDetails = levelInfo.details; // if level info not retrieved yet, switch state and wait for level retrieval
                  // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
                  // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)

                  if (!levelDetails || levelDetails.live &&
                      this.levelLastLoaded !== level) {
                    this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].WAITING_LEVEL;
                    return;
                  }

                  if (this._streamEnded(bufferInfo, levelDetails)) {
                    var data = {};

                    if (this.altAudio) {
                      data.type = 'video';
                    }

                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_EOS,
                        data);
                    this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].ENDED;
                    return;
                  } // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)

                  this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);
                };

                _proto._fetchPayloadOrEos = function _fetchPayloadOrEos(
                    pos, bufferInfo, levelDetails) {
                  var fragPrevious = this.fragPrevious,
                      level = this.level,
                      fragments = levelDetails.fragments,
                      fragLen = fragments.length; // empty playlist

                  if (fragLen === 0) {
                    return;
                  } // find fragment index, contiguous with end of buffer position

                  var start = fragments[0].start,
                      end = fragments[fragLen - 1].start +
                          fragments[fragLen - 1].duration,
                      bufferEnd = bufferInfo.end,
                      frag;

                  if (levelDetails.initSegment &&
                      !levelDetails.initSegment.data) {
                    frag = levelDetails.initSegment;
                  } else {
                    // in case of live playlist we need to ensure that requested position is not located before playlist start
                    if (levelDetails.live) {
                      var initialLiveManifestSize = this.config.initialLiveManifestSize;

                      if (fragLen < initialLiveManifestSize) {
                        __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].warn(
                            'Can not start playback of a level, reason: not enough fragments ' +
                            fragLen + ' < ' + initialLiveManifestSize);
                        return;
                      }

                      frag = this._ensureFragmentAtLivePoint(levelDetails,
                          bufferEnd, start, end, fragPrevious, fragments,
                          fragLen); // if it explicitely returns null don't load any fragment and exit function now

                      if (frag === null) {
                        return;
                      }
                    } else {
                      // VoD playlist: if bufferEnd before start of playlist, load first fragment
                      if (bufferEnd < start) {
                        frag = fragments[0];
                      }
                    }
                  }

                  if (!frag) {
                    frag = this._findFragment(start, fragPrevious, fragLen,
                        fragments, bufferEnd, end, levelDetails);
                  }

                  if (frag) {
                    if (frag.encrypted) {
                      __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                          'Loading key for ' + frag.sn + ' of [' +
                          levelDetails.startSN + ' ,' + levelDetails.endSN +
                          '],level ' + level);

                      this._loadKey(frag);
                    } else {
                      __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                          'Loading ' + frag.sn + ' of [' +
                          levelDetails.startSN + ' ,' + levelDetails.endSN +
                          '],level ' + level + ', currentTime:' +
                          pos.toFixed(3) + ',bufferEnd:' +
                          bufferEnd.toFixed(3));

                      this._loadFragment(frag);
                    }
                  }
                };

                _proto._ensureFragmentAtLivePoint = function _ensureFragmentAtLivePoint(
                    levelDetails, bufferEnd, start, end, fragPrevious,
                    fragments, fragLen) {
                  var config = this.hls.config,
                      media = this.media;
                  var frag; // check if requested position is within seekable boundaries :
                  // logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);

                  var maxLatency = config.liveMaxLatencyDuration !== undefined
                      ? config.liveMaxLatencyDuration
                      : config.liveMaxLatencyDurationCount *
                      levelDetails.targetduration;

                  if (bufferEnd <
                      Math.max(start - config.maxFragLookUpTolerance,
                          end - maxLatency)) {
                    var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(
                        start, levelDetails);
                    __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                        'buffer end: ' + bufferEnd.toFixed(3) +
                        ' is located too far from the end of live sliding playlist, reset currentTime to : ' +
                        liveSyncPosition.toFixed(3));
                    bufferEnd = liveSyncPosition;

                    if (media && !media.paused && media.readyState &&
                        media.duration > liveSyncPosition) {
                      media.currentTime = liveSyncPosition;
                    }

                    this.nextLoadPosition = liveSyncPosition;
                  } // if end of buffer greater than live edge, don't load any fragment
                  // this could happen if live playlist intermittently slides in the past.
                  // level 1 loaded [182580161,182580167]
                  // level 1 loaded [182580162,182580169]
                  // Loading 182580168 of [182580162 ,182580169],level 1 ..
                  // Loading 182580169 of [182580162 ,182580169],level 1 ..
                  // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
                  // level 1 loaded [182580164,182580171]
                  //
                  // don't return null in case media not loaded yet (readystate === 0)

                  if (levelDetails.PTSKnown && bufferEnd > end && media &&
                      media.readyState) {
                    return null;
                  }

                  if (this.startFragRequested && !levelDetails.PTSKnown) {
                    /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
         try to load frag matching with next SN.
         even if SN are not synchronized between playlists, loading this frag will help us
         compute playlist sliding and find the right one after in case it was not the right consecutive one */
                    if (fragPrevious) {
                      if (levelDetails.hasProgramDateTime) {
                        // Relies on PDT in order to switch bitrates (Support EXT-X-DISCONTINUITY without EXT-X-DISCONTINUITY-SEQUENCE)
                        __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                            'live playlist, switching playlist, load frag with same PDT: ' +
                            fragPrevious.programDateTime);
                        frag = Object(
                            __WEBPACK_IMPORTED_MODULE_13__fragment_finders__['a' /* findFragmentByPDT */])(
                            fragments, fragPrevious.endProgramDateTime,
                            config.maxFragLookUpTolerance);
                      } else {
                        // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)
                        var targetSN = fragPrevious.sn + 1;

                        if (targetSN >= levelDetails.startSN && targetSN <=
                            levelDetails.endSN) {
                          var fragNext = fragments[targetSN -
                          levelDetails.startSN];

                          if (fragPrevious.cc === fragNext.cc) {
                            frag = fragNext;
                            __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                                'live playlist, switching playlist, load frag with next SN: ' +
                                frag.sn);
                          }
                        } // next frag SN not available (or not with same continuity counter)
                        // look for a frag sharing the same CC

                        if (!frag) {
                          frag = __WEBPACK_IMPORTED_MODULE_1__utils_binary_search__['a' /* default */].search(
                              fragments, function(frag) {
                                return fragPrevious.cc - frag.cc;
                              });

                          if (frag) {
                            __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                                'live playlist, switching playlist, load frag with same CC: ' +
                                frag.sn);
                          }
                        }
                      }
                    }

                    if (!frag) {
                      /* we have no idea about which fragment should be loaded.
           so let's load mid fragment. it will help computing playlist sliding and find the right one
        */
                      frag = fragments[Math.min(fragLen - 1,
                          Math.round(fragLen / 2))];
                      __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                          'live playlist, switching playlist, unknown, load middle frag : ' +
                          frag.sn);
                    }
                  }

                  return frag;
                };

                _proto._findFragment = function _findFragment(
                    start, fragPreviousLoad, fragmentIndexRange, fragments,
                    bufferEnd, end, levelDetails) {
                  var config = this.hls.config;
                  var fragNextLoad;

                  if (bufferEnd < end) {
                    var lookupTolerance = bufferEnd > end -
                    config.maxFragLookUpTolerance
                        ? 0
                        : config.maxFragLookUpTolerance; // Remove the tolerance if it would put the bufferEnd past the actual end of stream
                    // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)

                    fragNextLoad = Object(
                        __WEBPACK_IMPORTED_MODULE_13__fragment_finders__['b' /* findFragmentByPTS */])(
                        fragPreviousLoad, fragments, bufferEnd,
                        lookupTolerance);
                  } else {
                    // reach end of playlist
                    fragNextLoad = fragments[fragmentIndexRange - 1];
                  }

                  if (fragNextLoad) {
                    var curSNIdx = fragNextLoad.sn - levelDetails.startSN;
                    var sameLevel = fragPreviousLoad && fragNextLoad.level ===
                        fragPreviousLoad.level;
                    var prevSnFrag = fragments[curSNIdx - 1];
                    var nextSnFrag = fragments[curSNIdx + 1]; // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);

                    if (fragPreviousLoad && fragNextLoad.sn ===
                        fragPreviousLoad.sn) {
                      if (sameLevel && !fragNextLoad.backtracked) {
                        if (fragNextLoad.sn < levelDetails.endSN) {
                          var deltaPTS = fragPreviousLoad.deltaPTS; // if there is a significant delta between audio and video, larger than max allowed hole,
                          // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
                          // let's try to load previous fragment again to get last keyframe
                          // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)

                          if (deltaPTS && deltaPTS > config.maxBufferHole &&
                              fragPreviousLoad.dropped && curSNIdx) {
                            fragNextLoad = prevSnFrag;
                            __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].warn(
                                'Previous fragment was dropped with large PTS gap between audio and video. Maybe fragment is not starting with a keyframe? Loading previous one to try to overcome this');
                          } else {
                            fragNextLoad = nextSnFrag;
                            __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                                'Re-loading fragment with SN: ' +
                                fragNextLoad.sn);
                          }
                        } else {
                          fragNextLoad = null;
                        }
                      } else if (fragNextLoad.backtracked) {
                        // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes
                        if (nextSnFrag && nextSnFrag.backtracked) {
                          __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].warn(
                              'Already backtracked from fragment ' +
                              nextSnFrag.sn +
                              ', will not backtrack to fragment ' +
                              fragNextLoad.sn + '. Loading fragment ' +
                              nextSnFrag.sn);
                          fragNextLoad = nextSnFrag;
                        } else {
                          // If a fragment has dropped frames and it's in a same level/sequence, load the previous fragment to try and find the keyframe
                          // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment
                          __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].warn(
                              'Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');
                          fragNextLoad.dropped = 0;

                          if (prevSnFrag) {
                            fragNextLoad = prevSnFrag;
                            fragNextLoad.backtracked = true;
                          } else if (curSNIdx) {
                            // can't backtrack on very first fragment
                            fragNextLoad = null;
                          }
                        }
                      }
                    }
                  }

                  return fragNextLoad;
                };

                _proto._loadKey = function _loadKey(frag) {
                  this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].KEY_LOADING;
                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].KEY_LOADING,
                      {
                        frag: frag,
                      });
                };

                _proto._loadFragment = function _loadFragment(frag) {
                  // Check if fragment is not loaded
                  var fragState = this.fragmentTracker.getState(frag);
                  this.fragCurrent = frag;

                  if (frag.sn !== 'initSegment') {
                    this.startFragRequested = true;
                  } // Don't update nextLoadPosition for fragments which are not buffered

                  if (Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      frag.sn) && !frag.bitrateTest) {
                    this.nextLoadPosition = frag.start + frag.duration;
                  } // Allow backtracked fragments to load

                  if (frag.backtracked || fragState ===
                      __WEBPACK_IMPORTED_MODULE_5__fragment_tracker__['a' /* FragmentState */].NOT_LOADED ||
                      fragState ===
                      __WEBPACK_IMPORTED_MODULE_5__fragment_tracker__['a' /* FragmentState */].PARTIAL) {
                    frag.autoLevel = this.hls.autoLevelEnabled;
                    frag.bitrateTest = this.bitrateTest;
                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_LOADING,
                        {
                          frag: frag,
                        }); // lazy demuxer init, as this could take some time ... do it during frag loading

                    if (!this.demuxer) {
                      this.demuxer = new __WEBPACK_IMPORTED_MODULE_3__demux_demuxer__['a' /* default */](
                          this.hls, 'main');
                    }

                    this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].FRAG_LOADING;
                  } else if (fragState ===
                      __WEBPACK_IMPORTED_MODULE_5__fragment_tracker__['a' /* FragmentState */].APPENDING) {
                    // Lower the buffer size and try again
                    if (this._reduceMaxBufferLength(frag.duration)) {
                      this.fragmentTracker.removeFragment(frag);
                    }
                  }
                };

                _proto.getBufferedFrag = function getBufferedFrag(position) {
                  return this.fragmentTracker.getBufferedFrag(position,
                      __WEBPACK_IMPORTED_MODULE_7__types_loader__['b' /* PlaylistLevelType */].MAIN);
                };

                _proto.followingBufferedFrag = function followingBufferedFrag(frag) {
                  if (frag) {
                    // try to get range of next fragment (500ms after this range)
                    return this.getBufferedFrag(frag.endPTS + 0.5);
                  }

                  return null;
                };

                _proto._checkFragmentChanged = function _checkFragmentChanged() {
                  var fragPlayingCurrent,
                      currentTime,
                      video = this.media;

                  if (video && video.readyState && video.seeking === false) {
                    currentTime = video.currentTime;
                    /* if video element is in seeked state, currentTime can only increase.
        (assuming that playback rate is positive ...)
        As sometimes currentTime jumps back to zero after a
        media decode error, check this, to avoid seeking back to
        wrong position after a media decode error
      */

                    if (currentTime > this.lastCurrentTime) {
                      this.lastCurrentTime = currentTime;
                    }

                    if (__WEBPACK_IMPORTED_MODULE_2__utils_buffer_helper__['a' /* BufferHelper */].isBuffered(
                        video, currentTime)) {
                      fragPlayingCurrent = this.getBufferedFrag(currentTime);
                    } else if (__WEBPACK_IMPORTED_MODULE_2__utils_buffer_helper__['a' /* BufferHelper */].isBuffered(
                        video, currentTime + 0.1)) {
                      /* ensure that FRAG_CHANGED event is triggered at startup,
          when first video frame is displayed and playback is paused.
          add a tolerance of 100ms, in case current position is not buffered,
          check if current pos+100ms is buffered and use that buffer range
          for FRAG_CHANGED event reporting */
                      fragPlayingCurrent = this.getBufferedFrag(
                          currentTime + 0.1);
                    }

                    if (fragPlayingCurrent) {
                      var fragPlaying = fragPlayingCurrent;

                      if (fragPlaying !== this.fragPlaying) {
                        this.hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_CHANGED,
                            {
                              frag: fragPlaying,
                            });
                        var fragPlayingLevel = fragPlaying.level;

                        if (!this.fragPlaying || this.fragPlaying.level !==
                            fragPlayingLevel) {
                          this.hls.trigger(
                              __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].LEVEL_SWITCHED,
                              {
                                level: fragPlayingLevel,
                              });
                        }

                        this.fragPlaying = fragPlaying;
                      }
                    }
                  }
                }
                /*
    on immediate level switch :
     - pause playback if playing
     - cancel any pending load request
     - and trigger a buffer flush
  */
                ;

                _proto.immediateLevelSwitch = function immediateLevelSwitch() {
                  __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                      'immediateLevelSwitch');

                  if (!this.immediateSwitch) {
                    this.immediateSwitch = true;
                    var media = this.media,
                        previouslyPaused;

                    if (media) {
                      previouslyPaused = media.paused;
                      media.pause();
                    } else {
                      // don't restart playback after instant level switch in case media not attached
                      previouslyPaused = true;
                    }

                    this.previouslyPaused = previouslyPaused;
                  }

                  var fragCurrent = this.fragCurrent;

                  if (fragCurrent && fragCurrent.loader) {
                    fragCurrent.loader.abort();
                  }

                  this.fragCurrent = null; // flush everything

                  this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
                }
                /**
                 * on immediate level switch end, after new fragment has been buffered:
                 * - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
                 * - resume the playback if needed
                 */
                ;

                _proto.immediateLevelSwitchEnd = function immediateLevelSwitchEnd() {
                  var media = this.media;

                  if (media && media.buffered.length) {
                    this.immediateSwitch = false;

                    if (__WEBPACK_IMPORTED_MODULE_2__utils_buffer_helper__['a' /* BufferHelper */].isBuffered(
                        media, media.currentTime)) {
                      // only nudge if currentTime is buffered
                      media.currentTime -= 0.0001;
                    }

                    if (!this.previouslyPaused) {
                      media.play();
                    }
                  }
                }
                /**
                 * try to switch ASAP without breaking video playback:
                 * in order to ensure smooth but quick level switching,
                 * we need to find the next flushable buffer range
                 * we should take into account new segment fetch time
                 */
                ;

                _proto.nextLevelSwitch = function nextLevelSwitch() {
                  var media = this.media; // ensure that media is defined and that metadata are available (to retrieve currentTime)

                  if (media && media.readyState) {
                    var fetchdelay, fragPlayingCurrent, nextBufferedFrag;
                    fragPlayingCurrent = this.getBufferedFrag(
                        media.currentTime);

                    if (fragPlayingCurrent && fragPlayingCurrent.startPTS > 1) {
                      // flush buffer preceding current fragment (flush until current fragment start offset)
                      // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
                      this.flushMainBuffer(0, fragPlayingCurrent.startPTS - 1);
                    }

                    if (!media.paused) {
                      // add a safety delay of 1s
                      var nextLevelId = this.hls.nextLoadLevel,
                          nextLevel = this.levels[nextLevelId],
                          fragLastKbps = this.fragLastKbps;

                      if (fragLastKbps && this.fragCurrent) {
                        fetchdelay = this.fragCurrent.duration *
                            nextLevel.bitrate / (1000 * fragLastKbps) + 1;
                      } else {
                        fetchdelay = 0;
                      }
                    } else {
                      fetchdelay = 0;
                    } // logger.log('fetchdelay:'+fetchdelay);
                    // find buffer range that will be reached once new fragment will be fetched

                    nextBufferedFrag = this.getBufferedFrag(
                        media.currentTime + fetchdelay);

                    if (nextBufferedFrag) {
                      // we can flush buffer range following this one without stalling playback
                      nextBufferedFrag = this.followingBufferedFrag(
                          nextBufferedFrag);

                      if (nextBufferedFrag) {
                        // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
                        var fragCurrent = this.fragCurrent;

                        if (fragCurrent && fragCurrent.loader) {
                          fragCurrent.loader.abort();
                        }

                        this.fragCurrent = null; // start flush position is the start PTS of next buffered frag.
                        // we use frag.naxStartPTS which is max(audio startPTS, video startPTS).
                        // in case there is a small PTS Delta between audio and video, using maxStartPTS avoids flushing last samples from current fragment

                        this.flushMainBuffer(nextBufferedFrag.maxStartPTS,
                            Number.POSITIVE_INFINITY);
                      }
                    }
                  }
                };

                _proto.flushMainBuffer = function flushMainBuffer(
                    startOffset, endOffset) {
                  this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].BUFFER_FLUSHING;
                  var flushScope = {
                    startOffset: startOffset,
                    endOffset: endOffset,
                  }; // if alternate audio tracks are used, only flush video, otherwise flush everything

                  if (this.altAudio) {
                    flushScope.type = 'video';
                  }

                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_FLUSHING,
                      flushScope);
                };

                _proto.onMediaAttached = function onMediaAttached(data) {
                  var media = this.media = this.mediaBuffer = data.media;
                  this.onvseeking = this.onMediaSeeking.bind(this);
                  this.onvseeked = this.onMediaSeeked.bind(this);
                  this.onvended = this.onMediaEnded.bind(this);
                  media.addEventListener('seeking', this.onvseeking);
                  media.addEventListener('seeked', this.onvseeked);
                  media.addEventListener('ended', this.onvended);
                  var config = this.config;

                  if (this.levels && config.autoStartLoad) {
                    this.hls.startLoad(config.startPosition);
                  }

                  this.gapController = new __WEBPACK_IMPORTED_MODULE_14__gap_controller__['a' /* default */](
                      config, media, this.fragmentTracker, this.hls);
                };

                _proto.onMediaDetaching = function onMediaDetaching() {
                  var media = this.media;

                  if (media && media.ended) {
                    __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                        'MSE detaching and video ended, reset startPosition');
                    this.startPosition = this.lastCurrentTime = 0;
                  } // reset fragment backtracked flag

                  var levels = this.levels;

                  if (levels) {
                    levels.forEach(function(level) {
                      if (level.details) {
                        level.details.fragments.forEach(function(fragment) {
                          fragment.backtracked = undefined;
                        });
                      }
                    });
                  } // remove video listeners

                  if (media) {
                    media.removeEventListener('seeking', this.onvseeking);
                    media.removeEventListener('seeked', this.onvseeked);
                    media.removeEventListener('ended', this.onvended);
                    this.onvseeking = this.onvseeked = this.onvended = null;
                  }

                  this.fragmentTracker.removeAllFragments();
                  this.media = this.mediaBuffer = null;
                  this.loadedmetadata = false;
                  this.stopLoad();
                };

                _proto.onMediaSeeked = function onMediaSeeked() {
                  var media = this.media;
                  var currentTime = media ? media.currentTime : undefined;

                  if (Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      currentTime)) {
                    __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                        'media seeked to ' + currentTime.toFixed(3));
                  } // tick to speed up FRAGMENT_PLAYING triggering

                  this.tick();
                };

                _proto.onManifestLoading = function onManifestLoading() {
                  // reset buffer on manifest loading
                  __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                      'trigger BUFFER_RESET');
                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_RESET);
                  this.fragmentTracker.removeAllFragments();
                  this.stalled = false;
                  this.startPosition = this.lastCurrentTime = 0;
                };

                _proto.onManifestParsed = function onManifestParsed(data) {
                  var aac = false,
                      heaac = false,
                      codec;
                  data.levels.forEach(function(level) {
                    // detect if we have different kind of audio codecs used amongst playlists
                    codec = level.audioCodec;

                    if (codec) {
                      if (codec.indexOf('mp4a.40.2') !== -1) {
                        aac = true;
                      }

                      if (codec.indexOf('mp4a.40.5') !== -1) {
                        heaac = true;
                      }
                    }
                  });
                  this.audioCodecSwitch = aac && heaac;

                  if (this.audioCodecSwitch) {
                    __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                        'both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
                  }

                  this.altAudio = data.altAudio;
                  this.levels = data.levels;
                  this.startFragRequested = false;
                  var config = this.config;

                  if (config.autoStartLoad || this.forceStartLoad) {
                    this.hls.startLoad(config.startPosition);
                  }
                };

                _proto.onLevelLoaded = function onLevelLoaded(data) {
                  var newDetails = data.details;
                  var newLevelId = data.level;
                  var lastLevel = this.levels[this.levelLastLoaded];
                  var curLevel = this.levels[newLevelId];
                  var duration = newDetails.totalduration;
                  var sliding = 0;
                  __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                      'level ' + newLevelId + ' loaded [' + newDetails.startSN +
                      ',' + newDetails.endSN + '],duration:' + duration);

                  if (newDetails.live) {
                    var curDetails = curLevel.details;

                    if (curDetails && newDetails.fragments.length > 0) {
                      // we already have details for that level, merge them
                      __WEBPACK_IMPORTED_MODULE_8__level_helper__['c' /* mergeDetails */](
                          curDetails, newDetails);
                      sliding = newDetails.fragments[0].start;
                      this.liveSyncPosition = this.computeLivePosition(sliding,
                          curDetails);

                      if (newDetails.PTSKnown && Object(
                          __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                          sliding)) {
                        __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                            'live playlist sliding:' + sliding.toFixed(3));
                      } else {
                        __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                            'live playlist - outdated PTS, unknown sliding');
                        Object(
                            __WEBPACK_IMPORTED_MODULE_12__utils_discontinuities__['a' /* alignStream */])(
                            this.fragPrevious, lastLevel, newDetails);
                      }
                    } else {
                      __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                          'live playlist - first load, unknown sliding');
                      newDetails.PTSKnown = false;
                      Object(
                          __WEBPACK_IMPORTED_MODULE_12__utils_discontinuities__['a' /* alignStream */])(
                          this.fragPrevious, lastLevel, newDetails);
                    }
                  } else {
                    newDetails.PTSKnown = false;
                  } // override level info

                  curLevel.details = newDetails;
                  this.levelLastLoaded = newLevelId;
                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].LEVEL_UPDATED,
                      {
                        details: newDetails,
                        level: newLevelId,
                      });

                  if (this.startFragRequested === false) {
                    // compute start position if set to -1. use it straight away if value is defined
                    if (this.startPosition === -1 || this.lastCurrentTime ===
                        -1) {
                      // first, check if start time offset has been set in playlist, if yes, use this value
                      var startTimeOffset = newDetails.startTimeOffset;

                      if (Object(
                          __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                          startTimeOffset)) {
                        if (startTimeOffset < 0) {
                          __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                              'negative start time offset ' + startTimeOffset +
                              ', count from end of last fragment');
                          startTimeOffset = sliding + duration +
                              startTimeOffset;
                        }

                        __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                            'start time offset found in playlist, adjust startPosition to ' +
                            startTimeOffset);
                        this.startPosition = startTimeOffset;
                      } else {
                        // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
                        if (newDetails.live) {
                          this.startPosition = this.computeLivePosition(sliding,
                              newDetails);
                          __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                              'configure startPosition to ' +
                              this.startPosition);
                        } else {
                          this.startPosition = 0;
                        }
                      }

                      this.lastCurrentTime = this.startPosition;
                    }

                    this.nextLoadPosition = this.startPosition;
                  } // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment

                  if (this.state ===
                      __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].WAITING_LEVEL) {
                    this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE;
                  } // trigger handler right now

                  this.tick();
                };

                _proto.onKeyLoaded = function onKeyLoaded() {
                  if (this.state ===
                      __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].KEY_LOADING) {
                    this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE;
                    this.tick();
                  }
                };

                _proto.onFragLoaded = function onFragLoaded(data) {
                  var fragCurrent = this.fragCurrent,
                      hls = this.hls,
                      levels = this.levels,
                      media = this.media;
                  var fragLoaded = data.frag;

                  if (this.state ===
                      __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].FRAG_LOADING &&
                      fragCurrent && fragLoaded.type === 'main' &&
                      fragLoaded.level === fragCurrent.level &&
                      fragLoaded.sn === fragCurrent.sn) {
                    var stats = data.stats;
                    var currentLevel = levels[fragCurrent.level];
                    var details = currentLevel.details; // reset frag bitrate test in any case after frag loaded event
                    // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
                    // then this means that we should be able to load a fragment at a higher quality level

                    this.bitrateTest = false;
                    this.stats = stats;
                    __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                        'Loaded ' + fragCurrent.sn + ' of [' + details.startSN +
                        ' ,' + details.endSN + '],level ' + fragCurrent.level);

                    if (fragLoaded.bitrateTest && hls.nextLoadLevel) {
                      // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
                      this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE;
                      this.startFragRequested = false;
                      stats.tparsed = stats.tbuffered = window.performance.now();
                      hls.trigger(
                          __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_BUFFERED,
                          {
                            stats: stats,
                            frag: fragCurrent,
                            id: 'main',
                          });
                      this.tick();
                    } else if (fragLoaded.sn === 'initSegment') {
                      this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE;
                      stats.tparsed = stats.tbuffered = window.performance.now();
                      details.initSegment.data = data.payload;
                      hls.trigger(
                          __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_BUFFERED,
                          {
                            stats: stats,
                            frag: fragCurrent,
                            id: 'main',
                          });
                      this.tick();
                    } else {
                      __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                          'Parsing ' + fragCurrent.sn + ' of [' +
                          details.startSN + ' ,' + details.endSN + '],level ' +
                          fragCurrent.level + ', cc ' + fragCurrent.cc);
                      this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].PARSING;
                      this.pendingBuffering = true;
                      this.appended = false; // Bitrate test frags are not usually buffered so the fragment tracker ignores them. If Hls.js decides to buffer
                      // it (and therefore ends up at this line), then the fragment tracker needs to be manually informed.

                      if (fragLoaded.bitrateTest) {
                        fragLoaded.bitrateTest = false;
                        this.fragmentTracker.onFragLoaded({
                          frag: fragLoaded,
                        });
                      } // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)

                      var accurateTimeOffset = !(media && media.seeking) &&
                          (details.PTSKnown || !details.live);
                      var initSegmentData = details.initSegment
                          ? details.initSegment.data
                          : [];

                      var audioCodec = this._getAudioCodec(currentLevel); // transmux the MPEG-TS data to ISO-BMFF segments

                      var demuxer = this.demuxer = this.demuxer ||
                          new __WEBPACK_IMPORTED_MODULE_3__demux_demuxer__['a' /* default */](
                              this.hls, 'main');
                      demuxer.push(data.payload, initSegmentData, audioCodec,
                          currentLevel.videoCodec, fragCurrent,
                          details.totalduration, accurateTimeOffset);
                    }
                  }

                  this.fragLoadError = 0;
                };

                _proto.onFragParsingInitSegment = function onFragParsingInitSegment(data) {
                  var fragCurrent = this.fragCurrent;
                  var fragNew = data.frag;

                  if (fragCurrent && data.id === 'main' && fragNew.sn ===
                      fragCurrent.sn && fragNew.level === fragCurrent.level &&
                      this.state ===
                      __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].PARSING) {
                    var tracks = data.tracks,
                        trackName,
                        track; // if audio track is expected to come from audio stream controller, discard any coming from main

                    if (tracks.audio && this.altAudio) {
                      delete tracks.audio;
                    } // include levelCodec in audio and video tracks

                    track = tracks.audio;

                    if (track) {
                      var audioCodec = this.levels[this.level].audioCodec,
                          ua = navigator.userAgent.toLowerCase();

                      if (audioCodec && this.audioCodecSwap) {
                        __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                            'swapping playlist audio codec');

                        if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                          audioCodec = 'mp4a.40.2';
                        } else {
                          audioCodec = 'mp4a.40.5';
                        }
                      } // in case AAC and HE-AAC audio codecs are signalled in manifest
                      // force HE-AAC , as it seems that most browsers prefers that way,
                      // except for mono streams OR on FF
                      // these conditions might need to be reviewed ...

                      if (this.audioCodecSwitch) {
                        // don't force HE-AAC if mono stream
                        if (track.metadata.channelCount !== 1 && // don't force HE-AAC if firefox
                            ua.indexOf('firefox') === -1) {
                          audioCodec = 'mp4a.40.5';
                        }
                      } // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise

                      if (ua.indexOf('android') !== -1 && track.container !==
                          'audio/mpeg') {
                        // Exclude mpeg audio
                        audioCodec = 'mp4a.40.2';
                        __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                            'Android: force audio codec to ' + audioCodec);
                      }

                      track.levelCodec = audioCodec;
                      track.id = data.id;
                    }

                    track = tracks.video;

                    if (track) {
                      track.levelCodec = this.levels[this.level].videoCodec;
                      track.id = data.id;
                    }

                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_CODECS,
                        tracks); // loop through tracks that are going to be provided to bufferController

                    for (trackName in tracks) {
                      track = tracks[trackName];
                      __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                          'main track:' + trackName + ',container:' +
                          track.container + ',codecs[level/parsed]=[' +
                          track.levelCodec + '/' + track.codec + ']');
                      var initSegment = track.initSegment;

                      if (initSegment) {
                        this.appended = true; // arm pending Buffering flag before appending a segment

                        this.pendingBuffering = true;
                        this.hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_APPENDING,
                            {
                              type: trackName,
                              data: initSegment,
                              parent: 'main',
                              content: 'initSegment',
                            });
                      }
                    } // trigger handler right now

                    this.tick();
                  }
                };

                _proto.onFragParsingData = function onFragParsingData(data) {
                  var _this2 = this;

                  var fragCurrent = this.fragCurrent;
                  var fragNew = data.frag;

                  if (fragCurrent && data.id === 'main' && fragNew.sn ===
                      fragCurrent.sn && fragNew.level === fragCurrent.level &&
                      !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
                      this.state ===
                      __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].PARSING) {
                    var level = this.levels[this.level],
                        frag = fragCurrent;

                    if (!Object(
                        __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                        data.endPTS)) {
                      data.endPTS = data.startPTS + fragCurrent.duration;
                      data.endDTS = data.startDTS + fragCurrent.duration;
                    }

                    if (data.hasAudio === true) {
                      frag.addElementaryStream(
                          __WEBPACK_IMPORTED_MODULE_6__loader_fragment__['a' /* ElementaryStreamTypes */].AUDIO);
                    }

                    if (data.hasVideo === true) {
                      frag.addElementaryStream(
                          __WEBPACK_IMPORTED_MODULE_6__loader_fragment__['a' /* ElementaryStreamTypes */].VIDEO);
                    }

                    __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                        'Parsed ' + data.type + ',PTS:[' +
                        data.startPTS.toFixed(3) + ',' +
                        data.endPTS.toFixed(3) + '],DTS:[' +
                        data.startDTS.toFixed(3) + '/' +
                        data.endDTS.toFixed(3) + '],nb:' + data.nb +
                        ',dropped:' + (data.dropped || 0)); // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)

                    if (data.type === 'video') {
                      frag.dropped = data.dropped;

                      if (frag.dropped) {
                        if (!frag.backtracked) {
                          var levelDetails = level.details;

                          if (levelDetails && frag.sn ===
                              levelDetails.startSN) {
                            __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].warn(
                                'missing video frame(s) on first frag, appending with gap',
                                frag.sn);
                          } else {
                            __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].warn(
                                'missing video frame(s), backtracking fragment',
                                frag.sn); // Return back to the IDLE state without appending to buffer
                            // Causes findFragments to backtrack a segment and find the keyframe
                            // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment

                            this.fragmentTracker.removeFragment(frag);
                            frag.backtracked = true;
                            this.nextLoadPosition = data.startPTS;
                            this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE;
                            this.fragPrevious = frag;
                            this.tick();
                            return;
                          }
                        } else {
                          __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].warn(
                              'Already backtracked on this fragment, appending with the gap',
                              frag.sn);
                        }
                      } else {
                        // Only reset the backtracked flag if we've loaded the frag without any dropped frames
                        frag.backtracked = false;
                      }
                    }

                    var drift = __WEBPACK_IMPORTED_MODULE_8__level_helper__['e' /* updateFragPTSDTS */](
                        level.details, frag, data.startPTS, data.endPTS,
                        data.startDTS, data.endDTS),
                        hls = this.hls;
                    hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].LEVEL_PTS_UPDATED,
                        {
                          details: level.details,
                          level: this.level,
                          drift: drift,
                          type: data.type,
                          start: data.startPTS,
                          end: data.endPTS,
                        }); // has remuxer dropped video frames located before first keyframe ?

                    [data.data1, data.data2].forEach(function(buffer) {
                      // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
                      // in that case it is useless to append following segments
                      if (buffer && buffer.length && _this2.state ===
                          __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].PARSING) {
                        _this2.appended = true; // arm pending Buffering flag before appending a segment

                        _this2.pendingBuffering = true;
                        hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_APPENDING,
                            {
                              type: data.type,
                              data: buffer,
                              parent: 'main',
                              content: 'data',
                            });
                      }
                    }); // trigger handler right now

                    this.tick();
                  }
                };

                _proto.onFragParsed = function onFragParsed(data) {
                  var fragCurrent = this.fragCurrent;
                  var fragNew = data.frag;

                  if (fragCurrent && data.id === 'main' && fragNew.sn ===
                      fragCurrent.sn && fragNew.level === fragCurrent.level &&
                      this.state ===
                      __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].PARSING) {
                    this.stats.tparsed = window.performance.now();
                    this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].PARSED;

                    this._checkAppendedParsed();
                  }
                };

                _proto.onAudioTrackSwitching = function onAudioTrackSwitching(data) {
                  // if any URL found on new audio track, it is an alternate audio track
                  var altAudio = !!data.url,
                      trackId = data.id; // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
                  // don't do anything if we switch to alt audio: audio stream controller is handling it.
                  // we will just have to change buffer scheduling on audioTrackSwitched

                  if (!altAudio) {
                    if (this.mediaBuffer !== this.media) {
                      __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                          'switching on main audio, use media.buffered to schedule main fragment loading');
                      this.mediaBuffer = this.media;
                      var fragCurrent = this.fragCurrent; // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch

                      if (fragCurrent.loader) {
                        __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                            'switching to main audio track, cancel main fragment load');
                        fragCurrent.loader.abort();
                      }

                      this.fragCurrent = null;
                      this.fragPrevious = null; // destroy demuxer to force init segment generation (following audio switch)

                      if (this.demuxer) {
                        this.demuxer.destroy();
                        this.demuxer = null;
                      } // switch to IDLE state to load new fragment

                      this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE;
                    }

                    var hls = this.hls; // switching to main audio, flush all audio and trigger track switched

                    hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_FLUSHING,
                        {
                          startOffset: 0,
                          endOffset: Number.POSITIVE_INFINITY,
                          type: 'audio',
                        });
                    hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].AUDIO_TRACK_SWITCHED,
                        {
                          id: trackId,
                        });
                    this.altAudio = false;
                  }
                };

                _proto.onAudioTrackSwitched = function onAudioTrackSwitched(data) {
                  var trackId = data.id,
                      altAudio = !!this.hls.audioTracks[trackId].url;

                  if (altAudio) {
                    var videoBuffer = this.videoBuffer; // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered

                    if (videoBuffer && this.mediaBuffer !== videoBuffer) {
                      __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                          'switching on alternate audio, use video.buffered to schedule main fragment loading');
                      this.mediaBuffer = videoBuffer;
                    }
                  }

                  this.altAudio = altAudio;
                  this.tick();
                };

                _proto.onBufferCreated = function onBufferCreated(data) {
                  var tracks = data.tracks,
                      mediaTrack,
                      name,
                      alternate = false;

                  for (var type in tracks) {
                    var track = tracks[type];

                    if (track.id === 'main') {
                      name = type;
                      mediaTrack = track; // keep video source buffer reference

                      if (type === 'video') {
                        this.videoBuffer = tracks[type].buffer;
                      }
                    } else {
                      alternate = true;
                    }
                  }

                  if (alternate && mediaTrack) {
                    __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                        'alternate track found, use ' + name +
                        '.buffered to schedule main fragment loading');
                    this.mediaBuffer = mediaTrack.buffer;
                  } else {
                    this.mediaBuffer = this.media;
                  }
                };

                _proto.onBufferAppended = function onBufferAppended(data) {
                  if (data.parent === 'main') {
                    var state = this.state;

                    if (state ===
                        __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].PARSING ||
                        state ===
                        __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].PARSED) {
                      // check if all buffers have been appended
                      this.pendingBuffering = data.pending > 0;

                      this._checkAppendedParsed();
                    }
                  }
                };

                _proto._checkAppendedParsed = function _checkAppendedParsed() {
                  // trigger handler right now
                  if (this.state ===
                      __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].PARSED &&
                      (!this.appended || !this.pendingBuffering)) {
                    var frag = this.fragCurrent;

                    if (frag) {
                      var media = this.mediaBuffer
                          ? this.mediaBuffer
                          : this.media;
                      __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                          'main buffered : ' +
                          __WEBPACK_IMPORTED_MODULE_9__utils_time_ranges__['a' /* default */].toString(
                              media.buffered));
                      this.fragPrevious = frag;
                      var stats = this.stats;
                      stats.tbuffered = window.performance.now(); // we should get rid of this.fragLastKbps

                      this.fragLastKbps = Math.round(
                          8 * stats.total / (stats.tbuffered - stats.tfirst));
                      this.hls.trigger(
                          __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_BUFFERED,
                          {
                            stats: stats,
                            frag: frag,
                            id: 'main',
                          });
                      this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE;
                    }

                    this.tick();
                  }
                };

                _proto.onError = function onError(data) {
                  var frag = data.frag || this.fragCurrent; // don't handle frag error not related to main fragment

                  if (frag && frag.type !== 'main') {
                    return;
                  } // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end

                  var mediaBuffered = !!this.media &&
                      __WEBPACK_IMPORTED_MODULE_2__utils_buffer_helper__['a' /* BufferHelper */].isBuffered(
                          this.media, this.media.currentTime) &&
                      __WEBPACK_IMPORTED_MODULE_2__utils_buffer_helper__['a' /* BufferHelper */].isBuffered(
                          this.media, this.media.currentTime + 0.5);

                  switch (data.details) {
                    case __WEBPACK_IMPORTED_MODULE_10__errors__['a' /* ErrorDetails */].FRAG_LOAD_ERROR:
                    case __WEBPACK_IMPORTED_MODULE_10__errors__['a' /* ErrorDetails */].FRAG_LOAD_TIMEOUT:
                    case __WEBPACK_IMPORTED_MODULE_10__errors__['a' /* ErrorDetails */].KEY_LOAD_ERROR:
                    case __WEBPACK_IMPORTED_MODULE_10__errors__['a' /* ErrorDetails */].KEY_LOAD_TIMEOUT:
                      if (!data.fatal) {
                        // keep retrying until the limit will be reached
                        if (this.fragLoadError + 1 <=
                            this.config.fragLoadingMaxRetry) {
                          // exponential backoff capped to config.fragLoadingMaxRetryTimeout
                          var delay = Math.min(Math.pow(2, this.fragLoadError) *
                              this.config.fragLoadingRetryDelay,
                              this.config.fragLoadingMaxRetryTimeout);
                          __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].warn(
                              'mediaController: frag loading failed, retry in ' +
                              delay + ' ms');
                          this.retryDate = window.performance.now() + delay; // retry loading state
                          // if loadedmetadata is not set, it means that we are emergency switch down on first frag
                          // in that case, reset startFragRequested flag

                          if (!this.loadedmetadata) {
                            this.startFragRequested = false;
                            this.nextLoadPosition = this.startPosition;
                          }

                          this.fragLoadError++;
                          this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].FRAG_LOADING_WAITING_RETRY;
                        } else {
                          __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].error(
                              'mediaController: ' + data.details +
                              ' reaches max retry, redispatch as fatal ...'); // switch error to fatal

                          data.fatal = true;
                          this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].ERROR;
                        }
                      }

                      break;

                    case __WEBPACK_IMPORTED_MODULE_10__errors__['a' /* ErrorDetails */].LEVEL_LOAD_ERROR:
                    case __WEBPACK_IMPORTED_MODULE_10__errors__['a' /* ErrorDetails */].LEVEL_LOAD_TIMEOUT:
                      if (this.state !==
                          __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].ERROR) {
                        if (data.fatal) {
                          // if fatal error, stop processing
                          this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].ERROR;
                          __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].warn(
                              'streamController: ' + data.details +
                              ',switch to ' + this.state + ' state ...');
                        } else {
                          // in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE
                          if (!data.levelRetry && this.state ===
                              __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].WAITING_LEVEL) {
                            this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE;
                          }
                        }
                      }

                      break;

                    case __WEBPACK_IMPORTED_MODULE_10__errors__['a' /* ErrorDetails */].BUFFER_FULL_ERROR:
                      // if in appending state
                      if (data.parent === 'main' && (this.state ===
                          __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].PARSING ||
                          this.state ===
                          __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].PARSED)) {
                        // reduce max buf len if current position is buffered
                        if (mediaBuffered) {
                          this._reduceMaxBufferLength(
                              this.config.maxBufferLength);

                          this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE;
                        } else {
                          // current position is not buffered, but browser is still complaining about buffer full error
                          // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
                          // in that case flush the whole buffer to recover
                          __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].warn(
                              'buffer full error also media.currentTime is not buffered, flush everything');
                          this.fragCurrent = null; // flush everything

                          this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
                        }
                      }

                      break;

                    default:
                      break;
                  }
                };

                _proto._reduceMaxBufferLength = function _reduceMaxBufferLength(minLength) {
                  var config = this.config;

                  if (config.maxMaxBufferLength >= minLength) {
                    // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
                    config.maxMaxBufferLength /= 2;
                    __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].warn(
                        'main:reduce max buffer length to ' +
                        config.maxMaxBufferLength + 's');
                    return true;
                  }

                  return false;
                }
                /**
                 * Checks the health of the buffer and attempts to resolve playback stalls.
                 * @private
                 */
                ;

                _proto._checkBuffer = function _checkBuffer() {
                  var media = this.media;

                  if (!media || media.readyState === 0) {
                    // Exit early if we don't have media or if the media hasn't bufferd anything yet (readyState 0)
                    return;
                  }

                  var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
                  var buffered = mediaBuffer.buffered;

                  if (!this.loadedmetadata && buffered.length) {
                    this.loadedmetadata = true;

                    this._seekToStartPos();
                  } else if (this.immediateSwitch) {
                    this.immediateLevelSwitchEnd();
                  } else {
                    this.gapController.poll(this.lastCurrentTime, buffered);
                  }
                };

                _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {
                  this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE; // if loadedmetadata is not set, it means that we are emergency switch down on first frag
                  // in that case, reset startFragRequested flag

                  if (!this.loadedmetadata) {
                    this.startFragRequested = false;
                    this.nextLoadPosition = this.startPosition;
                  }

                  this.tick();
                };

                _proto.onBufferFlushed = function onBufferFlushed() {
                  /* after successful buffer flushing, filter flushed fragments from bufferedFrags
      use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
    */
                  var media = this.mediaBuffer ? this.mediaBuffer : this.media;

                  if (media) {
                    // filter fragments potentially evicted from buffer. this is to avoid memleak on live streams
                    this.fragmentTracker.detectEvictedFragments(
                        __WEBPACK_IMPORTED_MODULE_6__loader_fragment__['a' /* ElementaryStreamTypes */].VIDEO,
                        media.buffered);
                  } // move to IDLE once flush complete. this should trigger new fragment loading

                  this.state = __WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['a' /* State */].IDLE; // reset reference to frag

                  this.fragPrevious = null;
                };

                _proto.swapAudioCodec = function swapAudioCodec() {
                  this.audioCodecSwap = !this.audioCodecSwap;
                }
                /**
                 * Seeks to the set startPosition if not equal to the mediaElement's current time.
                 * @private
                 */
                ;

                _proto._seekToStartPos = function _seekToStartPos() {
                  var media = this.media;
                  var currentTime = media.currentTime; // only adjust currentTime if different from startPosition or if startPosition not buffered
                  // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered

                  var startPosition = media.seeking
                      ? currentTime
                      : this.startPosition; // if currentTime not matching with expected startPosition or startPosition not buffered but close to first buffered

                  if (currentTime !== startPosition && startPosition >= 0) {
                    // if startPosition not buffered, let's seek to buffered.start(0)
                    __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                        'target start position not buffered, seek to buffered.start(0) ' +
                        startPosition + ' from current time ' + currentTime +
                        ' ');
                    media.currentTime = startPosition;
                  }
                };

                _proto._getAudioCodec = function _getAudioCodec(currentLevel) {
                  var audioCodec = this.config.defaultAudioCodec ||
                      currentLevel.audioCodec;

                  if (this.audioCodecSwap) {
                    __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                        'swapping playlist audio codec');

                    if (audioCodec) {
                      if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                        audioCodec = 'mp4a.40.2';
                      } else {
                        audioCodec = 'mp4a.40.5';
                      }
                    }
                  }

                  return audioCodec;
                };

                _createClass(StreamController, [
                  {
                    key: 'state',
                    set: function set(nextState) {
                      if (this.state !== nextState) {
                        var previousState = this.state;
                        this._state = nextState;
                        __WEBPACK_IMPORTED_MODULE_11__utils_logger__['b' /* logger */].log(
                            'main stream-controller: ' + previousState + '->' +
                            nextState);
                        this.hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].STREAM_STATE_TRANSITION,
                            {
                              previousState: previousState,
                              nextState: nextState,
                            });
                      }
                    },
                    get: function get() {
                      return this._state;
                    },
                  }, {
                    key: 'currentLevel',
                    get: function get() {
                      var media = this.media;

                      if (media) {
                        var frag = this.getBufferedFrag(media.currentTime);

                        if (frag) {
                          return frag.level;
                        }
                      }

                      return -1;
                    },
                  }, {
                    key: 'nextBufferedFrag',
                    get: function get() {
                      var media = this.media;

                      if (media) {
                        // first get end range of current fragment
                        return this.followingBufferedFrag(
                            this.getBufferedFrag(media.currentTime));
                      } else {
                        return null;
                      }
                    },
                  }, {
                    key: 'nextLevel',
                    get: function get() {
                      var frag = this.nextBufferedFrag;

                      if (frag) {
                        return frag.level;
                      } else {
                        return -1;
                      }
                    },
                  }, {
                    key: 'liveSyncPosition',
                    get: function get() {
                      return this._liveSyncPosition;
                    },
                    set: function set(value) {
                      this._liveSyncPosition = value;
                    },
                  }]);

                return StreamController;
              }(__WEBPACK_IMPORTED_MODULE_15__base_stream_controller__['b' /* default */]);

          /* harmony default export */
          __webpack_exports__['a'] = (StreamController);

          /***/
        }),
        /* 44 */
        /***/ (function(module, exports, __webpack_require__) {

          function webpackBootstrapFunc(modules) {
            /******/
            // The module cache

            /******/
            var installedModules = {};
            /******/
            // The require function

            /******/

            function __webpack_require__(moduleId) {
              /******/
              // Check if module is in cache

              /******/
              if (installedModules[moduleId])
                  /******/
                return installedModules[moduleId].exports;
              /******/
              // Create a new module (and put it into the cache)

              /******/

              var module = installedModules[moduleId] = {
                /******/
                i: moduleId,

                /******/
                l: false,

                /******/
                exports: {},
                /******/

              };
              /******/
              // Execute the module function

              /******/

              modules[moduleId].call(module.exports, module, module.exports,
                  __webpack_require__);
              /******/
              // Flag the module as loaded

              /******/

              module.l = true;
              /******/
              // Return the exports of the module

              /******/

              return module.exports;
              /******/
            }

            /******/
            // expose the modules object (__webpack_modules__)

            /******/

            __webpack_require__.m = modules;
            /******/
            // expose the module cache

            /******/

            __webpack_require__.c = installedModules;
            /******/
            // identity function for calling harmony imports with the correct context

            /******/

            __webpack_require__.i = function(value) {
              return value;
            };
            /******/
            // define getter function for harmony exports

            /******/

            __webpack_require__.d = function(exports, name, getter) {
              /******/
              if (!__webpack_require__.o(exports, name)) {
                /******/
                Object.defineProperty(exports, name, {
                  /******/
                  configurable: false,

                  /******/
                  enumerable: true,

                  /******/
                  get: getter,
                  /******/

                });
                /******/
              }
              /******/

            };
            /******/
            // define __esModule on exports

            /******/

            __webpack_require__.r = function(exports) {
              /******/
              Object.defineProperty(exports, '__esModule', {
                value: true,
              });
              /******/
            };
            /******/
            // getDefaultExport function for compatibility with non-harmony modules

            /******/

            __webpack_require__.n = function(module) {
              /******/
              var getter = module && module.__esModule ?
                  /******/
                  function getDefault() {
                    return module['default'];
                  } :
                  /******/
                  function getModuleExports() {
                    return module;
                  };
              /******/

              __webpack_require__.d(getter, 'a', getter);
              /******/

              return getter;
              /******/
            };
            /******/
            // Object.prototype.hasOwnProperty.call

            /******/

            __webpack_require__.o = function(object, property) {
              return Object.prototype.hasOwnProperty.call(object, property);
            };
            /******/
            // __webpack_public_path__

            /******/

            __webpack_require__.p = '/';
            /******/
            // on error function for async loading

            /******/

            __webpack_require__.oe = function(err) {
              console.error(err);
              throw err;
            };

            var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE);

            return f.default || f; // try to call default if defined to also support babel esmodule exports
          }

          var moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@]+';
          var dependencyRegExp = '\\(\\s*(\/\\*.*?\\*\/)?\\s*.*?(' +
              moduleNameReqExp + ').*?\\)'; // additional chars when output.pathinfo is true
// http://stackoverflow.com/a/2593661/130442

          function quoteRegExp(str) {
            return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
          }

          function isNumeric(n) {
            return !isNaN(1 * n); // 1 * n converts integers, integers as string ("123"), 1e3 and "1e3" to integers and strings to NaN
          }

          function getModuleDependencies(sources, module, queueName) {
            var retval = {};
            retval[queueName] = [];
            var fnString = module.toString();
            var wrapperSignature = fnString.match(
                /^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/);
            if (!wrapperSignature) return retval;
            var webpackRequireName = wrapperSignature[1]; // main bundle deps

            var re = new RegExp(
                '(\\\\n|\\W)' + quoteRegExp(webpackRequireName) +
                dependencyRegExp, 'g');
            var match;

            while (match = re.exec(fnString)) {
              if (match[3] === 'dll-reference') continue;
              retval[queueName].push(match[3]);
            } // dll deps

            re = new RegExp('\\(' + quoteRegExp(webpackRequireName) +
                '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' +
                dependencyRegExp, 'g');

            while (match = re.exec(fnString)) {
              if (!sources[match[2]]) {
                retval[queueName].push(match[1]);
                sources[match[2]] = __webpack_require__(match[1]).m;
              }

              retval[match[2]] = retval[match[2]] || [];
              retval[match[2]].push(match[4]);
            } // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3

            var keys = Object.keys(retval);

            for (var i = 0; i < keys.length; i++) {
              for (var j = 0; j < retval[keys[i]].length; j++) {
                if (isNumeric(retval[keys[i]][j])) {
                  retval[keys[i]][j] = 1 * retval[keys[i]][j];
                }
              }
            }

            return retval;
          }

          function hasValuesInQueues(queues) {
            var keys = Object.keys(queues);
            return keys.reduce(function(hasValues, key) {
              return hasValues || queues[key].length > 0;
            }, false);
          }

          function getRequiredModules(sources, moduleId) {
            var modulesQueue = {
              main: [moduleId],
            };
            var requiredModules = {
              main: [],
            };
            var seenModules = {
              main: {},
            };

            while (hasValuesInQueues(modulesQueue)) {
              var queues = Object.keys(modulesQueue);

              for (var i = 0; i < queues.length; i++) {
                var queueName = queues[i];
                var queue = modulesQueue[queueName];
                var moduleToCheck = queue.pop();
                seenModules[queueName] = seenModules[queueName] || {};
                if (seenModules[queueName][moduleToCheck] ||
                    !sources[queueName][moduleToCheck]) continue;
                seenModules[queueName][moduleToCheck] = true;
                requiredModules[queueName] = requiredModules[queueName] || [];
                requiredModules[queueName].push(moduleToCheck);
                var newModules = getModuleDependencies(sources,
                    sources[queueName][moduleToCheck], queueName);
                var newModulesKeys = Object.keys(newModules);

                for (var j = 0; j < newModulesKeys.length; j++) {
                  modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] ||
                      [];
                  modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(
                      newModules[newModulesKeys[j]]);
                }
              }
            }

            return requiredModules;
          }

          module.exports = function(moduleId, options) {
            options = options || {};
            var sources = {
              main: __webpack_require__.m,
            };
            var requiredModules = options.all ? {
              main: Object.keys(sources.main),
            } : getRequiredModules(sources, moduleId);
            var src = '';
            Object.keys(requiredModules).filter(function(m) {
              return m !== 'main';
            }).forEach(function(module) {
              var entryModule = 0;

              while (requiredModules[module][entryModule]) {
                entryModule++;
              }

              requiredModules[module].push(entryModule);
              sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })';
              src = src + 'var ' + module + ' = (' +
                  webpackBootstrapFunc.toString().
                      replace('ENTRY_MODULE', JSON.stringify(entryModule)) +
                  ')({' + requiredModules[module].map(function(id) {
                    return '' + JSON.stringify(id) + ': ' +
                        sources[module][id].toString();
                  }).join(',') + '});\n';
            });
            src = src + 'new ((' + webpackBootstrapFunc.toString().
                    replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' +
                requiredModules.main.map(function(id) {
                  return '' + JSON.stringify(id) + ': ' +
                      sources.main[id].toString();
                }).join(',') + '}))(self);';
            var blob = new window.Blob([src], {
              type: 'text/javascript',
            });

            if (options.bare) {
              return blob;
            }

            var URL = window.URL || window.webkitURL || window.mozURL ||
                window.msURL;
            var workerUrl = URL.createObjectURL(blob);
            var worker = new window.Worker(workerUrl);
            worker.objectURL = workerUrl;
            return worker;
          };

          /***/
        }),
        /* 45 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return AESCrypto; });
          var AESCrypto =
              /*#__PURE__*/
              function() {
                function AESCrypto(subtle, iv) {
                  this.subtle = subtle;
                  this.aesIV = iv;
                }

                var _proto = AESCrypto.prototype;

                _proto.decrypt = function decrypt(data, key) {
                  return this.subtle.decrypt({
                    name: 'AES-CBC',
                    iv: this.aesIV,
                  }, key, data);
                };

                return AESCrypto;
              }();

          /***/
        }),
        /* 46 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          var FastAESKey =
              /*#__PURE__*/
              function() {
                function FastAESKey(subtle, key) {
                  this.subtle = subtle;
                  this.key = key;
                }

                var _proto = FastAESKey.prototype;

                _proto.expandKey = function expandKey() {
                  return this.subtle.importKey('raw', this.key, {
                    name: 'AES-CBC',
                  }, false, ['encrypt', 'decrypt']);
                };

                return FastAESKey;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (FastAESKey);

          /***/
        }),
        /* 47 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* unused harmony export removePadding */

// PKCS7
          function removePadding(buffer) {
            var outputBytes = buffer.byteLength;
            var paddingBytes = outputBytes &&
                new DataView(buffer).getUint8(outputBytes - 1);

            if (paddingBytes) {
              return buffer.slice(0, outputBytes - paddingBytes);
            } else {
              return buffer;
            }
          }

          var AESDecryptor =
              /*#__PURE__*/
              function() {
                function AESDecryptor() {
                  // Static after running initTable
                  this.rcon = [
                    0x0,
                    0x1,
                    0x2,
                    0x4,
                    0x8,
                    0x10,
                    0x20,
                    0x40,
                    0x80,
                    0x1b,
                    0x36];
                  this.subMix = [
                    new Uint32Array(256),
                    new Uint32Array(256),
                    new Uint32Array(256),
                    new Uint32Array(256)];
                  this.invSubMix = [
                    new Uint32Array(256),
                    new Uint32Array(256),
                    new Uint32Array(256),
                    new Uint32Array(256)];
                  this.sBox = new Uint32Array(256);
                  this.invSBox = new Uint32Array(256); // Changes during runtime

                  this.key = new Uint32Array(0);
                  this.initTable();
                } // Using view.getUint32() also swaps the byte order.

                var _proto = AESDecryptor.prototype;

                _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {
                  var view = new DataView(arrayBuffer);
                  var newArray = new Uint32Array(4);

                  for (var i = 0; i < 4; i++) {
                    newArray[i] = view.getUint32(i * 4);
                  }

                  return newArray;
                };

                _proto.initTable = function initTable() {
                  var sBox = this.sBox;
                  var invSBox = this.invSBox;
                  var subMix = this.subMix;
                  var subMix0 = subMix[0];
                  var subMix1 = subMix[1];
                  var subMix2 = subMix[2];
                  var subMix3 = subMix[3];
                  var invSubMix = this.invSubMix;
                  var invSubMix0 = invSubMix[0];
                  var invSubMix1 = invSubMix[1];
                  var invSubMix2 = invSubMix[2];
                  var invSubMix3 = invSubMix[3];
                  var d = new Uint32Array(256);
                  var x = 0;
                  var xi = 0;
                  var i = 0;

                  for (i = 0; i < 256; i++) {
                    if (i < 128) {
                      d[i] = i << 1;
                    } else {
                      d[i] = i << 1 ^ 0x11b;
                    }
                  }

                  for (i = 0; i < 256; i++) {
                    var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
                    sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
                    sBox[x] = sx;
                    invSBox[sx] = x; // Compute multiplication

                    var x2 = d[x];
                    var x4 = d[x2];
                    var x8 = d[x4]; // Compute sub/invSub bytes, mix columns tables

                    var t = d[sx] * 0x101 ^ sx * 0x1010100;
                    subMix0[x] = t << 24 | t >>> 8;
                    subMix1[x] = t << 16 | t >>> 16;
                    subMix2[x] = t << 8 | t >>> 24;
                    subMix3[x] = t; // Compute inv sub bytes, inv mix columns tables

                    t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x *
                        0x1010100;
                    invSubMix0[sx] = t << 24 | t >>> 8;
                    invSubMix1[sx] = t << 16 | t >>> 16;
                    invSubMix2[sx] = t << 8 | t >>> 24;
                    invSubMix3[sx] = t; // Compute next counter

                    if (!x) {
                      x = xi = 1;
                    } else {
                      x = x2 ^ d[d[d[x8 ^ x2]]];
                      xi ^= d[d[xi]];
                    }
                  }
                };

                _proto.expandKey = function expandKey(keyBuffer) {
                  // convert keyBuffer to Uint32Array
                  var key = this.uint8ArrayToUint32Array_(keyBuffer);
                  var sameKey = true;
                  var offset = 0;

                  while (offset < key.length && sameKey) {
                    sameKey = key[offset] === this.key[offset];
                    offset++;
                  }

                  if (sameKey) {
                    return;
                  }

                  this.key = key;
                  var keySize = this.keySize = key.length;

                  if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
                    throw new Error('Invalid aes key size=' + keySize);
                  }

                  var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
                  var ksRow;
                  var invKsRow;
                  var keySchedule = this.keySchedule = new Uint32Array(ksRows);
                  var invKeySchedule = this.invKeySchedule = new Uint32Array(
                      ksRows);
                  var sbox = this.sBox;
                  var rcon = this.rcon;
                  var invSubMix = this.invSubMix;
                  var invSubMix0 = invSubMix[0];
                  var invSubMix1 = invSubMix[1];
                  var invSubMix2 = invSubMix[2];
                  var invSubMix3 = invSubMix[3];
                  var prev;
                  var t;

                  for (ksRow = 0; ksRow < ksRows; ksRow++) {
                    if (ksRow < keySize) {
                      prev = keySchedule[ksRow] = key[ksRow];
                      continue;
                    }

                    t = prev;

                    if (ksRow % keySize === 0) {
                      // Rot word
                      t = t << 8 | t >>> 24; // Sub word

                      t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 |
                          sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff]; // Mix Rcon

                      t ^= rcon[ksRow / keySize | 0] << 24;
                    } else if (keySize > 6 && ksRow % keySize === 4) {
                      // Sub word
                      t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 |
                          sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
                    }

                    keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^
                        t) >>> 0;
                  }

                  for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                    ksRow = ksRows - invKsRow;

                    if (invKsRow & 3) {
                      t = keySchedule[ksRow];
                    } else {
                      t = keySchedule[ksRow - 4];
                    }

                    if (invKsRow < 4 || ksRow <= 4) {
                      invKeySchedule[invKsRow] = t;
                    } else {
                      invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^
                          invSubMix1[sbox[t >>> 16 & 0xff]] ^
                          invSubMix2[sbox[t >>> 8 & 0xff]] ^
                          invSubMix3[sbox[t & 0xff]];
                    }

                    invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
                  }
                } // Adding this as a method greatly improves performance.
                ;

                _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {
                  return word << 24 | (word & 0xff00) << 8 |
                      (word & 0xff0000) >> 8 | word >>> 24;
                };

                _proto.decrypt = function decrypt(
                    inputArrayBuffer, offset, aesIV, removePKCS7Padding) {
                  var nRounds = this.keySize + 6;
                  var invKeySchedule = this.invKeySchedule;
                  var invSBOX = this.invSBox;
                  var invSubMix = this.invSubMix;
                  var invSubMix0 = invSubMix[0];
                  var invSubMix1 = invSubMix[1];
                  var invSubMix2 = invSubMix[2];
                  var invSubMix3 = invSubMix[3];
                  var initVector = this.uint8ArrayToUint32Array_(aesIV);
                  var initVector0 = initVector[0];
                  var initVector1 = initVector[1];
                  var initVector2 = initVector[2];
                  var initVector3 = initVector[3];
                  var inputInt32 = new Int32Array(inputArrayBuffer);
                  var outputInt32 = new Int32Array(inputInt32.length);
                  var t0, t1, t2, t3;
                  var s0, s1, s2, s3;
                  var inputWords0, inputWords1, inputWords2, inputWords3;
                  var ksRow, i;
                  var swapWord = this.networkToHostOrderSwap;

                  while (offset < inputInt32.length) {
                    inputWords0 = swapWord(inputInt32[offset]);
                    inputWords1 = swapWord(inputInt32[offset + 1]);
                    inputWords2 = swapWord(inputInt32[offset + 2]);
                    inputWords3 = swapWord(inputInt32[offset + 3]);
                    s0 = inputWords0 ^ invKeySchedule[0];
                    s1 = inputWords3 ^ invKeySchedule[1];
                    s2 = inputWords2 ^ invKeySchedule[2];
                    s3 = inputWords1 ^ invKeySchedule[3];
                    ksRow = 4; // Iterate through the rounds of decryption

                    for (i = 1; i < nRounds; i++) {
                      t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^
                          invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^
                          invKeySchedule[ksRow];
                      t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^
                          invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^
                          invKeySchedule[ksRow + 1];
                      t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^
                          invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^
                          invKeySchedule[ksRow + 2];
                      t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^
                          invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^
                          invKeySchedule[ksRow + 3]; // Update state

                      s0 = t0;
                      s1 = t1;
                      s2 = t2;
                      s3 = t3;
                      ksRow = ksRow + 4;
                    } // Shift rows, sub bytes, add round key

                    t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] <<
                        16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^
                        invKeySchedule[ksRow];
                    t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] <<
                        16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^
                        invKeySchedule[ksRow + 1];
                    t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] <<
                        16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^
                        invKeySchedule[ksRow + 2];
                    t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] <<
                        16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^
                        invKeySchedule[ksRow + 3];
                    ksRow = ksRow + 3; // Write

                    outputInt32[offset] = swapWord(t0 ^ initVector0);
                    outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
                    outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
                    outputInt32[offset + 3] = swapWord(t1 ^ initVector3); // reset initVector to last 4 unsigned int

                    initVector0 = inputWords0;
                    initVector1 = inputWords1;
                    initVector2 = inputWords2;
                    initVector3 = inputWords3;
                    offset = offset + 4;
                  }

                  return removePKCS7Padding
                      ? removePadding(outputInt32.buffer)
                      : outputInt32.buffer;
                };

                _proto.destroy = function destroy() {
                  this.key = undefined;
                  this.keySize = undefined;
                  this.ksRows = undefined;
                  this.sBox = undefined;
                  this.invSBox = undefined;
                  this.subMix = undefined;
                  this.invSubMix = undefined;
                  this.keySchedule = undefined;
                  this.invKeySchedule = undefined;
                  this.rcon = undefined;
                };

                return AESDecryptor;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (AESDecryptor);

          /***/
        }),
        /* 48 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__adts__ = __webpack_require__(25);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__demux_id3__ = __webpack_require__(8);

          /**
           * AAC demuxer
           */




          var AACDemuxer =
              /*#__PURE__*/
              function() {
                function AACDemuxer(observer, remuxer, config) {
                  this.observer = observer;
                  this.config = config;
                  this.remuxer = remuxer;
                }

                var _proto = AACDemuxer.prototype;

                _proto.resetInitSegment = function resetInitSegment(
                    initSegment, audioCodec, videoCodec, duration) {
                  this._audioTrack = {
                    container: 'audio/adts',
                    type: 'audio',
                    id: 0,
                    sequenceNumber: 0,
                    isAAC: true,
                    samples: [],
                    len: 0,
                    manifestCodec: audioCodec,
                    duration: duration,
                    inputTimeScale: 90000,
                  };
                };

                _proto.resetTimeStamp = function resetTimeStamp() {};

                AACDemuxer.probe = function probe(data) {
                  if (!data) {
                    return false;
                  } // Check for the ADTS sync word
                  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
                  // Layer bits (position 14 and 15) in header should be always 0 for ADTS
                  // More info https://wiki.multimedia.cx/index.php?title=ADTS

                  var id3Data = __WEBPACK_IMPORTED_MODULE_3__demux_id3__['a' /* default */].getID3Data(
                      data, 0) || [];
                  var offset = id3Data.length;

                  for (var length = data.length; offset < length; offset++) {
                    if (__WEBPACK_IMPORTED_MODULE_1__adts__['e' /* probe */](
                        data, offset)) {
                      __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                          'ADTS sync word found !');
                      return true;
                    }
                  }

                  return false;
                } // feed incoming data to the front of the parsing pipeline
                ;

                _proto.append = function append(
                    data, timeOffset, contiguous, accurateTimeOffset) {
                  var track = this._audioTrack;
                  var id3Data = __WEBPACK_IMPORTED_MODULE_3__demux_id3__['a' /* default */].getID3Data(
                      data, 0) || [];
                  var timestamp = __WEBPACK_IMPORTED_MODULE_3__demux_id3__['a' /* default */].getTimeStamp(
                      id3Data);
                  var pts = Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      timestamp) ? timestamp * 90 : timeOffset * 90000;
                  var frameIndex = 0;
                  var stamp = pts;
                  var length = data.length;
                  var offset = id3Data.length;
                  var id3Samples = [
                    {
                      pts: stamp,
                      dts: stamp,
                      data: id3Data,
                    }];

                  while (offset < length - 1) {
                    if (__WEBPACK_IMPORTED_MODULE_1__adts__['d' /* isHeader */](
                        data, offset) && offset + 5 < length) {
                      __WEBPACK_IMPORTED_MODULE_1__adts__['c' /* initTrackConfig */](
                          track, this.observer, data, offset,
                          track.manifestCodec);
                      var frame = __WEBPACK_IMPORTED_MODULE_1__adts__['a' /* appendFrame */](
                          track, data, offset, pts, frameIndex);

                      if (frame) {
                        offset += frame.length;
                        stamp = frame.sample.pts;
                        frameIndex++;
                      } else {
                        __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                            'Unable to parse AAC frame');
                        break;
                      }
                    } else if (__WEBPACK_IMPORTED_MODULE_3__demux_id3__['a' /* default */].isHeader(
                        data, offset)) {
                      id3Data = __WEBPACK_IMPORTED_MODULE_3__demux_id3__['a' /* default */].getID3Data(
                          data, offset);
                      id3Samples.push({
                        pts: stamp,
                        dts: stamp,
                        data: id3Data,
                      });
                      offset += id3Data.length;
                    } else {
                      // nothing found, keep looking
                      offset++;
                    }
                  }

                  this.remuxer.remux(track, {
                    samples: [],
                  }, {
                    samples: id3Samples,
                    inputTimeScale: 90000,
                  }, {
                    samples: [],
                  }, timeOffset, contiguous, accurateTimeOffset);
                };

                _proto.destroy = function destroy() {};

                return AACDemuxer;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (AACDemuxer);

          /***/
        }),
        /* 49 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__adts__ = __webpack_require__(25);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__mpegaudio__ = __webpack_require__(
              26);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__exp_golomb__ = __webpack_require__(
              50);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__sample_aes__ = __webpack_require__(
              51);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_6__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_7__id3__ = __webpack_require__(8);
          /**
           * highly optimized TS demuxer:
           * parse PAT, PMT
           * extract PES packet from audio and video PIDs
           * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
           * trigger the remuxer upon parsing completion
           * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
           * it also controls the remuxing process :
           * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
           */




              // import Hex from '../utils/hex';

              // We are using fixed track IDs for driving the MP4 remuxer
// instead of following the TS PIDs.
// There is no reason not to do this and some browsers/SourceBuffer-demuxers
// may not like if there are TrackID "switches"
// See https://github.com/video-dev/hls.js/issues/1331
// Here we are mapping our internal track types to constant MP4 track IDs
// With MSE currently one can only have one track of each, and we are muxing
// whatever video/audio rendition in them.

          var RemuxerTrackIdConfig = {
                video: 1,
                audio: 2,
                id3: 3,
                text: 4,
              };

          var TSDemuxer =
              /*#__PURE__*/
              function() {
                function TSDemuxer(observer, remuxer, config, typeSupported) {
                  this.observer = observer;
                  this.config = config;
                  this.typeSupported = typeSupported;
                  this.remuxer = remuxer;
                  this.sampleAes = null;
                }

                var _proto = TSDemuxer.prototype;

                _proto.setDecryptData = function setDecryptData(decryptdata) {
                  if (decryptdata != null && decryptdata.key != null &&
                      decryptdata.method === 'SAMPLE-AES') {
                    this.sampleAes = new __WEBPACK_IMPORTED_MODULE_4__sample_aes__['a' /* default */](
                        this.observer, this.config, decryptdata,
                        this.discardEPB);
                  } else {
                    this.sampleAes = null;
                  }
                };

                TSDemuxer.probe = function probe(data) {
                  var syncOffset = TSDemuxer._syncOffset(data);

                  if (syncOffset < 0) {
                    return false;
                  } else {
                    if (syncOffset) {
                      __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].warn(
                          'MPEG2-TS detected but first sync word found @ offset ' +
                          syncOffset + ', junk ahead ?');
                    }

                    return true;
                  }
                };

                TSDemuxer._syncOffset = function _syncOffset(data) {
                  // scan 1000 first bytes
                  var scanwindow = Math.min(1000, data.length - 3 * 188);
                  var i = 0;

                  while (i < scanwindow) {
                    // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
                    if (data[i] === 0x47 && data[i + 188] === 0x47 &&
                        data[i + 2 * 188] === 0x47) {
                      return i;
                    } else {
                      i++;
                    }
                  }

                  return -1;
                }
                /**
                 * Creates a track model internal to demuxer used to drive remuxing input
                 *
                 * @param {string} type 'audio' | 'video' | 'id3' | 'text'
                 * @param {number} duration
                 * @return {object} TSDemuxer's internal track model
                 */
                ;

                TSDemuxer.createTrack = function createTrack(type, duration) {
                  return {
                    container: type === 'video' || type === 'audio'
                        ? 'video/mp2t'
                        : undefined,
                    type: type,
                    id: RemuxerTrackIdConfig[type],
                    pid: -1,
                    inputTimeScale: 90000,
                    sequenceNumber: 0,
                    samples: [],
                    dropped: type === 'video' ? 0 : undefined,
                    isAAC: type === 'audio' ? true : undefined,
                    duration: type === 'audio' ? duration : undefined,
                  };
                }
                /**
                 * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
                 * Resets all internal track instances of the demuxer.
                 *
                 * @override Implements generic demuxing/remuxing interface (see DemuxerInline)
                 * @param {object} initSegment
                 * @param {string} audioCodec
                 * @param {string} videoCodec
                 * @param {number} duration (in TS timescale = 90kHz)
                 */
                ;

                _proto.resetInitSegment = function resetInitSegment(
                    initSegment, audioCodec, videoCodec, duration) {
                  this.pmtParsed = false;
                  this._pmtId = -1;
                  this._avcTrack = TSDemuxer.createTrack('video', duration);
                  this._audioTrack = TSDemuxer.createTrack('audio', duration);
                  this._id3Track = TSDemuxer.createTrack('id3', duration);
                  this._txtTrack = TSDemuxer.createTrack('text', duration); // flush any partial content

                  this.aacOverFlow = null;
                  this.aacLastPTS = null;
                  this.avcSample = null;
                  this.audioCodec = audioCodec;
                  this.videoCodec = videoCodec;
                  this._duration = duration;
                }
                /**
                 *
                 * @override
                 */
                ;

                _proto.resetTimeStamp = function resetTimeStamp() {} // feed incoming data to the front of the parsing pipeline
                ;

                _proto.append = function append(
                    data, timeOffset, contiguous, accurateTimeOffset) {
                  var start,
                      len = data.length,
                      stt,
                      pid,
                      atf,
                      offset,
                      pes,
                      unknownPIDs = false;
                  this.contiguous = contiguous;

                  var pmtParsed = this.pmtParsed,
                      avcTrack = this._avcTrack,
                      audioTrack = this._audioTrack,
                      id3Track = this._id3Track,
                      avcId = avcTrack.pid,
                      audioId = audioTrack.pid,
                      id3Id = id3Track.pid,
                      pmtId = this._pmtId,
                      avcData = avcTrack.pesData,
                      audioData = audioTrack.pesData,
                      id3Data = id3Track.pesData,
                      parsePAT = this._parsePAT,
                      parsePMT = this._parsePMT,
                      parsePES = this._parsePES,
                      parseAVCPES = this._parseAVCPES.bind(this),
                      parseAACPES = this._parseAACPES.bind(this),
                      parseMPEGPES = this._parseMPEGPES.bind(this),
                      parseID3PES = this._parseID3PES.bind(this);

                  var syncOffset = TSDemuxer._syncOffset(data); // don't parse last TS packet if incomplete

                  len -= (len + syncOffset) % 188; // loop through TS packets

                  for (start = syncOffset; start < len; start += 188) {
                    if (data[start] === 0x47) {
                      stt = !!(data[start + 1] & 0x40); // pid is a 13-bit field starting at the last bit of TS[1]

                      pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
                      atf = (data[start + 3] & 0x30) >> 4; // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.

                      if (atf > 1) {
                        offset = start + 5 + data[start + 4]; // continue if there is only adaptation field

                        if (offset === start + 188) {
                          continue;
                        }
                      } else {
                        offset = start + 4;
                      }

                      switch (pid) {
                        case avcId:
                          if (stt) {
                            if (avcData && (pes = parsePES(avcData))) {
                              parseAVCPES(pes, false);
                            }

                            avcData = {
                              data: [],
                              size: 0,
                            };
                          }

                          if (avcData) {
                            avcData.data.push(
                                data.subarray(offset, start + 188));
                            avcData.size += start + 188 - offset;
                          }

                          break;

                        case audioId:
                          if (stt) {
                            if (audioData && (pes = parsePES(audioData))) {
                              if (audioTrack.isAAC) {
                                parseAACPES(pes);
                              } else {
                                parseMPEGPES(pes);
                              }
                            }

                            audioData = {
                              data: [],
                              size: 0,
                            };
                          }

                          if (audioData) {
                            audioData.data.push(
                                data.subarray(offset, start + 188));
                            audioData.size += start + 188 - offset;
                          }

                          break;

                        case id3Id:
                          if (stt) {
                            if (id3Data && (pes = parsePES(id3Data))) {
                              parseID3PES(pes);
                            }

                            id3Data = {
                              data: [],
                              size: 0,
                            };
                          }

                          if (id3Data) {
                            id3Data.data.push(
                                data.subarray(offset, start + 188));
                            id3Data.size += start + 188 - offset;
                          }

                          break;

                        case 0:
                          if (stt) {
                            offset += data[offset] + 1;
                          }

                          pmtId = this._pmtId = parsePAT(data, offset);
                          break;

                        case pmtId:
                          if (stt) {
                            offset += data[offset] + 1;
                          }

                          var parsedPIDs = parsePMT(data, offset,
                              this.typeSupported.mpeg === true ||
                              this.typeSupported.mp3 === true,
                              this.sampleAes != null); // only update track id if track PID found while parsing PMT
                          // this is to avoid resetting the PID to -1 in case
                          // track PID transiently disappears from the stream
                          // this could happen in case of transient missing audio samples for example
                          // NOTE this is only the PID of the track as found in TS,
                          // but we are not using this for MP4 track IDs.

                          avcId = parsedPIDs.avc;

                          if (avcId > 0) {
                            avcTrack.pid = avcId;
                          }

                          audioId = parsedPIDs.audio;

                          if (audioId > 0) {
                            audioTrack.pid = audioId;
                            audioTrack.isAAC = parsedPIDs.isAAC;
                          }

                          id3Id = parsedPIDs.id3;

                          if (id3Id > 0) {
                            id3Track.pid = id3Id;
                          }

                          if (unknownPIDs && !pmtParsed) {
                            __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                                'reparse from beginning');
                            unknownPIDs = false; // we set it to -188, the += 188 in the for loop will reset start to 0

                            start = syncOffset - 188;
                          }

                          pmtParsed = this.pmtParsed = true;
                          break;

                        case 17:
                        case 0x1fff:
                          break;

                        default:
                          unknownPIDs = true;
                          break;
                      }
                    } else {
                      this.observer.trigger(
                          __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].ERROR,
                          {
                            type: __WEBPACK_IMPORTED_MODULE_6__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                            details: __WEBPACK_IMPORTED_MODULE_6__errors__['a' /* ErrorDetails */].FRAG_PARSING_ERROR,
                            fatal: false,
                            reason: 'TS packet did not start with 0x47',
                          });
                    }
                  } // try to parse last PES packets

                  if (avcData && (pes = parsePES(avcData))) {
                    parseAVCPES(pes, true);
                    avcTrack.pesData = null;
                  } else {
                    // either avcData null or PES truncated, keep it for next frag parsing
                    avcTrack.pesData = avcData;
                  }

                  if (audioData && (pes = parsePES(audioData))) {
                    if (audioTrack.isAAC) {
                      parseAACPES(pes);
                    } else {
                      parseMPEGPES(pes);
                    }

                    audioTrack.pesData = null;
                  } else {
                    if (audioData && audioData.size) {
                      __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                          'last AAC PES packet truncated,might overlap between fragments');
                    } // either audioData null or PES truncated, keep it for next frag parsing

                    audioTrack.pesData = audioData;
                  }

                  if (id3Data && (pes = parsePES(id3Data))) {
                    parseID3PES(pes);
                    id3Track.pesData = null;
                  } else {
                    // either id3Data null or PES truncated, keep it for next frag parsing
                    id3Track.pesData = id3Data;
                  }

                  if (this.sampleAes == null) {
                    this.remuxer.remux(audioTrack, avcTrack, id3Track,
                        this._txtTrack, timeOffset, contiguous,
                        accurateTimeOffset);
                  } else {
                    this.decryptAndRemux(audioTrack, avcTrack, id3Track,
                        this._txtTrack, timeOffset, contiguous,
                        accurateTimeOffset);
                  }
                };

                _proto.decryptAndRemux = function decryptAndRemux(
                    audioTrack, videoTrack, id3Track, textTrack, timeOffset,
                    contiguous, accurateTimeOffset) {
                  if (audioTrack.samples && audioTrack.isAAC) {
                    var localthis = this;
                    this.sampleAes.decryptAacSamples(audioTrack.samples, 0,
                        function() {
                          localthis.decryptAndRemuxAvc(audioTrack, videoTrack,
                              id3Track, textTrack, timeOffset, contiguous,
                              accurateTimeOffset);
                        });
                  } else {
                    this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track,
                        textTrack, timeOffset, contiguous, accurateTimeOffset);
                  }
                };

                _proto.decryptAndRemuxAvc = function decryptAndRemuxAvc(
                    audioTrack, videoTrack, id3Track, textTrack, timeOffset,
                    contiguous, accurateTimeOffset) {
                  if (videoTrack.samples) {
                    var localthis = this;
                    this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0,
                        function() {
                          localthis.remuxer.remux(audioTrack, videoTrack,
                              id3Track, textTrack, timeOffset, contiguous,
                              accurateTimeOffset);
                        });
                  } else {
                    this.remuxer.remux(audioTrack, videoTrack, id3Track,
                        textTrack, timeOffset, contiguous, accurateTimeOffset);
                  }
                };

                _proto.destroy = function destroy() {
                  this._initPTS = this._initDTS = undefined;
                  this._duration = 0;
                };

                _proto._parsePAT = function _parsePAT(data, offset) {
                  // skip the PSI header and parse the first PMT entry
                  return (data[offset + 10] & 0x1F) << 8 | data[offset + 11]; // logger.log('PMT PID:'  + this._pmtId);
                };

                _proto._parsePMT = function _parsePMT(
                    data, offset, mpegSupported, isSampleAes) {
                  var sectionLength,
                      tableEnd,
                      programInfoLength,
                      pid,
                      result = {
                        audio: -1,
                        avc: -1,
                        id3: -1,
                        isAAC: true,
                      };
                  sectionLength = (data[offset + 1] & 0x0f) << 8 |
                      data[offset + 2];
                  tableEnd = offset + 3 + sectionLength - 4; // to determine where the table is, we have to figure out how
                  // long the program info descriptors are

                  programInfoLength = (data[offset + 10] & 0x0f) << 8 |
                      data[offset + 11]; // advance the offset to the first entry in the mapping table

                  offset += 12 + programInfoLength;

                  while (offset < tableEnd) {
                    pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];

                    switch (data[offset]) {
                      case 0xcf:
                        // SAMPLE-AES AAC
                        if (!isSampleAes) {
                          __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                              'unknown stream type:' + data[offset]);
                          break;
                        }

                        /* falls through */
                        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)

                      case 0x0f:
                        // logger.log('AAC PID:'  + pid);
                        if (result.audio === -1) {
                          result.audio = pid;
                        }

                        break;
                        // Packetized metadata (ID3)

                      case 0x15:
                        // logger.log('ID3 PID:'  + pid);
                        if (result.id3 === -1) {
                          result.id3 = pid;
                        }

                        break;

                      case 0xdb:
                        // SAMPLE-AES AVC
                        if (!isSampleAes) {
                          __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                              'unknown stream type:' + data[offset]);
                          break;
                        }

                        /* falls through */
                        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)

                      case 0x1b:
                        // logger.log('AVC PID:'  + pid);
                        if (result.avc === -1) {
                          result.avc = pid;
                        }

                        break;
                        // ISO/IEC 11172-3 (MPEG-1 audio)
                        // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)

                      case 0x03:
                      case 0x04:
                        // logger.log('MPEG PID:'  + pid);
                        if (!mpegSupported) {
                          __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                              'MPEG audio found, not supported in this browser for now');
                        } else if (result.audio === -1) {
                          result.audio = pid;
                          result.isAAC = false;
                        }

                        break;

                      case 0x24:
                        __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].warn(
                            'HEVC stream type found, not supported for now');
                        break;

                      default:
                        __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                            'unknown stream type:' + data[offset]);
                        break;
                    } // move to the next table entry
                    // skip past the elementary stream descriptors, if present

                    offset += ((data[offset + 3] & 0x0F) << 8 |
                        data[offset + 4]) + 5;
                  }

                  return result;
                };

                _proto._parsePES = function _parsePES(stream) {
                  var i = 0,
                      frag,
                      pesFlags,
                      pesPrefix,
                      pesLen,
                      pesHdrLen,
                      pesData,
                      pesPts,
                      pesDts,
                      payloadStartOffset,
                      data = stream.data; // safety check

                  if (!stream || stream.size === 0) {
                    return null;
                  } // we might need up to 19 bytes to read PES header
                  // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
                  // usually only one merge is needed (and this is rare ...)

                  while (data[0].length < 19 && data.length > 1) {
                    var newData = new Uint8Array(
                        data[0].length + data[1].length);
                    newData.set(data[0]);
                    newData.set(data[1], data[0].length);
                    data[0] = newData;
                    data.splice(1, 1);
                  } // retrieve PTS/DTS from first fragment

                  frag = data[0];
                  pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];

                  if (pesPrefix === 1) {
                    pesLen = (frag[4] << 8) + frag[5]; // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
                    // minus 6 : PES header size

                    if (pesLen && pesLen > stream.size - 6) {
                      return null;
                    }

                    pesFlags = frag[7];

                    if (pesFlags & 0xC0) {
                      /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
            as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
            as Bitwise operators treat their operands as a sequence of 32 bits */
                      pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
                          (frag[10] & 0xFF) * 4194304 + // 1 << 22
                          (frag[11] & 0xFE) * 16384 + // 1 << 14
                          (frag[12] & 0xFF) * 128 + // 1 << 7
                          (frag[13] & 0xFE) / 2; // check if greater than 2^32 -1

                      if (pesPts > 4294967295) {
                        // decrement 2^33
                        pesPts -= 8589934592;
                      }

                      if (pesFlags & 0x40) {
                        pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
                            (frag[15] & 0xFF) * 4194304 + // 1 << 22
                            (frag[16] & 0xFE) * 16384 + // 1 << 14
                            (frag[17] & 0xFF) * 128 + // 1 << 7
                            (frag[18] & 0xFE) / 2; // check if greater than 2^32 -1

                        if (pesDts > 4294967295) {
                          // decrement 2^33
                          pesDts -= 8589934592;
                        }

                        if (pesPts - pesDts > 60 * 90000) {
                          __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].warn(
                              Math.round((pesPts - pesDts) / 90000) +
                              's delta between PTS and DTS, align them');
                          pesPts = pesDts;
                        }
                      } else {
                        pesDts = pesPts;
                      }
                    }

                    pesHdrLen = frag[8]; // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension

                    payloadStartOffset = pesHdrLen + 9;

                    if (stream.size <= payloadStartOffset) {
                      return null;
                    }

                    stream.size -= payloadStartOffset; // reassemble PES packet

                    pesData = new Uint8Array(stream.size);

                    for (var j = 0, dataLen = data.length; j < dataLen; j++) {
                      frag = data[j];
                      var len = frag.byteLength;

                      if (payloadStartOffset) {
                        if (payloadStartOffset > len) {
                          // trim full frag if PES header bigger than frag
                          payloadStartOffset -= len;
                          continue;
                        } else {
                          // trim partial frag if PES header smaller than frag
                          frag = frag.subarray(payloadStartOffset);
                          len -= payloadStartOffset;
                          payloadStartOffset = 0;
                        }
                      }

                      pesData.set(frag, i);
                      i += len;
                    }

                    if (pesLen) {
                      // payload size : remove PES header + PES extension
                      pesLen -= pesHdrLen + 3;
                    }

                    return {
                      data: pesData,
                      pts: pesPts,
                      dts: pesDts,
                      len: pesLen,
                    };
                  } else {
                    return null;
                  }
                };

                _proto.pushAccesUnit = function pushAccesUnit(
                    avcSample, avcTrack) {
                  if (avcSample.units.length && avcSample.frame) {
                    var samples = avcTrack.samples;
                    var nbSamples = samples.length; // if sample does not have PTS/DTS, patch with last sample PTS/DTS

                    if (isNaN(avcSample.pts)) {
                      if (nbSamples) {
                        var lastSample = samples[nbSamples - 1];
                        avcSample.pts = lastSample.pts;
                        avcSample.dts = lastSample.dts;
                      } else {
                        // dropping samples, no timestamp found
                        avcTrack.dropped++;
                        return;
                      }
                    } // only push AVC sample if starting with a keyframe is not mandatory OR
                    //    if keyframe already found in this fragment OR
                    //       keyframe found in last fragment (track.sps) AND
                    //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous

                    if (!this.config.forceKeyFrameOnDiscontinuity ||
                        avcSample.key === true || avcTrack.sps &&
                        (nbSamples || this.contiguous)) {
                      avcSample.id = nbSamples;
                      samples.push(avcSample);
                    } else {
                      // dropped samples, track it
                      avcTrack.dropped++;
                    }
                  }

                  if (avcSample.debug.length) {
                    __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                        avcSample.pts + '/' + avcSample.dts + ':' +
                        avcSample.debug);
                  }
                };

                _proto._parseAVCPES = function _parseAVCPES(pes, last) {
                  var _this = this;

                  // logger.log('parse new PES');
                  var track = this._avcTrack,
                      units = this._parseAVCNALu(pes.data),
                      debug = false,
                      expGolombDecoder,
                      avcSample = this.avcSample,
                      push,
                      spsfound = false,
                      i,
                      pushAccesUnit = this.pushAccesUnit.bind(this),
                      createAVCSample = function createAVCSample(
                          key, pts, dts, debug) {
                        return {
                          key: key,
                          pts: pts,
                          dts: dts,
                          units: [],
                          debug: debug,
                        };
                      }; // free pes.data to save up some memory

                  pes.data = null; // if new NAL units found and last sample still there, let's push ...
                  // this helps parsing streams with missing AUD (only do this if AUD never found)

                  if (avcSample && units.length && !track.audFound) {
                    pushAccesUnit(avcSample, track);
                    avcSample = this.avcSample = createAVCSample(false, pes.pts,
                        pes.dts, '');
                  }

                  units.forEach(function(unit) {
                    switch (unit.type) {
                        // NDR
                      case 1:
                        push = true;

                        if (!avcSample) {
                          avcSample = _this.avcSample = createAVCSample(true,
                              pes.pts, pes.dts, '');
                        }

                        if (debug) {
                          avcSample.debug += 'NDR ';
                        }

                        avcSample.frame = true;
                        var data = unit.data; // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)

                        if (spsfound && data.length > 4) {
                          // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
                          var sliceType = new __WEBPACK_IMPORTED_MODULE_3__exp_golomb__['a' /* default */](
                              data).readSliceType(); // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
                          // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
                          // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
                          // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
                          // if (sliceType === 2 || sliceType === 7) {

                          if (sliceType === 2 || sliceType === 4 ||
                              sliceType === 7 || sliceType === 9) {
                            avcSample.key = true;
                          }
                        }

                        break;
                        // IDR

                      case 5:
                        push = true; // handle PES not starting with AUD

                        if (!avcSample) {
                          avcSample = _this.avcSample = createAVCSample(true,
                              pes.pts, pes.dts, '');
                        }

                        if (debug) {
                          avcSample.debug += 'IDR ';
                        }

                        avcSample.key = true;
                        avcSample.frame = true;
                        break;
                        // SEI

                      case 6:
                        push = true;

                        if (debug && avcSample) {
                          avcSample.debug += 'SEI ';
                        }

                        expGolombDecoder = new __WEBPACK_IMPORTED_MODULE_3__exp_golomb__['a' /* default */](
                            _this.discardEPB(unit.data)); // skip frameType

                        expGolombDecoder.readUByte();
                        var payloadType = 0;
                        var payloadSize = 0;
                        var endOfCaptions = false;
                        var b = 0;

                        while (!endOfCaptions &&
                        expGolombDecoder.bytesAvailable > 1) {
                          payloadType = 0;

                          do {
                            b = expGolombDecoder.readUByte();
                            payloadType += b;
                          } while (b === 0xFF); // Parse payload size.

                          payloadSize = 0;

                          do {
                            b = expGolombDecoder.readUByte();
                            payloadSize += b;
                          } while (b === 0xFF); // TODO: there can be more than one payload in an SEI packet...
                          // TODO: need to read type and size in a while loop to get them all

                          if (payloadType === 4 &&
                              expGolombDecoder.bytesAvailable !== 0) {
                            endOfCaptions = true;
                            var countryCode = expGolombDecoder.readUByte();

                            if (countryCode === 181) {
                              var providerCode = expGolombDecoder.readUShort();

                              if (providerCode === 49) {
                                var userStructure = expGolombDecoder.readUInt();

                                if (userStructure === 0x47413934) {
                                  var userDataType = expGolombDecoder.readUByte(); // Raw CEA-608 bytes wrapped in CEA-708 packet

                                  if (userDataType === 3) {
                                    var firstByte = expGolombDecoder.readUByte();
                                    var secondByte = expGolombDecoder.readUByte();
                                    var totalCCs = 31 & firstByte;
                                    var byteArray = [firstByte, secondByte];

                                    for (i = 0; i < totalCCs; i++) {
                                      // 3 bytes per CC
                                      byteArray.push(
                                          expGolombDecoder.readUByte());
                                      byteArray.push(
                                          expGolombDecoder.readUByte());
                                      byteArray.push(
                                          expGolombDecoder.readUByte());
                                    }

                                    _this._insertSampleInOrder(
                                        _this._txtTrack.samples, {
                                          type: 3,
                                          pts: pes.pts,
                                          bytes: byteArray,
                                        });
                                  }
                                }
                              }
                            }
                          } else if (payloadType === 5 &&
                              expGolombDecoder.bytesAvailable !== 0) {
                            endOfCaptions = true;

                            if (payloadSize > 16) {
                              var uuidStrArray = [];

                              for (i = 0; i < 16; i++) {
                                uuidStrArray.push(
                                    expGolombDecoder.readUByte().toString(16));

                                if (i === 3 || i === 5 || i === 7 || i === 9) {
                                  uuidStrArray.push('-');
                                }
                              }

                              var length = payloadSize - 16;
                              var userDataPayloadBytes = new Uint8Array(length);

                              for (i = 0; i < length; i++) {
                                userDataPayloadBytes[i] = expGolombDecoder.readUByte();
                              }

                              _this._insertSampleInOrder(
                                  _this._txtTrack.samples, {
                                    pts: pes.pts,
                                    payloadType: payloadType,
                                    uuid: uuidStrArray.join(''),
                                    userDataBytes: userDataPayloadBytes,
                                    userData: Object(
                                        __WEBPACK_IMPORTED_MODULE_7__id3__['b' /* utf8ArrayToStr */])(
                                        userDataPayloadBytes.buffer),
                                  });
                            }
                          } else if (payloadSize <
                              expGolombDecoder.bytesAvailable) {
                            for (i = 0; i < payloadSize; i++) {
                              expGolombDecoder.readUByte();
                            }
                          }
                        }

                        break;
                        // SPS

                      case 7:
                        push = true;
                        spsfound = true;

                        if (debug && avcSample) {
                          avcSample.debug += 'SPS ';
                        }

                        if (!track.sps) {
                          expGolombDecoder = new __WEBPACK_IMPORTED_MODULE_3__exp_golomb__['a' /* default */](
                              unit.data);
                          var config = expGolombDecoder.readSPS();
                          track.width = config.width;
                          track.height = config.height;
                          track.pixelRatio = config.pixelRatio;
                          track.sps = [unit.data];
                          track.duration = _this._duration;
                          var codecarray = unit.data.subarray(1, 4);
                          var codecstring = 'avc1.';

                          for (i = 0; i < 3; i++) {
                            var h = codecarray[i].toString(16);

                            if (h.length < 2) {
                              h = '0' + h;
                            }

                            codecstring += h;
                          }

                          track.codec = codecstring;
                        }

                        break;
                        // PPS

                      case 8:
                        push = true;

                        if (debug && avcSample) {
                          avcSample.debug += 'PPS ';
                        }

                        if (!track.pps) {
                          track.pps = [unit.data];
                        }

                        break;
                        // AUD

                      case 9:
                        push = false;
                        track.audFound = true;

                        if (avcSample) {
                          pushAccesUnit(avcSample, track);
                        }

                        avcSample = _this.avcSample = createAVCSample(false,
                            pes.pts, pes.dts, debug ? 'AUD ' : '');
                        break;
                        // Filler Data

                      case 12:
                        push = false;
                        break;

                      default:
                        push = false;

                        if (avcSample) {
                          avcSample.debug += 'unknown NAL ' + unit.type + ' ';
                        }

                        break;
                    }

                    if (avcSample && push) {
                      var _units = avcSample.units;

                      _units.push(unit);
                    }
                  }); // if last PES packet, push samples

                  if (last && avcSample) {
                    pushAccesUnit(avcSample, track);
                    this.avcSample = null;
                  }
                };

                _proto._insertSampleInOrder = function _insertSampleInOrder(
                    arr, data) {
                  var len = arr.length;

                  if (len > 0) {
                    if (data.pts >= arr[len - 1].pts) {
                      arr.push(data);
                    } else {
                      for (var pos = len - 1; pos >= 0; pos--) {
                        if (data.pts < arr[pos].pts) {
                          arr.splice(pos, 0, data);
                          break;
                        }
                      }
                    }
                  } else {
                    arr.push(data);
                  }
                };

                _proto._getLastNalUnit = function _getLastNalUnit() {
                  var avcSample = this.avcSample,
                      lastUnit; // try to fallback to previous sample if current one is empty

                  if (!avcSample || avcSample.units.length === 0) {
                    var track = this._avcTrack,
                        samples = track.samples;
                    avcSample = samples[samples.length - 1];
                  }

                  if (avcSample) {
                    var units = avcSample.units;
                    lastUnit = units[units.length - 1];
                  }

                  return lastUnit;
                };

                _proto._parseAVCNALu = function _parseAVCNALu(array) {
                  var i = 0,
                      len = array.byteLength,
                      value,
                      overflow,
                      track = this._avcTrack,
                      state = track.naluState || 0,
                      lastState = state;
                  var units = [],
                      unit,
                      unitType,
                      lastUnitStart = -1,
                      lastUnitType; // logger.log('PES:' + Hex.hexDump(array));

                  if (state === -1) {
                    // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
                    lastUnitStart = 0; // NALu type is value read from offset 0

                    lastUnitType = array[0] & 0x1f;
                    state = 0;
                    i = 1;
                  }

                  while (i < len) {
                    value = array[i++]; // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case

                    if (!state) {
                      state = value ? 0 : 1;
                      continue;
                    }

                    if (state === 1) {
                      state = value ? 0 : 2;
                      continue;
                    } // here we have state either equal to 2 or 3

                    if (!value) {
                      state = 3;
                    } else if (value === 1) {
                      if (lastUnitStart >= 0) {
                        unit = {
                          data: array.subarray(lastUnitStart, i - state - 1),
                          type: lastUnitType,
                        }; // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);

                        units.push(unit);
                      } else {
                        // lastUnitStart is undefined => this is the first start code found in this PES packet
                        // first check if start code delimiter is overlapping between 2 PES packets,
                        // ie it started in last packet (lastState not zero)
                        // and ended at the beginning of this PES packet (i <= 4 - lastState)
                        var lastUnit = this._getLastNalUnit();

                        if (lastUnit) {
                          if (lastState && i <= 4 - lastState) {
                            // start delimiter overlapping between PES packets
                            // strip start delimiter bytes from the end of last NAL unit
                            // check if lastUnit had a state different from zero
                            if (lastUnit.state) {
                              // strip last bytes
                              lastUnit.data = lastUnit.data.subarray(0,
                                  lastUnit.data.byteLength - lastState);
                            }
                          } // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.

                          overflow = i - state - 1;

                          if (overflow > 0) {
                            // logger.log('first NALU found with overflow:' + overflow);
                            var tmp = new Uint8Array(
                                lastUnit.data.byteLength + overflow);
                            tmp.set(lastUnit.data, 0);
                            tmp.set(array.subarray(0, overflow),
                                lastUnit.data.byteLength);
                            lastUnit.data = tmp;
                          }
                        }
                      } // check if we can read unit type

                      if (i < len) {
                        unitType = array[i] & 0x1f; // logger.log('find NALU @ offset:' + i + ',type:' + unitType);

                        lastUnitStart = i;
                        lastUnitType = unitType;
                        state = 0;
                      } else {
                        // not enough byte to read unit type. let's read it on next PES parsing
                        state = -1;
                      }
                    } else {
                      state = 0;
                    }
                  }

                  if (lastUnitStart >= 0 && state >= 0) {
                    unit = {
                      data: array.subarray(lastUnitStart, len),
                      type: lastUnitType,
                      state: state,
                    };
                    units.push(unit); // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
                  } // no NALu found

                  if (units.length === 0) {
                    // append pes.data to previous NAL unit
                    var _lastUnit = this._getLastNalUnit();

                    if (_lastUnit) {
                      var _tmp = new Uint8Array(
                          _lastUnit.data.byteLength + array.byteLength);

                      _tmp.set(_lastUnit.data, 0);

                      _tmp.set(array, _lastUnit.data.byteLength);

                      _lastUnit.data = _tmp;
                    }
                  }

                  track.naluState = state;
                  return units;
                }
                /**
                 * remove Emulation Prevention bytes from a RBSP
                 */
                ;

                _proto.discardEPB = function discardEPB(data) {
                  var length = data.byteLength,
                      EPBPositions = [],
                      i = 1,
                      newLength,
                      newData; // Find all `Emulation Prevention Bytes`

                  while (i < length - 2) {
                    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] ===
                        0x03) {
                      EPBPositions.push(i + 2);
                      i += 2;
                    } else {
                      i++;
                    }
                  } // If no Emulation Prevention Bytes were found just return the original
                  // array

                  if (EPBPositions.length === 0) {
                    return data;
                  } // Create a new array to hold the NAL unit data

                  newLength = length - EPBPositions.length;
                  newData = new Uint8Array(newLength);
                  var sourceIndex = 0;

                  for (i = 0; i < newLength; sourceIndex++, i++) {
                    if (sourceIndex === EPBPositions[0]) {
                      // Skip this byte
                      sourceIndex++; // Remove this position index

                      EPBPositions.shift();
                    }

                    newData[i] = data[sourceIndex];
                  }

                  return newData;
                };

                _proto._parseAACPES = function _parseAACPES(pes) {
                  var track = this._audioTrack,
                      data = pes.data,
                      pts = pes.pts,
                      startOffset = 0,
                      aacOverFlow = this.aacOverFlow,
                      aacLastPTS = this.aacLastPTS,
                      frameDuration,
                      frameIndex,
                      offset,
                      stamp,
                      len;

                  if (aacOverFlow) {
                    var tmp = new Uint8Array(
                        aacOverFlow.byteLength + data.byteLength);
                    tmp.set(aacOverFlow, 0);
                    tmp.set(data, aacOverFlow.byteLength); // logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);

                    data = tmp;
                  } // look for ADTS header (0xFFFx)

                  for (offset = startOffset, len = data.length; offset < len -
                  1; offset++) {
                    if (__WEBPACK_IMPORTED_MODULE_0__adts__['d' /* isHeader */](
                        data, offset)) {
                      break;
                    }
                  } // if ADTS header does not start straight from the beginning of the PES payload, raise an error

                  if (offset) {
                    var reason, fatal;

                    if (offset < len - 1) {
                      reason = 'AAC PES did not start with ADTS header,offset:' +
                          offset;
                      fatal = false;
                    } else {
                      reason = 'no ADTS header found in AAC PES';
                      fatal = true;
                    }

                    __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].warn(
                        'parsing error:' + reason);
                    this.observer.trigger(
                        __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_6__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_6__errors__['a' /* ErrorDetails */].FRAG_PARSING_ERROR,
                          fatal: fatal,
                          reason: reason,
                        });

                    if (fatal) {
                      return;
                    }
                  }

                  __WEBPACK_IMPORTED_MODULE_0__adts__['c' /* initTrackConfig */](
                      track, this.observer, data, offset, this.audioCodec);
                  frameIndex = 0;
                  frameDuration = __WEBPACK_IMPORTED_MODULE_0__adts__['b' /* getFrameDuration */](
                      track.samplerate); // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
                  // first sample PTS should be equal to last sample PTS + frameDuration

                  if (aacOverFlow && aacLastPTS) {
                    var newPTS = aacLastPTS + frameDuration;

                    if (Math.abs(newPTS - pts) > 1) {
                      __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                          'AAC: align PTS for overlapping frames by ' +
                          Math.round((newPTS - pts) / 90));
                      pts = newPTS;
                    }
                  } // scan for aac samples

                  while (offset < len) {
                    if (__WEBPACK_IMPORTED_MODULE_0__adts__['d' /* isHeader */](
                        data, offset) && offset + 5 < len) {
                      var frame = __WEBPACK_IMPORTED_MODULE_0__adts__['a' /* appendFrame */](
                          track, data, offset, pts, frameIndex);

                      if (frame) {
                        // logger.log(`${Math.round(frame.sample.pts)} : AAC`);
                        offset += frame.length;
                        stamp = frame.sample.pts;
                        frameIndex++;
                      } else {
                        // logger.log('Unable to parse AAC frame');
                        break;
                      }
                    } else {
                      // nothing found, keep looking
                      offset++;
                    }
                  }

                  if (offset < len) {
                    aacOverFlow = data.subarray(offset, len); // logger.log(`AAC: overflow detected:${len-offset}`);
                  } else {
                    aacOverFlow = null;
                  }

                  this.aacOverFlow = aacOverFlow;
                  this.aacLastPTS = stamp;
                };

                _proto._parseMPEGPES = function _parseMPEGPES(pes) {
                  var data = pes.data;
                  var length = data.length;
                  var frameIndex = 0;
                  var offset = 0;
                  var pts = pes.pts;

                  while (offset < length) {
                    if (__WEBPACK_IMPORTED_MODULE_1__mpegaudio__['a' /* default */].isHeader(
                        data, offset)) {
                      var frame = __WEBPACK_IMPORTED_MODULE_1__mpegaudio__['a' /* default */].appendFrame(
                          this._audioTrack, data, offset, pts, frameIndex);

                      if (frame) {
                        offset += frame.length;
                        frameIndex++;
                      } else {
                        // logger.log('Unable to parse Mpeg audio frame');
                        break;
                      }
                    } else {
                      // nothing found, keep looking
                      offset++;
                    }
                  }
                };

                _proto._parseID3PES = function _parseID3PES(pes) {
                  this._id3Track.samples.push(pes);
                };

                return TSDemuxer;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (TSDemuxer);

          /***/
        }),
        /* 50 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__utils_logger__ = __webpack_require__(
              1);
          /**
           * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
           */


          var ExpGolomb =
              /*#__PURE__*/
              function() {
                function ExpGolomb(data) {
                  this.data = data; // the number of bytes left to examine in this.data

                  this.bytesAvailable = data.byteLength; // the current word being examined

                  this.word = 0; // :uint
                  // the number of bits left to examine in the current word

                  this.bitsAvailable = 0; // :uint
                } // ():void

                var _proto = ExpGolomb.prototype;

                _proto.loadWord = function loadWord() {
                  var data = this.data,
                      bytesAvailable = this.bytesAvailable,
                      position = data.byteLength - bytesAvailable,
                      workingBytes = new Uint8Array(4),
                      availableBytes = Math.min(4, bytesAvailable);

                  if (availableBytes === 0) {
                    throw new Error('no bytes available');
                  }

                  workingBytes.set(
                      data.subarray(position, position + availableBytes));
                  this.word = new DataView(workingBytes.buffer).getUint32(0); // track the amount of this.data that has been processed

                  this.bitsAvailable = availableBytes * 8;
                  this.bytesAvailable -= availableBytes;
                } // (count:int):void
                ;

                _proto.skipBits = function skipBits(count) {
                  var skipBytes; // :int

                  if (this.bitsAvailable > count) {
                    this.word <<= count;
                    this.bitsAvailable -= count;
                  } else {
                    count -= this.bitsAvailable;
                    skipBytes = count >> 3;
                    count -= skipBytes >> 3;
                    this.bytesAvailable -= skipBytes;
                    this.loadWord();
                    this.word <<= count;
                    this.bitsAvailable -= count;
                  }
                } // (size:int):uint
                ;

                _proto.readBits = function readBits(size) {
                  var bits = Math.min(this.bitsAvailable, size),
                      // :uint
                      valu = this.word >>> 32 - bits; // :uint

                  if (size > 32) {
                    __WEBPACK_IMPORTED_MODULE_0__utils_logger__['b' /* logger */].error(
                        'Cannot read more than 32 bits at a time');
                  }

                  this.bitsAvailable -= bits;

                  if (this.bitsAvailable > 0) {
                    this.word <<= bits;
                  } else if (this.bytesAvailable > 0) {
                    this.loadWord();
                  }

                  bits = size - bits;

                  if (bits > 0 && this.bitsAvailable) {
                    return valu << bits | this.readBits(bits);
                  } else {
                    return valu;
                  }
                } // ():uint
                ;

                _proto.skipLZ = function skipLZ() {
                  var leadingZeroCount; // :uint

                  for (leadingZeroCount = 0; leadingZeroCount <
                  this.bitsAvailable; ++leadingZeroCount) {
                    if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {
                      // the first bit of working word is 1
                      this.word <<= leadingZeroCount;
                      this.bitsAvailable -= leadingZeroCount;
                      return leadingZeroCount;
                    }
                  } // we exhausted word and still have not found a 1

                  this.loadWord();
                  return leadingZeroCount + this.skipLZ();
                } // ():void
                ;

                _proto.skipUEG = function skipUEG() {
                  this.skipBits(1 + this.skipLZ());
                } // ():void
                ;

                _proto.skipEG = function skipEG() {
                  this.skipBits(1 + this.skipLZ());
                } // ():uint
                ;

                _proto.readUEG = function readUEG() {
                  var clz = this.skipLZ(); // :uint

                  return this.readBits(clz + 1) - 1;
                } // ():int
                ;

                _proto.readEG = function readEG() {
                  var valu = this.readUEG(); // :int

                  if (0x01 & valu) {
                    // the number is odd if the low order bit is set
                    return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
                  } else {
                    return -1 * (valu >>> 1); // divide by two then make it negative
                  }
                } // Some convenience functions
                // :Boolean
                ;

                _proto.readBoolean = function readBoolean() {
                  return this.readBits(1) === 1;
                } // ():int
                ;

                _proto.readUByte = function readUByte() {
                  return this.readBits(8);
                } // ():int
                ;

                _proto.readUShort = function readUShort() {
                  return this.readBits(16);
                } // ():int
                ;

                _proto.readUInt = function readUInt() {
                  return this.readBits(32);
                }
                /**
                 * Advance the ExpGolomb decoder past a scaling list. The scaling
                 * list is optionally transmitted as part of a sequence parameter
                 * set and is not relevant to transmuxing.
                 * @param count {number} the number of entries in this scaling list
                 * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
                 */
                ;

                _proto.skipScalingList = function skipScalingList(count) {
                  var lastScale = 8,
                      nextScale = 8,
                      j,
                      deltaScale;

                  for (j = 0; j < count; j++) {
                    if (nextScale !== 0) {
                      deltaScale = this.readEG();
                      nextScale = (lastScale + deltaScale + 256) % 256;
                    }

                    lastScale = nextScale === 0 ? lastScale : nextScale;
                  }
                }
                /**
                 * Read a sequence parameter set and return some interesting video
                 * properties. A sequence parameter set is the H264 metadata that
                 * describes the properties of upcoming video frames.
                 * @param data {Uint8Array} the bytes of a sequence parameter set
                 * @return {object} an object with configuration parsed from the
                 * sequence parameter set, including the dimensions of the
                 * associated video frames.
                 */
                ;

                _proto.readSPS = function readSPS() {
                  var frameCropLeftOffset = 0,
                      frameCropRightOffset = 0,
                      frameCropTopOffset = 0,
                      frameCropBottomOffset = 0,
                      profileIdc,
                      profileCompat,
                      levelIdc,
                      numRefFramesInPicOrderCntCycle,
                      picWidthInMbsMinus1,
                      picHeightInMapUnitsMinus1,
                      frameMbsOnlyFlag,
                      scalingListCount,
                      i,
                      readUByte = this.readUByte.bind(this),
                      readBits = this.readBits.bind(this),
                      readUEG = this.readUEG.bind(this),
                      readBoolean = this.readBoolean.bind(this),
                      skipBits = this.skipBits.bind(this),
                      skipEG = this.skipEG.bind(this),
                      skipUEG = this.skipUEG.bind(this),
                      skipScalingList = this.skipScalingList.bind(this);
                  readUByte();
                  profileIdc = readUByte(); // profile_idc

                  profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)

                  skipBits(3); // reserved_zero_3bits u(3),

                  levelIdc = readUByte(); // level_idc u(8)

                  skipUEG(); // seq_parameter_set_id
                  // some profiles have more optional data we don't need

                  if (profileIdc === 100 || profileIdc === 110 || profileIdc ===
                      122 || profileIdc === 244 || profileIdc === 44 ||
                      profileIdc === 83 || profileIdc === 86 || profileIdc ===
                      118 || profileIdc === 128) {
                    var chromaFormatIdc = readUEG();

                    if (chromaFormatIdc === 3) {
                      skipBits(1);
                    } // separate_colour_plane_flag

                    skipUEG(); // bit_depth_luma_minus8

                    skipUEG(); // bit_depth_chroma_minus8

                    skipBits(1); // qpprime_y_zero_transform_bypass_flag

                    if (readBoolean()) {
                      // seq_scaling_matrix_present_flag
                      scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;

                      for (i = 0; i < scalingListCount; i++) {
                        if (readBoolean()) {
                          // seq_scaling_list_present_flag[ i ]
                          if (i < 6) {
                            skipScalingList(16);
                          } else {
                            skipScalingList(64);
                          }
                        }
                      }
                    }
                  }

                  skipUEG(); // log2_max_frame_num_minus4

                  var picOrderCntType = readUEG();

                  if (picOrderCntType === 0) {
                    readUEG(); // log2_max_pic_order_cnt_lsb_minus4
                  } else if (picOrderCntType === 1) {
                    skipBits(1); // delta_pic_order_always_zero_flag

                    skipEG(); // offset_for_non_ref_pic

                    skipEG(); // offset_for_top_to_bottom_field

                    numRefFramesInPicOrderCntCycle = readUEG();

                    for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
                      skipEG();
                    } // offset_for_ref_frame[ i ]

                  }

                  skipUEG(); // max_num_ref_frames

                  skipBits(1); // gaps_in_frame_num_value_allowed_flag

                  picWidthInMbsMinus1 = readUEG();
                  picHeightInMapUnitsMinus1 = readUEG();
                  frameMbsOnlyFlag = readBits(1);

                  if (frameMbsOnlyFlag === 0) {
                    skipBits(1);
                  } // mb_adaptive_frame_field_flag

                  skipBits(1); // direct_8x8_inference_flag

                  if (readBoolean()) {
                    // frame_cropping_flag
                    frameCropLeftOffset = readUEG();
                    frameCropRightOffset = readUEG();
                    frameCropTopOffset = readUEG();
                    frameCropBottomOffset = readUEG();
                  }

                  var pixelRatio = [1, 1];

                  if (readBoolean()) {
                    // vui_parameters_present_flag
                    if (readBoolean()) {
                      // aspect_ratio_info_present_flag
                      var aspectRatioIdc = readUByte();

                      switch (aspectRatioIdc) {
                        case 1:
                          pixelRatio = [1, 1];
                          break;

                        case 2:
                          pixelRatio = [12, 11];
                          break;

                        case 3:
                          pixelRatio = [10, 11];
                          break;

                        case 4:
                          pixelRatio = [16, 11];
                          break;

                        case 5:
                          pixelRatio = [40, 33];
                          break;

                        case 6:
                          pixelRatio = [24, 11];
                          break;

                        case 7:
                          pixelRatio = [20, 11];
                          break;

                        case 8:
                          pixelRatio = [32, 11];
                          break;

                        case 9:
                          pixelRatio = [80, 33];
                          break;

                        case 10:
                          pixelRatio = [18, 11];
                          break;

                        case 11:
                          pixelRatio = [15, 11];
                          break;

                        case 12:
                          pixelRatio = [64, 33];
                          break;

                        case 13:
                          pixelRatio = [160, 99];
                          break;

                        case 14:
                          pixelRatio = [4, 3];
                          break;

                        case 15:
                          pixelRatio = [3, 2];
                          break;

                        case 16:
                          pixelRatio = [2, 1];
                          break;

                        case 255: {
                          pixelRatio = [
                            readUByte() << 8 | readUByte(),
                            readUByte() << 8 | readUByte()];
                          break;
                        }
                      }
                    }
                  }

                  return {
                    width: Math.ceil(
                        (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset *
                        2 - frameCropRightOffset * 2),
                    height: (2 - frameMbsOnlyFlag) *
                        (picHeightInMapUnitsMinus1 + 1) * 16 -
                        (frameMbsOnlyFlag ? 2 : 4) *
                        (frameCropTopOffset + frameCropBottomOffset),
                    pixelRatio: pixelRatio,
                  };
                };

                _proto.readSliceType = function readSliceType() {
                  // skip NALu type
                  this.readUByte(); // discard first_mb_in_slice

                  this.readUEG(); // return slice_type

                  return this.readUEG();
                };

                return ExpGolomb;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (ExpGolomb);

          /***/
        }),
        /* 51 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__crypt_decrypter__ = __webpack_require__(
              12);
          /**
           * SAMPLE-AES decrypter
           */


          var SampleAesDecrypter =
              /*#__PURE__*/
              function() {
                function SampleAesDecrypter(
                    observer, config, decryptdata, discardEPB) {
                  this.decryptdata = decryptdata;
                  this.discardEPB = discardEPB;
                  this.decrypter = new __WEBPACK_IMPORTED_MODULE_0__crypt_decrypter__['a' /* default */](
                      observer, config, {
                        removePKCS7Padding: false,
                      });
                }

                var _proto = SampleAesDecrypter.prototype;

                _proto.decryptBuffer = function decryptBuffer(
                    encryptedData, callback) {
                  this.decrypter.decrypt(encryptedData,
                      this.decryptdata.key.buffer, this.decryptdata.iv.buffer,
                      callback);
                } // AAC - encrypt all full 16 bytes blocks starting from offset 16
                ;

                _proto.decryptAacSample = function decryptAacSample(
                    samples, sampleIndex, callback, sync) {
                  var curUnit = samples[sampleIndex].unit;
                  var encryptedData = curUnit.subarray(16,
                      curUnit.length - curUnit.length % 16);
                  var encryptedBuffer = encryptedData.buffer.slice(
                      encryptedData.byteOffset,
                      encryptedData.byteOffset + encryptedData.length);
                  var localthis = this;
                  this.decryptBuffer(encryptedBuffer, function(decryptedData) {
                    decryptedData = new Uint8Array(decryptedData);
                    curUnit.set(decryptedData, 16);

                    if (!sync) {
                      localthis.decryptAacSamples(samples, sampleIndex + 1,
                          callback);
                    }
                  });
                };

                _proto.decryptAacSamples = function decryptAacSamples(
                    samples, sampleIndex, callback) {
                  for (; ; sampleIndex++) {
                    if (sampleIndex >= samples.length) {
                      callback();
                      return;
                    }

                    if (samples[sampleIndex].unit.length < 32) {
                      continue;
                    }

                    var sync = this.decrypter.isSync();
                    this.decryptAacSample(samples, sampleIndex, callback, sync);

                    if (!sync) {
                      return;
                    }
                  }
                } // AVC - encrypt one 16 bytes block out of ten, starting from offset 32
                ;

                _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {
                  var encryptedDataLen = Math.floor(
                      (decodedData.length - 48) / 160) * 16 + 16;
                  var encryptedData = new Int8Array(encryptedDataLen);
                  var outputPos = 0;

                  for (var inputPos = 32; inputPos <= decodedData.length -
                  16; inputPos += 160, outputPos += 16) {
                    encryptedData.set(
                        decodedData.subarray(inputPos, inputPos + 16),
                        outputPos);
                  }

                  return encryptedData;
                };

                _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(
                    decodedData, decryptedData) {
                  decryptedData = new Uint8Array(decryptedData);
                  var inputPos = 0;

                  for (var outputPos = 32; outputPos <= decodedData.length -
                  16; outputPos += 160, inputPos += 16) {
                    decodedData.set(
                        decryptedData.subarray(inputPos, inputPos + 16),
                        outputPos);
                  }

                  return decodedData;
                };

                _proto.decryptAvcSample = function decryptAvcSample(
                    samples, sampleIndex, unitIndex, callback, curUnit, sync) {
                  var decodedData = this.discardEPB(curUnit.data);
                  var encryptedData = this.getAvcEncryptedData(decodedData);
                  var localthis = this;
                  this.decryptBuffer(encryptedData.buffer,
                      function(decryptedData) {
                        curUnit.data = localthis.getAvcDecryptedUnit(
                            decodedData, decryptedData);

                        if (!sync) {
                          localthis.decryptAvcSamples(samples, sampleIndex,
                              unitIndex + 1, callback);
                        }
                      });
                };

                _proto.decryptAvcSamples = function decryptAvcSamples(
                    samples, sampleIndex, unitIndex, callback) {
                  for (; ; sampleIndex++, unitIndex = 0) {
                    if (sampleIndex >= samples.length) {
                      callback();
                      return;
                    }

                    var curUnits = samples[sampleIndex].units;

                    for (; ; unitIndex++) {
                      if (unitIndex >= curUnits.length) {
                        break;
                      }

                      var curUnit = curUnits[unitIndex];

                      if (curUnit.length <= 48 || curUnit.type !== 1 &&
                          curUnit.type !== 5) {
                        continue;
                      }

                      var sync = this.decrypter.isSync();
                      this.decryptAvcSample(samples, sampleIndex, unitIndex,
                          callback, curUnit, sync);

                      if (!sync) {
                        return;
                      }
                    }
                  }
                };

                return SampleAesDecrypter;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (SampleAesDecrypter);

          /***/
        }),
        /* 52 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__demux_id3__ = __webpack_require__(8);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__mpegaudio__ = __webpack_require__(
              26);
          /**
           * MP3 demuxer
           */




          var MP3Demuxer =
              /*#__PURE__*/
              function() {
                function MP3Demuxer(observer, remuxer, config) {
                  this.observer = observer;
                  this.config = config;
                  this.remuxer = remuxer;
                }

                var _proto = MP3Demuxer.prototype;

                _proto.resetInitSegment = function resetInitSegment(
                    initSegment, audioCodec, videoCodec, duration) {
                  this._audioTrack = {
                    container: 'audio/mpeg',
                    type: 'audio',
                    id: -1,
                    sequenceNumber: 0,
                    isAAC: false,
                    samples: [],
                    len: 0,
                    manifestCodec: audioCodec,
                    duration: duration,
                    inputTimeScale: 90000,
                  };
                };

                _proto.resetTimeStamp = function resetTimeStamp() {};

                MP3Demuxer.probe = function probe(data) {
                  // check if data contains ID3 timestamp and MPEG sync word
                  var offset, length;
                  var id3Data = __WEBPACK_IMPORTED_MODULE_0__demux_id3__['a' /* default */].getID3Data(
                      data, 0);

                  if (id3Data &&
                      __WEBPACK_IMPORTED_MODULE_0__demux_id3__['a' /* default */].getTimeStamp(
                          id3Data) !== undefined) {
                    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
                    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
                    // More info http://www.mp3-tech.org/programmer/frame_header.html
                    for (offset = id3Data.length, length = Math.min(
                        data.length - 1, offset + 100); offset <
                    length; offset++) {
                      if (__WEBPACK_IMPORTED_MODULE_2__mpegaudio__['a' /* default */].probe(
                          data, offset)) {
                        __WEBPACK_IMPORTED_MODULE_1__utils_logger__['b' /* logger */].log(
                            'MPEG Audio sync word found !');
                        return true;
                      }
                    }
                  }

                  return false;
                } // feed incoming data to the front of the parsing pipeline
                ;

                _proto.append = function append(
                    data, timeOffset, contiguous, accurateTimeOffset) {
                  var id3Data = __WEBPACK_IMPORTED_MODULE_0__demux_id3__['a' /* default */].getID3Data(
                      data, 0);
                  var timestamp = __WEBPACK_IMPORTED_MODULE_0__demux_id3__['a' /* default */].getTimeStamp(
                      id3Data);
                  var pts = timestamp ? 90 * timestamp : timeOffset * 90000;
                  var offset = id3Data.length;
                  var length = data.length;
                  var frameIndex = 0,
                      stamp = 0;
                  var track = this._audioTrack;
                  var id3Samples = [
                    {
                      pts: pts,
                      dts: pts,
                      data: id3Data,
                    }];

                  while (offset < length) {
                    if (__WEBPACK_IMPORTED_MODULE_2__mpegaudio__['a' /* default */].isHeader(
                        data, offset)) {
                      var frame = __WEBPACK_IMPORTED_MODULE_2__mpegaudio__['a' /* default */].appendFrame(
                          track, data, offset, pts, frameIndex);

                      if (frame) {
                        offset += frame.length;
                        stamp = frame.sample.pts;
                        frameIndex++;
                      } else {
                        // logger.log('Unable to parse Mpeg audio frame');
                        break;
                      }
                    } else if (__WEBPACK_IMPORTED_MODULE_0__demux_id3__['a' /* default */].isHeader(
                        data, offset)) {
                      id3Data = __WEBPACK_IMPORTED_MODULE_0__demux_id3__['a' /* default */].getID3Data(
                          data, offset);
                      id3Samples.push({
                        pts: stamp,
                        dts: stamp,
                        data: id3Data,
                      });
                      offset += id3Data.length;
                    } else {
                      // nothing found, keep looking
                      offset++;
                    }
                  }

                  this.remuxer.remux(track, {
                    samples: [],
                  }, {
                    samples: id3Samples,
                    inputTimeScale: 90000,
                  }, {
                    samples: [],
                  }, timeOffset, contiguous, accurateTimeOffset);
                };

                _proto.destroy = function destroy() {};

                return MP3Demuxer;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (MP3Demuxer);

          /***/
        }),
        /* 53 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__aac_helper__ = __webpack_require__(
              54);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__mp4_generator__ = __webpack_require__(
              55);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__ = __webpack_require__(
              56);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__utils_logger__ = __webpack_require__(
              1);
          /**
           * fMP4 remuxer
           */






          var MAX_SILENT_FRAME_DURATION_90KHZ = Object(
              __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['a' /* toMpegTsClockFromTimescale */])(
              10);
          var PTS_DTS_SHIFT_TOLERANCE_90KHZ = Object(
              __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['a' /* toMpegTsClockFromTimescale */])(
              0.2);

          var MP4Remuxer =
              /*#__PURE__*/
              function() {
                function MP4Remuxer(observer, config, typeSupported, vendor) {
                  this.observer = observer;
                  this.config = config;
                  this.typeSupported = typeSupported;
                  var userAgent = navigator.userAgent;
                  this.isSafari = vendor && vendor.indexOf('Apple') > -1 &&
                      userAgent && !userAgent.match('CriOS');
                  this.ISGenerated = false;
                }

                var _proto = MP4Remuxer.prototype;

                _proto.destroy = function destroy() {};

                _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {
                  this._initPTS = this._initDTS = defaultTimeStamp;
                };

                _proto.resetInitSegment = function resetInitSegment() {
                  this.ISGenerated = false;
                };

                _proto.remux = function remux(
                    audioTrack, videoTrack, id3Track, textTrack, timeOffset,
                    contiguous, accurateTimeOffset) {
                  // generate Init Segment if needed
                  if (!this.ISGenerated) {
                    this.generateIS(audioTrack, videoTrack, timeOffset);
                  }

                  if (this.ISGenerated) {
                    var nbAudioSamples = audioTrack.samples.length;
                    var nbVideoSamples = videoTrack.samples.length;
                    var audioTimeOffset = timeOffset;
                    var videoTimeOffset = timeOffset;

                    if (nbAudioSamples && nbVideoSamples) {
                      // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)
                      // if first audio DTS is not aligned with first video DTS then we need to take that into account
                      // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small
                      // drift between audio and video streams
                      var audiovideoDeltaDts = (audioTrack.samples[0].pts -
                          videoTrack.samples[0].pts) /
                          videoTrack.inputTimeScale;
                      audioTimeOffset += Math.max(0, audiovideoDeltaDts);
                      videoTimeOffset += Math.max(0, -audiovideoDeltaDts);
                    } // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
                    // calculated in remuxAudio.
                    // logger.log('nb AAC samples:' + audioTrack.samples.length);

                    if (nbAudioSamples) {
                      // if initSegment was generated without video samples, regenerate it again
                      if (!audioTrack.timescale) {
                        __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].warn(
                            'regenerate InitSegment as audio detected');
                        this.generateIS(audioTrack, videoTrack, timeOffset);
                      }

                      var audioData = this.remuxAudio(audioTrack,
                          audioTimeOffset, contiguous, accurateTimeOffset); // logger.log('nb AVC samples:' + videoTrack.samples.length);

                      if (nbVideoSamples) {
                        var audioTrackLength;

                        if (audioData) {
                          audioTrackLength = audioData.endPTS -
                              audioData.startPTS;
                        } // if initSegment was generated without video samples, regenerate it again

                        if (!videoTrack.timescale) {
                          __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].warn(
                              'regenerate InitSegment as video detected');
                          this.generateIS(audioTrack, videoTrack, timeOffset);
                        }

                        this.remuxVideo(videoTrack, videoTimeOffset, contiguous,
                            audioTrackLength, accurateTimeOffset);
                      }
                    } else {
                      // logger.log('nb AVC samples:' + videoTrack.samples.length);
                      if (nbVideoSamples) {
                        var videoData = this.remuxVideo(videoTrack,
                            videoTimeOffset, contiguous, 0, accurateTimeOffset);

                        if (videoData && audioTrack.codec) {
                          this.remuxEmptyAudio(audioTrack, audioTimeOffset,
                              contiguous, videoData);
                        }
                      }
                    }
                  } // logger.log('nb ID3 samples:' + audioTrack.samples.length);

                  if (id3Track.samples.length) {
                    this.remuxID3(id3Track, timeOffset);
                  } // logger.log('nb ID3 samples:' + audioTrack.samples.length);

                  if (textTrack.samples.length) {
                    this.remuxText(textTrack, timeOffset);
                  } // notify end of parsing

                  this.observer.trigger(
                      __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].FRAG_PARSED);
                };

                _proto.generateIS = function generateIS(
                    audioTrack, videoTrack, timeOffset) {
                  var observer = this.observer,
                      audioSamples = audioTrack.samples,
                      videoSamples = videoTrack.samples,
                      typeSupported = this.typeSupported,
                      container = 'audio/mp4',
                      tracks = {},
                      data = {
                        tracks: tracks,
                      },
                      computePTSDTS = this._initPTS === undefined,
                      initPTS,
                      initDTS;

                  if (computePTSDTS) {
                    initPTS = initDTS = Infinity;
                  }

                  if (audioTrack.config && audioSamples.length) {
                    // let's use audio sampling rate as MP4 time scale.
                    // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
                    // using audio sampling rate here helps having an integer MP4 frame duration
                    // this avoids potential rounding issue and AV sync issue
                    audioTrack.timescale = audioTrack.samplerate;
                    __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                        'audio sampling rate : ' + audioTrack.samplerate);

                    if (!audioTrack.isAAC) {
                      if (typeSupported.mpeg) {
                        // Chrome and Safari
                        container = 'audio/mpeg';
                        audioTrack.codec = '';
                      } else if (typeSupported.mp3) {
                        // Firefox
                        audioTrack.codec = 'mp3';
                      }
                    }

                    tracks.audio = {
                      container: container,
                      codec: audioTrack.codec,
                      initSegment: !audioTrack.isAAC && typeSupported.mpeg
                          ? new Uint8Array()
                          : __WEBPACK_IMPORTED_MODULE_1__mp4_generator__['a' /* default */].initSegment(
                              [audioTrack]),
                      metadata: {
                        channelCount: audioTrack.channelCount,
                      },
                    };

                    if (computePTSDTS) {
                      // remember first PTS of this demuxing context. for audio, PTS = DTS
                      initPTS = initDTS = audioSamples[0].pts -
                          audioTrack.inputTimeScale * timeOffset;
                    }
                  }

                  if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
                    // let's use input time scale as MP4 video timescale
                    // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
                    var inputTimeScale = videoTrack.inputTimeScale;
                    videoTrack.timescale = inputTimeScale;
                    tracks.video = {
                      container: 'video/mp4',
                      codec: videoTrack.codec,
                      initSegment: __WEBPACK_IMPORTED_MODULE_1__mp4_generator__['a' /* default */].initSegment(
                          [videoTrack]),
                      metadata: {
                        width: videoTrack.width,
                        height: videoTrack.height,
                      },
                    };

                    if (computePTSDTS) {
                      initPTS = Math.min(initPTS,
                          videoSamples[0].pts - inputTimeScale * timeOffset);
                      initDTS = Math.min(initDTS,
                          videoSamples[0].dts - inputTimeScale * timeOffset);
                      this.observer.trigger(
                          __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].INIT_PTS_FOUND,
                          {
                            initPTS: initPTS,
                          });
                    }
                  }

                  if (Object.keys(tracks).length) {
                    observer.trigger(
                        __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].FRAG_PARSING_INIT_SEGMENT,
                        data);
                    this.ISGenerated = true;

                    if (computePTSDTS) {
                      this._initPTS = initPTS;
                      this._initDTS = initDTS;
                    }
                  } else {
                    observer.trigger(
                        __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_3__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].FRAG_PARSING_ERROR,
                          fatal: false,
                          reason: 'no audio/video samples found',
                        });
                  }
                };

                _proto.remuxVideo = function remuxVideo(
                    track, timeOffset, contiguous, audioTrackLength,
                    accurateTimeOffset) {
                  var offset = 8;
                  var mp4SampleDuration;
                  var mdat;
                  var moof;
                  var firstPTS;
                  var firstDTS;
                  var lastPTS;
                  var lastDTS;
                  var timeScale = track.timescale;
                  var inputSamples = track.samples;
                  var outputSamples = [];
                  var nbSamples = inputSamples.length;
                  var ptsNormalize = this._PTSNormalize;
                  var initPTS = this._initPTS; // if parsed fragment is contiguous with last one, let's use last DTS value as reference

                  var nextAvcDts = this.nextAvcDts;
                  var isSafari = this.isSafari;

                  if (nbSamples === 0) {
                    return;
                  } // Safari does not like overlapping DTS on consecutive fragments. let's use nextAvcDts to overcome this if fragments are consecutive

                  if (isSafari) {
                    // also consider consecutive fragments as being contiguous (even if a level switch occurs),
                    // for sake of clarity:
                    // consecutive fragments are frags with
                    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
                    //  - less than 200 ms PTS gaps (timeScale/5)
                    contiguous |= inputSamples.length && nextAvcDts &&
                        (accurateTimeOffset &&
                            Math.abs(timeOffset - nextAvcDts / timeScale) <
                            0.1 || Math.abs(
                                inputSamples[0].pts - nextAvcDts - initPTS) <
                            timeScale / 5);
                  }

                  if (!contiguous) {
                    // if not contiguous, let's use target timeOffset
                    nextAvcDts = timeOffset * timeScale;
                  } // PTS is coded on 33bits, and can loop from -2^32 to 2^32
                  // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value

                  inputSamples.forEach(function(sample) {
                    sample.pts = ptsNormalize(sample.pts - initPTS, nextAvcDts);
                    sample.dts = ptsNormalize(sample.dts - initPTS, nextAvcDts);
                  }); // sort video samples by DTS then PTS then demux id order

                  inputSamples.sort(function(a, b) {
                    var deltadts = a.dts - b.dts;
                    var deltapts = a.pts - b.pts;
                    return deltadts || deltapts || a.id - b.id;
                  }); // handle broken streams with PTS < DTS, tolerance up 0.2 seconds

                  var PTSDTSshift = inputSamples.reduce(function(prev, curr) {
                    return Math.max(Math.min(prev, curr.pts - curr.dts),
                        -1 * PTS_DTS_SHIFT_TOLERANCE_90KHZ);
                  }, 0);

                  if (PTSDTSshift < 0) {
                    __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].warn(
                        'PTS < DTS detected in video samples, shifting DTS by ' +
                        Object(
                            __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                            PTSDTSshift, true) + ' ms to overcome this issue');

                    for (var i = 0; i < inputSamples.length; i++) {
                      inputSamples[i].dts += PTSDTSshift;
                    }
                  } // compute first DTS and last DTS, normalize them against reference value

                  var sample = inputSamples[0];
                  firstDTS = Math.max(sample.dts, 0);
                  firstPTS = Math.max(sample.pts, 0); // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)

                  var delta = firstDTS - nextAvcDts; // if fragment are contiguous, detect hole/overlapping between fragments

                  if (contiguous) {
                    if (delta) {
                      if (delta > 1) {
                        __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                            'AVC: ' + Object(
                            __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                            delta, true) +
                            ' ms hole between fragments detected,filling it');
                      } else if (delta < -1) {
                        __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                            'AVC: ' + Object(
                            __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                            -delta, true) +
                            ' ms overlapping between fragments detected');
                      } // remove hole/gap : set DTS to next expected DTS

                      firstDTS = nextAvcDts;
                      inputSamples[0].dts = firstDTS; // offset PTS as well, ensure that PTS is smaller or equal than new DTS

                      firstPTS = Math.max(firstPTS - delta, nextAvcDts);
                      inputSamples[0].pts = firstPTS;
                      __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                          'Video: PTS/DTS adjusted: ' + Object(
                          __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                          firstPTS, true) + '/' + Object(
                          __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                          firstDTS, true) + ', delta: ' + Object(
                          __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                          delta, true) + ' ms');
                    }
                  } // compute lastPTS/lastDTS

                  sample = inputSamples[inputSamples.length - 1];
                  lastDTS = Math.max(sample.dts, 0);
                  lastPTS = Math.max(sample.pts, 0, lastDTS); // on Safari let's signal the same sample duration for all samples
                  // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
                  // set this constant duration as being the avg delta between consecutive DTS.

                  if (isSafari) {
                    mp4SampleDuration = Math.round(
                        (lastDTS - firstDTS) / (inputSamples.length - 1));
                  }

                  var nbNalu = 0,
                      naluLen = 0;

                  for (var _i = 0; _i < nbSamples; _i++) {
                    // compute total/avc sample length and nb of NAL units
                    var _sample = inputSamples[_i],
                        units = _sample.units,
                        nbUnits = units.length,
                        sampleLen = 0;

                    for (var j = 0; j < nbUnits; j++) {
                      sampleLen += units[j].data.length;
                    }

                    naluLen += sampleLen;
                    nbNalu += nbUnits;
                    _sample.length = sampleLen; // normalize PTS/DTS

                    if (isSafari) {
                      // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
                      _sample.dts = firstDTS + _i * mp4SampleDuration;
                    } else {
                      // ensure sample monotonic DTS
                      _sample.dts = Math.max(_sample.dts, firstDTS);
                    } // ensure that computed value is greater or equal than sample DTS

                    _sample.pts = Math.max(_sample.pts, _sample.dts);
                  }
                  /* concatenate the video data and construct the mdat in place
      (need 8 more bytes to fill length and mpdat type) */

                  var mdatSize = naluLen + 4 * nbNalu + 8;

                  try {
                    mdat = new Uint8Array(mdatSize);
                  } catch (err) {
                    this.observer.trigger(
                        __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_3__errors__['b' /* ErrorTypes */].MUX_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].REMUX_ALLOC_ERROR,
                          fatal: false,
                          bytes: mdatSize,
                          reason: 'fail allocating video mdat ' + mdatSize,
                        });
                    return;
                  }

                  var view = new DataView(mdat.buffer);
                  view.setUint32(0, mdatSize);
                  mdat.set(
                      __WEBPACK_IMPORTED_MODULE_1__mp4_generator__['a' /* default */].types.mdat,
                      4);

                  for (var _i2 = 0; _i2 < nbSamples; _i2++) {
                    var avcSample = inputSamples[_i2],
                        avcSampleUnits = avcSample.units,
                        mp4SampleLength = 0,
                        compositionTimeOffset = void 0; // convert NALU bitstream to MP4 format (prepend NALU with size field)

                    for (var _j = 0, _nbUnits = avcSampleUnits.length; _j <
                    _nbUnits; _j++) {
                      var unit = avcSampleUnits[_j],
                          unitData = unit.data,
                          unitDataLen = unit.data.byteLength;
                      view.setUint32(offset, unitDataLen);
                      offset += 4;
                      mdat.set(unitData, offset);
                      offset += unitDataLen;
                      mp4SampleLength += 4 + unitDataLen;
                    }

                    if (!isSafari) {
                      // expected sample duration is the Decoding Timestamp diff of consecutive samples
                      if (_i2 < nbSamples - 1) {
                        mp4SampleDuration = inputSamples[_i2 + 1].dts -
                            avcSample.dts;
                      } else {
                        var config = this.config,
                            lastFrameDuration = avcSample.dts -
                                inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;

                        if (config.stretchShortVideoTrack) {
                          // In some cases, a segment's audio track duration may exceed the video track duration.
                          // Since we've already remuxed audio, and we know how long the audio track is, we look to
                          // see if the delta to the next segment is longer than maxBufferHole.
                          // If so, playback would potentially get stuck, so we artificially inflate
                          // the duration of the last frame to minimize any potential gap between segments.
                          var maxBufferHole = config.maxBufferHole,
                              gapTolerance = Math.floor(
                                  maxBufferHole * timeScale),
                              deltaToFrameEnd = (audioTrackLength
                                  ? firstPTS + audioTrackLength * timeScale
                                  : this.nextAudioPts) - avcSample.pts;

                          if (deltaToFrameEnd > gapTolerance) {
                            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.
                            mp4SampleDuration = deltaToFrameEnd -
                                lastFrameDuration;

                            if (mp4SampleDuration < 0) {
                              mp4SampleDuration = lastFrameDuration;
                            }

                            __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                                'It is approximately ' + Object(
                                __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                                deltaToFrameEnd, false) +
                                ' ms to the next segment; using duration ' +
                                Object(
                                    __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                                    mp4SampleDuration, false) +
                                ' ms for the last video frame.');
                          } else {
                            mp4SampleDuration = lastFrameDuration;
                          }
                        } else {
                          mp4SampleDuration = lastFrameDuration;
                        }
                      }

                      compositionTimeOffset = Math.round(
                          avcSample.pts - avcSample.dts);
                    } else {
                      compositionTimeOffset = Math.max(0, mp4SampleDuration *
                          Math.round((avcSample.pts - avcSample.dts) /
                              mp4SampleDuration));
                    } // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');

                    outputSamples.push({
                      size: mp4SampleLength,
                      // constant duration
                      duration: mp4SampleDuration,
                      cts: compositionTimeOffset,
                      flags: {
                        isLeading: 0,
                        isDependedOn: 0,
                        hasRedundancy: 0,
                        degradPrio: 0,
                        dependsOn: avcSample.key ? 2 : 1,
                        isNonSync: avcSample.key ? 0 : 1,
                      },
                    });
                  } // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)

                  this.nextAvcDts = lastDTS + mp4SampleDuration;
                  var dropped = track.dropped;
                  track.nbNalu = 0;
                  track.dropped = 0;

                  if (outputSamples.length &&
                      navigator.userAgent.toLowerCase().indexOf('chrome') >
                      -1) {
                    var flags = outputSamples[0].flags; // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
                    // https://code.google.com/p/chromium/issues/detail?id=229412

                    flags.dependsOn = 2;
                    flags.isNonSync = 0;
                  }

                  track.samples = outputSamples;
                  moof = __WEBPACK_IMPORTED_MODULE_1__mp4_generator__['a' /* default */].moof(
                      track.sequenceNumber++, firstDTS, track);
                  track.samples = [];
                  var data = {
                    data1: moof,
                    data2: mdat,
                    startPTS: firstPTS / timeScale,
                    endPTS: (lastPTS + mp4SampleDuration) / timeScale,
                    startDTS: firstDTS / timeScale,
                    endDTS: this.nextAvcDts / timeScale,
                    type: 'video',
                    hasAudio: false,
                    hasVideo: true,
                    nb: outputSamples.length,
                    dropped: dropped,
                  };
                  this.observer.trigger(
                      __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].FRAG_PARSING_DATA,
                      data);
                  return data;
                };

                _proto.remuxAudio = function remuxAudio(
                    track, timeOffset, contiguous, accurateTimeOffset) {
                  var inputTimeScale = track.inputTimeScale;
                  var mp4timeScale = track.timescale;
                  var scaleFactor = inputTimeScale / mp4timeScale;
                  var mp4SampleDuration = track.isAAC ? 1024 : 1152;
                  var inputSampleDuration = mp4SampleDuration * scaleFactor;
                  var ptsNormalize = this._PTSNormalize;
                  var initPTS = this._initPTS;
                  var rawMPEG = !track.isAAC && this.typeSupported.mpeg;
                  var mp4Sample;
                  var fillFrame;
                  var mdat;
                  var moof;
                  var firstPTS;
                  var lastPTS;
                  var offset = rawMPEG ? 0 : 8;
                  var inputSamples = track.samples;
                  var outputSamples = [];
                  var nextAudioPts = this.nextAudioPts; // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
                  // for sake of clarity:
                  // consecutive fragments are frags with
                  //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
                  //  - less than 20 audio frames distance
                  // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
                  // this helps ensuring audio continuity
                  // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame

                  contiguous |= inputSamples.length && nextAudioPts &&
                      (accurateTimeOffset &&
                          Math.abs(timeOffset - nextAudioPts / inputTimeScale) <
                          0.1 || Math.abs(
                              inputSamples[0].pts - nextAudioPts - initPTS) <
                          20 * inputSampleDuration); // compute normalized PTS

                  inputSamples.forEach(function(sample) {
                    sample.pts = sample.dts = ptsNormalize(sample.pts - initPTS,
                        timeOffset * inputTimeScale);
                  }); // filter out sample with negative PTS that are not playable anyway
                  // if we don't remove these negative samples, they will shift all audio samples forward.
                  // leading to audio overlap between current / next fragment

                  inputSamples = inputSamples.filter(function(sample) {
                    return sample.pts >= 0;
                  }); // in case all samples have negative PTS, and have been filtered out, return now

                  if (inputSamples.length === 0) {
                    return;
                  }

                  if (!contiguous) {
                    if (!accurateTimeOffset) {
                      // if frag are mot contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS
                      nextAudioPts = inputSamples[0].pts;
                    } else {
                      // if timeOffset is accurate, let's use it as predicted next audio PTS
                      nextAudioPts = timeOffset * inputTimeScale;
                    }
                  } // If the audio track is missing samples, the frames seem to get "left-shifted" within the
                  // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
                  // In an effort to prevent this from happening, we inject frames here where there are gaps.
                  // When possible, we inject a silent frame; when that's not possible, we duplicate the last
                  // frame.

                  if (track.isAAC) {
                    var maxAudioFramesDrift = this.config.maxAudioFramesDrift;

                    for (var i = 0, nextPts = nextAudioPts; i <
                    inputSamples.length;) {
                      // First, let's see how far off this frame is from where we expect it to be
                      var sample = inputSamples[i],
                          delta;
                      var pts = sample.pts;
                      delta = pts - nextPts; // If we're overlapping by more than a duration, drop this sample

                      if (delta <= -maxAudioFramesDrift * inputSampleDuration) {
                        __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].warn(
                            'Dropping 1 audio frame @ ' + Object(
                            __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                            nextPts, true) + ' ms due to ' + Object(
                            __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                            delta, true) + ' ms overlap.');
                        inputSamples.splice(i, 1); // Don't touch nextPtsNorm or i
                      } // eslint-disable-line brace-style
                          // Insert missing frames if:
                          // 1: We're more than maxAudioFramesDrift frame away
                          // 2: Not more than MAX_SILENT_FRAME_DURATION away
                      // 3: currentTime (aka nextPtsNorm) is not 0
                      else if (delta >= maxAudioFramesDrift *
                          inputSampleDuration && delta <
                          MAX_SILENT_FRAME_DURATION_90KHZ && nextPts) {
                        var missing = Math.round(delta / inputSampleDuration);
                        __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].warn(
                            'Injecting ' + missing + ' audio frames @ ' +
                            Object(
                                __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                                nextPts, true) + ' ms due to ' + Object(
                            __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                            nextPts, true) + ' ms gap.');

                        for (var j = 0; j < missing; j++) {
                          var newStamp = Math.max(nextPts, 0);
                          fillFrame = __WEBPACK_IMPORTED_MODULE_0__aac_helper__['a' /* default */].getSilentFrame(
                              track.manifestCodec || track.codec,
                              track.channelCount);

                          if (!fillFrame) {
                            __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                                'Unable to get silent frame for given audio codec; duplicating last frame instead.');
                            fillFrame = sample.unit.subarray();
                          }

                          inputSamples.splice(i, 0, {
                            unit: fillFrame,
                            pts: newStamp,
                            dts: newStamp,
                          });
                          nextPts += inputSampleDuration;
                          i++;
                        } // Adjust sample to next expected pts

                        sample.pts = sample.dts = nextPts;
                        nextPts += inputSampleDuration;
                        i++;
                      } else {
                        // Otherwise, just adjust pts
                        if (Math.abs(delta) > 0.1 * inputSampleDuration) {// logger.log(`Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(pts / 90)} (should be ${Math.round(inputSampleDuration)}).`);
                        }

                        sample.pts = sample.dts = nextPts;
                        nextPts += inputSampleDuration;
                        i++;
                      }
                    }
                  } // compute mdat size, as we eventually filtered/added some samples

                  var nbSamples = inputSamples.length;
                  var mdatSize = 0;

                  while (nbSamples--) {
                    mdatSize += inputSamples[nbSamples].unit.byteLength;
                  }

                  for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 <
                  _nbSamples; _j2++) {
                    var audioSample = inputSamples[_j2];
                    var unit = audioSample.unit;
                    var _pts = audioSample.pts; // logger.log(`Audio/PTS:${toMsFromMpegTsClock(pts, true)}`);
                    // if not first sample

                    if (lastPTS !== undefined) {
                      mp4Sample.duration = Math.round(
                          (_pts - lastPTS) / scaleFactor);
                    } else {
                      var _delta = _pts - nextAudioPts;

                      var numMissingFrames = 0; // if fragment are contiguous, detect hole/overlapping between fragments
                      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)

                      if (contiguous && track.isAAC) {
                        // log delta
                        if (_delta) {
                          if (_delta > 0 && _delta <
                              MAX_SILENT_FRAME_DURATION_90KHZ) {
                            // Q: why do we have to round here, shouldn't this always result in an integer if timestamps are correct,
                            // and if not, shouldn't we actually Math.ceil() instead?
                            numMissingFrames = Math.round(
                                (_pts - nextAudioPts) / inputSampleDuration);
                            __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                                Object(
                                    __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                                    _delta, true) +
                                ' ms hole between AAC samples detected,filling it');

                            if (numMissingFrames > 0) {
                              fillFrame = __WEBPACK_IMPORTED_MODULE_0__aac_helper__['a' /* default */].getSilentFrame(
                                  track.manifestCodec || track.codec,
                                  track.channelCount);

                              if (!fillFrame) {
                                fillFrame = unit.subarray();
                              }

                              mdatSize += numMissingFrames * fillFrame.length;
                            } // if we have frame overlap, overlapping for more than half a frame duraion

                          } else if (_delta < -12) {
                            // drop overlapping audio frames... browser will deal with it
                            __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                                'drop overlapping AAC sample, expected/parsed/delta: ' +
                                Object(
                                    __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                                    nextAudioPts, true) + ' ms / ' + Object(
                                __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                                _pts, true) + ' ms / ' + Object(
                                __WEBPACK_IMPORTED_MODULE_4__utils_timescale_conversion__['b' /* toMsFromMpegTsClock */])(
                                -_delta, true) + ' ms');
                            mdatSize -= unit.byteLength;
                            continue;
                          } // set PTS/DTS to expected PTS/DTS

                          _pts = nextAudioPts;
                        }
                      } // remember first PTS of our audioSamples

                      firstPTS = _pts;

                      if (mdatSize > 0) {
                        mdatSize += offset;

                        try {
                          mdat = new Uint8Array(mdatSize);
                        } catch (err) {
                          this.observer.trigger(
                              __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].ERROR,
                              {
                                type: __WEBPACK_IMPORTED_MODULE_3__errors__['b' /* ErrorTypes */].MUX_ERROR,
                                details: __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].REMUX_ALLOC_ERROR,
                                fatal: false,
                                bytes: mdatSize,
                                reason: 'fail allocating audio mdat ' +
                                    mdatSize,
                              });
                          return;
                        }

                        if (!rawMPEG) {
                          var view = new DataView(mdat.buffer);
                          view.setUint32(0, mdatSize);
                          mdat.set(
                              __WEBPACK_IMPORTED_MODULE_1__mp4_generator__['a' /* default */].types.mdat,
                              4);
                        }
                      } else {
                        // no audio samples
                        return;
                      }

                      for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {
                        fillFrame = __WEBPACK_IMPORTED_MODULE_0__aac_helper__['a' /* default */].getSilentFrame(
                            track.manifestCodec || track.codec,
                            track.channelCount);

                        if (!fillFrame) {
                          __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                              'Unable to get silent frame for given audio codec; duplicating this frame instead.');
                          fillFrame = unit.subarray();
                        }

                        mdat.set(fillFrame, offset);
                        offset += fillFrame.byteLength;
                        mp4Sample = {
                          size: fillFrame.byteLength,
                          cts: 0,
                          duration: 1024,
                          flags: {
                            isLeading: 0,
                            isDependedOn: 0,
                            hasRedundancy: 0,
                            degradPrio: 0,
                            dependsOn: 1,
                          },
                        };
                        outputSamples.push(mp4Sample);
                      }
                    }

                    mdat.set(unit, offset);
                    var unitLen = unit.byteLength;
                    offset += unitLen; // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');

                    mp4Sample = {
                      size: unitLen,
                      cts: 0,
                      duration: 0,
                      flags: {
                        isLeading: 0,
                        isDependedOn: 0,
                        hasRedundancy: 0,
                        degradPrio: 0,
                        dependsOn: 1,
                      },
                    };
                    outputSamples.push(mp4Sample);
                    lastPTS = _pts;
                  }

                  var lastSampleDuration = 0;
                  nbSamples = outputSamples.length; // set last sample duration as being identical to previous sample

                  if (nbSamples >= 2) {
                    lastSampleDuration = outputSamples[nbSamples - 2].duration;
                    mp4Sample.duration = lastSampleDuration;
                  }

                  if (nbSamples) {
                    // next audio sample PTS should be equal to last sample PTS + duration
                    this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor *
                        lastSampleDuration; // logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));

                    track.samples = outputSamples;

                    if (rawMPEG) {
                      moof = new Uint8Array();
                    } else {
                      moof = __WEBPACK_IMPORTED_MODULE_1__mp4_generator__['a' /* default */].moof(
                          track.sequenceNumber++, firstPTS / scaleFactor,
                          track);
                    }

                    track.samples = [];
                    var start = firstPTS / inputTimeScale;
                    var end = nextAudioPts / inputTimeScale;
                    var audioData = {
                      data1: moof,
                      data2: mdat,
                      startPTS: start,
                      endPTS: end,
                      startDTS: start,
                      endDTS: end,
                      type: 'audio',
                      hasAudio: true,
                      hasVideo: false,
                      nb: nbSamples,
                    };
                    this.observer.trigger(
                        __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].FRAG_PARSING_DATA,
                        audioData);
                    return audioData;
                  }

                  return null;
                };

                _proto.remuxEmptyAudio = function remuxEmptyAudio(
                    track, timeOffset, contiguous, videoData) {
                  var inputTimeScale = track.inputTimeScale;
                  var mp4timeScale = track.samplerate
                      ? track.samplerate
                      : inputTimeScale;
                  var scaleFactor = inputTimeScale / mp4timeScale;
                  var nextAudioPts = this.nextAudioPts; // sync with video's timestamp

                  var startDTS = (nextAudioPts !== undefined
                      ? nextAudioPts
                      : videoData.startDTS * inputTimeScale) + this._initDTS;
                  var endDTS = videoData.endDTS * inputTimeScale +
                      this._initDTS; // one sample's duration value

                  var sampleDuration = 1024;
                  var frameDuration = scaleFactor * sampleDuration; // samples count of this segment's duration

                  var nbSamples = Math.ceil(
                      (endDTS - startDTS) / frameDuration); // silent frame

                  var silentFrame = __WEBPACK_IMPORTED_MODULE_0__aac_helper__['a' /* default */].getSilentFrame(
                      track.manifestCodec || track.codec, track.channelCount);
                  __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].warn(
                      'remux empty Audio'); // Can't remux if we can't generate a silent frame...

                  if (!silentFrame) {
                    __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].trace(
                        'Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
                    return;
                  }

                  var samples = [];

                  for (var i = 0; i < nbSamples; i++) {
                    var stamp = startDTS + i * frameDuration;
                    samples.push({
                      unit: silentFrame,
                      pts: stamp,
                      dts: stamp,
                    });
                  }

                  track.samples = samples;
                  this.remuxAudio(track, timeOffset, contiguous);
                };

                _proto.remuxID3 = function remuxID3(track) {
                  var length = track.samples.length,
                      sample;
                  var inputTimeScale = track.inputTimeScale;
                  var initPTS = this._initPTS;
                  var initDTS = this._initDTS; // consume samples

                  if (length) {
                    for (var index = 0; index < length; index++) {
                      sample = track.samples[index]; // setting id3 pts, dts to relative time
                      // using this._initPTS and this._initDTS to calculate relative time

                      sample.pts = (sample.pts - initPTS) / inputTimeScale;
                      sample.dts = (sample.dts - initDTS) / inputTimeScale;
                    }

                    this.observer.trigger(
                        __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].FRAG_PARSING_METADATA,
                        {
                          samples: track.samples,
                        });
                  }

                  track.samples = [];
                };

                _proto.remuxText = function remuxText(track) {
                  track.samples.sort(function(a, b) {
                    return a.pts - b.pts;
                  });
                  var length = track.samples.length,
                      sample;
                  var inputTimeScale = track.inputTimeScale;
                  var initPTS = this._initPTS; // consume samples

                  if (length) {
                    for (var index = 0; index < length; index++) {
                      sample = track.samples[index]; // setting text pts, dts to relative time
                      // using this._initPTS and this._initDTS to calculate relative time

                      sample.pts = (sample.pts - initPTS) / inputTimeScale;
                    }

                    this.observer.trigger(
                        __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].FRAG_PARSING_USERDATA,
                        {
                          samples: track.samples,
                        });
                  }

                  track.samples = [];
                };

                _proto._PTSNormalize = function _PTSNormalize(
                    value, reference) {
                  var offset;

                  if (reference === undefined) {
                    return value;
                  }

                  if (reference < value) {
                    // - 2^33
                    offset = -8589934592;
                  } else {
                    // + 2^33
                    offset = 8589934592;
                  }
                  /* PTS is 33bit (from 0 to 2^33 -1)
      if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
      PTS looping occured. fill the gap */

                  while (Math.abs(value - reference) > 4294967296) {
                    value += offset;
                  }

                  return value;
                };

                return MP4Remuxer;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (MP4Remuxer);

          /***/
        }),
        /* 54 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /**
           *  AAC helper
           */
          var AAC =
              /*#__PURE__*/
              function() {
                function AAC() {}

                AAC.getSilentFrame = function getSilentFrame(
                    codec, channelCount) {
                  switch (codec) {
                    case 'mp4a.40.2':
                      if (channelCount === 1) {
                        return new Uint8Array(
                            [0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
                      } else if (channelCount === 2) {
                        return new Uint8Array([
                          0x21,
                          0x00,
                          0x49,
                          0x90,
                          0x02,
                          0x19,
                          0x00,
                          0x23,
                          0x80]);
                      } else if (channelCount === 3) {
                        return new Uint8Array([
                          0x00,
                          0xc8,
                          0x00,
                          0x80,
                          0x20,
                          0x84,
                          0x01,
                          0x26,
                          0x40,
                          0x08,
                          0x64,
                          0x00,
                          0x8e]);
                      } else if (channelCount === 4) {
                        return new Uint8Array([
                          0x00,
                          0xc8,
                          0x00,
                          0x80,
                          0x20,
                          0x84,
                          0x01,
                          0x26,
                          0x40,
                          0x08,
                          0x64,
                          0x00,
                          0x80,
                          0x2c,
                          0x80,
                          0x08,
                          0x02,
                          0x38]);
                      } else if (channelCount === 5) {
                        return new Uint8Array([
                          0x00,
                          0xc8,
                          0x00,
                          0x80,
                          0x20,
                          0x84,
                          0x01,
                          0x26,
                          0x40,
                          0x08,
                          0x64,
                          0x00,
                          0x82,
                          0x30,
                          0x04,
                          0x99,
                          0x00,
                          0x21,
                          0x90,
                          0x02,
                          0x38]);
                      } else if (channelCount === 6) {
                        return new Uint8Array([
                          0x00,
                          0xc8,
                          0x00,
                          0x80,
                          0x20,
                          0x84,
                          0x01,
                          0x26,
                          0x40,
                          0x08,
                          0x64,
                          0x00,
                          0x82,
                          0x30,
                          0x04,
                          0x99,
                          0x00,
                          0x21,
                          0x90,
                          0x02,
                          0x00,
                          0xb2,
                          0x00,
                          0x20,
                          0x08,
                          0xe0]);
                      }

                      break;
                      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)

                    default:
                      if (channelCount === 1) {
                        // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
                        return new Uint8Array([
                          0x1,
                          0x40,
                          0x22,
                          0x80,
                          0xa3,
                          0x4e,
                          0xe6,
                          0x80,
                          0xba,
                          0x8,
                          0x0,
                          0x0,
                          0x0,
                          0x1c,
                          0x6,
                          0xf1,
                          0xc1,
                          0xa,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5e]);
                      } else if (channelCount === 2) {
                        // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
                        return new Uint8Array([
                          0x1,
                          0x40,
                          0x22,
                          0x80,
                          0xa3,
                          0x5e,
                          0xe6,
                          0x80,
                          0xba,
                          0x8,
                          0x0,
                          0x0,
                          0x0,
                          0x0,
                          0x95,
                          0x0,
                          0x6,
                          0xf1,
                          0xa1,
                          0xa,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5e]);
                      } else if (channelCount === 3) {
                        // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
                        return new Uint8Array([
                          0x1,
                          0x40,
                          0x22,
                          0x80,
                          0xa3,
                          0x5e,
                          0xe6,
                          0x80,
                          0xba,
                          0x8,
                          0x0,
                          0x0,
                          0x0,
                          0x0,
                          0x95,
                          0x0,
                          0x6,
                          0xf1,
                          0xa1,
                          0xa,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5a,
                          0x5e]);
                      }

                      break;
                  }

                  return null;
                };

                return AAC;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (AAC);

          /***/
        }),
        /* 55 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /**
           * Generate MP4 Box
           */
          var UINT32_MAX = Math.pow(2, 32) - 1;

          var MP4 =
              /*#__PURE__*/
              function() {
                function MP4() {}

                MP4.init = function init() {
                  MP4.types = {
                    avc1: [],
                    // codingname
                    avcC: [],
                    btrt: [],
                    dinf: [],
                    dref: [],
                    esds: [],
                    ftyp: [],
                    hdlr: [],
                    mdat: [],
                    mdhd: [],
                    mdia: [],
                    mfhd: [],
                    minf: [],
                    moof: [],
                    moov: [],
                    mp4a: [],
                    '.mp3': [],
                    mvex: [],
                    mvhd: [],
                    pasp: [],
                    sdtp: [],
                    stbl: [],
                    stco: [],
                    stsc: [],
                    stsd: [],
                    stsz: [],
                    stts: [],
                    tfdt: [],
                    tfhd: [],
                    traf: [],
                    trak: [],
                    trun: [],
                    trex: [],
                    tkhd: [],
                    vmhd: [],
                    smhd: [],
                  };
                  var i;

                  for (i in MP4.types) {
                    if (MP4.types.hasOwnProperty(i)) {
                      MP4.types[i] = [
                        i.charCodeAt(0),
                        i.charCodeAt(1),
                        i.charCodeAt(2),
                        i.charCodeAt(3)];
                    }
                  }

                  var videoHdlr = new Uint8Array([
                    0x00, // version 0
                    0x00,
                    0x00,
                    0x00, // flags
                    0x00,
                    0x00,
                    0x00,
                    0x00, // pre_defined
                    0x76,
                    0x69,
                    0x64,
                    0x65, // handler_type: 'vide'
                    0x00,
                    0x00,
                    0x00,
                    0x00, // reserved
                    0x00,
                    0x00,
                    0x00,
                    0x00, // reserved
                    0x00,
                    0x00,
                    0x00,
                    0x00, // reserved
                    0x56,
                    0x69,
                    0x64,
                    0x65,
                    0x6f,
                    0x48,
                    0x61,
                    0x6e,
                    0x64,
                    0x6c,
                    0x65,
                    0x72,
                    0x00, // name: 'VideoHandler'
                  ]);
                  var audioHdlr = new Uint8Array([
                    0x00, // version 0
                    0x00,
                    0x00,
                    0x00, // flags
                    0x00,
                    0x00,
                    0x00,
                    0x00, // pre_defined
                    0x73,
                    0x6f,
                    0x75,
                    0x6e, // handler_type: 'soun'
                    0x00,
                    0x00,
                    0x00,
                    0x00, // reserved
                    0x00,
                    0x00,
                    0x00,
                    0x00, // reserved
                    0x00,
                    0x00,
                    0x00,
                    0x00, // reserved
                    0x53,
                    0x6f,
                    0x75,
                    0x6e,
                    0x64,
                    0x48,
                    0x61,
                    0x6e,
                    0x64,
                    0x6c,
                    0x65,
                    0x72,
                    0x00, // name: 'SoundHandler'
                  ]);
                  MP4.HDLR_TYPES = {
                    'video': videoHdlr,
                    'audio': audioHdlr,
                  };
                  var dref = new Uint8Array([
                    0x00, // version 0
                    0x00, 0x00, 0x00, // flags
                    0x00, 0x00, 0x00, 0x01, // entry_count
                    0x00, 0x00, 0x00, 0x0c, // entry_size
                    0x75, 0x72, 0x6c, 0x20, // 'url' type
                    0x00, // version 0
                    0x00, 0x00, 0x01, // entry_flags
                  ]);
                  var stco = new Uint8Array([
                    0x00, // version
                    0x00, 0x00, 0x00, // flags
                    0x00, 0x00, 0x00, 0x00, // entry_count
                  ]);
                  MP4.STTS = MP4.STSC = MP4.STCO = stco;
                  MP4.STSZ = new Uint8Array([
                    0x00, // version
                    0x00, 0x00, 0x00, // flags
                    0x00, 0x00, 0x00, 0x00, // sample_size
                    0x00, 0x00, 0x00, 0x00, // sample_count
                  ]);
                  MP4.VMHD = new Uint8Array([
                    0x00, // version
                    0x00, 0x00, 0x01, // flags
                    0x00, 0x00, // graphicsmode
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // opcolor
                  ]);
                  MP4.SMHD = new Uint8Array([
                    0x00, // version
                    0x00, 0x00, 0x00, // flags
                    0x00, 0x00, // balance
                    0x00, 0x00, // reserved
                  ]);
                  MP4.STSD = new Uint8Array([
                    0x00, // version 0
                    0x00, 0x00, 0x00, // flags
                    0x00, 0x00, 0x00, 0x01]); // entry_count

                  var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom

                  var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1

                  var minorVersion = new Uint8Array([0, 0, 0, 1]);
                  MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion,
                      majorBrand, avc1Brand);
                  MP4.DINF = MP4.box(MP4.types.dinf,
                      MP4.box(MP4.types.dref, dref));
                };

                MP4.box = function box(type) {
                  var payload = Array.prototype.slice.call(arguments, 1),
                      size = 8,
                      i = payload.length,
                      len = i,
                      result; // calculate the total size we need to allocate

                  while (i--) {
                    size += payload[i].byteLength;
                  }

                  result = new Uint8Array(size);
                  result[0] = size >> 24 & 0xff;
                  result[1] = size >> 16 & 0xff;
                  result[2] = size >> 8 & 0xff;
                  result[3] = size & 0xff;
                  result.set(type, 4); // copy the payload into the result

                  for (i = 0, size = 8; i < len; i++) {
                    // copy payload[i] array @ offset size
                    result.set(payload[i], size);
                    size += payload[i].byteLength;
                  }

                  return result;
                };

                MP4.hdlr = function hdlr(type) {
                  return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
                };

                MP4.mdat = function mdat(data) {
                  return MP4.box(MP4.types.mdat, data);
                };

                MP4.mdhd = function mdhd(timescale, duration) {
                  duration *= timescale;
                  var upperWordDuration = Math.floor(
                      duration / (UINT32_MAX + 1));
                  var lowerWordDuration = Math.floor(
                      duration % (UINT32_MAX + 1));
                  return MP4.box(MP4.types.mdhd, new Uint8Array([
                    0x01, // version 1
                    0x00,
                    0x00,
                    0x00, // flags
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x02, // creation_time
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x03, // modification_time
                    timescale >> 24 & 0xFF,
                    timescale >> 16 & 0xFF,
                    timescale >> 8 & 0xFF,
                    timescale & 0xFF, // timescale
                    upperWordDuration >> 24,
                    upperWordDuration >> 16 & 0xFF,
                    upperWordDuration >> 8 & 0xFF,
                    upperWordDuration & 0xFF,
                    lowerWordDuration >> 24,
                    lowerWordDuration >> 16 & 0xFF,
                    lowerWordDuration >> 8 & 0xFF,
                    lowerWordDuration & 0xFF,
                    0x55,
                    0xc4, // 'und' language (undetermined)
                    0x00,
                    0x00]));
                };

                MP4.mdia = function mdia(track) {
                  return MP4.box(MP4.types.mdia,
                      MP4.mdhd(track.timescale, track.duration),
                      MP4.hdlr(track.type), MP4.minf(track));
                };

                MP4.mfhd = function mfhd(sequenceNumber) {
                  return MP4.box(MP4.types.mfhd, new Uint8Array([
                    0x00,
                    0x00,
                    0x00,
                    0x00, // flags
                    sequenceNumber >> 24,
                    sequenceNumber >> 16 & 0xFF,
                    sequenceNumber >> 8 & 0xFF,
                    sequenceNumber & 0xFF, // sequence_number
                  ]));
                };

                MP4.minf = function minf(track) {
                  if (track.type === 'audio') {
                    return MP4.box(MP4.types.minf,
                        MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF,
                        MP4.stbl(track));
                  } else {
                    return MP4.box(MP4.types.minf,
                        MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF,
                        MP4.stbl(track));
                  }
                };

                MP4.moof = function moof(sn, baseMediaDecodeTime, track) {
                  return MP4.box(MP4.types.moof, MP4.mfhd(sn),
                      MP4.traf(track, baseMediaDecodeTime));
                }
                /**
                 * @param tracks... (optional) {array} the tracks associated with this movie
                 */
                ;

                MP4.moov = function moov(tracks) {
                  var i = tracks.length,
                      boxes = [];

                  while (i--) {
                    boxes[i] = MP4.trak(tracks[i]);
                  }

                  return MP4.box.apply(null, [
                    MP4.types.moov,
                    MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(
                      boxes).concat(MP4.mvex(tracks)));
                };

                MP4.mvex = function mvex(tracks) {
                  var i = tracks.length,
                      boxes = [];

                  while (i--) {
                    boxes[i] = MP4.trex(tracks[i]);
                  }

                  return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
                };

                MP4.mvhd = function mvhd(timescale, duration) {
                  duration *= timescale;
                  var upperWordDuration = Math.floor(
                      duration / (UINT32_MAX + 1));
                  var lowerWordDuration = Math.floor(
                      duration % (UINT32_MAX + 1));
                  var bytes = new Uint8Array([
                    0x01, // version 1
                    0x00,
                    0x00,
                    0x00, // flags
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x02, // creation_time
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x03, // modification_time
                    timescale >> 24 & 0xFF,
                    timescale >> 16 & 0xFF,
                    timescale >> 8 & 0xFF,
                    timescale & 0xFF, // timescale
                    upperWordDuration >> 24,
                    upperWordDuration >> 16 & 0xFF,
                    upperWordDuration >> 8 & 0xFF,
                    upperWordDuration & 0xFF,
                    lowerWordDuration >> 24,
                    lowerWordDuration >> 16 & 0xFF,
                    lowerWordDuration >> 8 & 0xFF,
                    lowerWordDuration & 0xFF,
                    0x00,
                    0x01,
                    0x00,
                    0x00, // 1.0 rate
                    0x01,
                    0x00, // 1.0 volume
                    0x00,
                    0x00, // reserved
                    0x00,
                    0x00,
                    0x00,
                    0x00, // reserved
                    0x00,
                    0x00,
                    0x00,
                    0x00, // reserved
                    0x00,
                    0x01,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x01,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x40,
                    0x00,
                    0x00,
                    0x00, // transformation: unity matrix
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00, // pre_defined
                    0xff,
                    0xff,
                    0xff,
                    0xff, // next_track_ID
                  ]);
                  return MP4.box(MP4.types.mvhd, bytes);
                };

                MP4.sdtp = function sdtp(track) {
                  var samples = track.samples || [],
                      bytes = new Uint8Array(4 + samples.length),
                      flags,
                      i; // leave the full box header (4 bytes) all zero
                  // write the sample table

                  for (i = 0; i < samples.length; i++) {
                    flags = samples[i].flags;
                    bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn <<
                        2 | flags.hasRedundancy;
                  }

                  return MP4.box(MP4.types.sdtp, bytes);
                };

                MP4.stbl = function stbl(track) {
                  return MP4.box(MP4.types.stbl, MP4.stsd(track),
                      MP4.box(MP4.types.stts, MP4.STTS),
                      MP4.box(MP4.types.stsc, MP4.STSC),
                      MP4.box(MP4.types.stsz, MP4.STSZ),
                      MP4.box(MP4.types.stco, MP4.STCO));
                };

                MP4.avc1 = function avc1(track) {
                  var sps = [],
                      pps = [],
                      i,
                      data,
                      len; // assemble the SPSs

                  for (i = 0; i < track.sps.length; i++) {
                    data = track.sps[i];
                    len = data.byteLength;
                    sps.push(len >>> 8 & 0xFF);
                    sps.push(len & 0xFF); // SPS

                    sps = sps.concat(Array.prototype.slice.call(data));
                  } // assemble the PPSs

                  for (i = 0; i < track.pps.length; i++) {
                    data = track.pps[i];
                    len = data.byteLength;
                    pps.push(len >>> 8 & 0xFF);
                    pps.push(len & 0xFF);
                    pps = pps.concat(Array.prototype.slice.call(data));
                  }

                  var avcc = MP4.box(MP4.types.avcC, new Uint8Array([
                        0x01, // version
                        sps[3], // profile
                        sps[4], // profile compat
                        sps[5], // level
                        0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
                        0xE0 | track.sps.length, // 3bit reserved (111) + numOfSequenceParameterSets
                      ].concat(sps).concat([
                        track.pps.length, // numOfPictureParameterSets
                      ]).concat(pps))),
                      // "PPS"
                      width = track.width,
                      height = track.height,
                      hSpacing = track.pixelRatio[0],
                      vSpacing = track.pixelRatio[1];
                  return MP4.box(MP4.types.avc1, new Uint8Array([
                        0x00,
                        0x00,
                        0x00, // reserved
                        0x00,
                        0x00,
                        0x00, // reserved
                        0x00,
                        0x01, // data_reference_index
                        0x00,
                        0x00, // pre_defined
                        0x00,
                        0x00, // reserved
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00, // pre_defined
                        width >> 8 & 0xFF,
                        width & 0xff, // width
                        height >> 8 & 0xFF,
                        height & 0xff, // height
                        0x00,
                        0x48,
                        0x00,
                        0x00, // horizresolution
                        0x00,
                        0x48,
                        0x00,
                        0x00, // vertresolution
                        0x00,
                        0x00,
                        0x00,
                        0x00, // reserved
                        0x00,
                        0x01, // frame_count
                        0x12,
                        0x64,
                        0x61,
                        0x69,
                        0x6C, // dailymotion/hls.js
                        0x79,
                        0x6D,
                        0x6F,
                        0x74,
                        0x69,
                        0x6F,
                        0x6E,
                        0x2F,
                        0x68,
                        0x6C,
                        0x73,
                        0x2E,
                        0x6A,
                        0x73,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00,
                        0x00, // compressorname
                        0x00,
                        0x18, // depth = 24
                        0x11,
                        0x11]), // pre_defined = -1
                      avcc, MP4.box(MP4.types.btrt, new Uint8Array([
                        0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
                        0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
                        0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate
                      MP4.box(MP4.types.pasp, new Uint8Array([
                        hSpacing >> 24, // hSpacing
                        hSpacing >> 16 & 0xFF,
                        hSpacing >> 8 & 0xFF,
                        hSpacing & 0xFF,
                        vSpacing >> 24, // vSpacing
                        vSpacing >> 16 & 0xFF,
                        vSpacing >> 8 & 0xFF,
                        vSpacing & 0xFF])));
                };

                MP4.esds = function esds(track) {
                  var configlen = track.config.length;
                  return new Uint8Array([
                    0x00, // version 0
                    0x00, 0x00, 0x00, // flags
                    0x03, // descriptor_type
                    0x17 + configlen, // length
                    0x00, 0x01, // es_id
                    0x00, // stream_priority
                    0x04, // descriptor_type
                    0x0f + configlen, // length
                    0x40, // codec : mpeg4_audio
                    0x15, // stream_type
                    0x00, 0x00, 0x00, // buffer_size
                    0x00, 0x00, 0x00, 0x00, // maxBitrate
                    0x00, 0x00, 0x00, 0x00, // avgBitrate
                    0x05, // descriptor_type
                  ].concat([configlen]).
                      concat(track.config).
                      concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
                };

                MP4.mp4a = function mp4a(track) {
                  var samplerate = track.samplerate;
                  return MP4.box(MP4.types.mp4a, new Uint8Array([
                    0x00, 0x00, 0x00, // reserved
                    0x00, 0x00, 0x00, // reserved
                    0x00, 0x01, // data_reference_index
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
                    0x00, track.channelCount, // channelcount
                    0x00, 0x10, // sampleSize:16bits
                    0x00, 0x00, 0x00, 0x00, // reserved2
                    samplerate >> 8 & 0xFF, samplerate & 0xff, //
                    0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
                };

                MP4.mp3 = function mp3(track) {
                  var samplerate = track.samplerate;
                  return MP4.box(MP4.types['.mp3'], new Uint8Array([
                    0x00, 0x00, 0x00, // reserved
                    0x00, 0x00, 0x00, // reserved
                    0x00, 0x01, // data_reference_index
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
                    0x00, track.channelCount, // channelcount
                    0x00, 0x10, // sampleSize:16bits
                    0x00, 0x00, 0x00, 0x00, // reserved2
                    samplerate >> 8 & 0xFF, samplerate & 0xff, //
                    0x00, 0x00]));
                };

                MP4.stsd = function stsd(track) {
                  if (track.type === 'audio') {
                    if (!track.isAAC && track.codec === 'mp3') {
                      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
                    }

                    return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
                  } else {
                    return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
                  }
                };

                MP4.tkhd = function tkhd(track) {
                  var id = track.id,
                      duration = track.duration * track.timescale,
                      width = track.width,
                      height = track.height,
                      upperWordDuration = Math.floor(
                          duration / (UINT32_MAX + 1)),
                      lowerWordDuration = Math.floor(
                          duration % (UINT32_MAX + 1));
                  return MP4.box(MP4.types.tkhd, new Uint8Array([
                    0x01, // version 1
                    0x00,
                    0x00,
                    0x07, // flags
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x02, // creation_time
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x03, // modification_time
                    id >> 24 & 0xFF,
                    id >> 16 & 0xFF,
                    id >> 8 & 0xFF,
                    id & 0xFF, // track_ID
                    0x00,
                    0x00,
                    0x00,
                    0x00, // reserved
                    upperWordDuration >> 24,
                    upperWordDuration >> 16 & 0xFF,
                    upperWordDuration >> 8 & 0xFF,
                    upperWordDuration & 0xFF,
                    lowerWordDuration >> 24,
                    lowerWordDuration >> 16 & 0xFF,
                    lowerWordDuration >> 8 & 0xFF,
                    lowerWordDuration & 0xFF,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00, // reserved
                    0x00,
                    0x00, // layer
                    0x00,
                    0x00, // alternate_group
                    0x00,
                    0x00, // non-audio track volume
                    0x00,
                    0x00, // reserved
                    0x00,
                    0x01,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x01,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x40,
                    0x00,
                    0x00,
                    0x00, // transformation: unity matrix
                    width >> 8 & 0xFF,
                    width & 0xFF,
                    0x00,
                    0x00, // width
                    height >> 8 & 0xFF,
                    height & 0xFF,
                    0x00,
                    0x00, // height
                  ]));
                };

                MP4.traf = function traf(track, baseMediaDecodeTime) {
                  var sampleDependencyTable = MP4.sdtp(track),
                      id = track.id,
                      upperWordBaseMediaDecodeTime = Math.floor(
                          baseMediaDecodeTime / (UINT32_MAX + 1)),
                      lowerWordBaseMediaDecodeTime = Math.floor(
                          baseMediaDecodeTime % (UINT32_MAX + 1));
                  return MP4.box(MP4.types.traf,
                      MP4.box(MP4.types.tfhd, new Uint8Array([
                        0x00, // version 0
                        0x00, 0x00, 0x00, // flags
                        id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF])),
                      MP4.box(MP4.types.tfdt, new Uint8Array([
                        0x01, // version 1
                        0x00,
                        0x00,
                        0x00, // flags
                        upperWordBaseMediaDecodeTime >> 24,
                        upperWordBaseMediaDecodeTime >> 16 & 0XFF,
                        upperWordBaseMediaDecodeTime >> 8 & 0XFF,
                        upperWordBaseMediaDecodeTime & 0xFF,
                        lowerWordBaseMediaDecodeTime >> 24,
                        lowerWordBaseMediaDecodeTime >> 16 & 0XFF,
                        lowerWordBaseMediaDecodeTime >> 8 & 0XFF,
                        lowerWordBaseMediaDecodeTime & 0xFF])), MP4.trun(track,
                          sampleDependencyTable.length + 16 + // tfhd
                          20 + // tfdt
                          8 + // traf header
                          16 + // mfhd
                          8 + // moof header
                          8), // mdat header
                      sampleDependencyTable);
                }
                /**
                 * Generate a track box.
                 * @param track {object} a track definition
                 * @return {Uint8Array} the track box
                 */
                ;

                MP4.trak = function trak(track) {
                  track.duration = track.duration || 0xffffffff;
                  return MP4.box(MP4.types.trak, MP4.tkhd(track),
                      MP4.mdia(track));
                };

                MP4.trex = function trex(track) {
                  var id = track.id;
                  return MP4.box(MP4.types.trex, new Uint8Array([
                    0x00, // version 0
                    0x00,
                    0x00,
                    0x00, // flags
                    id >> 24,
                    id >> 16 & 0XFF,
                    id >> 8 & 0XFF,
                    id & 0xFF, // track_ID
                    0x00,
                    0x00,
                    0x00,
                    0x01, // default_sample_description_index
                    0x00,
                    0x00,
                    0x00,
                    0x00, // default_sample_duration
                    0x00,
                    0x00,
                    0x00,
                    0x00, // default_sample_size
                    0x00,
                    0x01,
                    0x00,
                    0x01, // default_sample_flags
                  ]));
                };

                MP4.trun = function trun(track, offset) {
                  var samples = track.samples || [],
                      len = samples.length,
                      arraylen = 12 + 16 * len,
                      array = new Uint8Array(arraylen),
                      i,
                      sample,
                      duration,
                      size,
                      flags,
                      cts;
                  offset += 8 + arraylen;
                  array.set([
                    0x00, // version 0
                    0x00,
                    0x0f,
                    0x01, // flags
                    len >>> 24 & 0xFF,
                    len >>> 16 & 0xFF,
                    len >>> 8 & 0xFF,
                    len & 0xFF, // sample_count
                    offset >>> 24 & 0xFF,
                    offset >>> 16 & 0xFF,
                    offset >>> 8 & 0xFF,
                    offset & 0xFF, // data_offset
                  ], 0);

                  for (i = 0; i < len; i++) {
                    sample = samples[i];
                    duration = sample.duration;
                    size = sample.size;
                    flags = sample.flags;
                    cts = sample.cts;
                    array.set([
                      duration >>> 24 & 0xFF,
                      duration >>> 16 & 0xFF,
                      duration >>> 8 & 0xFF,
                      duration & 0xFF, // sample_duration
                      size >>> 24 & 0xFF,
                      size >>> 16 & 0xFF,
                      size >>> 8 & 0xFF,
                      size & 0xFF, // sample_size
                      flags.isLeading << 2 | flags.dependsOn,
                      flags.isDependedOn << 6 | flags.hasRedundancy << 4 |
                      flags.paddingValue << 1 | flags.isNonSync,
                      flags.degradPrio & 0xF0 << 8,
                      flags.degradPrio & 0x0F, // sample_flags
                      cts >>> 24 & 0xFF,
                      cts >>> 16 & 0xFF,
                      cts >>> 8 & 0xFF,
                      cts & 0xFF, // sample_composition_time_offset
                    ], 12 + 16 * i);
                  }

                  return MP4.box(MP4.types.trun, array);
                };

                MP4.initSegment = function initSegment(tracks) {
                  if (!MP4.types) {
                    MP4.init();
                  }

                  var movie = MP4.moov(tracks),
                      result;
                  result = new Uint8Array(
                      MP4.FTYP.byteLength + movie.byteLength);
                  result.set(MP4.FTYP);
                  result.set(movie, MP4.FTYP.byteLength);
                  return result;
                };

                return MP4;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (MP4);

          /***/
        }),
        /* 56 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* unused harmony export toTimescaleFromScale */
          /* unused harmony export toTimescaleFromBase */
          /* harmony export (immutable) */
          __webpack_exports__['b'] = toMsFromMpegTsClock;
          /* harmony export (immutable) */
          __webpack_exports__['a'] = toMpegTsClockFromTimescale;
          var MPEG_TS_CLOCK_FREQ_HZ = 90000;

          function toTimescaleFromScale(value, destScale, srcScale, round) {
            if (srcScale === void 0) {
              srcScale = 1;
            }

            if (round === void 0) {
              round = false;
            }

            return toTimescaleFromBase(value, destScale, 1 / srcScale);
          }

          function toTimescaleFromBase(value, destScale, srcBase, round) {
            if (srcBase === void 0) {
              srcBase = 1;
            }

            if (round === void 0) {
              round = false;
            }

            var result = value * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`

            return round ? Math.round(result) : result;
          }

          function toMsFromMpegTsClock(value, round) {
            if (round === void 0) {
              round = false;
            }

            return toTimescaleFromBase(value, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ,
                round);
          }

          function toMpegTsClockFromTimescale(value, srcScale) {
            if (srcScale === void 0) {
              srcScale = 1;
            }

            return toTimescaleFromBase(value, MPEG_TS_CLOCK_FREQ_HZ,
                1 / srcScale);
          }

          /***/
        }),
        /* 57 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__events__ = __webpack_require__(2);
          /**
           * passthrough remuxer
           */


          var PassThroughRemuxer =
              /*#__PURE__*/
              function() {
                function PassThroughRemuxer(observer) {
                  this.observer = observer;
                }

                var _proto = PassThroughRemuxer.prototype;

                _proto.destroy = function destroy() {};

                _proto.resetTimeStamp = function resetTimeStamp() {};

                _proto.resetInitSegment = function resetInitSegment() {};

                _proto.remux = function remux(
                    audioTrack, videoTrack, id3Track, textTrack, timeOffset,
                    contiguous, accurateTimeOffset, rawData) {
                  var observer = this.observer;
                  var streamType = '';

                  if (audioTrack) {
                    streamType += 'audio';
                  }

                  if (videoTrack) {
                    streamType += 'video';
                  }

                  observer.trigger(
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].FRAG_PARSING_DATA,
                      {
                        data1: rawData,
                        startPTS: timeOffset,
                        startDTS: timeOffset,
                        type: streamType,
                        hasAudio: !!audioTrack,
                        hasVideo: !!videoTrack,
                        nb: 1,
                        dropped: 0,
                      }); // notify end of parsing

                  observer.trigger(
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].FRAG_PARSED);
                };

                return PassThroughRemuxer;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (PassThroughRemuxer);

          /***/
        }),
        /* 58 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          Object.defineProperty(__webpack_exports__, '__esModule',
              {value: true});
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__demux_demuxer_inline__ = __webpack_require__(
              24);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3_eventemitter3__ = __webpack_require__(
              14);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3_eventemitter3___default = __webpack_require__.n(
              __WEBPACK_IMPORTED_MODULE_3_eventemitter3__);
          /* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */

          var DemuxerWorker = function DemuxerWorker(self) {
            // observer setup
            var observer = new __WEBPACK_IMPORTED_MODULE_3_eventemitter3__['EventEmitter']();

            observer.trigger = function trigger(event) {
              for (var _len = arguments.length, data = new Array(
                  _len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                data[_key - 1] = arguments[_key];
              }

              observer.emit.apply(observer, [event, event].concat(data));
            };

            observer.off = function off(event) {
              for (var _len2 = arguments.length, data = new Array(
                  _len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 <
              _len2; _key2++) {
                data[_key2 - 1] = arguments[_key2];
              }

              observer.removeListener.apply(observer, [event].concat(data));
            };

            var forwardMessage = function forwardMessage(ev, data) {
              self.postMessage({
                event: ev,
                data: data,
              });
            };

            self.addEventListener('message', function(ev) {
              var data = ev.data; // console.log('demuxer cmd:' + data.cmd);

              switch (data.cmd) {
                case 'init':
                  var config = JSON.parse(data.config);
                  self.demuxer = new __WEBPACK_IMPORTED_MODULE_0__demux_demuxer_inline__['a' /* default */](
                      observer, data.typeSupported, config, data.vendor);
                  Object(
                      __WEBPACK_IMPORTED_MODULE_2__utils_logger__['a' /* enableLogs */])(
                      config.debug); // signal end of worker init

                  forwardMessage('init', null);
                  break;

                case 'demux':
                  self.demuxer.push(data.data, data.decryptdata,
                      data.initSegment, data.audioCodec, data.videoCodec,
                      data.timeOffset, data.discontinuity, data.trackSwitch,
                      data.contiguous, data.duration, data.accurateTimeOffset,
                      data.defaultInitPTS);
                  break;

                default:
                  break;
              }
            }); // forward events to main thread

            observer.on(
                __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_DECRYPTED,
                forwardMessage);
            observer.on(
                __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_PARSING_INIT_SEGMENT,
                forwardMessage);
            observer.on(
                __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_PARSED,
                forwardMessage);
            observer.on(
                __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                forwardMessage);
            observer.on(
                __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_PARSING_METADATA,
                forwardMessage);
            observer.on(
                __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_PARSING_USERDATA,
                forwardMessage);
            observer.on(
                __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].INIT_PTS_FOUND,
                forwardMessage); // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)

            observer.on(
                __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_PARSING_DATA,
                function(ev, data) {
                  var transferable = [];
                  var message = {
                    event: ev,
                    data: data,
                  };

                  if (data.data1) {
                    message.data1 = data.data1.buffer;
                    transferable.push(data.data1.buffer);
                    delete data.data1;
                  }

                  if (data.data2) {
                    message.data2 = data.data2.buffer;
                    transferable.push(data.data2.buffer);
                    delete data.data2;
                  }

                  self.postMessage(message, transferable);
                });
          };

          /* harmony default export */
          __webpack_exports__['default'] = (DemuxerWorker);

          /***/
        }),
        /* 59 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* unused harmony export STALL_MINIMUM_DURATION_MS */
          /* unused harmony export MAX_START_GAP_JUMP */
          /* unused harmony export SKIP_BUFFER_HOLE_STEP_SECONDS */
          /* unused harmony export SKIP_BUFFER_RANGE_START */
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return GapController; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__utils_buffer_helper__ = __webpack_require__(
              6);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__utils_logger__ = __webpack_require__(
              1);

          var STALL_MINIMUM_DURATION_MS = 250;
          var MAX_START_GAP_JUMP = 2.0;
          var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;
          var SKIP_BUFFER_RANGE_START = 0.05;

          var GapController =
              /*#__PURE__*/
              function() {
                function GapController(config, media, fragmentTracker, hls) {
                  this.config = config;
                  this.media = media;
                  this.fragmentTracker = fragmentTracker;
                  this.hls = hls;
                  this.nudgeRetry = 0;
                  this.stallReported = false;
                  this.stalled = null;
                  this.moved = false;
                  this.seeking = false;
                }

                /**
                 * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
                 * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
                 *
                 * @param {number} lastCurrentTime Previously read playhead position
                 */


                var _proto = GapController.prototype;

                _proto.poll = function poll(lastCurrentTime) {
                  var config = this.config,
                      media = this.media,
                      stalled = this.stalled;
                  var currentTime = media.currentTime,
                      seeking = media.seeking;
                  var seeked = this.seeking && !seeking;
                  var beginSeek = !this.seeking && seeking;
                  this.seeking = seeking; // The playhead is moving, no-op

                  if (currentTime !== lastCurrentTime) {
                    this.moved = true;

                    if (stalled !== null) {
                      // The playhead is now moving, but was previously stalled
                      if (this.stallReported) {
                        var _stalledDuration = self.performance.now() - stalled;

                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                            'playback not stuck anymore @' + currentTime +
                            ', after ' + Math.round(_stalledDuration) + 'ms');
                        this.stallReported = false;
                      }

                      this.stalled = null;
                      this.nudgeRetry = 0;
                    }

                    return;
                  } // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek

                  if (beginSeek || seeked) {
                    this.stalled = null;
                  } // The playhead should not be moving

                  if (media.paused || media.ended || media.playbackRate === 0 ||
                      !media.buffered.length) {
                    return;
                  }

                  var bufferInfo = __WEBPACK_IMPORTED_MODULE_0__utils_buffer_helper__['a' /* BufferHelper */].bufferInfo(
                      media, currentTime, 0);
                  var isBuffered = bufferInfo.len > 0;
                  var nextStart = bufferInfo.nextStart || 0; // There is no playable buffer (waiting for buffer append)

                  if (!isBuffered && !nextStart) {
                    return;
                  }

                  if (seeking) {
                    // Waiting for seeking in a buffered range to complete
                    var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP; // Next buffered range is too far ahead to jump to while still seeking

                    var noBufferGap = !nextStart || nextStart - currentTime >
                        MAX_START_GAP_JUMP;

                    if (hasEnoughBuffer || noBufferGap) {
                      return;
                    } // Reset moved state when seeking to a point in or before a gap

                    this.moved = false;
                  } // Skip start gaps if we haven't played, but the last poll detected the start of a stall
                  // The addition poll gives the browser a chance to jump the gap for us

                  if (!this.moved && this.stalled) {
                    // Jump start gaps within jump threshold
                    var startJump = Math.max(nextStart, bufferInfo.start || 0) -
                        currentTime;

                    if (startJump > 0 && startJump <= MAX_START_GAP_JUMP) {
                      this._trySkipBufferHole(null);

                      return;
                    }
                  } // Start tracking stall time

                  var tnow = self.performance.now();

                  if (stalled === null) {
                    this.stalled = tnow;
                    return;
                  }

                  var stalledDuration = tnow - stalled;

                  if (!seeking && stalledDuration >=
                      STALL_MINIMUM_DURATION_MS) {
                    // Report stalling after trying to fix
                    this._reportStall(bufferInfo.len);
                  }

                  var bufferedWithHoles = __WEBPACK_IMPORTED_MODULE_0__utils_buffer_helper__['a' /* BufferHelper */].bufferInfo(
                      media, currentTime, config.maxBufferHole);

                  this._tryFixBufferStall(bufferedWithHoles, stalledDuration);
                }
                /**
                 * Detects and attempts to fix known buffer stalling issues.
                 * @param bufferInfo - The properties of the current buffer.
                 * @param stalledDurationMs - The amount of time Hls.js has been stalling for.
                 * @private
                 */
                ;

                _proto._tryFixBufferStall = function _tryFixBufferStall(
                    bufferInfo, stalledDurationMs) {
                  var config = this.config,
                      fragmentTracker = this.fragmentTracker,
                      media = this.media;
                  var currentTime = media.currentTime;
                  var partial = fragmentTracker.getPartialFragment(currentTime);

                  if (partial) {
                    // Try to skip over the buffer hole caused by a partial fragment
                    // This method isn't limited by the size of the gap between buffered ranges
                    var targetTime = this._trySkipBufferHole(partial); // we return here in this case, meaning
                    // the branch below only executes when we don't handle a partial fragment

                    if (targetTime) {
                      return;
                    }
                  } // if we haven't had to skip over a buffer hole of a partial fragment
                  // we may just have to "nudge" the playlist as the browser decoding/rendering engine
                  // needs to cross some sort of threshold covering all source-buffers content
                  // to start playing properly.

                  if (bufferInfo.len > config.maxBufferHole &&
                      stalledDurationMs > config.highBufferWatchdogPeriod *
                      1000) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                        'Trying to nudge playhead over buffer-hole'); // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds
                    // We only try to jump the hole if it's under the configured size
                    // Reset stalled so to rearm watchdog timer

                    this.stalled = null;

                    this._tryNudgeBuffer();
                  }
                }
                /**
                 * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
                 * @param bufferLen - The playhead distance from the end of the current buffer segment.
                 * @private
                 */
                ;

                _proto._reportStall = function _reportStall(bufferLen) {
                  var hls = this.hls,
                      media = this.media,
                      stallReported = this.stallReported;

                  if (!stallReported) {
                    // Report stalled error once
                    this.stallReported = true;
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                        'Playback stalling at @' + media.currentTime +
                        ' due to low buffer');
                    hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_1__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_1__errors__['a' /* ErrorDetails */].BUFFER_STALLED_ERROR,
                          fatal: false,
                          buffer: bufferLen,
                        });
                  }
                }
                /**
                 * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
                 * @param partial - The partial fragment found at the current time (where playback is stalling).
                 * @private
                 */
                ;

                _proto._trySkipBufferHole = function _trySkipBufferHole(partial) {
                  var config = this.config,
                      hls = this.hls,
                      media = this.media;
                  var currentTime = media.currentTime;
                  var lastEndTime = 0; // Check if currentTime is between unbuffered regions of partial fragments

                  for (var i = 0; i < media.buffered.length; i++) {
                    var startTime = media.buffered.start(i);

                    if (currentTime + config.maxBufferHole >= lastEndTime &&
                        currentTime < startTime) {
                      var targetTime = Math.max(
                          startTime + SKIP_BUFFER_RANGE_START,
                          media.currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);
                      __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                          'skipping hole, adjusting currentTime from ' +
                          currentTime + ' to ' + targetTime);
                      this.moved = true;
                      this.stalled = null;
                      media.currentTime = targetTime;

                      if (partial) {
                        hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].ERROR,
                            {
                              type: __WEBPACK_IMPORTED_MODULE_1__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                              details: __WEBPACK_IMPORTED_MODULE_1__errors__['a' /* ErrorDetails */].BUFFER_SEEK_OVER_HOLE,
                              fatal: false,
                              reason: 'fragment loaded with buffer holes, seeking from ' +
                                  currentTime + ' to ' + targetTime,
                              frag: partial,
                            });
                      }

                      return targetTime;
                    }

                    lastEndTime = media.buffered.end(i);
                  }

                  return 0;
                }
                /**
                 * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
                 * @private
                 */
                ;

                _proto._tryNudgeBuffer = function _tryNudgeBuffer() {
                  var config = this.config,
                      hls = this.hls,
                      media = this.media;
                  var currentTime = media.currentTime;
                  var nudgeRetry = (this.nudgeRetry || 0) + 1;
                  this.nudgeRetry = nudgeRetry;

                  if (nudgeRetry < config.nudgeMaxRetry) {
                    var targetTime = currentTime + nudgeRetry *
                        config.nudgeOffset; // playback stalled in buffered area ... let's nudge currentTime to try to overcome this

                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                        'Nudging \'currentTime\' from ' + currentTime + ' to ' +
                        targetTime);
                    media.currentTime = targetTime;
                    hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_1__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_1__errors__['a' /* ErrorDetails */].BUFFER_NUDGE_ON_STALL,
                          fatal: false,
                        });
                  } else {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                        'Playhead still not moving while enough data buffered @' +
                        currentTime + ' after ' + config.nudgeMaxRetry +
                        ' nudges');
                    hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_2__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_1__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_1__errors__['a' /* ErrorDetails */].BUFFER_STALLED_ERROR,
                          fatal: true,
                        });
                  }
                };

                return GapController;
              }();

          /***/
        }),
        /* 60 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return LevelController; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__event_handler__ = __webpack_require__(
              4);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__utils_codecs__ = __webpack_require__(
              22);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__level_helper__ = __webpack_require__(
              9);

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(
              Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype,
                protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /*
 * Level Controller
*/

          var _window = window,
              performance = _window.performance;
          var chromeOrFirefox;

          var LevelController =
              /*#__PURE__*/
              function(_EventHandler) {
                _inheritsLoose(LevelController, _EventHandler);

                function LevelController(hls) {
                  var _this;

                  _this = _EventHandler.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].MANIFEST_LOADED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].LEVEL_LOADED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].AUDIO_TRACK_SWITCHED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].FRAG_LOADED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].ERROR) ||
                      this;
                  _this.canload = false;
                  _this.currentLevelIndex = null;
                  _this.manualLevelIndex = -1;
                  _this.timer = null;
                  chromeOrFirefox = /chrome|firefox/.test(
                      navigator.userAgent.toLowerCase());
                  return _this;
                }

                var _proto = LevelController.prototype;

                _proto.onHandlerDestroying = function onHandlerDestroying() {
                  this.clearTimer();
                  this.manualLevelIndex = -1;
                };

                _proto.clearTimer = function clearTimer() {
                  if (this.timer !== null) {
                    clearTimeout(this.timer);
                    this.timer = null;
                  }
                };

                _proto.startLoad = function startLoad() {
                  var levels = this._levels;
                  this.canload = true;
                  this.levelRetryCount = 0; // clean up live level details to force reload them, and reset load errors

                  if (levels) {
                    levels.forEach(function(level) {
                      level.loadError = 0;
                      var levelDetails = level.details;

                      if (levelDetails && levelDetails.live) {
                        level.details = undefined;
                      }
                    });
                  } // speed up live playlist refresh if timer exists

                  if (this.timer !== null) {
                    this.loadLevel();
                  }
                };

                _proto.stopLoad = function stopLoad() {
                  this.canload = false;
                };

                _proto.onManifestLoaded = function onManifestLoaded(data) {
                  var levels = [];
                  var audioTracks = [];
                  var bitrateStart;
                  var levelSet = {};
                  var levelFromSet = null;
                  var videoCodecFound = false;
                  var audioCodecFound = false; // regroup redundant levels together

                  data.levels.forEach(function(level) {
                    var attributes = level.attrs;
                    level.loadError = 0;
                    level.fragmentError = false;
                    videoCodecFound = videoCodecFound || !!level.videoCodec;
                    audioCodecFound = audioCodecFound || !!level.audioCodec; // erase audio codec info if browser does not support mp4a.40.34.
                    // demuxer will autodetect codec and fallback to mpeg/audio

                    if (chromeOrFirefox && level.audioCodec &&
                        level.audioCodec.indexOf('mp4a.40.34') !== -1) {
                      level.audioCodec = undefined;
                    }

                    levelFromSet = levelSet[level.bitrate]; // FIXME: we would also have to match the resolution here

                    if (!levelFromSet) {
                      level.url = [level.url];
                      level.urlId = 0;
                      levelSet[level.bitrate] = level;
                      levels.push(level);
                    } else {
                      levelFromSet.url.push(level.url);
                    }

                    if (attributes) {
                      if (attributes.AUDIO) {
                        audioCodecFound = true;
                        Object(
                            __WEBPACK_IMPORTED_MODULE_5__level_helper__['a' /* addGroupId */])(
                            levelFromSet || level, 'audio', attributes.AUDIO);
                      }

                      if (attributes.SUBTITLES) {
                        Object(
                            __WEBPACK_IMPORTED_MODULE_5__level_helper__['a' /* addGroupId */])(
                            levelFromSet || level, 'text',
                            attributes.SUBTITLES);
                      }
                    }
                  }); // remove audio-only level if we also have levels with audio+video codecs signalled

                  if (videoCodecFound && audioCodecFound) {
                    levels = levels.filter(function(_ref) {
                      var videoCodec = _ref.videoCodec;
                      return !!videoCodec;
                    });
                  } // only keep levels with supported audio/video codecs

                  levels = levels.filter(function(_ref2) {
                    var audioCodec = _ref2.audioCodec,
                        videoCodec = _ref2.videoCodec;
                    return (!audioCodec || Object(
                        __WEBPACK_IMPORTED_MODULE_4__utils_codecs__['a' /* isCodecSupportedInMp4 */])(
                        audioCodec, 'audio')) && (!videoCodec || Object(
                        __WEBPACK_IMPORTED_MODULE_4__utils_codecs__['a' /* isCodecSupportedInMp4 */])(
                        videoCodec, 'video'));
                  });

                  if (data.audioTracks) {
                    audioTracks = data.audioTracks.filter(function(track) {
                      return !track.audioCodec || Object(
                          __WEBPACK_IMPORTED_MODULE_4__utils_codecs__['a' /* isCodecSupportedInMp4 */])(
                          track.audioCodec, 'audio');
                    }); // Reassign id's after filtering since they're used as array indices

                    audioTracks.forEach(function(track, index) {
                      track.id = index;
                    });
                  }

                  if (levels.length > 0) {
                    // start bitrate is the first bitrate of the manifest
                    bitrateStart = levels[0].bitrate; // sort level on bitrate

                    levels.sort(function(a, b) {
                      return a.bitrate - b.bitrate;
                    });
                    this._levels = levels; // find index of first level in sorted levels

                    for (var i = 0; i < levels.length; i++) {
                      if (levels[i].bitrate === bitrateStart) {
                        this._firstLevel = i;
                        __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                            'manifest loaded,' + levels.length +
                            ' level(s) found, first bitrate:' + bitrateStart);
                        break;
                      }
                    } // Audio is only alternate if manifest include a URI along with the audio group tag

                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].MANIFEST_PARSED,
                        {
                          levels: levels,
                          audioTracks: audioTracks,
                          firstLevel: this._firstLevel,
                          stats: data.stats,
                          audio: audioCodecFound,
                          video: videoCodecFound,
                          altAudio: audioTracks.some(function(t) {
                            return !!t.url;
                          }),
                        });
                  } else {
                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_3__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                          fatal: true,
                          url: this.hls.url,
                          reason: 'no level with compatible codecs found in manifest',
                        });
                  }
                };

                _proto.setLevelInternal = function setLevelInternal(newLevel) {
                  var levels = this._levels;
                  var hls = this.hls; // check if level idx is valid

                  if (newLevel >= 0 && newLevel < levels.length) {
                    // stopping live reloading timer if any
                    this.clearTimer();

                    if (this.currentLevelIndex !== newLevel) {
                      __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                          'switching to level ' + newLevel);
                      this.currentLevelIndex = newLevel;
                      var levelProperties = levels[newLevel];
                      levelProperties.level = newLevel;
                      hls.trigger(
                          __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].LEVEL_SWITCHING,
                          levelProperties);
                    }

                    var level = levels[newLevel];
                    var levelDetails = level.details; // check if we need to load playlist for this level

                    if (!levelDetails || levelDetails.live) {
                      // level not retrieved yet, or live playlist we need to (re)load it
                      var urlId = level.urlId;
                      hls.trigger(
                          __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].LEVEL_LOADING,
                          {
                            url: level.url[urlId],
                            level: newLevel,
                            id: urlId,
                          });
                    }
                  } else {
                    // invalid level id given, trigger error
                    hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_3__errors__['b' /* ErrorTypes */].OTHER_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].LEVEL_SWITCH_ERROR,
                          level: newLevel,
                          fatal: false,
                          reason: 'invalid level idx',
                        });
                  }
                };

                _proto.onError = function onError(data) {
                  if (data.fatal) {
                    if (data.type ===
                        __WEBPACK_IMPORTED_MODULE_3__errors__['b' /* ErrorTypes */].NETWORK_ERROR) {
                      this.clearTimer();
                    }

                    return;
                  }

                  var levelError = false,
                      fragmentError = false;
                  var levelIndex; // try to recover not fatal errors

                  switch (data.details) {
                    case __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].FRAG_LOAD_ERROR:
                    case __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].FRAG_LOAD_TIMEOUT:
                    case __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].KEY_LOAD_ERROR:
                    case __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].KEY_LOAD_TIMEOUT:
                      levelIndex = data.frag.level;
                      fragmentError = true;
                      break;

                    case __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].LEVEL_LOAD_ERROR:
                    case __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].LEVEL_LOAD_TIMEOUT:
                      levelIndex = data.context.level;
                      levelError = true;
                      break;

                    case __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].REMUX_ALLOC_ERROR:
                      levelIndex = data.level;
                      levelError = true;
                      break;
                  }

                  if (levelIndex !== undefined) {
                    this.recoverLevel(data, levelIndex, levelError,
                        fragmentError);
                  }
                }
                /**
                 * Switch to a redundant stream if any available.
                 * If redundant stream is not available, emergency switch down if ABR mode is enabled.
                 *
                 * @param {Object} errorEvent
                 * @param {Number} levelIndex current level index
                 * @param {Boolean} levelError
                 * @param {Boolean} fragmentError
                 */
                // FIXME Find a better abstraction where fragment/level retry management is well decoupled
                ;

                _proto.recoverLevel = function recoverLevel(
                    errorEvent, levelIndex, levelError, fragmentError) {
                  var _this2 = this;

                  var config = this.hls.config;
                  var errorDetails = errorEvent.details;
                  var level = this._levels[levelIndex];
                  var redundantLevels, delay, nextLevel;
                  level.loadError++;
                  level.fragmentError = fragmentError;

                  if (levelError) {
                    if (this.levelRetryCount + 1 <=
                        config.levelLoadingMaxRetry) {
                      // exponential backoff capped to max retry timeout
                      delay = Math.min(Math.pow(2, this.levelRetryCount) *
                          config.levelLoadingRetryDelay,
                          config.levelLoadingMaxRetryTimeout); // Schedule level reload

                      this.timer = setTimeout(function() {
                        return _this2.loadLevel();
                      }, delay); // boolean used to inform stream controller not to switch back to IDLE on non fatal error

                      errorEvent.levelRetry = true;
                      this.levelRetryCount++;
                      __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].warn(
                          'level controller, ' + errorDetails + ', retry in ' +
                          delay + ' ms, current retry count is ' +
                          this.levelRetryCount);
                    } else {
                      __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].error(
                          'level controller, cannot recover from ' +
                          errorDetails + ' error');
                      this.currentLevelIndex = null; // stopping live reloading timer if any

                      this.clearTimer(); // switch error to fatal

                      errorEvent.fatal = true;
                      return;
                    }
                  } // Try any redundant streams if available for both errors: level and fragment
                  // If level.loadError reaches redundantLevels it means that we tried them all, no hope  => let's switch down

                  if (levelError || fragmentError) {
                    redundantLevels = level.url.length;

                    if (redundantLevels > 1 && level.loadError <
                        redundantLevels) {
                      level.urlId = (level.urlId + 1) % redundantLevels;
                      level.details = undefined;
                      __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].warn(
                          'level controller, ' + errorDetails + ' for level ' +
                          levelIndex + ': switching to redundant URL-id ' +
                          level.urlId); // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
                      // console.log('New video quality level audio group id:', level.attrs.AUDIO);
                    } else {
                      // Search for available level
                      if (this.manualLevelIndex === -1) {
                        // When lowest level has been reached, let's start hunt from the top
                        nextLevel = levelIndex === 0
                            ? this._levels.length - 1
                            : levelIndex - 1;
                        __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].warn(
                            'level controller, ' + errorDetails +
                            ': switch to ' + nextLevel);
                        this.hls.nextAutoLevel = this.currentLevelIndex = nextLevel;
                      } else if (fragmentError) {
                        // Allow fragment retry as long as configuration allows.
                        // reset this._level so that another call to set level() will trigger again a frag load
                        __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].warn(
                            'level controller, ' + errorDetails +
                            ': reload a fragment');
                        this.currentLevelIndex = null;
                      }
                    }
                  }
                } // reset errors on the successful load of a fragment
                ;

                _proto.onFragLoaded = function onFragLoaded(_ref3) {
                  var frag = _ref3.frag;

                  if (frag !== undefined && frag.type === 'main') {
                    var level = this._levels[frag.level];

                    if (level !== undefined) {
                      level.fragmentError = false;
                      level.loadError = 0;
                      this.levelRetryCount = 0;
                    }
                  }
                };

                _proto.onLevelLoaded = function onLevelLoaded(data) {
                  var _this3 = this;

                  var level = data.level,
                      details = data.details; // only process level loaded events matching with expected level

                  if (level !== this.currentLevelIndex) {
                    return;
                  }

                  var curLevel = this._levels[level]; // reset level load error counter on successful level loaded only if there is no issues with fragments

                  if (!curLevel.fragmentError) {
                    curLevel.loadError = 0;
                    this.levelRetryCount = 0;
                  } // if current playlist is a live playlist, arm a timer to reload it

                  if (details.live) {
                    var reloadInterval = Object(
                        __WEBPACK_IMPORTED_MODULE_5__level_helper__['b' /* computeReloadInterval */])(
                        curLevel.details, details, data.stats.trequest);
                    __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                        'live playlist, reload in ' +
                        Math.round(reloadInterval) + ' ms');
                    this.timer = setTimeout(function() {
                      return _this3.loadLevel();
                    }, reloadInterval);
                  } else {
                    this.clearTimer();
                  }
                };

                _proto.onAudioTrackSwitched = function onAudioTrackSwitched(data) {
                  var audioGroupId = this.hls.audioTracks[data.id].groupId;
                  var currentLevel = this.hls.levels[this.currentLevelIndex];

                  if (!currentLevel) {
                    return;
                  }

                  if (currentLevel.audioGroupIds) {
                    var urlId = -1;

                    for (var i = 0; i <
                    currentLevel.audioGroupIds.length; i++) {
                      if (currentLevel.audioGroupIds[i] === audioGroupId) {
                        urlId = i;
                        break;
                      }
                    }

                    if (urlId !== currentLevel.urlId) {
                      currentLevel.urlId = urlId;
                      this.startLoad();
                    }
                  }
                };

                _proto.loadLevel = function loadLevel() {
                  __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].debug(
                      'call to loadLevel');

                  if (this.currentLevelIndex !== null && this.canload) {
                    var levelObject = this._levels[this.currentLevelIndex];

                    if (typeof levelObject === 'object' &&
                        levelObject.url.length > 0) {
                      var level = this.currentLevelIndex;
                      var id = levelObject.urlId;
                      var url = levelObject.url[id];
                      __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                          'Attempt loading level index ' + level +
                          ' with URL-id ' + id); // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
                      // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);

                      this.hls.trigger(
                          __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].LEVEL_LOADING,
                          {
                            url: url,
                            level: level,
                            id: id,
                          });
                    }
                  }
                };

                _createClass(LevelController, [
                  {
                    key: 'levels',
                    get: function get() {
                      return this._levels;
                    },
                  }, {
                    key: 'level',
                    get: function get() {
                      return this.currentLevelIndex;
                    },
                    set: function set(newLevel) {
                      var levels = this._levels;

                      if (levels) {
                        newLevel = Math.min(newLevel, levels.length - 1);

                        if (this.currentLevelIndex !== newLevel ||
                            !levels[newLevel].details) {
                          this.setLevelInternal(newLevel);
                        }
                      }
                    },
                  }, {
                    key: 'manualLevel',
                    get: function get() {
                      return this.manualLevelIndex;
                    },
                    set: function set(newLevel) {
                      this.manualLevelIndex = newLevel;

                      if (this._startLevel === undefined) {
                        this._startLevel = newLevel;
                      }

                      if (newLevel !== -1) {
                        this.level = newLevel;
                      }
                    },
                  }, {
                    key: 'firstLevel',
                    get: function get() {
                      return this._firstLevel;
                    },
                    set: function set(newLevel) {
                      this._firstLevel = newLevel;
                    },
                  }, {
                    key: 'startLevel',
                    get: function get() {
                      // hls.startLevel takes precedence over config.startLevel
                      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
                      if (this._startLevel === undefined) {
                        var configStartLevel = this.hls.config.startLevel;

                        if (configStartLevel !== undefined) {
                          return configStartLevel;
                        } else {
                          return this._firstLevel;
                        }
                      } else {
                        return this._startLevel;
                      }
                    },
                    set: function set(newLevel) {
                      this._startLevel = newLevel;
                    },
                  }, {
                    key: 'nextLoadLevel',
                    get: function get() {
                      if (this.manualLevelIndex !== -1) {
                        return this.manualLevelIndex;
                      } else {
                        return this.hls.nextAutoLevel;
                      }
                    },
                    set: function set(nextLevel) {
                      this.level = nextLevel;

                      if (this.manualLevelIndex === -1) {
                        this.hls.nextAutoLevel = nextLevel;
                      }
                    },
                  }]);

                return LevelController;
              }(__WEBPACK_IMPORTED_MODULE_1__event_handler__['a' /* default */]);

          /***/
        }),
        /* 61 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__event_handler__ = __webpack_require__(
              4);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__demux_id3__ = __webpack_require__(8);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__utils_texttrack_utils__ = __webpack_require__(
              18);

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /*
 * id3 metadata track controller
*/

          var ID3TrackController =
              /*#__PURE__*/
              function(_EventHandler) {
                _inheritsLoose(ID3TrackController, _EventHandler);

                function ID3TrackController(hls) {
                  var _this;

                  _this = _EventHandler.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].MEDIA_ATTACHED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].MEDIA_DETACHING,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].FRAG_PARSING_METADATA,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].LIVE_BACK_BUFFER_REACHED) ||
                      this;
                  _this.id3Track = undefined;
                  _this.media = undefined;
                  return _this;
                }

                var _proto = ID3TrackController.prototype;

                _proto.destroy = function destroy() {
                  __WEBPACK_IMPORTED_MODULE_1__event_handler__['a' /* default */].prototype.destroy.call(
                      this);
                } // Add ID3 metatadata text track.
                ;

                _proto.onMediaAttached = function onMediaAttached(data) {
                  this.media = data.media;

                  if (!this.media) {}
                };

                _proto.onMediaDetaching = function onMediaDetaching() {
                  Object(
                      __WEBPACK_IMPORTED_MODULE_4__utils_texttrack_utils__['a' /* clearCurrentCues */])(
                      this.id3Track);
                  this.id3Track = undefined;
                  this.media = undefined;
                };

                _proto.getID3Track = function getID3Track(textTracks) {
                  for (var i = 0; i < textTracks.length; i++) {
                    var textTrack = textTracks[i];

                    if (textTrack.kind === 'metadata' && textTrack.label ===
                        'id3') {
                      // send 'addtrack' when reusing the textTrack for metadata,
                      // same as what we do for captions
                      Object(
                          __WEBPACK_IMPORTED_MODULE_4__utils_texttrack_utils__['c' /* sendAddTrackEvent */])(
                          textTrack, this.media);
                      return textTrack;
                    }
                  }

                  return this.media.addTextTrack('metadata', 'id3');
                };

                _proto.onFragParsingMetadata = function onFragParsingMetadata(data) {
                  var fragment = data.frag;
                  var samples = data.samples; // create track dynamically

                  if (!this.id3Track) {
                    this.id3Track = this.getID3Track(this.media.textTracks);
                    this.id3Track.mode = 'hidden';
                  } // Attempt to recreate Safari functionality by creating
                  // WebKitDataCue objects when available and store the decoded
                  // ID3 data in the value property of the cue

                  var Cue = window.WebKitDataCue || window.VTTCue ||
                      window.TextTrackCue;

                  for (var i = 0; i < samples.length; i++) {
                    var frames = __WEBPACK_IMPORTED_MODULE_2__demux_id3__['a' /* default */].getID3Frames(
                        samples[i].data);

                    if (frames) {
                      var startTime = samples[i].pts;
                      var endTime = i < samples.length - 1
                          ? samples[i + 1].pts
                          : fragment.endPTS;

                      if (startTime === endTime) {
                        // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
                        endTime += 0.0001;
                      } else if (startTime > endTime) {
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                            'detected an id3 sample with endTime < startTime, adjusting endTime to (startTime + 0.25)');
                        endTime = startTime + 0.25;
                      }

                      for (var j = 0; j < frames.length; j++) {
                        var frame = frames[j]; // Safari doesn't put the timestamp frame in the TextTrack

                        if (!__WEBPACK_IMPORTED_MODULE_2__demux_id3__['a' /* default */].isTimeStampFrame(
                            frame)) {
                          var cue = new Cue(startTime, endTime, '');
                          cue.value = frame;
                          this.id3Track.addCue(cue);
                        }
                      }
                    }
                  }
                };

                _proto.onLiveBackBufferReached = function onLiveBackBufferReached(_ref) {
                  var bufferEnd = _ref.bufferEnd;
                  var id3Track = this.id3Track;

                  if (!id3Track || !id3Track.cues || !id3Track.cues.length) {
                    return;
                  }

                  var foundCue = Object(
                      __WEBPACK_IMPORTED_MODULE_4__utils_texttrack_utils__['b' /* getClosestCue */])(
                      id3Track.cues, bufferEnd);

                  if (!foundCue) {
                    return;
                  }

                  while (id3Track.cues[0] !== foundCue) {
                    id3Track.removeCue(id3Track.cues[0]);
                  }
                };

                return ID3TrackController;
              }(__WEBPACK_IMPORTED_MODULE_1__event_handler__['a' /* default */]);

          /* harmony default export */
          __webpack_exports__['a'] = (ID3TrackController);

          /***/
        }),
        /* 62 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (immutable) */
          __webpack_exports__['a'] = isSupported;
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__utils_mediasource_helper__ = __webpack_require__(
              15);

          function isSupported() {
            var mediaSource = Object(
                __WEBPACK_IMPORTED_MODULE_0__utils_mediasource_helper__['a' /* getMediaSource */])();

            if (!mediaSource) {
              return false;
            }

            var sourceBuffer = self.SourceBuffer || self.WebKitSourceBuffer;
            var isTypeSupported = mediaSource &&
                typeof mediaSource.isTypeSupported === 'function' &&
                mediaSource.isTypeSupported(
                    'video/mp4; codecs="avc1.42E01E,mp4a.40.2"'); // if SourceBuffer is exposed ensure its API is valid
            // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible

            var sourceBufferValidAPI = !sourceBuffer ||
                sourceBuffer.prototype &&
                typeof sourceBuffer.prototype.appendBuffer === 'function' &&
                typeof sourceBuffer.prototype.remove === 'function';
            return !!isTypeSupported && !!sourceBufferValidAPI;
          }

          /***/
        }),
        /* 63 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return hlsDefaultConfig; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__controller_abr_controller__ = __webpack_require__(
              64);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__controller_buffer_controller__ = __webpack_require__(
              67);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__controller_cap_level_controller__ = __webpack_require__(
              68);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__controller_fps_controller__ = __webpack_require__(
              69);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__utils_xhr_loader__ = __webpack_require__(
              31);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__controller_audio_track_controller__ = __webpack_require__(
              70);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_6__controller_audio_stream_controller__ = __webpack_require__(
              71);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_7__utils_cues__ = __webpack_require__(
              72);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_8__controller_timeline_controller__ = __webpack_require__(
              74);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_9__controller_subtitle_track_controller__ = __webpack_require__(
              78);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_10__controller_subtitle_stream_controller__ = __webpack_require__(
              79);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_11__controller_eme_controller__ = __webpack_require__(
              80);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_12__utils_mediakeys_helper__ = __webpack_require__(
              33);

          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null
                  ? arguments[i]
                  : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === 'function') {
                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).
                    filter(function(sym) {
                      return Object.getOwnPropertyDescriptor(source,
                          sym).enumerable;
                    }));
              }
              ownKeys.forEach(
                  function(key) { _defineProperty(target, key, source[key]); });
            }
            return target;
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true,
              });
            } else { obj[key] = value; }
            return obj;
          }

          /**
           * HLS config
           */




              // import FetchLoader from './utils/fetch-loader';

// If possible, keep hlsDefaultConfig shallow
// It is cloned whenever a new Hls instance is created, by keeping the config
// shallow the properties are cloned, and we don't end up manipulating the default
          var hlsDefaultConfig = _objectSpread({
                autoStartLoad: true,
                // used by stream-controller
                startPosition: -1,
                // used by stream-controller
                defaultAudioCodec: void 0,
                // used by stream-controller
                debug: false,
                // used by logger
                capLevelOnFPSDrop: false,
                // used by fps-controller
                capLevelToPlayerSize: false,
                // used by cap-level-controller
                initialLiveManifestSize: 1,
                // used by stream-controller
                maxBufferLength: 30,
                // used by stream-controller
                maxBufferSize: 60 * 1000 * 1000,
                // used by stream-controller
                maxBufferHole: 0.5,
                // used by stream-controller
                lowBufferWatchdogPeriod: 0.5,
                // used by stream-controller
                highBufferWatchdogPeriod: 3,
                // used by stream-controller
                nudgeOffset: 0.1,
                // used by stream-controller
                nudgeMaxRetry: 3,
                // used by stream-controller
                maxFragLookUpTolerance: 0.25,
                // used by stream-controller
                liveSyncDurationCount: 3,
                // used by stream-controller
                liveMaxLatencyDurationCount: Infinity,
                // used by stream-controller
                liveSyncDuration: void 0,
                // used by stream-controller
                liveMaxLatencyDuration: void 0,
                // used by stream-controller
                liveDurationInfinity: false,
                // used by buffer-controller
                liveBackBufferLength: Infinity,
                // used by buffer-controller
                maxMaxBufferLength: 600,
                // used by stream-controller
                enableWorker: true,
                // used by demuxer
                enableSoftwareAES: true,
                // used by decrypter
                manifestLoadingTimeOut: 10000,
                // used by playlist-loader
                manifestLoadingMaxRetry: 1,
                // used by playlist-loader
                manifestLoadingRetryDelay: 1000,
                // used by playlist-loader
                manifestLoadingMaxRetryTimeout: 64000,
                // used by playlist-loader
                startLevel: void 0,
                // used by level-controller
                levelLoadingTimeOut: 10000,
                // used by playlist-loader
                levelLoadingMaxRetry: 4,
                // used by playlist-loader
                levelLoadingRetryDelay: 1000,
                // used by playlist-loader
                levelLoadingMaxRetryTimeout: 64000,
                // used by playlist-loader
                fragLoadingTimeOut: 20000,
                // used by fragment-loader
                fragLoadingMaxRetry: 6,
                // used by fragment-loader
                fragLoadingRetryDelay: 1000,
                // used by fragment-loader
                fragLoadingMaxRetryTimeout: 64000,
                // used by fragment-loader
                startFragPrefetch: false,
                // used by stream-controller
                fpsDroppedMonitoringPeriod: 5000,
                // used by fps-controller
                fpsDroppedMonitoringThreshold: 0.2,
                // used by fps-controller
                appendErrorMaxRetry: 3,
                // used by buffer-controller
                loader: __WEBPACK_IMPORTED_MODULE_4__utils_xhr_loader__['a' /* default */],
                // loader: FetchLoader,
                fLoader: void 0,
                // used by fragment-loader
                pLoader: void 0,
                // used by playlist-loader
                xhrSetup: void 0,
                // used by xhr-loader
                aesSetup: void 0,
                // used by aes-loader
                licenseXhrSetup: void 0,
                // used by eme-controller
                // fetchSetup: void 0,
                abrController: __WEBPACK_IMPORTED_MODULE_0__controller_abr_controller__['a' /* default */],
                bufferController: __WEBPACK_IMPORTED_MODULE_1__controller_buffer_controller__['a' /* default */],
                capLevelController: __WEBPACK_IMPORTED_MODULE_2__controller_cap_level_controller__['a' /* default */],
                fpsController: __WEBPACK_IMPORTED_MODULE_3__controller_fps_controller__['a' /* default */],
                stretchShortVideoTrack: false,
                // used by mp4-remuxer
                maxAudioFramesDrift: 1,
                // used by mp4-remuxer
                forceKeyFrameOnDiscontinuity: true,
                // used by ts-demuxer
                abrEwmaFastLive: 3,
                // used by abr-controller
                abrEwmaSlowLive: 9,
                // used by abr-controller
                abrEwmaFastVoD: 3,
                // used by abr-controller
                abrEwmaSlowVoD: 9,
                // used by abr-controller
                abrEwmaDefaultEstimate: 5e5,
                // 500 kbps  // used by abr-controller
                abrBandWidthFactor: 0.95,
                // used by abr-controller
                abrBandWidthUpFactor: 0.7,
                // used by abr-controller
                abrMaxWithRealBitrate: false,
                // used by abr-controller
                maxStarvationDelay: 4,
                // used by abr-controller
                maxLoadingDelay: 4,
                // used by abr-controller
                minAutoBitrate: 0,
                // used by hls
                emeEnabled: false,
                // used by eme-controller
                widevineLicenseUrl: void 0,
                // used by eme-controller
                requestMediaKeySystemAccessFunc: __WEBPACK_IMPORTED_MODULE_12__utils_mediakeys_helper__['b' /* requestMediaKeySystemAccess */],
              }, timelineConfig(), {
                subtitleStreamController: true
                    ? __WEBPACK_IMPORTED_MODULE_10__controller_subtitle_stream_controller__['a' /* SubtitleStreamController */]
                    : void 0,
                subtitleTrackController: true
                    ? __WEBPACK_IMPORTED_MODULE_9__controller_subtitle_track_controller__['a' /* default */]
                    : void 0,
                timelineController: true
                    ? __WEBPACK_IMPORTED_MODULE_8__controller_timeline_controller__['a' /* default */]
                    : void 0,
                audioStreamController: true
                    ? __WEBPACK_IMPORTED_MODULE_6__controller_audio_stream_controller__['a' /* default */]
                    : void 0,
                audioTrackController: true
                    ? __WEBPACK_IMPORTED_MODULE_5__controller_audio_track_controller__['a' /* default */]
                    : void 0,
                emeController: true
                    ? __WEBPACK_IMPORTED_MODULE_11__controller_eme_controller__['a' /* default */]
                    : void 0,
              });

          function timelineConfig() {
            if (false) {
              // intentionally doing this over returning Partial<TimelineControllerConfig> above
              // this has the added nice property of still requiring the object below to completely define all props.
              return {};
            }

            return {
              cueHandler: __WEBPACK_IMPORTED_MODULE_7__utils_cues__,
              // used by timeline-controller
              enableCEA708Captions: true,
              // used by timeline-controller
              enableWebVTT: true,
              // used by timeline-controller
              captionsTextTrack1Label: 'English',
              // used by timeline-controller
              captionsTextTrack1LanguageCode: 'en',
              // used by timeline-controller
              captionsTextTrack2Label: 'Spanish',
              // used by timeline-controller
              captionsTextTrack2LanguageCode: 'es', // used by timeline-controller

            };
          }

          /***/
        }),
        /* 64 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__event_handler__ = __webpack_require__(
              4);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__utils_buffer_helper__ = __webpack_require__(
              6);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_6__utils_ewma_bandwidth_estimator__ = __webpack_require__(
              65);

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(
              Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype,
                protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError(
                  'this hasn\'t been initialised - super() hasn\'t been called');
            }
            return self;
          }

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /*
 * simple ABR Controller
 *  - compute next level based on last fragment bw heuristics
 *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
 */

          var _window = window,
              performance = _window.performance;

          var AbrController =
              /*#__PURE__*/
              function(_EventHandler) {
                _inheritsLoose(AbrController, _EventHandler);

                function AbrController(hls) {
                  var _this;

                  _this = _EventHandler.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_LOADING,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_LOADED,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_BUFFERED,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR) ||
                      this;
                  _this.lastLoadedFragLevel = 0;
                  _this._nextAutoLevel = -1;
                  _this.hls = hls;
                  _this.timer = null;
                  _this._bwEstimator = null;
                  _this.onCheck = _this._abandonRulesCheck.bind(
                      _assertThisInitialized(_this));
                  return _this;
                }

                var _proto = AbrController.prototype;

                _proto.destroy = function destroy() {
                  this.clearTimer();
                  __WEBPACK_IMPORTED_MODULE_2__event_handler__['a' /* default */].prototype.destroy.call(
                      this);
                };

                _proto.onFragLoading = function onFragLoading(data) {
                  var frag = data.frag;

                  if (frag.type === 'main') {
                    if (!this.timer) {
                      this.fragCurrent = frag;
                      this.timer = setInterval(this.onCheck, 100);
                    } // lazy init of BwEstimator, rationale is that we use different params for Live/VoD
                    // so we need to wait for stream manifest / playlist type to instantiate it.

                    if (!this._bwEstimator) {
                      var hls = this.hls;
                      var config = hls.config;
                      var level = frag.level;
                      var isLive = hls.levels[level].details.live;
                      var ewmaFast;
                      var ewmaSlow;

                      if (isLive) {
                        ewmaFast = config.abrEwmaFastLive;
                        ewmaSlow = config.abrEwmaSlowLive;
                      } else {
                        ewmaFast = config.abrEwmaFastVoD;
                        ewmaSlow = config.abrEwmaSlowVoD;
                      }

                      this._bwEstimator = new __WEBPACK_IMPORTED_MODULE_6__utils_ewma_bandwidth_estimator__['a' /* default */](
                          hls, ewmaSlow, ewmaFast,
                          config.abrEwmaDefaultEstimate);
                    }
                  }
                };

                _proto._abandonRulesCheck = function _abandonRulesCheck() {
                  /*
      monitor fragment retrieval time...
      we compute expected time of arrival of the complete fragment.
      we compare it to expected time of buffer starvation
    */
                  var hls = this.hls;
                  var video = hls.media;
                  var frag = this.fragCurrent;

                  if (!frag) {
                    return;
                  }

                  var loader = frag.loader;
                  var minAutoLevel = hls.minAutoLevel; // if loader has been destroyed or loading has been aborted, stop timer and return

                  if (!loader || loader.stats && loader.stats.aborted) {
                    __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].warn(
                        'frag loader destroy or aborted, disarm abandonRules');
                    this.clearTimer(); // reset forced auto level value so that next level will be selected

                    this._nextAutoLevel = -1;
                    return;
                  }

                  var stats = loader.stats;
                  /* only monitor frag retrieval time if
    (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */

                  if (video && stats &&
                      (!video.paused && video.playbackRate !== 0 ||
                          !video.readyState) && frag.autoLevel && frag.level) {
                    var requestDelay = performance.now() - stats.trequest;
                    var playbackRate = Math.abs(video.playbackRate); // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate

                    if (requestDelay > 500 * frag.duration / playbackRate) {
                      var levels = hls.levels;
                      var loadRate = Math.max(1,
                          stats.bw ? stats.bw / 8 : stats.loaded * 1000 /
                              requestDelay); // byte/s; at least 1 byte/s to avoid division by zero
                      // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size

                      var level = levels[frag.level];
                      var levelBitrate = level.realBitrate ? Math.max(
                          level.realBitrate, level.bitrate) : level.bitrate;
                      var expectedLen = stats.total ? stats.total : Math.max(
                          stats.loaded,
                          Math.round(frag.duration * levelBitrate / 8));
                      var pos = video.currentTime;
                      var fragLoadedDelay = (expectedLen - stats.loaded) /
                          loadRate;
                      var bufferStarvationDelay = (__WEBPACK_IMPORTED_MODULE_3__utils_buffer_helper__['a' /* BufferHelper */].bufferInfo(
                          video, pos, hls.config.maxBufferHole).end - pos) /
                          playbackRate; // consider emergency switch down only if we have less than 2 frag buffered AND
                      // time to finish loading current fragment is bigger than buffer starvation delay
                      // ie if we risk buffer starvation if bw does not increase quickly

                      if (bufferStarvationDelay < 2 * frag.duration /
                          playbackRate && fragLoadedDelay >
                          bufferStarvationDelay) {
                        var fragLevelNextLoadedDelay;
                        var nextLoadLevel; // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
                        // we start from current level - 1 and we step down , until we find a matching level

                        for (nextLoadLevel = frag.level - 1; nextLoadLevel >
                        minAutoLevel; nextLoadLevel--) {
                          // compute time to load next fragment at lower level
                          // 0.8 : consider only 80% of current bw to be conservative
                          // 8 = bits per byte (bps/Bps)
                          var levelNextBitrate = levels[nextLoadLevel].realBitrate
                              ? Math.max(levels[nextLoadLevel].realBitrate,
                                  levels[nextLoadLevel].bitrate)
                              : levels[nextLoadLevel].bitrate;

                          var _fragLevelNextLoadedDelay = frag.duration *
                              levelNextBitrate / (8 * 0.8 * loadRate);

                          if (_fragLevelNextLoadedDelay <
                              bufferStarvationDelay) {
                            // we found a lower level that be rebuffering free with current estimated bw !
                            break;
                          }
                        } // only emergency switch down if it takes less time to load new fragment at lowest level instead
                        // of finishing loading current one ...

                        if (fragLevelNextLoadedDelay < fragLoadedDelay) {
                          __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].warn(
                              'loading too slow, abort fragment loading and switch to level ' +
                              nextLoadLevel + ':fragLoadedDelay[' +
                              nextLoadLevel + ']<fragLoadedDelay[' +
                              (frag.level - 1) + '];bufferStarvationDelay:' +
                              fragLevelNextLoadedDelay.toFixed(1) + '<' +
                              fragLoadedDelay.toFixed(1) + ':' +
                              bufferStarvationDelay.toFixed(1)); // force next load level in auto mode

                          hls.nextLoadLevel = nextLoadLevel; // update bw estimate for this fragment before cancelling load (this will help reducing the bw)

                          this._bwEstimator.sample(requestDelay, stats.loaded); // abort fragment loading

                          loader.abort(); // stop abandon rules timer

                          this.clearTimer();
                          hls.trigger(
                              __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_LOAD_EMERGENCY_ABORTED,
                              {
                                frag: frag,
                                stats: stats,
                              });
                        }
                      }
                    }
                  }
                };

                _proto.onFragLoaded = function onFragLoaded(data) {
                  var frag = data.frag;

                  if (frag.type === 'main' && Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      frag.sn)) {
                    // stop monitoring bw once frag loaded
                    this.clearTimer(); // store level id after successful fragment load

                    this.lastLoadedFragLevel = frag.level; // reset forced auto level value so that next level will be selected

                    this._nextAutoLevel = -1; // compute level average bitrate

                    if (this.hls.config.abrMaxWithRealBitrate) {
                      var level = this.hls.levels[frag.level];
                      var loadedBytes = (level.loaded
                          ? level.loaded.bytes
                          : 0) + data.stats.loaded;
                      var loadedDuration = (level.loaded
                          ? level.loaded.duration
                          : 0) + data.frag.duration;
                      level.loaded = {
                        bytes: loadedBytes,
                        duration: loadedDuration,
                      };
                      level.realBitrate = Math.round(
                          8 * loadedBytes / loadedDuration);
                    } // if fragment has been loaded to perform a bitrate test,

                    if (data.frag.bitrateTest) {
                      var stats = data.stats;
                      stats.tparsed = stats.tbuffered = stats.tload;
                      this.onFragBuffered(data);
                    }
                  }
                };

                _proto.onFragBuffered = function onFragBuffered(data) {
                  var stats = data.stats;
                  var frag = data.frag; // only update stats on first frag buffering
                  // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
                  // and leading to wrong bw estimation
                  // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)

                  if (stats.aborted !== true && frag.type === 'main' && Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      frag.sn) &&
                      (!frag.bitrateTest || stats.tload === stats.tbuffered)) {
                    // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
                    // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
                    // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
                    var fragLoadingProcessingMs = stats.tparsed -
                        stats.trequest;
                    __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].log(
                        'latency/loading/parsing/append/kbps:' +
                        Math.round(stats.tfirst - stats.trequest) + '/' +
                        Math.round(stats.tload - stats.tfirst) + '/' +
                        Math.round(stats.tparsed - stats.tload) + '/' +
                        Math.round(stats.tbuffered - stats.tparsed) + '/' +
                        Math.round(8 * stats.loaded /
                            (stats.tbuffered - stats.trequest)));

                    this._bwEstimator.sample(fragLoadingProcessingMs,
                        stats.loaded);

                    stats.bwEstimate = this._bwEstimator.getEstimate(); // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration

                    if (frag.bitrateTest) {
                      this.bitrateTestDelay = fragLoadingProcessingMs / 1000;
                    } else {
                      this.bitrateTestDelay = 0;
                    }
                  }
                };

                _proto.onError = function onError(data) {
                  // stop timer in case of frag loading error
                  switch (data.details) {
                    case __WEBPACK_IMPORTED_MODULE_4__errors__['a' /* ErrorDetails */].FRAG_LOAD_ERROR:
                    case __WEBPACK_IMPORTED_MODULE_4__errors__['a' /* ErrorDetails */].FRAG_LOAD_TIMEOUT:
                      this.clearTimer();
                      break;

                    default:
                      break;
                  }
                };

                _proto.clearTimer = function clearTimer() {
                  clearInterval(this.timer);
                  this.timer = null;
                } // return next auto level
                ;

                _proto._findBestLevel = function _findBestLevel(
                    currentLevel, currentFragDuration, currentBw, minAutoLevel,
                    maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor,
                    levels) {
                  for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
                    var levelInfo = levels[i];

                    if (!levelInfo) {
                      continue;
                    }

                    var levelDetails = levelInfo.details;
                    var avgDuration = levelDetails
                        ? levelDetails.totalduration /
                        levelDetails.fragments.length
                        : currentFragDuration;
                    var live = levelDetails ? levelDetails.live : false;
                    var adjustedbw = void 0; // follow algorithm captured from stagefright :
                    // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
                    // Pick the highest bandwidth stream below or equal to estimated bandwidth.
                    // consider only 80% of the available bandwidth, but if we are switching up,
                    // be even more conservative (70%) to avoid overestimating and immediately
                    // switching back.

                    if (i <= currentLevel) {
                      adjustedbw = bwFactor * currentBw;
                    } else {
                      adjustedbw = bwUpFactor * currentBw;
                    }

                    var bitrate = levels[i].realBitrate
                        ? Math.max(levels[i].realBitrate, levels[i].bitrate)
                        : levels[i].bitrate;
                    var fetchDuration = bitrate * avgDuration / adjustedbw;
                    __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].trace(
                        'level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' +
                        i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' +
                        avgDuration + '/' + maxFetchDuration + '/' +
                        fetchDuration); // if adjusted bw is greater than level bitrate AND

                    if (adjustedbw > bitrate && ( // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
                        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
                        // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
                        !fetchDuration || live && !this.bitrateTestDelay ||
                        fetchDuration < maxFetchDuration)) {
                      // as we are looping from highest to lowest, this will return the best achievable quality level
                      return i;
                    }
                  } // not enough time budget even with quality level 0 ... rebuffering might happen

                  return -1;
                };

                _createClass(AbrController, [
                  {
                    key: 'nextAutoLevel',
                    get: function get() {
                      var forcedAutoLevel = this._nextAutoLevel;
                      var bwEstimator = this._bwEstimator; // in case next auto level has been forced, and bw not available or not reliable, return forced value

                      if (forcedAutoLevel !== -1 &&
                          (!bwEstimator || !bwEstimator.canEstimate())) {
                        return forcedAutoLevel;
                      } // compute next level using ABR logic

                      var nextABRAutoLevel = this._nextABRAutoLevel; // if forced auto level has been defined, use it to cap ABR computed quality level

                      if (forcedAutoLevel !== -1) {
                        nextABRAutoLevel = Math.min(forcedAutoLevel,
                            nextABRAutoLevel);
                      }

                      return nextABRAutoLevel;
                    },
                    set: function set(nextLevel) {
                      this._nextAutoLevel = nextLevel;
                    },
                  }, {
                    key: '_nextABRAutoLevel',
                    get: function get() {
                      var hls = this.hls;
                      var maxAutoLevel = hls.maxAutoLevel,
                          levels = hls.levels,
                          config = hls.config,
                          minAutoLevel = hls.minAutoLevel;
                      var video = hls.media;
                      var currentLevel = this.lastLoadedFragLevel;
                      var currentFragDuration = this.fragCurrent
                          ? this.fragCurrent.duration
                          : 0;
                      var pos = video ? video.currentTime : 0; // playbackRate is the absolute value of the playback rate; if video.playbackRate is 0, we use 1 to load as
                      // if we're playing back at the normal rate.

                      var playbackRate = video && video.playbackRate !== 0
                          ? Math.abs(video.playbackRate)
                          : 1.0;
                      var avgbw = this._bwEstimator
                          ? this._bwEstimator.getEstimate()
                          : config.abrEwmaDefaultEstimate; // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.

                      var bufferStarvationDelay = (__WEBPACK_IMPORTED_MODULE_3__utils_buffer_helper__['a' /* BufferHelper */].bufferInfo(
                          video, pos, config.maxBufferHole).end - pos) /
                          playbackRate; // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all

                      var bestLevel = this._findBestLevel(currentLevel,
                          currentFragDuration, avgbw, minAutoLevel,
                          maxAutoLevel, bufferStarvationDelay,
                          config.abrBandWidthFactor,
                          config.abrBandWidthUpFactor, levels);

                      if (bestLevel >= 0) {
                        return bestLevel;
                      } else {
                        __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].trace(
                            'rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering'); // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
                        // if no matching level found, logic will return 0

                        var maxStarvationDelay = currentFragDuration
                            ? Math.min(currentFragDuration,
                                config.maxStarvationDelay)
                            : config.maxStarvationDelay;
                        var bwFactor = config.abrBandWidthFactor;
                        var bwUpFactor = config.abrBandWidthUpFactor;

                        if (bufferStarvationDelay === 0) {
                          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
                          var bitrateTestDelay = this.bitrateTestDelay;

                          if (bitrateTestDelay) {
                            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
                            // max video loading delay used in  automatic start level selection :
                            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
                            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
                            // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
                            var maxLoadingDelay = currentFragDuration
                                ? Math.min(currentFragDuration,
                                    config.maxLoadingDelay)
                                : config.maxLoadingDelay;
                            maxStarvationDelay = maxLoadingDelay -
                                bitrateTestDelay;
                            __WEBPACK_IMPORTED_MODULE_5__utils_logger__['b' /* logger */].trace(
                                'bitrate test took ' +
                                Math.round(1000 * bitrateTestDelay) +
                                'ms, set first fragment max fetchDuration to ' +
                                Math.round(1000 * maxStarvationDelay) + ' ms'); // don't use conservative factor on bitrate test

                            bwFactor = bwUpFactor = 1;
                          }
                        }

                        bestLevel = this._findBestLevel(currentLevel,
                            currentFragDuration, avgbw, minAutoLevel,
                            maxAutoLevel,
                            bufferStarvationDelay + maxStarvationDelay,
                            bwFactor, bwUpFactor, levels);
                        return Math.max(bestLevel, 0);
                      }
                    },
                  }]);

                return AbrController;
              }(__WEBPACK_IMPORTED_MODULE_2__event_handler__['a' /* default */]);

          /* harmony default export */
          __webpack_exports__['a'] = (AbrController);

          /***/
        }),
        /* 65 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__utils_ewma__ = __webpack_require__(
              66);
          /*
 * EWMA Bandwidth Estimator
 *  - heavily inspired from shaka-player
 * Tracks bandwidth samples and estimates available bandwidth.
 * Based on the minimum of two exponentially-weighted moving averages with
 * different half-lives.
 */

          var EwmaBandWidthEstimator =
              /*#__PURE__*/
              function() {
                // TODO(typescript-hls)
                function EwmaBandWidthEstimator(
                    hls, slow, fast, defaultEstimate) {
                  this.hls = void 0;
                  this.defaultEstimate_ = void 0;
                  this.minWeight_ = void 0;
                  this.minDelayMs_ = void 0;
                  this.slow_ = void 0;
                  this.fast_ = void 0;
                  this.hls = hls;
                  this.defaultEstimate_ = defaultEstimate;
                  this.minWeight_ = 0.001;
                  this.minDelayMs_ = 50;
                  this.slow_ = new __WEBPACK_IMPORTED_MODULE_0__utils_ewma__['a' /* default */](
                      slow);
                  this.fast_ = new __WEBPACK_IMPORTED_MODULE_0__utils_ewma__['a' /* default */](
                      fast);
                }

                var _proto = EwmaBandWidthEstimator.prototype;

                _proto.sample = function sample(durationMs, numBytes) {
                  durationMs = Math.max(durationMs, this.minDelayMs_);
                  var numBits = 8 * numBytes,
                      // weight is duration in seconds
                      durationS = durationMs / 1000,
                      // value is bandwidth in bits/s
                      bandwidthInBps = numBits / durationS;
                  this.fast_.sample(durationS, bandwidthInBps);
                  this.slow_.sample(durationS, bandwidthInBps);
                };

                _proto.canEstimate = function canEstimate() {
                  var fast = this.fast_;
                  return fast && fast.getTotalWeight() >= this.minWeight_;
                };

                _proto.getEstimate = function getEstimate() {
                  if (this.canEstimate()) {
                    // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
                    // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
                    // Take the minimum of these two estimates.  This should have the effect of
                    // adapting down quickly, but up more slowly.
                    return Math.min(this.fast_.getEstimate(),
                        this.slow_.getEstimate());
                  } else {
                    return this.defaultEstimate_;
                  }
                };

                _proto.destroy = function destroy() {};

                return EwmaBandWidthEstimator;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (EwmaBandWidthEstimator);

          /***/
        }),
        /* 66 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */
          var EWMA =
              /*#__PURE__*/
              function() {
                //  About half of the estimated value will be from the last |halfLife| samples by weight.
                function EWMA(halfLife) {
                  this.alpha_ = void 0;
                  this.estimate_ = void 0;
                  this.totalWeight_ = void 0;
                  // Larger values of alpha expire historical data more slowly.
                  this.alpha_ = halfLife
                      ? Math.exp(Math.log(0.5) / halfLife)
                      : 0;
                  this.estimate_ = 0;
                  this.totalWeight_ = 0;
                }

                var _proto = EWMA.prototype;

                _proto.sample = function sample(weight, value) {
                  var adjAlpha = Math.pow(this.alpha_, weight);
                  this.estimate_ = value * (1 - adjAlpha) + adjAlpha *
                      this.estimate_;
                  this.totalWeight_ += weight;
                };

                _proto.getTotalWeight = function getTotalWeight() {
                  return this.totalWeight_;
                };

                _proto.getEstimate = function getEstimate() {
                  if (this.alpha_) {
                    var zeroFactor = 1 -
                        Math.pow(this.alpha_, this.totalWeight_);
                    return this.estimate_ / zeroFactor;
                  } else {
                    return this.estimate_;
                  }
                };

                return EWMA;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (EWMA);

          /***/
        }),
        /* 67 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__event_handler__ = __webpack_require__(
              4);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__utils_mediasource_helper__ = __webpack_require__(
              15);

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /*
 * Buffer Controller
 */

          var MediaSource = Object(
              __WEBPACK_IMPORTED_MODULE_5__utils_mediasource_helper__['a' /* getMediaSource */])();

          var BufferController =
              /*#__PURE__*/
              function(_EventHandler) {
                _inheritsLoose(BufferController, _EventHandler);

                // the value that we have set mediasource.duration to
                // (the actual duration may be tweaked slighly by the browser)
                // the value that we want to set mediaSource.duration to
                // the target duration of the current media playlist
                // current stream state: true - for live broadcast, false - for VoD content
                // cache the self generated object url to detect hijack of video tag
                // signals that the sourceBuffers need to be flushed
                // signals that mediaSource should have endOfStream called
                // this is optional because this property is removed from the class sometimes
                // The number of BUFFER_CODEC events received before any sourceBuffers are created
                // The total number of BUFFER_CODEC events received
                // A reference to the attached media element
                // A reference to the active media source
                // List of pending segments to be appended to source buffer
                // A guard to see if we are currently appending to the source buffer
                // counters
                function BufferController(hls) {
                  var _this;

                  _this = _EventHandler.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MEDIA_ATTACHING,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MEDIA_DETACHING,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MANIFEST_PARSED,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].BUFFER_RESET,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].BUFFER_APPENDING,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].BUFFER_CODECS,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].BUFFER_EOS,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].BUFFER_FLUSHING,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].LEVEL_PTS_UPDATED,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].LEVEL_UPDATED) ||
                      this;
                  _this._msDuration = null;
                  _this._levelDuration = null;
                  _this._levelTargetDuration = 10;
                  _this._live = null;
                  _this._objectUrl = null;
                  _this._needsFlush = false;
                  _this._needsEos = false;
                  _this.config = void 0;
                  _this.audioTimestampOffset = void 0;
                  _this.bufferCodecEventsExpected = 0;
                  _this._bufferCodecEventsTotal = 0;
                  _this.media = null;
                  _this.mediaSource = null;
                  _this.segments = [];
                  _this.parent = void 0;
                  _this.appending = false;
                  _this.appended = 0;
                  _this.appendError = 0;
                  _this.flushBufferCounter = 0;
                  _this.tracks = {};
                  _this.pendingTracks = {};
                  _this.sourceBuffer = {};
                  _this.flushRange = [];

                  _this._onMediaSourceOpen = function() {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                        'media source opened');

                    _this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MEDIA_ATTACHED,
                        {
                          media: _this.media,
                        });

                    var mediaSource = _this.mediaSource;

                    if (mediaSource) {
                      // once received, don't listen anymore to sourceopen event
                      mediaSource.removeEventListener('sourceopen',
                          _this._onMediaSourceOpen);
                    }

                    _this.checkPendingTracks();
                  };

                  _this._onMediaSourceClose = function() {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                        'media source closed');
                  };

                  _this._onMediaSourceEnded = function() {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                        'media source ended');
                  };

                  _this._onSBUpdateEnd = function() {
                    // update timestampOffset
                    if (_this.audioTimestampOffset &&
                        _this.sourceBuffer.audio) {
                      var audioBuffer = _this.sourceBuffer.audio;
                      __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                          'change mpeg audio timestamp offset from ' +
                          audioBuffer.timestampOffset + ' to ' +
                          _this.audioTimestampOffset);
                      audioBuffer.timestampOffset = _this.audioTimestampOffset;
                      delete _this.audioTimestampOffset;
                    }

                    if (_this._needsFlush) {
                      _this.doFlush();
                    }

                    if (_this._needsEos) {
                      _this.checkEos();
                    }

                    _this.appending = false;
                    var parent = _this.parent; // count nb of pending segments waiting for appending on this sourcebuffer

                    var pending = _this.segments.reduce(
                        function(counter, segment) {
                          return segment.parent === parent
                              ? counter + 1
                              : counter;
                        }, 0); // this.sourceBuffer is better to use than media.buffered as it is closer to the PTS data from the fragments

                    var timeRanges = {};
                    var sbSet = _this.sourceBuffer;

                    for (var streamType in sbSet) {
                      var sb = sbSet[streamType];

                      if (!sb) {
                        throw Error(
                            'handling source buffer update end error: source buffer for ' +
                            streamType +
                            ' uninitilized and unable to update buffered TimeRanges.');
                      }

                      timeRanges[streamType] = sb.buffered;
                    }

                    _this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].BUFFER_APPENDED,
                        {
                          parent: parent,
                          pending: pending,
                          timeRanges: timeRanges,
                        }); // don't append in flushing mode

                    if (!_this._needsFlush) {
                      _this.doAppending();
                    }

                    _this.updateMediaElementDuration(); // appending goes first

                    if (pending === 0) {
                      _this.flushLiveBackBuffer();
                    }
                  };

                  _this._onSBUpdateError = function(event) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                        'sourceBuffer error:', event); // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
                    // this error might not always be fatal (it is fatal if decode error is set, in that case
                    // it will be followed by a mediaElement error ...)

                    _this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_4__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_4__errors__['a' /* ErrorDetails */].BUFFER_APPENDING_ERROR,
                          fatal: false,
                        }); // we don't need to do more than that, as accordin to the spec, updateend will be fired just after

                  };

                  _this.config = hls.config;
                  return _this;
                }

                var _proto = BufferController.prototype;

                _proto.destroy = function destroy() {
                  __WEBPACK_IMPORTED_MODULE_2__event_handler__['a' /* default */].prototype.destroy.call(
                      this);
                };

                _proto.onLevelPtsUpdated = function onLevelPtsUpdated(data) {
                  var type = data.type;
                  var audioTrack = this.tracks.audio; // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
                  // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
                  // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
                  // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
                  // event if SB is in updating state.
                  // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486

                  if (type === 'audio' && audioTrack && audioTrack.container ===
                      'audio/mpeg') {
                    // Chrome audio mp3 track
                    var audioBuffer = this.sourceBuffer.audio;

                    if (!audioBuffer) {
                      throw Error(
                          'Level PTS Updated and source buffer for audio uninitalized');
                    }

                    var delta = Math.abs(
                        audioBuffer.timestampOffset - data.start); // adjust timestamp offset if time delta is greater than 100ms

                    if (delta > 0.1) {
                      var updating = audioBuffer.updating;

                      try {
                        audioBuffer.abort();
                      } catch (err) {
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                            'can not abort audio buffer: ' + err);
                      }

                      if (!updating) {
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                            'change mpeg audio timestamp offset from ' +
                            audioBuffer.timestampOffset + ' to ' + data.start);
                        audioBuffer.timestampOffset = data.start;
                      } else {
                        this.audioTimestampOffset = data.start;
                      }
                    }
                  }
                };

                _proto.onManifestParsed = function onManifestParsed(data) {
                  // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
                  // sourcebuffers will be created all at once when the expected nb of tracks will be reached
                  // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
                  // it will contain the expected nb of source buffers, no need to compute it
                  this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = data.altAudio
                      ? 2
                      : 1;
                  __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                      this.bufferCodecEventsExpected +
                      ' bufferCodec event(s) expected');
                };

                _proto.onMediaAttaching = function onMediaAttaching(data) {
                  var media = this.media = data.media;

                  if (media && MediaSource) {
                    // setup the media source
                    var ms = this.mediaSource = new MediaSource(); // Media Source listeners

                    ms.addEventListener('sourceopen', this._onMediaSourceOpen);
                    ms.addEventListener('sourceended',
                        this._onMediaSourceEnded);
                    ms.addEventListener('sourceclose',
                        this._onMediaSourceClose); // link video and media Source

                    media.src = window.URL.createObjectURL(ms); // cache the locally generated object url

                    this._objectUrl = media.src;
                  }
                };

                _proto.onMediaDetaching = function onMediaDetaching() {
                  __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                      'media source detaching');
                  var ms = this.mediaSource;

                  if (ms) {
                    if (ms.readyState === 'open') {
                      try {
                        // endOfStream could trigger exception if any sourcebuffer is in updating state
                        // we don't really care about checking sourcebuffer state here,
                        // as we are anyway detaching the MediaSource
                        // let's just avoid this exception to propagate
                        ms.endOfStream();
                      } catch (err) {
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                            'onMediaDetaching:' + err.message +
                            ' while calling endOfStream');
                      }
                    }

                    ms.removeEventListener('sourceopen',
                        this._onMediaSourceOpen);
                    ms.removeEventListener('sourceended',
                        this._onMediaSourceEnded);
                    ms.removeEventListener('sourceclose',
                        this._onMediaSourceClose); // Detach properly the MediaSource from the HTMLMediaElement as
                    // suggested in https://github.com/w3c/media-source/issues/53.

                    if (this.media) {
                      if (this._objectUrl) {
                        window.URL.revokeObjectURL(this._objectUrl);
                      } // clean up video tag src only if it's our own url. some external libraries might
                      // hijack the video tag and change its 'src' without destroying the Hls instance first

                      if (this.media.src === this._objectUrl) {
                        this.media.removeAttribute('src');
                        this.media.load();
                      } else {
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                            'media.src was changed by a third party - skip cleanup');
                      }
                    }

                    this.mediaSource = null;
                    this.media = null;
                    this._objectUrl = null;
                    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;
                    this.pendingTracks = {};
                    this.tracks = {};
                    this.sourceBuffer = {};
                    this.flushRange = [];
                    this.segments = [];
                    this.appended = 0;
                  }

                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MEDIA_DETACHED);
                };

                _proto.checkPendingTracks = function checkPendingTracks() {
                  var bufferCodecEventsExpected = this.bufferCodecEventsExpected,
                      pendingTracks = this.pendingTracks; // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.
                  // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after
                  // data has been appended to existing ones.
                  // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.

                  var pendingTracksCount = Object.keys(pendingTracks).length;

                  if (pendingTracksCount && !bufferCodecEventsExpected ||
                      pendingTracksCount === 2) {
                    // ok, let's create them now !
                    this.createSourceBuffers(pendingTracks);
                    this.pendingTracks = {}; // append any pending segments now !

                    this.doAppending();
                  }
                };

                _proto.onBufferReset = function onBufferReset() {
                  var sourceBuffer = this.sourceBuffer;

                  for (var type in sourceBuffer) {
                    var sb = sourceBuffer[type];

                    try {
                      if (sb) {
                        if (this.mediaSource) {
                          this.mediaSource.removeSourceBuffer(sb);
                        }

                        sb.removeEventListener('updateend',
                            this._onSBUpdateEnd);
                        sb.removeEventListener('error', this._onSBUpdateError);
                      }
                    } catch (err) {}
                  }

                  this.sourceBuffer = {};
                  this.flushRange = [];
                  this.segments = [];
                  this.appended = 0;
                };

                _proto.onBufferCodecs = function onBufferCodecs(tracks) {
                  var _this2 = this;

                  // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
                  // if sourcebuffers already created, do nothing ...
                  if (Object.keys(this.sourceBuffer).length) {
                    return;
                  }

                  Object.keys(tracks).forEach(function(trackName) {
                    _this2.pendingTracks[trackName] = tracks[trackName];
                  });
                  this.bufferCodecEventsExpected = Math.max(
                      this.bufferCodecEventsExpected - 1, 0);

                  if (this.mediaSource && this.mediaSource.readyState ===
                      'open') {
                    this.checkPendingTracks();
                  }
                };

                _proto.createSourceBuffers = function createSourceBuffers(tracks) {
                  var sourceBuffer = this.sourceBuffer,
                      mediaSource = this.mediaSource;

                  if (!mediaSource) {
                    throw Error(
                        'createSourceBuffers called when mediaSource was null');
                  }

                  for (var trackName in tracks) {
                    if (!sourceBuffer[trackName]) {
                      var track = tracks[trackName];

                      if (!track) {
                        throw Error(
                            'source buffer exists for track ' + trackName +
                            ', however track does not');
                      } // use levelCodec as first priority

                      var codec = track.levelCodec || track.codec;
                      var mimeType = track.container + ';codecs=' + codec;
                      __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                          'creating sourceBuffer(' + mimeType + ')');

                      try {
                        var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(
                            mimeType);
                        sb.addEventListener('updateend', this._onSBUpdateEnd);
                        sb.addEventListener('error', this._onSBUpdateError);
                        this.tracks[trackName] = {
                          buffer: sb,
                          codec: codec,
                          id: track.id,
                          container: track.container,
                          levelCodec: track.levelCodec,
                        };
                      } catch (err) {
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                            'error while trying to add sourceBuffer:' +
                            err.message);
                        this.hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                            {
                              type: __WEBPACK_IMPORTED_MODULE_4__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                              details: __WEBPACK_IMPORTED_MODULE_4__errors__['a' /* ErrorDetails */].BUFFER_ADD_CODEC_ERROR,
                              fatal: false,
                              err: err,
                              mimeType: mimeType,
                            });
                      }
                    }
                  }

                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].BUFFER_CREATED,
                      {
                        tracks: this.tracks,
                      });
                };

                _proto.onBufferAppending = function onBufferAppending(data) {
                  if (!this._needsFlush) {
                    if (!this.segments) {
                      this.segments = [data];
                    } else {
                      this.segments.push(data);
                    }

                    this.doAppending();
                  }
                } // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()
                // an undefined data.type will mark all buffers as EOS.
                ;

                _proto.onBufferEos = function onBufferEos(data) {
                  for (var type in this.sourceBuffer) {
                    if (!data.type || data.type === type) {
                      var sb = this.sourceBuffer[type];

                      if (sb && !sb.ended) {
                        sb.ended = true;
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                            type + ' sourceBuffer now EOS');
                      }
                    }
                  }

                  this.checkEos();
                } // if all source buffers are marked as ended, signal endOfStream() to MediaSource.
                ;

                _proto.checkEos = function checkEos() {
                  var sourceBuffer = this.sourceBuffer,
                      mediaSource = this.mediaSource;

                  if (!mediaSource || mediaSource.readyState !== 'open') {
                    this._needsEos = false;
                    return;
                  }

                  for (var type in sourceBuffer) {
                    var sb = sourceBuffer[type];
                    if (!sb) continue;

                    if (!sb.ended) {
                      return;
                    }

                    if (sb.updating) {
                      this._needsEos = true;
                      return;
                    }
                  }

                  __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                      'all media data are available, signal endOfStream() to MediaSource and stop loading fragment'); // Notify the media element that it now has all of the media data

                  try {
                    mediaSource.endOfStream();
                  } catch (e) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                        'exception while calling mediaSource.endOfStream()');
                  }

                  this._needsEos = false;
                };

                _proto.onBufferFlushing = function onBufferFlushing(data) {
                  if (data.type) {
                    this.flushRange.push({
                      start: data.startOffset,
                      end: data.endOffset,
                      type: data.type,
                    });
                  } else {
                    this.flushRange.push({
                      start: data.startOffset,
                      end: data.endOffset,
                      type: 'video',
                    });
                    this.flushRange.push({
                      start: data.startOffset,
                      end: data.endOffset,
                      type: 'audio',
                    });
                  } // attempt flush immediately

                  this.flushBufferCounter = 0;
                  this.doFlush();
                };

                _proto.flushLiveBackBuffer = function flushLiveBackBuffer() {
                  // clear back buffer for live only
                  if (!this._live) {
                    return;
                  }

                  var liveBackBufferLength = this.config.liveBackBufferLength;

                  if (!isFinite(liveBackBufferLength) || liveBackBufferLength <
                      0) {
                    return;
                  }

                  if (!this.media) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                        'flushLiveBackBuffer called without attaching media');
                    return;
                  }

                  var currentTime = this.media.currentTime;
                  var sourceBuffer = this.sourceBuffer;
                  var bufferTypes = Object.keys(sourceBuffer);
                  var targetBackBufferPosition = currentTime -
                      Math.max(liveBackBufferLength, this._levelTargetDuration);

                  for (var index = bufferTypes.length - 1; index >=
                  0; index--) {
                    var bufferType = bufferTypes[index];
                    var sb = sourceBuffer[bufferType];

                    if (sb) {
                      var buffered = sb.buffered; // when target buffer start exceeds actual buffer start

                      if (buffered.length > 0 && targetBackBufferPosition >
                          buffered.start(0)) {
                        // remove buffer up until current time minus minimum back buffer length (removing buffer too close to current
                        // time will lead to playback freezing)
                        // credits for level target duration - https://github.com/videojs/http-streaming/blob/3132933b6aa99ddefab29c10447624efd6fd6e52/src/segment-loader.js#L91
                        if (this.removeBufferRange(bufferType, sb, 0,
                            targetBackBufferPosition)) {
                          this.hls.trigger(
                              __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].LIVE_BACK_BUFFER_REACHED,
                              {
                                bufferEnd: targetBackBufferPosition,
                              });
                        }
                      }
                    }
                  }
                };

                _proto.onLevelUpdated = function onLevelUpdated(_ref) {
                  var details = _ref.details;

                  if (details.fragments.length > 0) {
                    this._levelDuration = details.totalduration +
                        details.fragments[0].start;
                    this._levelTargetDuration = details.averagetargetduration ||
                        details.targetduration || 10;
                    this._live = details.live;
                    this.updateMediaElementDuration();
                  }
                }
                /**
                 * Update Media Source duration to current level duration or override to Infinity if configuration parameter
                 * 'liveDurationInfinity` is set to `true`
                 * More details: https://github.com/video-dev/hls.js/issues/355
                 */
                ;

                _proto.updateMediaElementDuration = function updateMediaElementDuration() {
                  var config = this.config;
                  var duration;

                  if (this._levelDuration === null || !this.media ||
                      !this.mediaSource || !this.sourceBuffer ||
                      this.media.readyState === 0 ||
                      this.mediaSource.readyState !== 'open') {
                    return;
                  }

                  for (var type in this.sourceBuffer) {
                    var sb = this.sourceBuffer[type];

                    if (sb && sb.updating === true) {
                      // can't set duration whilst a buffer is updating
                      return;
                    }
                  }

                  duration = this.media.duration; // initialise to the value that the media source is reporting

                  if (this._msDuration === null) {
                    this._msDuration = this.mediaSource.duration;
                  }

                  if (this._live === true && config.liveDurationInfinity ===
                      true) {
                    // Override duration to Infinity
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                        'Media Source duration is set to Infinity');
                    this._msDuration = this.mediaSource.duration = Infinity;
                  } else if (this._levelDuration > this._msDuration &&
                      this._levelDuration > duration || !Object(
                          __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                          duration)) {
                    // levelDuration was the last value we set.
                    // not using mediaSource.duration as the browser may tweak this value
                    // only update Media Source duration if its value increase, this is to avoid
                    // flushing already buffered portion when switching between quality level
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                        'Updating Media Source duration to ' +
                        this._levelDuration.toFixed(3));
                    this._msDuration = this.mediaSource.duration = this._levelDuration;
                  }
                };

                _proto.doFlush = function doFlush() {
                  // loop through all buffer ranges to flush
                  while (this.flushRange.length) {
                    var range = this.flushRange[0]; // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer

                    if (this.flushBuffer(range.start, range.end, range.type)) {
                      // range flushed, remove from flush array
                      this.flushRange.shift();
                      this.flushBufferCounter = 0;
                    } else {
                      this._needsFlush = true; // avoid looping, wait for SB update end to retrigger a flush

                      return;
                    }
                  }

                  if (this.flushRange.length === 0) {
                    // everything flushed
                    this._needsFlush = false; // let's recompute this.appended, which is used to avoid flush looping

                    var appended = 0;
                    var sourceBuffer = this.sourceBuffer;

                    try {
                      for (var type in sourceBuffer) {
                        var sb = sourceBuffer[type];

                        if (sb) {
                          appended += sb.buffered.length;
                        }
                      }
                    } catch (error) {
                      // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
                      // this is harmess at this stage, catch this to avoid reporting an internal exception
                      __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                          'error while accessing sourceBuffer.buffered');
                    }

                    this.appended = appended;
                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].BUFFER_FLUSHED);
                  }
                };

                _proto.doAppending = function doAppending() {
                  var config = this.config,
                      hls = this.hls,
                      segments = this.segments,
                      sourceBuffer = this.sourceBuffer;

                  if (!Object.keys(sourceBuffer).length) {
                    // early exit if no source buffers have been initialized yet
                    return;
                  }

                  if (!this.media || this.media.error) {
                    this.segments = [];
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                        'trying to append although a media error occured, flush segment and abort');
                    return;
                  }

                  if (this.appending) {
                    // logger.log(`sb appending in progress`);
                    return;
                  }

                  var segment = segments.shift();

                  if (!segment) {
                    // handle undefined shift
                    return;
                  }

                  try {
                    var sb = sourceBuffer[segment.type];

                    if (!sb) {
                      // in case we don't have any source buffer matching with this segment type,
                      // it means that Mediasource fails to create sourcebuffer
                      // discard this segment, and trigger update end
                      this._onSBUpdateEnd();

                      return;
                    }

                    if (sb.updating) {
                      // if we are still updating the source buffer from the last segment, place this back at the front of the queue
                      segments.unshift(segment);
                      return;
                    } // reset sourceBuffer ended flag before appending segment

                    sb.ended = false; // logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);

                    this.parent = segment.parent;
                    sb.appendBuffer(segment.data);
                    this.appendError = 0;
                    this.appended++;
                    this.appending = true;
                  } catch (err) {
                    // in case any error occured while appending, put back segment in segments table
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                        'error while trying to append buffer:' + err.message);
                    segments.unshift(segment);
                    var event = {
                      type: __WEBPACK_IMPORTED_MODULE_4__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                      parent: segment.parent,
                      details: '',
                      fatal: false,
                    };

                    if (err.code === 22) {
                      // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
                      // let's stop appending any segments, and report BUFFER_FULL_ERROR error
                      this.segments = [];
                      event.details = __WEBPACK_IMPORTED_MODULE_4__errors__['a' /* ErrorDetails */].BUFFER_FULL_ERROR;
                    } else {
                      this.appendError++;
                      event.details = __WEBPACK_IMPORTED_MODULE_4__errors__['a' /* ErrorDetails */].BUFFER_APPEND_ERROR;
                      /* with UHD content, we could get loop of quota exceeded error until
          browser is able to evict some data from sourcebuffer. retrying help recovering this
        */

                      if (this.appendError > config.appendErrorMaxRetry) {
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                            'fail ' + config.appendErrorMaxRetry +
                            ' times to append segment in sourceBuffer');
                        this.segments = [];
                        event.fatal = true;
                      }
                    }

                    hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                        event);
                  }
                }
                /*
    flush specified buffered range,
    return true once range has been flushed.
    as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
  */
                ;

                _proto.flushBuffer = function flushBuffer(
                    startOffset, endOffset, sbType) {
                  var sourceBuffer = this.sourceBuffer; // exit if no sourceBuffers are initialized

                  if (!Object.keys(sourceBuffer).length) {
                    return true;
                  }

                  var currentTime = 'null';

                  if (this.media) {
                    currentTime = this.media.currentTime.toFixed(3);
                  }

                  __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                      'flushBuffer,pos/start/end: ' + currentTime + '/' +
                      startOffset + '/' + endOffset); // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments

                  if (this.flushBufferCounter >= this.appended) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                        'abort flushing too many retries');
                    return true;
                  }

                  var sb = sourceBuffer[sbType]; // we are going to flush buffer, mark source buffer as 'not ended'

                  if (sb) {
                    sb.ended = false;

                    if (!sb.updating) {
                      if (this.removeBufferRange(sbType, sb, startOffset,
                          endOffset)) {
                        this.flushBufferCounter++;
                        return false;
                      }
                    } else {
                      __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                          'cannot flush, sb updating in progress');
                      return false;
                    }
                  }

                  __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                      'buffer flushed'); // everything flushed !

                  return true;
                }
                /**
                 * Removes first buffered range from provided source buffer that lies within given start and end offsets.
                 *
                 * @param {string} type Type of the source buffer, logging purposes only.
                 * @param {SourceBuffer} sb Target SourceBuffer instance.
                 * @param {number} startOffset
                 * @param {number} endOffset
                 *
                 * @returns {boolean} True when source buffer remove requested.
                 */
                ;

                _proto.removeBufferRange = function removeBufferRange(
                    type, sb, startOffset, endOffset) {
                  try {
                    for (var i = 0; i < sb.buffered.length; i++) {
                      var bufStart = sb.buffered.start(i);
                      var bufEnd = sb.buffered.end(i);
                      var removeStart = Math.max(bufStart, startOffset);
                      var removeEnd = Math.min(bufEnd, endOffset);
                      /* sometimes sourcebuffer.remove() does not flush
          the exact expected time range.
          to avoid rounding issues/infinite loop,
          only flush buffer range of length greater than 500ms.
        */

                      if (Math.min(removeEnd, bufEnd) - removeStart > 0.5) {
                        var currentTime = 'null';

                        if (this.media) {
                          currentTime = this.media.currentTime.toString();
                        }

                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                            'sb remove ' + type + ' [' + removeStart + ',' +
                            removeEnd + '], of [' + bufStart + ',' + bufEnd +
                            '], pos:' + currentTime);
                        sb.remove(removeStart, removeEnd);
                        return true;
                      }
                    }
                  } catch (error) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                        'removeBufferRange failed', error);
                  }

                  return false;
                };

                return BufferController;
              }(__WEBPACK_IMPORTED_MODULE_2__event_handler__['a' /* default */]);

          /* harmony default export */
          __webpack_exports__['a'] = (BufferController);

          /***/
        }),
        /* 68 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__event_handler__ = __webpack_require__(
              4);

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(
              Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype,
                protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /*
 * cap stream level to media size dimension controller
*/

          var CapLevelController =
              /*#__PURE__*/
              function(_EventHandler) {
                _inheritsLoose(CapLevelController, _EventHandler);

                function CapLevelController(hls) {
                  var _this;

                  _this = _EventHandler.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].FPS_DROP_LEVEL_CAPPING,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].MEDIA_ATTACHING,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].MANIFEST_PARSED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].BUFFER_CODECS,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].MEDIA_DETACHING) ||
                      this;
                  _this.autoLevelCapping = Number.POSITIVE_INFINITY;
                  _this.firstLevel = null;
                  _this.levels = [];
                  _this.media = null;
                  _this.restrictedLevels = [];
                  _this.timer = null;
                  return _this;
                }

                var _proto = CapLevelController.prototype;

                _proto.destroy = function destroy() {
                  if (this.hls.config.capLevelToPlayerSize) {
                    this.media = null;
                    this.stopCapping();
                  }
                };

                _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(data) {
                  // Don't add a restricted level more than once
                  if (CapLevelController.isLevelAllowed(data.droppedLevel,
                      this.restrictedLevels)) {
                    this.restrictedLevels.push(data.droppedLevel);
                  }
                };

                _proto.onMediaAttaching = function onMediaAttaching(data) {
                  this.media = data.media instanceof window.HTMLVideoElement
                      ? data.media
                      : null;
                };

                _proto.onManifestParsed = function onManifestParsed(data) {
                  var hls = this.hls;
                  this.restrictedLevels = [];
                  this.levels = data.levels;
                  this.firstLevel = data.firstLevel;

                  if (hls.config.capLevelToPlayerSize && data.video) {
                    // Start capping immediately if the manifest has signaled video codecs
                    this.startCapping();
                  }
                } // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
                // to the first level
                ;

                _proto.onBufferCodecs = function onBufferCodecs(data) {
                  var hls = this.hls;

                  if (hls.config.capLevelToPlayerSize && data.video) {
                    // If the manifest did not signal a video codec capping has been deferred until we're certain video is present
                    this.startCapping();
                  }
                };

                _proto.onLevelsUpdated = function onLevelsUpdated(data) {
                  this.levels = data.levels;
                };

                _proto.onMediaDetaching = function onMediaDetaching() {
                  this.stopCapping();
                };

                _proto.detectPlayerSize = function detectPlayerSize() {
                  if (this.media) {
                    var levelsLength = this.levels ? this.levels.length : 0;

                    if (levelsLength) {
                      var hls = this.hls;
                      hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);

                      if (hls.autoLevelCapping > this.autoLevelCapping) {
                        // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
                        // usually happen when the user go to the fullscreen mode.
                        hls.streamController.nextLevelSwitch();
                      }

                      this.autoLevelCapping = hls.autoLevelCapping;
                    }
                  }
                }
                /*
  * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
  */
                ;

                _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {
                  var _this2 = this;

                  if (!this.levels) {
                    return -1;
                  }

                  var validLevels = this.levels.filter(function(level, index) {
                    return CapLevelController.isLevelAllowed(index,
                        _this2.restrictedLevels) && index <= capLevelIndex;
                  });
                  return CapLevelController.getMaxLevelByMediaSize(validLevels,
                      this.mediaWidth, this.mediaHeight);
                };

                _proto.startCapping = function startCapping() {
                  if (this.timer) {
                    // Don't reset capping if started twice; this can happen if the manifest signals a video codec
                    return;
                  }

                  this.autoLevelCapping = Number.POSITIVE_INFINITY;
                  this.hls.firstLevel = this.getMaxLevel(this.firstLevel);
                  clearInterval(this.timer);
                  this.timer = setInterval(this.detectPlayerSize.bind(this),
                      1000);
                  this.detectPlayerSize();
                };

                _proto.stopCapping = function stopCapping() {
                  this.restrictedLevels = [];
                  this.firstLevel = null;
                  this.autoLevelCapping = Number.POSITIVE_INFINITY;

                  if (this.timer) {
                    this.timer = clearInterval(this.timer);
                    this.timer = null;
                  }
                };

                CapLevelController.isLevelAllowed = function isLevelAllowed(
                    level, restrictedLevels) {
                  if (restrictedLevels === void 0) {
                    restrictedLevels = [];
                  }

                  return restrictedLevels.indexOf(level) === -1;
                };

                CapLevelController.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(
                    levels, width, height) {
                  if (!levels || levels && !levels.length) {
                    return -1;
                  } // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next
                  // to determine whether we've chosen the greatest bandwidth for the media's dimensions

                  var atGreatestBandiwdth = function atGreatestBandiwdth(
                      curLevel, nextLevel) {
                    if (!nextLevel) {
                      return true;
                    }

                    return curLevel.width !== nextLevel.width ||
                        curLevel.height !== nextLevel.height;
                  }; // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to
                  // the max level

                  var maxLevelIndex = levels.length - 1;

                  for (var i = 0; i < levels.length; i += 1) {
                    var level = levels[i];

                    if ((level.width >= width || level.height >= height) &&
                        atGreatestBandiwdth(level, levels[i + 1])) {
                      maxLevelIndex = i;
                      break;
                    }
                  }

                  return maxLevelIndex;
                };

                _createClass(CapLevelController, [
                  {
                    key: 'mediaWidth',
                    get: function get() {
                      var width;
                      var media = this.media;

                      if (media) {
                        width = media.width || media.clientWidth ||
                            media.offsetWidth;
                        width *= CapLevelController.contentScaleFactor;
                      }

                      return width;
                    },
                  }, {
                    key: 'mediaHeight',
                    get: function get() {
                      var height;
                      var media = this.media;

                      if (media) {
                        height = media.height || media.clientHeight ||
                            media.offsetHeight;
                        height *= CapLevelController.contentScaleFactor;
                      }

                      return height;
                    },
                  }], [
                  {
                    key: 'contentScaleFactor',
                    get: function get() {
                      var pixelRatio = 1;

                      try {
                        pixelRatio = window.devicePixelRatio;
                      } catch (e) {}

                      return pixelRatio;
                    },
                  }]);

                return CapLevelController;
              }(__WEBPACK_IMPORTED_MODULE_1__event_handler__['a' /* default */]);

          /* harmony default export */
          __webpack_exports__['a'] = (CapLevelController);

          /***/
        }),
        /* 69 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__event_handler__ = __webpack_require__(
              4);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__utils_logger__ = __webpack_require__(
              1);

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /*
 * FPS Controller
*/

          var _window = window,
              performance = _window.performance;

          var FPSController =
              /*#__PURE__*/
              function(_EventHandler) {
                _inheritsLoose(FPSController, _EventHandler);

                function FPSController(hls) {
                  return _EventHandler.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].MEDIA_ATTACHING) ||
                      this;
                }

                var _proto = FPSController.prototype;

                _proto.destroy = function destroy() {
                  if (this.timer) {
                    clearInterval(this.timer);
                  }

                  this.isVideoPlaybackQualityAvailable = false;
                };

                _proto.onMediaAttaching = function onMediaAttaching(data) {
                  var config = this.hls.config;

                  if (config.capLevelOnFPSDrop) {
                    var video = this.video = data.media instanceof
                    window.HTMLVideoElement ? data.media : null;

                    if (typeof video.getVideoPlaybackQuality === 'function') {
                      this.isVideoPlaybackQualityAvailable = true;
                    }

                    clearInterval(this.timer);
                    this.timer = setInterval(this.checkFPSInterval.bind(this),
                        config.fpsDroppedMonitoringPeriod);
                  }
                };

                _proto.checkFPS = function checkFPS(
                    video, decodedFrames, droppedFrames) {
                  var currentTime = performance.now();

                  if (decodedFrames) {
                    if (this.lastTime) {
                      var currentPeriod = currentTime - this.lastTime,
                          currentDropped = droppedFrames -
                              this.lastDroppedFrames,
                          currentDecoded = decodedFrames -
                              this.lastDecodedFrames,
                          droppedFPS = 1000 * currentDropped / currentPeriod,
                          hls = this.hls;
                      hls.trigger(
                          __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].FPS_DROP,
                          {
                            currentDropped: currentDropped,
                            currentDecoded: currentDecoded,
                            totalDroppedFrames: droppedFrames,
                          });

                      if (droppedFPS > 0) {
                        // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
                        if (currentDropped >
                            hls.config.fpsDroppedMonitoringThreshold *
                            currentDecoded) {
                          var currentLevel = hls.currentLevel;
                          __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].warn(
                              'drop FPS ratio greater than max allowed value for currentLevel: ' +
                              currentLevel);

                          if (currentLevel > 0 &&
                              (hls.autoLevelCapping === -1 ||
                                  hls.autoLevelCapping >= currentLevel)) {
                            currentLevel = currentLevel - 1;
                            hls.trigger(
                                __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].FPS_DROP_LEVEL_CAPPING,
                                {
                                  level: currentLevel,
                                  droppedLevel: hls.currentLevel,
                                });
                            hls.autoLevelCapping = currentLevel;
                            hls.streamController.nextLevelSwitch();
                          }
                        }
                      }
                    }

                    this.lastTime = currentTime;
                    this.lastDroppedFrames = droppedFrames;
                    this.lastDecodedFrames = decodedFrames;
                  }
                };

                _proto.checkFPSInterval = function checkFPSInterval() {
                  var video = this.video;

                  if (video) {
                    if (this.isVideoPlaybackQualityAvailable) {
                      var videoPlaybackQuality = video.getVideoPlaybackQuality();
                      this.checkFPS(video,
                          videoPlaybackQuality.totalVideoFrames,
                          videoPlaybackQuality.droppedVideoFrames);
                    } else {
                      this.checkFPS(video, video.webkitDecodedFrameCount,
                          video.webkitDroppedFrameCount);
                    }
                  }
                };

                return FPSController;
              }(__WEBPACK_IMPORTED_MODULE_1__event_handler__['a' /* default */]);

          /* harmony default export */
          __webpack_exports__['a'] = (FPSController);

          /***/
        }),
        /* 70 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__task_loop__ = __webpack_require__(
              30);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__errors__ = __webpack_require__(3);

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(
              Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype,
                protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /**
           * @class AudioTrackController
           * @implements {EventHandler}
           *
           * Handles main manifest and audio-track metadata loaded,
           * owns and exposes the selectable audio-tracks data-models.
           *
           * Exposes internal interface to select available audio-tracks.
           *
           * Handles errors on loading audio-track playlists. Manages fallback mechanism
           * with redundants tracks (group-IDs).
           *
           * Handles level-loading and group-ID switches for video (fallback on video levels),
           * and eventually adapts the audio-track group-ID to match.
           *
           * @fires AUDIO_TRACK_LOADING
           * @fires AUDIO_TRACK_SWITCHING
           * @fires AUDIO_TRACKS_UPDATED
           * @fires ERROR
           *
           */

          var AudioTrackController =
              /*#__PURE__*/
              function(_TaskLoop) {
                _inheritsLoose(AudioTrackController, _TaskLoop);

                function AudioTrackController(hls) {
                  var _this;

                  _this = _TaskLoop.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].MANIFEST_LOADING,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].MANIFEST_PARSED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].AUDIO_TRACK_LOADED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].AUDIO_TRACK_SWITCHED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].LEVEL_LOADED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].ERROR) ||
                      this;
                  /**
                   * @private
                   * Currently selected index in `tracks`
                   * @member {number} trackId
                   */

                  _this._trackId = -1;
                  /**
                   * @private
                   * If should select tracks according to default track attribute
                   * @member {boolean} _selectDefaultTrack
                   */

                  _this._selectDefaultTrack = true;
                  /**
                   * @public
                   * All tracks available
                   * @member {AudioTrack[]}
                   */

                  _this.tracks = [];
                  /**
                   * @public
                   * List of blacklisted audio track IDs (that have caused failure)
                   * @member {number[]}
                   */

                  _this.trackIdBlacklist = Object.create(null);
                  /**
                   * @public
                   * The currently running group ID for audio
                   * (we grab this on manifest-parsed and new level-loaded)
                   * @member {string}
                   */

                  _this.audioGroupId = null;
                  return _this;
                }

                /**
                 * Reset audio tracks on new manifest loading.
                 */


                var _proto = AudioTrackController.prototype;

                _proto.onManifestLoading = function onManifestLoading() {
                  this.tracks = [];
                  this._trackId = -1;
                  this._selectDefaultTrack = true;
                }
                /**
                 * Store tracks data from manifest parsed data.
                 *
                 * Trigger AUDIO_TRACKS_UPDATED event.
                 *
                 * @param {*} data
                 */
                ;

                _proto.onManifestParsed = function onManifestParsed(data) {
                  var tracks = this.tracks = data.audioTracks || [];
                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].AUDIO_TRACKS_UPDATED,
                      {
                        audioTracks: tracks,
                      });
                }
                /**
                 * Store track details of loaded track in our data-model.
                 *
                 * Set-up metadata update interval task for live-mode streams.
                 *
                 * @param {*} data
                 */
                ;

                _proto.onAudioTrackLoaded = function onAudioTrackLoaded(data) {
                  if (data.id >= this.tracks.length) {
                    __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].warn(
                        'Invalid audio track id:', data.id);
                    return;
                  }

                  __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                      'audioTrack ' + data.id + ' loaded');
                  this.tracks[data.id].details = data.details; // check if current playlist is a live playlist
                  // and if we have already our reload interval setup

                  if (data.details.live && !this.hasInterval()) {
                    // if live playlist we will have to reload it periodically
                    // set reload period to playlist target duration
                    var updatePeriodMs = data.details.targetduration * 1000;
                    this.setInterval(updatePeriodMs);
                  }

                  if (!data.details.live && this.hasInterval()) {
                    // playlist is not live and timer is scheduled: cancel it
                    this.clearInterval();
                  }
                }
                /**
                 * Update the internal group ID to any audio-track we may have set manually
                 * or because of a failure-handling fallback.
                 *
                 * Quality-levels should update to that group ID in this case.
                 *
                 * @param {*} data
                 */
                ;

                _proto.onAudioTrackSwitched = function onAudioTrackSwitched(data) {
                  var audioGroupId = this.tracks[data.id].groupId;

                  if (audioGroupId && this.audioGroupId !== audioGroupId) {
                    this.audioGroupId = audioGroupId;
                  }
                }
                /**
                 * When a level gets loaded, if it has redundant audioGroupIds (in the same ordinality as it's redundant URLs)
                 * we are setting our audio-group ID internally to the one set, if it is different from the group ID currently set.
                 *
                 * If group-ID got update, we re-select the appropriate audio-track with this group-ID matching the currently
                 * selected one (based on NAME property).
                 *
                 * @param {*} data
                 */
                ;

                _proto.onLevelLoaded = function onLevelLoaded(data) {
                  // FIXME: crashes because currentLevel is undefined
                  // const levelInfo = this.hls.levels[this.hls.currentLevel];
                  var levelInfo = this.hls.levels[data.level];

                  if (!levelInfo.audioGroupIds) {
                    return;
                  }

                  var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];

                  if (this.audioGroupId !== audioGroupId) {
                    this.audioGroupId = audioGroupId;

                    this._selectInitialAudioTrack();
                  }
                }
                /**
                 * Handle network errors loading audio track manifests
                 * and also pausing on any netwok errors.
                 *
                 * @param {ErrorEventData} data
                 */
                ;

                _proto.onError = function onError(data) {
                  // Only handle network errors
                  if (data.type !==
                      __WEBPACK_IMPORTED_MODULE_3__errors__['b' /* ErrorTypes */].NETWORK_ERROR) {
                    return;
                  } // If fatal network error, cancel update task

                  if (data.fatal) {
                    this.clearInterval();
                  } // If not an audio-track loading error don't handle further

                  if (data.details !==
                      __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].AUDIO_TRACK_LOAD_ERROR) {
                    return;
                  }

                  __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].warn(
                      'Network failure on audio-track id:', data.context.id);

                  this._handleLoadError();
                }
                /**
                 * @type {AudioTrack[]} Audio-track list we own
                 */
                ;

                /**
                 * @private
                 * @param {number} newId
                 */
                _proto._setAudioTrack = function _setAudioTrack(newId) {
                  // noop on same audio track id as already set
                  if (this._trackId === newId &&
                      this.tracks[this._trackId].details) {
                    __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].debug(
                        'Same id as current audio-track passed, and track details available -> no-op');
                    return;
                  } // check if level idx is valid

                  if (newId < 0 || newId >= this.tracks.length) {
                    __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].warn(
                        'Invalid id passed to audio-track controller');
                    return;
                  }

                  var audioTrack = this.tracks[newId];
                  __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                      'Now switching to audio-track index ' + newId); // stopping live reloading timer if any

                  this.clearInterval();
                  this._trackId = newId;
                  var url = audioTrack.url,
                      type = audioTrack.type,
                      id = audioTrack.id;
                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].AUDIO_TRACK_SWITCHING,
                      {
                        id: id,
                        type: type,
                        url: url,
                      });

                  this._loadTrackDetailsIfNeeded(audioTrack);
                }
                /**
                 * @override
                 */
                ;

                _proto.doTick = function doTick() {
                  this._updateTrack(this._trackId);
                }
                /**
                 * Select initial track
                 * @private
                 */
                ;

                _proto._selectInitialAudioTrack = function _selectInitialAudioTrack() {
                  var _this2 = this;

                  var tracks = this.tracks;

                  if (!tracks.length) {
                    return;
                  }

                  var currentAudioTrack = this.tracks[this._trackId];
                  var name = null;

                  if (currentAudioTrack) {
                    name = currentAudioTrack.name;
                  } // Pre-select default tracks if there are any

                  if (this._selectDefaultTrack) {
                    var defaultTracks = tracks.filter(function(track) {
                      return track.default;
                    });

                    if (defaultTracks.length) {
                      tracks = defaultTracks;
                    } else {
                      __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].warn(
                          'No default audio tracks defined');
                    }
                  }

                  var trackFound = false;

                  var traverseTracks = function traverseTracks() {
                    // Select track with right group ID
                    tracks.forEach(function(track) {
                      if (trackFound) {
                        return;
                      } // We need to match the (pre-)selected group ID
                      // and the NAME of the current track.

                      if ((!_this2.audioGroupId || track.groupId ===
                          _this2.audioGroupId) &&
                          (!name || name === track.name)) {
                        // If there was a previous track try to stay with the same `NAME`.
                        // It should be unique across tracks of same group, and consistent through redundant track groups.
                        _this2._setAudioTrack(track.id);

                        trackFound = true;
                      }
                    });
                  };

                  traverseTracks();

                  if (!trackFound) {
                    name = null;
                    traverseTracks();
                  }

                  if (!trackFound) {
                    __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].error(
                        'No track found for running audio group-ID: ' +
                        this.audioGroupId);
                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_3__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_3__errors__['a' /* ErrorDetails */].AUDIO_TRACK_LOAD_ERROR,
                          fatal: true,
                        });
                  }
                }
                /**
                 * @private
                 * @param {AudioTrack} audioTrack
                 * @returns {boolean}
                 */
                ;

                _proto._needsTrackLoading = function _needsTrackLoading(audioTrack) {
                  var details = audioTrack.details,
                      url = audioTrack.url;

                  if (!details || details.live) {
                    // check if we face an audio track embedded in main playlist (audio track without URI attribute)
                    return !!url;
                  }

                  return false;
                }
                /**
                 * @private
                 * @param {AudioTrack} audioTrack
                 */
                ;

                _proto._loadTrackDetailsIfNeeded = function _loadTrackDetailsIfNeeded(audioTrack) {
                  if (this._needsTrackLoading(audioTrack)) {
                    var url = audioTrack.url,
                        id = audioTrack.id; // track not retrieved yet, or live playlist we need to (re)load it

                    __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                        'loading audio-track playlist for id: ' + id);
                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].AUDIO_TRACK_LOADING,
                        {
                          url: url,
                          id: id,
                        });
                  }
                }
                /**
                 * @private
                 * @param {number} newId
                 */
                ;

                _proto._updateTrack = function _updateTrack(newId) {
                  // check if level idx is valid
                  if (newId < 0 || newId >= this.tracks.length) {
                    return;
                  } // stopping live reloading timer if any

                  this.clearInterval();
                  this._trackId = newId;
                  __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                      'trying to update audio-track ' + newId);
                  var audioTrack = this.tracks[newId];

                  this._loadTrackDetailsIfNeeded(audioTrack);
                }
                /**
                 * @private
                 */
                ;

                _proto._handleLoadError = function _handleLoadError() {
                  // First, let's black list current track id
                  this.trackIdBlacklist[this._trackId] = true; // Let's try to fall back on a functional audio-track with the same group ID

                  var previousId = this._trackId;
                  var _this$tracks$previous = this.tracks[previousId],
                      name = _this$tracks$previous.name,
                      language = _this$tracks$previous.language,
                      groupId = _this$tracks$previous.groupId;
                  __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].warn(
                      'Loading failed on audio track id: ' + previousId +
                      ', group-id: ' + groupId + ', name/language: "' + name +
                      '" / "' + language + '"'); // Find a non-blacklisted track ID with the same NAME
                  // At least a track that is not blacklisted, thus on another group-ID.

                  var newId = previousId;

                  for (var i = 0; i < this.tracks.length; i++) {
                    if (this.trackIdBlacklist[i]) {
                      continue;
                    }

                    var newTrack = this.tracks[i];

                    if (newTrack.name === name) {
                      newId = i;
                      break;
                    }
                  }

                  if (newId === previousId) {
                    __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].warn(
                        'No fallback audio-track found for name/language: "' +
                        name + '" / "' + language + '"');
                    return;
                  }

                  __WEBPACK_IMPORTED_MODULE_2__utils_logger__['b' /* logger */].log(
                      'Attempting audio-track fallback id:', newId, 'group-id:',
                      this.tracks[newId].groupId);

                  this._setAudioTrack(newId);
                };

                _createClass(AudioTrackController, [
                  {
                    key: 'audioTracks',
                    get: function get() {
                      return this.tracks;
                    },
                    /**
                     * @type {number} Index into audio-tracks list of currently selected track.
                     */

                  }, {
                    key: 'audioTrack',
                    get: function get() {
                      return this._trackId;
                    }
                    /**
                     * Select current track by index
                     */
                    ,
                    set: function set(newId) {
                      this._setAudioTrack(newId); // If audio track is selected from API then don't choose from the manifest default track

                      this._selectDefaultTrack = false;
                    },
                  }]);

                return AudioTrackController;
              }(__WEBPACK_IMPORTED_MODULE_1__task_loop__['a' /* default */]);

          /* harmony default export */
          __webpack_exports__['a'] = (AudioTrackController);

          /***/
        }),
        /* 71 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__utils_binary_search__ = __webpack_require__(
              11);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__utils_buffer_helper__ = __webpack_require__(
              6);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__demux_demuxer__ = __webpack_require__(
              23);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__level_helper__ = __webpack_require__(
              9);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_6__utils_time_ranges__ = __webpack_require__(
              27);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_7__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_8__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_9__utils_discontinuities__ = __webpack_require__(
              28);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_10__fragment_tracker__ = __webpack_require__(
              7);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_11__loader_fragment__ = __webpack_require__(
              13);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__ = __webpack_require__(
              17);

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(
              Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype,
                protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /*
 * Audio Stream Controller
*/

          var _window = window,
              performance = _window.performance;
          var TICK_INTERVAL = 100; // how often to tick in ms

          var AudioStreamController =
              /*#__PURE__*/
              function(_BaseStreamController) {
                _inheritsLoose(AudioStreamController, _BaseStreamController);

                function AudioStreamController(hls, fragmentTracker) {
                  var _this;

                  _this = _BaseStreamController.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].MEDIA_ATTACHED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].MEDIA_DETACHING,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].AUDIO_TRACKS_UPDATED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].AUDIO_TRACK_SWITCHING,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].AUDIO_TRACK_LOADED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].KEY_LOADED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_LOADED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_PARSING_INIT_SEGMENT,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_PARSING_DATA,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_PARSED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].ERROR,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_RESET,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_CREATED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_APPENDED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_FLUSHED,
                      __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].INIT_PTS_FOUND) ||
                      this;
                  _this.fragmentTracker = fragmentTracker;
                  _this.config = hls.config;
                  _this.audioCodecSwap = false;
                  _this._state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].STOPPED;
                  _this.initPTS = [];
                  _this.waitingFragment = null;
                  _this.videoTrackCC = null;
                  return _this;
                } // Signal that video PTS was found

                var _proto = AudioStreamController.prototype;

                _proto.onInitPtsFound = function onInitPtsFound(data) {
                  var demuxerId = data.id,
                      cc = data.frag.cc,
                      initPTS = data.initPTS;

                  if (demuxerId === 'main') {
                    // Always update the new INIT PTS
                    // Can change due level switch
                    this.initPTS[cc] = initPTS;
                    this.videoTrackCC = cc;
                    __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                        'InitPTS for cc: ' + cc + ' found from video track: ' +
                        initPTS); // If we are waiting we need to demux/remux the waiting frag
                    // With the new initPTS

                    if (this.state ===
                        __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].WAITING_INIT_PTS) {
                      this.tick();
                    }
                  }
                };

                _proto.startLoad = function startLoad(startPosition) {
                  if (this.tracks) {
                    var lastCurrentTime = this.lastCurrentTime;
                    this.stopLoad();
                    this.setInterval(TICK_INTERVAL);
                    this.fragLoadError = 0;

                    if (lastCurrentTime > 0 && startPosition === -1) {
                      __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                          'audio:override startPosition with lastCurrentTime @' +
                          lastCurrentTime.toFixed(3));
                      this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].IDLE;
                    } else {
                      this.lastCurrentTime = this.startPosition
                          ? this.startPosition
                          : startPosition;
                      this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].STARTING;
                    }

                    this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
                    this.tick();
                  } else {
                    this.startPosition = startPosition;
                    this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].STOPPED;
                  }
                };

                _proto.doTick = function doTick() {
                  var pos,
                      track,
                      trackDetails,
                      hls = this.hls,
                      config = hls.config; // logger.log('audioStream:' + this.state);

                  switch (this.state) {
                    case __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].ERROR: // don't do anything in error state to avoid breaking further ...

                    case __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PAUSED: // don't do anything in paused state either ...

                    case __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].BUFFER_FLUSHING:
                      break;

                    case __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].STARTING:
                      this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].WAITING_TRACK;
                      this.loadedmetadata = false;
                      break;

                    case __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].IDLE:
                      var tracks = this.tracks; // audio tracks not received => exit loop

                      if (!tracks) {
                        break;
                      } // if video not attached AND
                      // start fragment already requested OR start frag prefetch disable
                      // exit loop
                      // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop

                      if (!this.media && (this.startFragRequested ||
                          !config.startFragPrefetch)) {
                        break;
                      } // determine next candidate fragment to be loaded, based on current position and
                      //  end of buffer position
                      // if we have not yet loaded any fragment, start loading from start position

                      if (this.loadedmetadata) {
                        pos = this.media.currentTime;
                      } else {
                        pos = this.nextLoadPosition;

                        if (pos === undefined) {
                          break;
                        }
                      }

                      var media = this.mediaBuffer
                          ? this.mediaBuffer
                          : this.media,
                          videoBuffer = this.videoBuffer
                              ? this.videoBuffer
                              : this.media,
                          bufferInfo = __WEBPACK_IMPORTED_MODULE_2__utils_buffer_helper__['a' /* BufferHelper */].bufferInfo(
                              media, pos, config.maxBufferHole),
                          mainBufferInfo = __WEBPACK_IMPORTED_MODULE_2__utils_buffer_helper__['a' /* BufferHelper */].bufferInfo(
                              videoBuffer, pos, config.maxBufferHole),
                          bufferLen = bufferInfo.len,
                          bufferEnd = bufferInfo.end,
                          fragPrevious = this.fragPrevious,
                          // ensure we buffer at least config.maxBufferLength (default 30s) or config.maxMaxBufferLength (default: 600s)
                          // whichever is smaller.
                          // once we reach that threshold, don't buffer more than video (mainBufferInfo.len)
                          maxConfigBuffer = Math.min(config.maxBufferLength,
                              config.maxMaxBufferLength),
                          maxBufLen = Math.max(maxConfigBuffer,
                              mainBufferInfo.len),
                          audioSwitch = this.audioSwitch,
                          trackId = this.trackId; // if buffer length is less than maxBufLen try to load a new fragment

                      if ((bufferLen < maxBufLen || audioSwitch) && trackId <
                          tracks.length) {
                        trackDetails = tracks[trackId].details; // if track info not retrieved yet, switch state and wait for track retrieval

                        if (typeof trackDetails === 'undefined') {
                          this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].WAITING_TRACK;
                          break;
                        }

                        if (!audioSwitch &&
                            this._streamEnded(bufferInfo, trackDetails)) {
                          this.hls.trigger(
                              __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_EOS,
                              {
                                type: 'audio',
                              });
                          this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].ENDED;
                          return;
                        } // find fragment index, contiguous with end of buffer position

                        var fragments = trackDetails.fragments,
                            fragLen = fragments.length,
                            start = fragments[0].start,
                            end = fragments[fragLen - 1].start +
                                fragments[fragLen - 1].duration,
                            frag; // When switching audio track, reload audio as close as possible to currentTime

                        if (audioSwitch) {
                          if (trackDetails.live && !trackDetails.PTSKnown) {
                            __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                                'switching audiotrack, live stream, unknown PTS,load first fragment');
                            bufferEnd = 0;
                          } else {
                            bufferEnd = pos; // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime

                            if (trackDetails.PTSKnown && pos < start) {
                              // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
                              if (bufferInfo.end > start ||
                                  bufferInfo.nextStart) {
                                __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                                    'alt audio track ahead of main track, seek to start of alt audio track');
                                this.media.currentTime = start + 0.05;
                              } else {
                                return;
                              }
                            }
                          }
                        }

                        if (trackDetails.initSegment &&
                            !trackDetails.initSegment.data) {
                          frag = trackDetails.initSegment;
                        } // eslint-disable-line brace-style
                        // if bufferEnd before start of playlist, load first fragment
                        else if (bufferEnd <= start) {
                          frag = fragments[0];

                          if (this.videoTrackCC !== null && frag.cc !==
                              this.videoTrackCC) {
                            // Ensure we find a fragment which matches the continuity of the video track
                            frag = Object(
                                __WEBPACK_IMPORTED_MODULE_9__utils_discontinuities__['b' /* findFragWithCC */])(
                                fragments, this.videoTrackCC);
                          }

                          if (trackDetails.live && frag.loadIdx &&
                              frag.loadIdx === this.fragLoadIdx) {
                            // we just loaded this first fragment, and we are still lagging behind the start of the live playlist
                            // let's force seek to start
                            var nextBuffered = bufferInfo.nextStart
                                ? bufferInfo.nextStart
                                : start;
                            __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                                'no alt audio available @currentTime:' +
                                this.media.currentTime + ', seeking @' +
                                (nextBuffered + 0.05));
                            this.media.currentTime = nextBuffered + 0.05;
                            return;
                          }
                        } else {
                          var foundFrag;
                          var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                          var fragNext = fragPrevious
                              ? fragments[fragPrevious.sn - fragments[0].sn + 1]
                              : undefined;

                          var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
                            // offset should be within fragment boundary - config.maxFragLookUpTolerance
                            // this is to cope with situations like
                            // bufferEnd = 9.991
                            // frag[] : [0,10]
                            // frag[1] : [10,20]
                            // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                            //              frag start               frag start+duration
                            //                  |-----------------------------|
                            //              <--->                         <--->
                            //  ...--------><-----------------------------><---------....
                            // previous frag         matching fragment         next frag
                            //  return -1             return 0                 return 1
                            // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                            // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
                            var candidateLookupTolerance = Math.min(
                                maxFragLookUpTolerance, candidate.duration);

                            if (candidate.start + candidate.duration -
                                candidateLookupTolerance <= bufferEnd) {
                              return 1;
                            } else if (candidate.start -
                                candidateLookupTolerance > bufferEnd &&
                                candidate.start) {
                              // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
                              return -1;
                            }

                            return 0;
                          };

                          if (bufferEnd < end) {
                            if (bufferEnd > end - maxFragLookUpTolerance) {
                              maxFragLookUpTolerance = 0;
                            } // Prefer the next fragment if it's within tolerance

                            if (fragNext &&
                                !fragmentWithinToleranceTest(fragNext)) {
                              foundFrag = fragNext;
                            } else {
                              foundFrag = __WEBPACK_IMPORTED_MODULE_1__utils_binary_search__['a' /* default */].search(
                                  fragments, fragmentWithinToleranceTest);
                            }
                          } else {
                            // reach end of playlist
                            foundFrag = fragments[fragLen - 1];
                          }

                          if (foundFrag) {
                            frag = foundFrag;
                            start = foundFrag.start; // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);

                            if (fragPrevious && frag.level ===
                                fragPrevious.level && frag.sn ===
                                fragPrevious.sn) {
                              if (frag.sn < trackDetails.endSN) {
                                frag = fragments[frag.sn + 1 -
                                trackDetails.startSN];
                                __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                                    'SN just loaded, load next one: ' +
                                    frag.sn);
                              } else {
                                frag = null;
                              }
                            }
                          }
                        }

                        if (frag) {
                          // logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
                          if (frag.encrypted) {
                            __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                                'Loading key for ' + frag.sn + ' of [' +
                                trackDetails.startSN + ' ,' +
                                trackDetails.endSN + '],track ' + trackId);
                            this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].KEY_LOADING;
                            hls.trigger(
                                __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].KEY_LOADING,
                                {
                                  frag: frag,
                                });
                          } else {
                            __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                                'Loading ' + frag.sn + ', cc: ' + frag.cc +
                                ' of [' + trackDetails.startSN + ' ,' +
                                trackDetails.endSN + '],track ' + trackId +
                                ', currentTime:' + pos + ',bufferEnd:' +
                                bufferEnd.toFixed(3)); // only load if fragment is not loaded or if in audio switch
                            // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch

                            this.fragCurrent = frag;

                            if (audioSwitch ||
                                this.fragmentTracker.getState(frag) ===
                                __WEBPACK_IMPORTED_MODULE_10__fragment_tracker__['a' /* FragmentState */].NOT_LOADED) {
                              if (frag.sn !== 'initSegment') {
                                this.startFragRequested = true;
                              }

                              if (Object(
                                  __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                                  frag.sn)) {
                                this.nextLoadPosition = frag.start +
                                    frag.duration;
                              }

                              hls.trigger(
                                  __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_LOADING,
                                  {
                                    frag: frag,
                                  });
                              this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].FRAG_LOADING;
                            }
                          }
                        }
                      }

                      break;

                    case __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].WAITING_TRACK:
                      track = this.tracks[this.trackId]; // check if playlist is already loaded

                      if (track && track.details) {
                        this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].IDLE;
                      }

                      break;

                    case __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].FRAG_LOADING_WAITING_RETRY:
                      var now = performance.now();
                      var retryDate = this.retryDate;
                      media = this.media;
                      var isSeeking = media && media.seeking; // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading

                      if (!retryDate || now >= retryDate || isSeeking) {
                        __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                            'audioStreamController: retryDate reached, switch back to IDLE state');
                        this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].IDLE;
                      }

                      break;

                    case __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].WAITING_INIT_PTS:
                      var videoTrackCC = this.videoTrackCC;

                      if (this.initPTS[videoTrackCC] === undefined) {
                        break;
                      } // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS

                      var waitingFrag = this.waitingFragment;

                      if (waitingFrag) {
                        var waitingFragCC = waitingFrag.frag.cc;

                        if (videoTrackCC !== waitingFragCC) {
                          track = this.tracks[this.trackId];

                          if (track.details && track.details.live) {
                            __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].warn(
                                'Waiting fragment CC (' + waitingFragCC +
                                ') does not match video track CC (' +
                                videoTrackCC + ')');
                            this.waitingFragment = null;
                            this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].IDLE;
                          }
                        } else {
                          this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].FRAG_LOADING;
                          this.onFragLoaded(this.waitingFragment);
                          this.waitingFragment = null;
                        }
                      } else {
                        this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].IDLE;
                      }

                      break;

                    case __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].STOPPED:
                    case __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].FRAG_LOADING:
                    case __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PARSING:
                    case __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PARSED:
                    case __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].ENDED:
                      break;

                    default:
                      break;
                  }
                };

                _proto.onMediaAttached = function onMediaAttached(data) {
                  var media = this.media = this.mediaBuffer = data.media;
                  this.onvseeking = this.onMediaSeeking.bind(this);
                  this.onvended = this.onMediaEnded.bind(this);
                  media.addEventListener('seeking', this.onvseeking);
                  media.addEventListener('ended', this.onvended);
                  var config = this.config;

                  if (this.tracks && config.autoStartLoad) {
                    this.startLoad(config.startPosition);
                  }
                };

                _proto.onMediaDetaching = function onMediaDetaching() {
                  var media = this.media;

                  if (media && media.ended) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                        'MSE detaching and video ended, reset startPosition');
                    this.startPosition = this.lastCurrentTime = 0;
                  } // remove video listeners

                  if (media) {
                    media.removeEventListener('seeking', this.onvseeking);
                    media.removeEventListener('ended', this.onvended);
                    this.onvseeking = this.onvseeked = this.onvended = null;
                  }

                  this.media = this.mediaBuffer = this.videoBuffer = null;
                  this.loadedmetadata = false;
                  this.fragmentTracker.removeAllFragments();
                  this.stopLoad();
                };

                _proto.onAudioTracksUpdated = function onAudioTracksUpdated(data) {
                  __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                      'audio tracks updated');
                  this.tracks = data.audioTracks;
                };

                _proto.onAudioTrackSwitching = function onAudioTrackSwitching(data) {
                  // if any URL found on new audio track, it is an alternate audio track
                  var altAudio = !!data.url;
                  this.trackId = data.id;
                  this.fragCurrent = null;
                  this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PAUSED;
                  this.waitingFragment = null; // destroy useless demuxer when switching audio to main

                  if (!altAudio) {
                    if (this.demuxer) {
                      this.demuxer.destroy();
                      this.demuxer = null;
                    }
                  } else {
                    // switching to audio track, start timer if not already started
                    this.setInterval(TICK_INTERVAL);
                  } // should we switch tracks ?

                  if (altAudio) {
                    this.audioSwitch = true; // main audio track are handled by stream-controller, just do something if switching to alt audio track

                    this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].IDLE;
                  }

                  this.tick();
                };

                _proto.onAudioTrackLoaded = function onAudioTrackLoaded(data) {
                  var newDetails = data.details,
                      trackId = data.id,
                      track = this.tracks[trackId],
                      duration = newDetails.totalduration,
                      sliding = 0;
                  __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                      'track ' + trackId + ' loaded [' + newDetails.startSN +
                      ',' + newDetails.endSN + '],duration:' + duration);

                  if (newDetails.live) {
                    var curDetails = track.details;

                    if (curDetails && newDetails.fragments.length > 0) {
                      // we already have details for that level, merge them
                      __WEBPACK_IMPORTED_MODULE_5__level_helper__['c' /* mergeDetails */](
                          curDetails, newDetails);
                      sliding = newDetails.fragments[0].start; // TODO
                      // this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);

                      if (newDetails.PTSKnown) {
                        __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                            'live audio playlist sliding:' +
                            sliding.toFixed(3));
                      } else {
                        __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                            'live audio playlist - outdated PTS, unknown sliding');
                      }
                    } else {
                      newDetails.PTSKnown = false;
                      __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                          'live audio playlist - first load, unknown sliding');
                    }
                  } else {
                    newDetails.PTSKnown = false;
                  }

                  track.details = newDetails; // compute start position

                  if (!this.startFragRequested) {
                    // compute start position if set to -1. use it straight away if value is defined
                    if (this.startPosition === -1) {
                      // first, check if start time offset has been set in playlist, if yes, use this value
                      var startTimeOffset = newDetails.startTimeOffset;

                      if (Object(
                          __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                          startTimeOffset)) {
                        __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                            'start time offset found in playlist, adjust startPosition to ' +
                            startTimeOffset);
                        this.startPosition = startTimeOffset;
                      } else {
                        if (newDetails.live) {
                          this.startPosition = this.computeLivePosition(sliding,
                              newDetails);
                          __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                              'compute startPosition for audio-track to ' +
                              this.startPosition);
                        } else {
                          this.startPosition = 0;
                        }
                      }
                    }

                    this.nextLoadPosition = this.startPosition;
                  } // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment

                  if (this.state ===
                      __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].WAITING_TRACK) {
                    this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].IDLE;
                  } // trigger handler right now

                  this.tick();
                };

                _proto.onKeyLoaded = function onKeyLoaded() {
                  if (this.state ===
                      __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].KEY_LOADING) {
                    this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].IDLE;
                    this.tick();
                  }
                };

                _proto.onFragLoaded = function onFragLoaded(data) {
                  var fragCurrent = this.fragCurrent,
                      fragLoaded = data.frag;

                  if (this.state ===
                      __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].FRAG_LOADING &&
                      fragCurrent && fragLoaded.type === 'audio' &&
                      fragLoaded.level === fragCurrent.level &&
                      fragLoaded.sn === fragCurrent.sn) {
                    var track = this.tracks[this.trackId],
                        details = track.details,
                        duration = details.totalduration,
                        trackId = fragCurrent.level,
                        sn = fragCurrent.sn,
                        cc = fragCurrent.cc,
                        audioCodec = this.config.defaultAudioCodec ||
                            track.audioCodec || 'mp4a.40.2',
                        stats = this.stats = data.stats;

                    if (sn === 'initSegment') {
                      this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].IDLE;
                      stats.tparsed = stats.tbuffered = performance.now();
                      details.initSegment.data = data.payload;
                      this.hls.trigger(
                          __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_BUFFERED,
                          {
                            stats: stats,
                            frag: fragCurrent,
                            id: 'audio',
                          });
                      this.tick();
                    } else {
                      this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PARSING; // transmux the MPEG-TS data to ISO-BMFF segments

                      this.appended = false;

                      if (!this.demuxer) {
                        this.demuxer = new __WEBPACK_IMPORTED_MODULE_3__demux_demuxer__['a' /* default */](
                            this.hls, 'audio');
                      } // Check if we have video initPTS
                      // If not we need to wait for it

                      var initPTS = this.initPTS[cc];
                      var initSegmentData = details.initSegment
                          ? details.initSegment.data
                          : [];

                      if (details.initSegment || initPTS !== undefined) {
                        this.pendingBuffering = true;
                        __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                            'Demuxing ' + sn + ' of [' + details.startSN +
                            ' ,' + details.endSN + '],track ' + trackId); // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)

                        var accurateTimeOffset = false; // details.PTSKnown || !details.live;

                        this.demuxer.push(data.payload, initSegmentData,
                            audioCodec, null, fragCurrent, duration,
                            accurateTimeOffset, initPTS);
                      } else {
                        __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                            'unknown video PTS for continuity counter ' + cc +
                            ', waiting for video PTS before demuxing audio frag ' +
                            sn + ' of [' + details.startSN + ' ,' +
                            details.endSN + '],track ' + trackId);
                        this.waitingFragment = data;
                        this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].WAITING_INIT_PTS;
                      }
                    }
                  }

                  this.fragLoadError = 0;
                };

                _proto.onFragParsingInitSegment = function onFragParsingInitSegment(data) {
                  var fragCurrent = this.fragCurrent;
                  var fragNew = data.frag;

                  if (fragCurrent && data.id === 'audio' && fragNew.sn ===
                      fragCurrent.sn && fragNew.level === fragCurrent.level &&
                      this.state ===
                      __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PARSING) {
                    var tracks = data.tracks,
                        track; // delete any video track found on audio demuxer

                    if (tracks.video) {
                      delete tracks.video;
                    } // include levelCodec in audio and video tracks

                    track = tracks.audio;

                    if (track) {
                      track.levelCodec = track.codec;
                      track.id = data.id;
                      this.hls.trigger(
                          __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_CODECS,
                          tracks);
                      __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                          'audio track:audio,container:' + track.container +
                          ',codecs[level/parsed]=[' + track.levelCodec + '/' +
                          track.codec + ']');
                      var initSegment = track.initSegment;

                      if (initSegment) {
                        var appendObj = {
                          type: 'audio',
                          data: initSegment,
                          parent: 'audio',
                          content: 'initSegment',
                        };

                        if (this.audioSwitch) {
                          this.pendingData = [appendObj];
                        } else {
                          this.appended = true; // arm pending Buffering flag before appending a segment

                          this.pendingBuffering = true;
                          this.hls.trigger(
                              __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_APPENDING,
                              appendObj);
                        }
                      } // trigger handler right now

                      this.tick();
                    }
                  }
                };

                _proto.onFragParsingData = function onFragParsingData(data) {
                  var _this2 = this;

                  var fragCurrent = this.fragCurrent;
                  var fragNew = data.frag;

                  if (fragCurrent && data.id === 'audio' && data.type ===
                      'audio' && fragNew.sn === fragCurrent.sn &&
                      fragNew.level === fragCurrent.level && this.state ===
                      __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PARSING) {
                    var trackId = this.trackId,
                        track = this.tracks[trackId],
                        hls = this.hls;

                    if (!Object(
                        __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                        data.endPTS)) {
                      data.endPTS = data.startPTS + fragCurrent.duration;
                      data.endDTS = data.startDTS + fragCurrent.duration;
                    }

                    fragCurrent.addElementaryStream(
                        __WEBPACK_IMPORTED_MODULE_11__loader_fragment__['a' /* ElementaryStreamTypes */].AUDIO);
                    __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                        'parsed ' + data.type + ',PTS:[' +
                        data.startPTS.toFixed(3) + ',' +
                        data.endPTS.toFixed(3) + '],DTS:[' +
                        data.startDTS.toFixed(3) + '/' +
                        data.endDTS.toFixed(3) + '],nb:' + data.nb);
                    __WEBPACK_IMPORTED_MODULE_5__level_helper__['e' /* updateFragPTSDTS */](
                        track.details, fragCurrent, data.startPTS, data.endPTS);
                    var audioSwitch = this.audioSwitch,
                        media = this.media,
                        appendOnBufferFlush = false; // Only flush audio from old audio tracks when PTS is known on new audio track

                    if (audioSwitch) {
                      if (media && media.readyState) {
                        var currentTime = media.currentTime;
                        __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                            'switching audio track : currentTime:' +
                            currentTime);

                        if (currentTime >= data.startPTS) {
                          __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                              'switching audio track : flushing all audio');
                          this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].BUFFER_FLUSHING;
                          hls.trigger(
                              __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_FLUSHING,
                              {
                                startOffset: 0,
                                endOffset: Number.POSITIVE_INFINITY,
                                type: 'audio',
                              });
                          appendOnBufferFlush = true; // Lets announce that the initial audio track switch flush occur

                          this.audioSwitch = false;
                          hls.trigger(
                              __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].AUDIO_TRACK_SWITCHED,
                              {
                                id: trackId,
                              });
                        }
                      } else {
                        // Lets announce that the initial audio track switch flush occur
                        this.audioSwitch = false;
                        hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].AUDIO_TRACK_SWITCHED,
                            {
                              id: trackId,
                            });
                      }
                    }

                    var pendingData = this.pendingData;

                    if (!pendingData) {
                      __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].warn(
                          'Apparently attempt to enqueue media payload without codec initialization data upfront');
                      hls.trigger(
                          __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].ERROR,
                          {
                            type: __WEBPACK_IMPORTED_MODULE_7__errors__['b' /* ErrorTypes */].MEDIA_ERROR,
                            details: null,
                            fatal: true,
                          });
                      return;
                    }

                    if (!this.audioSwitch) {
                      [data.data1, data.data2].forEach(function(buffer) {
                        if (buffer && buffer.length) {
                          pendingData.push({
                            type: data.type,
                            data: buffer,
                            parent: 'audio',
                            content: 'data',
                          });
                        }
                      });

                      if (!appendOnBufferFlush && pendingData.length) {
                        pendingData.forEach(function(appendObj) {
                          // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
                          // in that case it is useless to append following segments
                          if (_this2.state ===
                              __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PARSING) {
                            // arm pending Buffering flag before appending a segment
                            _this2.pendingBuffering = true;

                            _this2.hls.trigger(
                                __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_APPENDING,
                                appendObj);
                          }
                        });
                        this.pendingData = [];
                        this.appended = true;
                      }
                    } // trigger handler right now

                    this.tick();
                  }
                };

                _proto.onFragParsed = function onFragParsed(data) {
                  var fragCurrent = this.fragCurrent;
                  var fragNew = data.frag;

                  if (fragCurrent && data.id === 'audio' && fragNew.sn ===
                      fragCurrent.sn && fragNew.level === fragCurrent.level &&
                      this.state ===
                      __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PARSING) {
                    this.stats.tparsed = performance.now();
                    this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PARSED;

                    this._checkAppendedParsed();
                  }
                };

                _proto.onBufferReset = function onBufferReset() {
                  // reset reference to sourcebuffers
                  this.mediaBuffer = this.videoBuffer = null;
                  this.loadedmetadata = false;
                };

                _proto.onBufferCreated = function onBufferCreated(data) {
                  var audioTrack = data.tracks.audio;

                  if (audioTrack) {
                    this.mediaBuffer = audioTrack.buffer;
                    this.loadedmetadata = true;
                  }

                  if (data.tracks.video) {
                    this.videoBuffer = data.tracks.video.buffer;
                  }
                };

                _proto.onBufferAppended = function onBufferAppended(data) {
                  if (data.parent === 'audio') {
                    var state = this.state;

                    if (state ===
                        __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PARSING ||
                        state ===
                        __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PARSED) {
                      // check if all buffers have been appended
                      this.pendingBuffering = data.pending > 0;

                      this._checkAppendedParsed();
                    }
                  }
                };

                _proto._checkAppendedParsed = function _checkAppendedParsed() {
                  // trigger handler right now
                  if (this.state ===
                      __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PARSED &&
                      (!this.appended || !this.pendingBuffering)) {
                    var frag = this.fragCurrent,
                        stats = this.stats,
                        hls = this.hls;

                    if (frag) {
                      this.fragPrevious = frag;
                      stats.tbuffered = performance.now();
                      hls.trigger(
                          __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].FRAG_BUFFERED,
                          {
                            stats: stats,
                            frag: frag,
                            id: 'audio',
                          });
                      var media = this.mediaBuffer
                          ? this.mediaBuffer
                          : this.media;

                      if (media) {
                        __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                            'audio buffered : ' +
                            __WEBPACK_IMPORTED_MODULE_6__utils_time_ranges__['a' /* default */].toString(
                                media.buffered));
                      }

                      if (this.audioSwitch && this.appended) {
                        this.audioSwitch = false;
                        hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].AUDIO_TRACK_SWITCHED,
                            {
                              id: this.trackId,
                            });
                      }

                      this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].IDLE;
                    }

                    this.tick();
                  }
                };

                _proto.onError = function onError(data) {
                  var frag = data.frag; // don't handle frag error not related to audio fragment

                  if (frag && frag.type !== 'audio') {
                    return;
                  }

                  switch (data.details) {
                    case __WEBPACK_IMPORTED_MODULE_7__errors__['a' /* ErrorDetails */].FRAG_LOAD_ERROR:
                    case __WEBPACK_IMPORTED_MODULE_7__errors__['a' /* ErrorDetails */].FRAG_LOAD_TIMEOUT:
                      var _frag = data.frag; // don't handle frag error not related to audio fragment

                      if (_frag && _frag.type !== 'audio') {
                        break;
                      }

                      if (!data.fatal) {
                        var loadError = this.fragLoadError;

                        if (loadError) {
                          loadError++;
                        } else {
                          loadError = 1;
                        }

                        var config = this.config;

                        if (loadError <= config.fragLoadingMaxRetry) {
                          this.fragLoadError = loadError; // exponential backoff capped to config.fragLoadingMaxRetryTimeout

                          var delay = Math.min(Math.pow(2, loadError - 1) *
                              config.fragLoadingRetryDelay,
                              config.fragLoadingMaxRetryTimeout);
                          __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].warn(
                              'AudioStreamController: frag loading failed, retry in ' +
                              delay + ' ms');
                          this.retryDate = performance.now() + delay; // retry loading state

                          this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].FRAG_LOADING_WAITING_RETRY;
                        } else {
                          __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].error(
                              'AudioStreamController: ' + data.details +
                              ' reaches max retry, redispatch as fatal ...'); // switch error to fatal

                          data.fatal = true;
                          this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].ERROR;
                        }
                      }

                      break;

                    case __WEBPACK_IMPORTED_MODULE_7__errors__['a' /* ErrorDetails */].AUDIO_TRACK_LOAD_ERROR:
                    case __WEBPACK_IMPORTED_MODULE_7__errors__['a' /* ErrorDetails */].AUDIO_TRACK_LOAD_TIMEOUT:
                    case __WEBPACK_IMPORTED_MODULE_7__errors__['a' /* ErrorDetails */].KEY_LOAD_ERROR:
                    case __WEBPACK_IMPORTED_MODULE_7__errors__['a' /* ErrorDetails */].KEY_LOAD_TIMEOUT:
                      //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
                      if (this.state !==
                          __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].ERROR) {
                        // if fatal error, stop processing, otherwise move to IDLE to retry loading
                        this.state = data.fatal
                            ? __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].ERROR
                            : __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].IDLE;
                        __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].warn(
                            'AudioStreamController: ' + data.details +
                            ' while loading frag, now switching to ' +
                            this.state + ' state ...');
                      }

                      break;

                    case __WEBPACK_IMPORTED_MODULE_7__errors__['a' /* ErrorDetails */].BUFFER_FULL_ERROR:
                      // if in appending state
                      if (data.parent === 'audio' && (this.state ===
                          __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PARSING ||
                          this.state ===
                          __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PARSED)) {
                        var media = this.mediaBuffer,
                            currentTime = this.media.currentTime,
                            mediaBuffered = media &&
                                __WEBPACK_IMPORTED_MODULE_2__utils_buffer_helper__['a' /* BufferHelper */].isBuffered(
                                    media, currentTime) &&
                                __WEBPACK_IMPORTED_MODULE_2__utils_buffer_helper__['a' /* BufferHelper */].isBuffered(
                                    media, currentTime + 0.5); // reduce max buf len if current position is buffered

                        if (mediaBuffered) {
                          var _config = this.config;

                          if (_config.maxMaxBufferLength >=
                              _config.maxBufferLength) {
                            // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
                            _config.maxMaxBufferLength /= 2;
                            __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].warn(
                                'AudioStreamController: reduce max buffer length to ' +
                                _config.maxMaxBufferLength + 's');
                          }

                          this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].IDLE;
                        } else {
                          // current position is not buffered, but browser is still complaining about buffer full error
                          // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
                          // in that case flush the whole audio buffer to recover
                          __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].warn(
                              'AudioStreamController: buffer full error also media.currentTime is not buffered, flush audio buffer');
                          this.fragCurrent = null; // flush everything

                          this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].BUFFER_FLUSHING;
                          this.hls.trigger(
                              __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_FLUSHING,
                              {
                                startOffset: 0,
                                endOffset: Number.POSITIVE_INFINITY,
                                type: 'audio',
                              });
                        }
                      }

                      break;

                    default:
                      break;
                  }
                };

                _proto.onBufferFlushed = function onBufferFlushed() {
                  var _this3 = this;

                  var pendingData = this.pendingData;

                  if (pendingData && pendingData.length) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                        'AudioStreamController: appending pending audio data after buffer flushed');
                    pendingData.forEach(function(appendObj) {
                      _this3.hls.trigger(
                          __WEBPACK_IMPORTED_MODULE_4__events__['a' /* default */].BUFFER_APPENDING,
                          appendObj);
                    });
                    this.appended = true;
                    this.pendingData = [];
                    this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].PARSED;
                  } else {
                    // move to IDLE once flush complete. this should trigger new fragment loading
                    this.state = __WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['a' /* State */].IDLE; // reset reference to frag

                    this.fragPrevious = null;
                    this.tick();
                  }
                };

                _createClass(AudioStreamController, [
                  {
                    key: 'state',
                    set: function set(nextState) {
                      if (this.state !== nextState) {
                        var previousState = this.state;
                        this._state = nextState;
                        __WEBPACK_IMPORTED_MODULE_8__utils_logger__['b' /* logger */].log(
                            'audio stream:' + previousState + '->' + nextState);
                      }
                    },
                    get: function get() {
                      return this._state;
                    },
                  }]);

                return AudioStreamController;
              }(__WEBPACK_IMPORTED_MODULE_12__base_stream_controller__['b' /* default */]);

          /* harmony default export */
          __webpack_exports__['a'] = (AudioStreamController);

          /***/
        }),
        /* 72 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          Object.defineProperty(__webpack_exports__, '__esModule',
              {value: true});
          /* harmony export (immutable) */
          __webpack_exports__['newCue'] = newCue;
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__vttparser__ = __webpack_require__(
              32);

          function newCue(track, startTime, endTime, captionScreen) {
            var row; // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers

            var cue;
            var indenting;
            var indent;
            var text;
            var VTTCue = window.VTTCue || TextTrackCue;

            for (var r = 0; r < captionScreen.rows.length; r++) {
              row = captionScreen.rows[r];
              indenting = true;
              indent = 0;
              text = '';

              if (!row.isEmpty()) {
                for (var c = 0; c < row.chars.length; c++) {
                  if (row.chars[c].uchar.match(/\s/) && indenting) {
                    indent++;
                  } else {
                    text += row.chars[c].uchar;
                    indenting = false;
                  }
                } // To be used for cleaning-up orphaned roll-up captions

                row.cueStartTime = startTime; // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE

                if (startTime === endTime) {
                  endTime += 0.0001;
                }

                cue = new VTTCue(startTime, endTime, Object(
                    __WEBPACK_IMPORTED_MODULE_0__vttparser__['b' /* fixLineBreaks */])(
                    text.trim()));

                if (indent >= 16) {
                  indent--;
                } else {
                  indent++;
                } // VTTCue.line get's flakey when using controls, so let's now include line 13&14
                // also, drop line 1 since it's to close to the top

                if (navigator.userAgent.match(/Firefox\//)) {
                  cue.line = r + 1;
                } else {
                  cue.line = r > 7 ? r - 2 : r + 1;
                }

                cue.align = 'left'; // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break

                cue.position = Math.max(0, Math.min(100, 100 * (indent / 32)));
                track.addCue(cue);
              }
            }
          }

          /***/
        }),
        /* 73 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /**
           * Copyright 2013 vtt.js Contributors
           *
           * Licensed under the Apache License, Version 2.0 (the "License");
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *   http://www.apache.org/licenses/LICENSE-2.0
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an "AS IS" BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           */
          /* harmony default export */
          __webpack_exports__['a'] = ((function() {
            if (typeof window !== 'undefined' && window.VTTCue) {
              return window.VTTCue;
            }

            var autoKeyword = 'auto';
            var directionSetting = {
              '': true,
              lr: true,
              rl: true,
            };
            var alignSetting = {
              start: true,
              middle: true,
              end: true,
              left: true,
              right: true,
            };

            function findDirectionSetting(value) {
              if (typeof value !== 'string') {
                return false;
              }

              var dir = directionSetting[value.toLowerCase()];
              return dir ? value.toLowerCase() : false;
            }

            function findAlignSetting(value) {
              if (typeof value !== 'string') {
                return false;
              }

              var align = alignSetting[value.toLowerCase()];
              return align ? value.toLowerCase() : false;
            }

            function extend(obj) {
              var i = 1;

              for (; i < arguments.length; i++) {
                var cobj = arguments[i];

                for (var p in cobj) {
                  obj[p] = cobj[p];
                }
              }

              return obj;
            }

            function VTTCue(startTime, endTime, text) {
              var cue = this;
              var baseObj = {};
              baseObj.enumerable = true;
              /**
               * Shim implementation specific properties. These properties are not in
               * the spec.
               */
              // Lets us know when the VTTCue's data has changed in such a way that we need
              // to recompute its display state. This lets us compute its display state
              // lazily.

              cue.hasBeenReset = false;
              /**
               * VTTCue and TextTrackCue properties
               * http://dev.w3.org/html5/webvtt/#vttcue-interface
               */

              var _id = '';
              var _pauseOnExit = false;
              var _startTime = startTime;
              var _endTime = endTime;
              var _text = text;
              var _region = null;
              var _vertical = '';
              var _snapToLines = true;
              var _line = 'auto';
              var _lineAlign = 'start';
              var _position = 50;
              var _positionAlign = 'middle';
              var _size = 50;
              var _align = 'middle';
              Object.defineProperty(cue, 'id', extend({}, baseObj, {
                get: function get() {
                  return _id;
                },
                set: function set(value) {
                  _id = '' + value;
                },
              }));
              Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
                get: function get() {
                  return _pauseOnExit;
                },
                set: function set(value) {
                  _pauseOnExit = !!value;
                },
              }));
              Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
                get: function get() {
                  return _startTime;
                },
                set: function set(value) {
                  if (typeof value !== 'number') {
                    throw new TypeError('Start time must be set to a number.');
                  }

                  _startTime = value;
                  this.hasBeenReset = true;
                },
              }));
              Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
                get: function get() {
                  return _endTime;
                },
                set: function set(value) {
                  if (typeof value !== 'number') {
                    throw new TypeError('End time must be set to a number.');
                  }

                  _endTime = value;
                  this.hasBeenReset = true;
                },
              }));
              Object.defineProperty(cue, 'text', extend({}, baseObj, {
                get: function get() {
                  return _text;
                },
                set: function set(value) {
                  _text = '' + value;
                  this.hasBeenReset = true;
                },
              }));
              Object.defineProperty(cue, 'region', extend({}, baseObj, {
                get: function get() {
                  return _region;
                },
                set: function set(value) {
                  _region = value;
                  this.hasBeenReset = true;
                },
              }));
              Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
                get: function get() {
                  return _vertical;
                },
                set: function set(value) {
                  var setting = findDirectionSetting(value); // Have to check for false because the setting an be an empty string.

                  if (setting === false) {
                    throw new SyntaxError(
                        'An invalid or illegal string was specified.');
                  }

                  _vertical = setting;
                  this.hasBeenReset = true;
                },
              }));
              Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
                get: function get() {
                  return _snapToLines;
                },
                set: function set(value) {
                  _snapToLines = !!value;
                  this.hasBeenReset = true;
                },
              }));
              Object.defineProperty(cue, 'line', extend({}, baseObj, {
                get: function get() {
                  return _line;
                },
                set: function set(value) {
                  if (typeof value !== 'number' && value !== autoKeyword) {
                    throw new SyntaxError(
                        'An invalid number or illegal string was specified.');
                  }

                  _line = value;
                  this.hasBeenReset = true;
                },
              }));
              Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
                get: function get() {
                  return _lineAlign;
                },
                set: function set(value) {
                  var setting = findAlignSetting(value);

                  if (!setting) {
                    throw new SyntaxError(
                        'An invalid or illegal string was specified.');
                  }

                  _lineAlign = setting;
                  this.hasBeenReset = true;
                },
              }));
              Object.defineProperty(cue, 'position', extend({}, baseObj, {
                get: function get() {
                  return _position;
                },
                set: function set(value) {
                  if (value < 0 || value > 100) {
                    throw new Error('Position must be between 0 and 100.');
                  }

                  _position = value;
                  this.hasBeenReset = true;
                },
              }));
              Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
                get: function get() {
                  return _positionAlign;
                },
                set: function set(value) {
                  var setting = findAlignSetting(value);

                  if (!setting) {
                    throw new SyntaxError(
                        'An invalid or illegal string was specified.');
                  }

                  _positionAlign = setting;
                  this.hasBeenReset = true;
                },
              }));
              Object.defineProperty(cue, 'size', extend({}, baseObj, {
                get: function get() {
                  return _size;
                },
                set: function set(value) {
                  if (value < 0 || value > 100) {
                    throw new Error('Size must be between 0 and 100.');
                  }

                  _size = value;
                  this.hasBeenReset = true;
                },
              }));
              Object.defineProperty(cue, 'align', extend({}, baseObj, {
                get: function get() {
                  return _align;
                },
                set: function set(value) {
                  var setting = findAlignSetting(value);

                  if (!setting) {
                    throw new SyntaxError(
                        'An invalid or illegal string was specified.');
                  }

                  _align = setting;
                  this.hasBeenReset = true;
                },
              }));
              /**
               * Other <track> spec defined properties
               */
              // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state

              cue.displayState = void 0;
            }

            /**
             * VTTCue methods
             */

            VTTCue.prototype.getCueAsHTML = function() {
              // Assume WebVTT.convertCueToDOMTree is on the global.
              var WebVTT = window.WebVTT;
              return WebVTT.convertCueToDOMTree(window, this.text);
            };

            return VTTCue;
          })());

          /***/
        }),
        /* 74 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__event_handler__ = __webpack_require__(
              4);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__utils_cea_608_parser__ = __webpack_require__(
              75);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__utils_output_filter__ = __webpack_require__(
              76);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__utils_webvtt_parser__ = __webpack_require__(
              77);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_6__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_7__utils_texttrack_utils__ = __webpack_require__(
              18);

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError(
                  'this hasn\'t been initialised - super() hasn\'t been called');
            }
            return self;
          }

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

// TS todo: Reduce usage of any
          var TimelineController =
              /*#__PURE__*/
              function(_EventHandler) {
                _inheritsLoose(TimelineController, _EventHandler);

                function TimelineController(hls) {
                  var _this;

                  _this = _EventHandler.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MEDIA_ATTACHING,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MEDIA_DETACHING,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_PARSING_USERDATA,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_DECRYPTED,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MANIFEST_LOADING,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MANIFEST_LOADED,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].FRAG_LOADED,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].INIT_PTS_FOUND) ||
                      this;
                  _this.media = null;
                  _this.config = void 0;
                  _this.enabled = true;
                  _this.Cues = void 0;
                  _this.textTracks = [];
                  _this.tracks = [];
                  _this.initPTS = [];
                  _this.unparsedVttFrags = [];
                  _this.cueRanges = [];
                  _this.captionsTracks = {};
                  _this.captionsProperties = void 0;
                  _this.cea608Parser = void 0;
                  _this.lastSn = -1;
                  _this.prevCC = -1;
                  _this.vttCCs = null;
                  _this.hls = hls;
                  _this.config = hls.config;
                  _this.Cues = hls.config.cueHandler;
                  _this.captionsProperties = {
                    textTrack1: {
                      label: _this.config.captionsTextTrack1Label,
                      languageCode: _this.config.captionsTextTrack1LanguageCode,
                    },
                    textTrack2: {
                      label: _this.config.captionsTextTrack2Label,
                      languageCode: _this.config.captionsTextTrack2LanguageCode,
                    },
                  };

                  if (_this.config.enableCEA708Captions) {
                    var channel1 = new __WEBPACK_IMPORTED_MODULE_4__utils_output_filter__['a' /* default */](
                        _assertThisInitialized(_this), 'textTrack1');
                    var channel2 = new __WEBPACK_IMPORTED_MODULE_4__utils_output_filter__['a' /* default */](
                        _assertThisInitialized(_this), 'textTrack2');
                    _this.cea608Parser = new __WEBPACK_IMPORTED_MODULE_3__utils_cea_608_parser__['a' /* default */](
                        0, channel1, channel2);
                  }

                  return _this;
                }

                var _proto = TimelineController.prototype;

                _proto.addCues = function addCues(
                    trackName, startTime, endTime, screen) {
                  // skip cues which overlap more than 50% with previously parsed time ranges
                  var ranges = this.cueRanges;
                  var merged = false;

                  for (var i = ranges.length; i--;) {
                    var cueRange = ranges[i];
                    var overlap = intersection(cueRange[0], cueRange[1],
                        startTime, endTime);

                    if (overlap >= 0) {
                      cueRange[0] = Math.min(cueRange[0], startTime);
                      cueRange[1] = Math.max(cueRange[1], endTime);
                      merged = true;

                      if (overlap / (endTime - startTime) > 0.5) {
                        return;
                      }
                    }
                  }

                  if (!merged) {
                    ranges.push([startTime, endTime]);
                  }

                  this.Cues.newCue(this.captionsTracks[trackName], startTime,
                      endTime, screen);
                } // Triggered when an initial PTS is found; used for synchronisation of WebVTT.
                ;

                _proto.onInitPtsFound = function onInitPtsFound(data) {
                  var _this2 = this;

                  var frag = data.frag,
                      id = data.id,
                      initPTS = data.initPTS;
                  var unparsedVttFrags = this.unparsedVttFrags;

                  if (id === 'main') {
                    this.initPTS[frag.cc] = initPTS;
                  } // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.
                  // Parse any unparsed fragments upon receiving the initial PTS.

                  if (unparsedVttFrags.length) {
                    this.unparsedVttFrags = [];
                    unparsedVttFrags.forEach(function(frag) {
                      _this2.onFragLoaded(frag);
                    });
                  }
                };

                _proto.getExistingTrack = function getExistingTrack(trackName) {
                  var media = this.media;

                  if (media) {
                    for (var i = 0; i < media.textTracks.length; i++) {
                      var textTrack = media.textTracks[i];

                      if (textTrack[trackName]) {
                        return textTrack;
                      }
                    }
                  }

                  return null;
                };

                _proto.createCaptionsTrack = function createCaptionsTrack(trackName) {
                  var captionsProperties = this.captionsProperties,
                      captionsTracks = this.captionsTracks,
                      media = this.media;
                  var _captionsProperties$t = captionsProperties[trackName],
                      label = _captionsProperties$t.label,
                      languageCode = _captionsProperties$t.languageCode;

                  if (!captionsTracks[trackName]) {
                    // Enable reuse of existing text track.
                    var existingTrack = this.getExistingTrack(trackName);

                    if (!existingTrack) {
                      var textTrack = this.createTextTrack('captions', label,
                          languageCode);

                      if (textTrack) {
                        // Set a special property on the track so we know it's managed by Hls.js
                        textTrack[trackName] = true;
                        captionsTracks[trackName] = textTrack;
                      }
                    } else {
                      captionsTracks[trackName] = existingTrack;
                      Object(
                          __WEBPACK_IMPORTED_MODULE_7__utils_texttrack_utils__['a' /* clearCurrentCues */])(
                          captionsTracks[trackName]);
                      Object(
                          __WEBPACK_IMPORTED_MODULE_7__utils_texttrack_utils__['c' /* sendAddTrackEvent */])(
                          captionsTracks[trackName], media);
                    }
                  }
                };

                _proto.createTextTrack = function createTextTrack(
                    kind, label, lang) {
                  var media = this.media;

                  if (!media) {
                    return;
                  }

                  return media.addTextTrack(kind, label, lang);
                };

                _proto.destroy = function destroy() {
                  _EventHandler.prototype.destroy.call(this);
                };

                _proto.onMediaAttaching = function onMediaAttaching(data) {
                  this.media = data.media;

                  this._cleanTracks();
                };

                _proto.onMediaDetaching = function onMediaDetaching() {
                  var captionsTracks = this.captionsTracks;
                  Object.keys(captionsTracks).forEach(function(trackName) {
                    Object(
                        __WEBPACK_IMPORTED_MODULE_7__utils_texttrack_utils__['a' /* clearCurrentCues */])(
                        captionsTracks[trackName]);
                    delete captionsTracks[trackName];
                  });
                };

                _proto.onManifestLoading = function onManifestLoading() {
                  this.lastSn = -1; // Detect discontiguity in fragment parsing

                  this.prevCC = -1;
                  this.vttCCs = {
                    // Detect discontinuity in subtitle manifests
                    ccOffset: 0,
                    presentationOffset: 0,
                    0: {
                      start: 0,
                      prevCC: -1,
                      new: false,
                    },
                  };

                  this._cleanTracks();
                };

                _proto._cleanTracks = function _cleanTracks() {
                  // clear outdated subtitles
                  var media = this.media;

                  if (!media) {
                    return;
                  }

                  var textTracks = media.textTracks;

                  if (textTracks) {
                    for (var i = 0; i < textTracks.length; i++) {
                      Object(
                          __WEBPACK_IMPORTED_MODULE_7__utils_texttrack_utils__['a' /* clearCurrentCues */])(
                          textTracks[i]);
                    }
                  }
                };

                _proto.onManifestLoaded = function onManifestLoaded(data) {
                  var _this3 = this;

                  this.textTracks = [];
                  this.unparsedVttFrags = this.unparsedVttFrags || [];
                  this.initPTS = [];
                  this.cueRanges = [];

                  if (this.config.enableWebVTT) {
                    this.tracks = data.subtitles || [];
                    var inUseTracks = this.media ? this.media.textTracks : [];
                    this.tracks.forEach(function(track, index) {
                      var textTrack;

                      if (index < inUseTracks.length) {
                        var inUseTrack = null;

                        for (var i = 0; i < inUseTracks.length; i++) {
                          if (canReuseVttTextTrack(inUseTracks[i], track)) {
                            inUseTrack = inUseTracks[i];
                            break;
                          }
                        } // Reuse tracks with the same label, but do not reuse 608/708 tracks

                        if (inUseTrack) {
                          textTrack = inUseTrack;
                        }
                      }

                      if (!textTrack) {
                        textTrack = _this3.createTextTrack('subtitles',
                            track.name, track.lang);
                      }

                      if (track.default) {
                        textTrack.mode = _this3.hls.subtitleDisplay
                            ? 'showing'
                            : 'hidden';
                      } else {
                        textTrack.mode = 'disabled';
                      }

                      _this3.textTracks.push(textTrack);
                    });
                  }
                };

                _proto.onFragLoaded = function onFragLoaded(data) {
                  var frag = data.frag,
                      payload = data.payload;
                  var cea608Parser = this.cea608Parser,
                      initPTS = this.initPTS,
                      lastSn = this.lastSn,
                      unparsedVttFrags = this.unparsedVttFrags;

                  if (frag.type === 'main') {
                    var sn = frag.sn; // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack

                    if (frag.sn !== lastSn + 1) {
                      if (cea608Parser) {
                        cea608Parser.reset();
                      }
                    }

                    this.lastSn = sn;
                  } // eslint-disable-line brace-style
                  // If fragment is subtitle type, parse as WebVTT.
                  else if (frag.type === 'subtitle') {
                    if (payload.byteLength) {
                      // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
                      if (!Object(
                          __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                          initPTS[frag.cc])) {
                        unparsedVttFrags.push(data);

                        if (initPTS.length) {
                          // finish unsuccessfully, otherwise the subtitle-stream-controller could be blocked from loading new frags.
                          this.hls.trigger(
                              __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].SUBTITLE_FRAG_PROCESSED,
                              {
                                success: false,
                                frag: frag,
                              });
                        }

                        return;
                      }

                      var decryptData = frag.decryptdata; // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.

                      if (decryptData == null || decryptData.key == null ||
                          decryptData.method !== 'AES-128') {
                        this._parseVTTs(frag, payload);
                      }
                    } else {
                      // In case there is no payload, finish unsuccessfully.
                      this.hls.trigger(
                          __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].SUBTITLE_FRAG_PROCESSED,
                          {
                            success: false,
                            frag: frag,
                          });
                    }
                  }
                };

                _proto._parseVTTs = function _parseVTTs(frag, payload) {
                  var hls = this.hls,
                      prevCC = this.prevCC,
                      textTracks = this.textTracks,
                      vttCCs = this.vttCCs;

                  if (!vttCCs[frag.cc]) {
                    vttCCs[frag.cc] = {
                      start: frag.start,
                      prevCC: prevCC,
                      new: true,
                    };
                    this.prevCC = frag.cc;
                  } // Parse the WebVTT file contents.

                  __WEBPACK_IMPORTED_MODULE_5__utils_webvtt_parser__['a' /* default */].parse(
                      payload, this.initPTS[frag.cc], vttCCs, frag.cc,
                      function(cues) {
                        var currentTrack = textTracks[frag.level]; // WebVTTParser.parse is an async method and if the currently selected text track mode is set to "disabled"
                        // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null
                        // and trying to access getCueById method of cues will throw an exception

                        if (currentTrack.mode === 'disabled') {
                          hls.trigger(
                              __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].SUBTITLE_FRAG_PROCESSED,
                              {
                                success: false,
                                frag: frag,
                              });
                          return;
                        } // Add cues and trigger event with success true.

                        cues.forEach(function(cue) {
                          // Sometimes there are cue overlaps on segmented vtts so the same
                          // cue can appear more than once in different vtt files.
                          // This avoid showing duplicated cues with same timecode and text.
                          if (!currentTrack.cues.getCueById(cue.id)) {
                            try {
                              currentTrack.addCue(cue);

                              if (!currentTrack.cues.getCueById(cue.id)) {
                                throw new Error('addCue is failed for: ' + cue);
                              }
                            } catch (err) {
                              __WEBPACK_IMPORTED_MODULE_6__utils_logger__['b' /* logger */].debug(
                                  'Failed occurred on adding cues: ' + err);
                              var textTrackCue = new window.TextTrackCue(
                                  cue.startTime, cue.endTime, cue.text);
                              textTrackCue.id = cue.id;
                              currentTrack.addCue(textTrackCue);
                            }
                          }
                        });
                        hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].SUBTITLE_FRAG_PROCESSED,
                            {
                              success: true,
                              frag: frag,
                            });
                      }, function(e) {
                        // Something went wrong while parsing. Trigger event with success false.
                        __WEBPACK_IMPORTED_MODULE_6__utils_logger__['b' /* logger */].log(
                            'Failed to parse VTT cue: ' + e);
                        hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].SUBTITLE_FRAG_PROCESSED,
                            {
                              success: false,
                              frag: frag,
                            });
                      });
                };

                _proto.onFragDecrypted = function onFragDecrypted(data) {
                  var frag = data.frag,
                      payload = data.payload;

                  if (frag.type === 'subtitle') {
                    if (!Object(
                        __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                        this.initPTS[frag.cc])) {
                      this.unparsedVttFrags.push(data);
                      return;
                    }

                    this._parseVTTs(frag, payload);
                  }
                };

                _proto.onFragParsingUserdata = function onFragParsingUserdata(data) {
                  if (!this.enabled || !this.cea608Parser) {
                    return;
                  } // If the event contains captions (found in the bytes property), push all bytes into the parser immediately
                  // It will create the proper timestamps based on the PTS value

                  for (var i = 0; i < data.samples.length; i++) {
                    var ccBytes = data.samples[i].bytes;

                    if (ccBytes) {
                      var ccdatas = this.extractCea608Data(ccBytes);
                      this.cea608Parser.addData(data.samples[i].pts, ccdatas);
                    }
                  }
                };

                _proto.extractCea608Data = function extractCea608Data(byteArray) {
                  var count = byteArray[0] & 31;
                  var position = 2;
                  var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;
                  var actualCCBytes = [];

                  for (var j = 0; j < count; j++) {
                    tmpByte = byteArray[position++];
                    ccbyte1 = 0x7F & byteArray[position++];
                    ccbyte2 = 0x7F & byteArray[position++];
                    ccValid = (4 & tmpByte) !== 0;
                    ccType = 3 & tmpByte;

                    if (ccbyte1 === 0 && ccbyte2 === 0) {
                      continue;
                    }

                    if (ccValid) {
                      if (ccType === 0) {
                        // || ccType === 1
                        actualCCBytes.push(ccbyte1);
                        actualCCBytes.push(ccbyte2);
                      }
                    }
                  }

                  return actualCCBytes;
                };

                return TimelineController;
              }(__WEBPACK_IMPORTED_MODULE_2__event_handler__['a' /* default */]);

          function canReuseVttTextTrack(inUseTrack, manifestTrack) {
            return inUseTrack && inUseTrack.label === manifestTrack.name &&
                !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
          }

          function intersection(x1, x2, y1, y2) {
            return Math.min(x2, y2) - Math.max(x1, y1);
          }

          /* harmony default export */
          __webpack_exports__['a'] = (TimelineController);

          /***/
        }),
        /* 75 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* unused harmony export Row */
          /* unused harmony export CaptionScreen */
          /**
           *
           * This code was ported from the dash.js project at:
           *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
           *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
           *
           * The original copyright appears below:
           *
           * The copyright in this software is being made available under the BSD License,
           * included below. This software may be subject to other third party and contributor
           * rights, including patent rights, and no such rights are granted under this license.
           *
           * Copyright (c) 2015-2016, DASH Industry Forum.
           * All rights reserved.
           *
           * Redistribution and use in source and binary forms, with or without modification,
           * are permitted provided that the following conditions are met:
           *  1. Redistributions of source code must retain the above copyright notice, this
           *  list of conditions and the following disclaimer.
           *  * Redistributions in binary form must reproduce the above copyright notice,
           *  this list of conditions and the following disclaimer in the documentation and/or
           *  other materials provided with the distribution.
           *  2. Neither the name of Dash Industry Forum nor the names of its
           *  contributors may be used to endorse or promote products derived from this software
           *  without specific prior written permission.
           *
           *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
           *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
           *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
           *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
           *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
           *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
           *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
           *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
           *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
           *  POSSIBILITY OF SUCH DAMAGE.
           */

          /**
           *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
           */
          var specialCea608CharsCodes = {
            0x2a: 0xe1,
            // lowercase a, acute accent
            0x5c: 0xe9,
            // lowercase e, acute accent
            0x5e: 0xed,
            // lowercase i, acute accent
            0x5f: 0xf3,
            // lowercase o, acute accent
            0x60: 0xfa,
            // lowercase u, acute accent
            0x7b: 0xe7,
            // lowercase c with cedilla
            0x7c: 0xf7,
            // division symbol
            0x7d: 0xd1,
            // uppercase N tilde
            0x7e: 0xf1,
            // lowercase n tilde
            0x7f: 0x2588,
            // Full block
            // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
            // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
            0x80: 0xae,
            // Registered symbol (R)
            0x81: 0xb0,
            // degree sign
            0x82: 0xbd,
            // 1/2 symbol
            0x83: 0xbf,
            // Inverted (open) question mark
            0x84: 0x2122,
            // Trademark symbol (TM)
            0x85: 0xa2,
            // Cents symbol
            0x86: 0xa3,
            // Pounds sterling
            0x87: 0x266a,
            // Music 8'th note
            0x88: 0xe0,
            // lowercase a, grave accent
            0x89: 0x20,
            // transparent space (regular)
            0x8a: 0xe8,
            // lowercase e, grave accent
            0x8b: 0xe2,
            // lowercase a, circumflex accent
            0x8c: 0xea,
            // lowercase e, circumflex accent
            0x8d: 0xee,
            // lowercase i, circumflex accent
            0x8e: 0xf4,
            // lowercase o, circumflex accent
            0x8f: 0xfb,
            // lowercase u, circumflex accent
            // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
            0x90: 0xc1,
            // capital letter A with acute
            0x91: 0xc9,
            // capital letter E with acute
            0x92: 0xd3,
            // capital letter O with acute
            0x93: 0xda,
            // capital letter U with acute
            0x94: 0xdc,
            // capital letter U with diaresis
            0x95: 0xfc,
            // lowercase letter U with diaeresis
            0x96: 0x2018,
            // opening single quote
            0x97: 0xa1,
            // inverted exclamation mark
            0x98: 0x2a,
            // asterisk
            0x99: 0x2019,
            // closing single quote
            0x9a: 0x2501,
            // box drawings heavy horizontal
            0x9b: 0xa9,
            // copyright sign
            0x9c: 0x2120,
            // Service mark
            0x9d: 0x2022,
            // (round) bullet
            0x9e: 0x201c,
            // Left double quotation mark
            0x9f: 0x201d,
            // Right double quotation mark
            0xa0: 0xc0,
            // uppercase A, grave accent
            0xa1: 0xc2,
            // uppercase A, circumflex
            0xa2: 0xc7,
            // uppercase C with cedilla
            0xa3: 0xc8,
            // uppercase E, grave accent
            0xa4: 0xca,
            // uppercase E, circumflex
            0xa5: 0xcb,
            // capital letter E with diaresis
            0xa6: 0xeb,
            // lowercase letter e with diaresis
            0xa7: 0xce,
            // uppercase I, circumflex
            0xa8: 0xcf,
            // uppercase I, with diaresis
            0xa9: 0xef,
            // lowercase i, with diaresis
            0xaa: 0xd4,
            // uppercase O, circumflex
            0xab: 0xd9,
            // uppercase U, grave accent
            0xac: 0xf9,
            // lowercase u, grave accent
            0xad: 0xdb,
            // uppercase U, circumflex
            0xae: 0xab,
            // left-pointing double angle quotation mark
            0xaf: 0xbb,
            // right-pointing double angle quotation mark
            // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
            0xb0: 0xc3,
            // Uppercase A, tilde
            0xb1: 0xe3,
            // Lowercase a, tilde
            0xb2: 0xcd,
            // Uppercase I, acute accent
            0xb3: 0xcc,
            // Uppercase I, grave accent
            0xb4: 0xec,
            // Lowercase i, grave accent
            0xb5: 0xd2,
            // Uppercase O, grave accent
            0xb6: 0xf2,
            // Lowercase o, grave accent
            0xb7: 0xd5,
            // Uppercase O, tilde
            0xb8: 0xf5,
            // Lowercase o, tilde
            0xb9: 0x7b,
            // Open curly brace
            0xba: 0x7d,
            // Closing curly brace
            0xbb: 0x5c,
            // Backslash
            0xbc: 0x5e,
            // Caret
            0xbd: 0x5f,
            // Underscore
            0xbe: 0x7c,
            // Pipe (vertical line)
            0xbf: 0x223c,
            // Tilde operator
            0xc0: 0xc4,
            // Uppercase A, umlaut
            0xc1: 0xe4,
            // Lowercase A, umlaut
            0xc2: 0xd6,
            // Uppercase O, umlaut
            0xc3: 0xf6,
            // Lowercase o, umlaut
            0xc4: 0xdf,
            // Esszett (sharp S)
            0xc5: 0xa5,
            // Yen symbol
            0xc6: 0xa4,
            // Generic currency sign
            0xc7: 0x2503,
            // Box drawings heavy vertical
            0xc8: 0xc5,
            // Uppercase A, ring
            0xc9: 0xe5,
            // Lowercase A, ring
            0xca: 0xd8,
            // Uppercase O, stroke
            0xcb: 0xf8,
            // Lowercase o, strok
            0xcc: 0x250f,
            // Box drawings heavy down and right
            0xcd: 0x2513,
            // Box drawings heavy down and left
            0xce: 0x2517,
            // Box drawings heavy up and right
            0xcf: 0x251b, // Box drawings heavy up and left

          };
          /**
           * Utils
           */

          var getCharForByte = function getCharForByte(_byte) {
            var charCode = _byte;

            if (specialCea608CharsCodes.hasOwnProperty(_byte)) {
              charCode = specialCea608CharsCodes[_byte];
            }

            return String.fromCharCode(charCode);
          };

          var NR_ROWS = 15,
              NR_COLS = 100; // Tables to look up row from PAC data

          var rowsLowCh1 = {
            0x11: 1,
            0x12: 3,
            0x15: 5,
            0x16: 7,
            0x17: 9,
            0x10: 11,
            0x13: 12,
            0x14: 14,
          };
          var rowsHighCh1 = {
            0x11: 2,
            0x12: 4,
            0x15: 6,
            0x16: 8,
            0x17: 10,
            0x13: 13,
            0x14: 15,
          };
          var rowsLowCh2 = {
            0x19: 1,
            0x1A: 3,
            0x1D: 5,
            0x1E: 7,
            0x1F: 9,
            0x18: 11,
            0x1B: 12,
            0x1C: 14,
          };
          var rowsHighCh2 = {
            0x19: 2,
            0x1A: 4,
            0x1D: 6,
            0x1E: 8,
            0x1F: 10,
            0x1B: 13,
            0x1C: 15,
          };
          var backgroundColors = [
            'white',
            'green',
            'blue',
            'cyan',
            'red',
            'yellow',
            'magenta',
            'black',
            'transparent'];
          var VerboseFilter;
          /**
           * Simple logger class to be able to write with time-stamps and filter on level.
           */

          (function(VerboseFilter) {
            VerboseFilter[VerboseFilter['ERROR'] = 0] = 'ERROR';
            VerboseFilter[VerboseFilter['TEXT'] = 1] = 'TEXT';
            VerboseFilter[VerboseFilter['WARNING'] = 2] = 'WARNING';
            VerboseFilter[VerboseFilter['INFO'] = 2] = 'INFO';
            VerboseFilter[VerboseFilter['DEBUG'] = 3] = 'DEBUG';
            VerboseFilter[VerboseFilter['DATA'] = 3] = 'DATA';
          })(VerboseFilter || (VerboseFilter = {}));

          var logger = {
            verboseFilter: {
              'DATA': 3,
              'DEBUG': 3,
              'INFO': 2,
              'WARNING': 2,
              'TEXT': 1,
              'ERROR': 0,
            },
            time: null,
            verboseLevel: 0,
            // Only write errors
            setTime: function setTime(newTime) {
              this.time = newTime;
            },
            log: function log(severity, msg) {
              var minLevel = this.verboseFilter[severity];

              if (this.verboseLevel >= minLevel) {// console.log(this.time + ' [' + severity + '] ' + msg);
              }
            },
          };

          var numArrayToHexArray = function numArrayToHexArray(numArray) {
            var hexArray = [];

            for (var j = 0; j < numArray.length; j++) {
              hexArray.push(numArray[j].toString(16));
            }

            return hexArray;
          };

          var PenState =
              /*#__PURE__*/
              function() {
                function PenState(
                    foreground, underline, italics, background, flash) {
                  this.foreground = void 0;
                  this.underline = void 0;
                  this.italics = void 0;
                  this.background = void 0;
                  this.flash = void 0;
                  this.foreground = foreground || 'white';
                  this.underline = underline || false;
                  this.italics = italics || false;
                  this.background = background || 'black';
                  this.flash = flash || false;
                }

                var _proto = PenState.prototype;

                _proto.reset = function reset() {
                  this.foreground = 'white';
                  this.underline = false;
                  this.italics = false;
                  this.background = 'black';
                  this.flash = false;
                };

                _proto.setStyles = function setStyles(styles) {
                  var attribs = [
                    'foreground',
                    'underline',
                    'italics',
                    'background',
                    'flash'];

                  for (var i = 0; i < attribs.length; i++) {
                    var style = attribs[i];

                    if (styles.hasOwnProperty(style)) {
                      this[style] = styles[style];
                    }
                  }
                };

                _proto.isDefault = function isDefault() {
                  return this.foreground === 'white' && !this.underline &&
                      !this.italics && this.background === 'black' &&
                      !this.flash;
                };

                _proto.equals = function equals(other) {
                  return this.foreground === other.foreground &&
                      this.underline === other.underline && this.italics ===
                      other.italics && this.background === other.background &&
                      this.flash === other.flash;
                };

                _proto.copy = function copy(newPenState) {
                  this.foreground = newPenState.foreground;
                  this.underline = newPenState.underline;
                  this.italics = newPenState.italics;
                  this.background = newPenState.background;
                  this.flash = newPenState.flash;
                };

                _proto.toString = function toString() {
                  return 'color=' + this.foreground + ', underline=' +
                      this.underline + ', italics=' + this.italics +
                      ', background=' + this.background + ', flash=' +
                      this.flash;
                };

                return PenState;
              }();
          /**
           * Unicode character with styling and background.
           * @constructor
           */


          var StyledUnicodeChar =
              /*#__PURE__*/
              function() {
                function StyledUnicodeChar(
                    uchar, foreground, underline, italics, background, flash) {
                  this.uchar = void 0;
                  this.penState = void 0;
                  this.uchar = uchar || ' '; // unicode character

                  this.penState = new PenState(foreground, underline, italics,
                      background, flash);
                }

                var _proto2 = StyledUnicodeChar.prototype;

                _proto2.reset = function reset() {
                  this.uchar = ' ';
                  this.penState.reset();
                };

                _proto2.setChar = function setChar(uchar, newPenState) {
                  this.uchar = uchar;
                  this.penState.copy(newPenState);
                };

                _proto2.setPenState = function setPenState(newPenState) {
                  this.penState.copy(newPenState);
                };

                _proto2.equals = function equals(other) {
                  return this.uchar === other.uchar &&
                      this.penState.equals(other.penState);
                };

                _proto2.copy = function copy(newChar) {
                  this.uchar = newChar.uchar;
                  this.penState.copy(newChar.penState);
                };

                _proto2.isEmpty = function isEmpty() {
                  return this.uchar === ' ' && this.penState.isDefault();
                };

                return StyledUnicodeChar;
              }();
          /**
           * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
           * @constructor
           */


          var Row =
              /*#__PURE__*/
              function() {
                function Row() {
                  this.chars = void 0;
                  this.pos = void 0;
                  this.currPenState = void 0;
                  this.cueStartTime = void 0;
                  this.chars = [];

                  for (var i = 0; i < NR_COLS; i++) {
                    this.chars.push(new StyledUnicodeChar());
                  }

                  this.pos = 0;
                  this.currPenState = new PenState();
                }

                var _proto3 = Row.prototype;

                _proto3.equals = function equals(other) {
                  var equal = true;

                  for (var i = 0; i < NR_COLS; i++) {
                    if (!this.chars[i].equals(other.chars[i])) {
                      equal = false;
                      break;
                    }
                  }

                  return equal;
                };

                _proto3.copy = function copy(other) {
                  for (var i = 0; i < NR_COLS; i++) {
                    this.chars[i].copy(other.chars[i]);
                  }
                };

                _proto3.isEmpty = function isEmpty() {
                  var empty = true;

                  for (var i = 0; i < NR_COLS; i++) {
                    if (!this.chars[i].isEmpty()) {
                      empty = false;
                      break;
                    }
                  }

                  return empty;
                }
                /**
                 *  Set the cursor to a valid column.
                 */
                ;

                _proto3.setCursor = function setCursor(absPos) {
                  if (this.pos !== absPos) {
                    this.pos = absPos;
                  }

                  if (this.pos < 0) {
                    logger.log('ERROR', 'Negative cursor position ' + this.pos);
                    this.pos = 0;
                  } else if (this.pos > NR_COLS) {
                    logger.log('ERROR',
                        'Too large cursor position ' + this.pos);
                    this.pos = NR_COLS;
                  }
                }
                /**
                 * Move the cursor relative to current position.
                 */
                ;

                _proto3.moveCursor = function moveCursor(relPos) {
                  var newPos = this.pos + relPos;

                  if (relPos > 1) {
                    for (var i = this.pos + 1; i < newPos + 1; i++) {
                      this.chars[i].setPenState(this.currPenState);
                    }
                  }

                  this.setCursor(newPos);
                }
                /**
                 * Backspace, move one step back and clear character.
                 */
                ;

                _proto3.backSpace = function backSpace() {
                  this.moveCursor(-1);
                  this.chars[this.pos].setChar(' ', this.currPenState);
                };

                _proto3.insertChar = function insertChar(_byte2) {
                  if (_byte2 >= 0x90) {
                    // Extended char
                    this.backSpace();
                  }

                  var _char = getCharForByte(_byte2);

                  if (this.pos >= NR_COLS) {
                    logger.log('ERROR',
                        'Cannot insert ' + _byte2.toString(16) + ' (' + _char +
                        ') at position ' + this.pos + '. Skipping it!');
                    return;
                  }

                  this.chars[this.pos].setChar(_char, this.currPenState);
                  this.moveCursor(1);
                };

                _proto3.clearFromPos = function clearFromPos(startPos) {
                  var i;

                  for (i = startPos; i < NR_COLS; i++) {
                    this.chars[i].reset();
                  }
                };

                _proto3.clear = function clear() {
                  this.clearFromPos(0);
                  this.pos = 0;
                  this.currPenState.reset();
                };

                _proto3.clearToEndOfRow = function clearToEndOfRow() {
                  this.clearFromPos(this.pos);
                };

                _proto3.getTextString = function getTextString() {
                  var chars = [];
                  var empty = true;

                  for (var i = 0; i < NR_COLS; i++) {
                    var _char2 = this.chars[i].uchar;

                    if (_char2 !== ' ') {
                      empty = false;
                    }

                    chars.push(_char2);
                  }

                  if (empty) {
                    return '';
                  } else {
                    return chars.join('');
                  }
                };

                _proto3.setPenStyles = function setPenStyles(styles) {
                  this.currPenState.setStyles(styles);
                  var currChar = this.chars[this.pos];
                  currChar.setPenState(this.currPenState);
                };

                return Row;
              }();
          /**
           * Keep a CEA-608 screen of 32x15 styled characters
           * @constructor
           */

          var CaptionScreen =
              /*#__PURE__*/
              function() {
                function CaptionScreen() {
                  this.rows = void 0;
                  this.currRow = void 0;
                  this.nrRollUpRows = void 0;
                  this.lastOutputScreen = void 0;
                  this.rows = [];

                  for (var i = 0; i < NR_ROWS; i++) {
                    this.rows.push(new Row());
                  } // Note that we use zero-based numbering (0-14)

                  this.currRow = NR_ROWS - 1;
                  this.nrRollUpRows = null;
                  this.reset();
                }

                var _proto4 = CaptionScreen.prototype;

                _proto4.reset = function reset() {
                  for (var i = 0; i < NR_ROWS; i++) {
                    this.rows[i].clear();
                  }

                  this.currRow = NR_ROWS - 1;
                };

                _proto4.equals = function equals(other) {
                  var equal = true;

                  for (var i = 0; i < NR_ROWS; i++) {
                    if (!this.rows[i].equals(other.rows[i])) {
                      equal = false;
                      break;
                    }
                  }

                  return equal;
                };

                _proto4.copy = function copy(other) {
                  for (var i = 0; i < NR_ROWS; i++) {
                    this.rows[i].copy(other.rows[i]);
                  }
                };

                _proto4.isEmpty = function isEmpty() {
                  var empty = true;

                  for (var i = 0; i < NR_ROWS; i++) {
                    if (!this.rows[i].isEmpty()) {
                      empty = false;
                      break;
                    }
                  }

                  return empty;
                };

                _proto4.backSpace = function backSpace() {
                  var row = this.rows[this.currRow];
                  row.backSpace();
                };

                _proto4.clearToEndOfRow = function clearToEndOfRow() {
                  var row = this.rows[this.currRow];
                  row.clearToEndOfRow();
                }
                /**
                 * Insert a character (without styling) in the current row.
                 */
                ;

                _proto4.insertChar = function insertChar(_char3) {
                  var row = this.rows[this.currRow];
                  row.insertChar(_char3);
                };

                _proto4.setPen = function setPen(styles) {
                  var row = this.rows[this.currRow];
                  row.setPenStyles(styles);
                };

                _proto4.moveCursor = function moveCursor(relPos) {
                  var row = this.rows[this.currRow];
                  row.moveCursor(relPos);
                };

                _proto4.setCursor = function setCursor(absPos) {
                  logger.log('INFO', 'setCursor: ' + absPos);
                  var row = this.rows[this.currRow];
                  row.setCursor(absPos);
                };

                _proto4.setPAC = function setPAC(pacData) {
                  logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
                  var newRow = pacData.row - 1;

                  if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
                    newRow = this.nrRollUpRows - 1;
                  } // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows

                  if (this.nrRollUpRows && this.currRow !== newRow) {
                    // clear all rows first
                    for (var i = 0; i < NR_ROWS; i++) {
                      this.rows[i].clear();
                    } // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
                    // topRowIndex - the start of rows to copy (inclusive index)

                    var topRowIndex = this.currRow + 1 - this.nrRollUpRows; // We only copy if the last position was already shown.
                    // We use the cueStartTime value to check this.

                    var lastOutputScreen = this.lastOutputScreen;

                    if (lastOutputScreen) {
                      var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;

                      if (prevLineTime && logger.time && prevLineTime <
                          logger.time) {
                        for (var _i = 0; _i < this.nrRollUpRows; _i++) {
                          this.rows[newRow - this.nrRollUpRows + _i + 1].copy(
                              lastOutputScreen.rows[topRowIndex + _i]);
                        }
                      }
                    }
                  }

                  this.currRow = newRow;
                  var row = this.rows[this.currRow];

                  if (pacData.indent !== null) {
                    var indent = pacData.indent;
                    var prevPos = Math.max(indent - 1, 0);
                    row.setCursor(pacData.indent);
                    pacData.color = row.chars[prevPos].penState.foreground;
                  }

                  var styles = {
                    foreground: pacData.color,
                    underline: pacData.underline,
                    italics: pacData.italics,
                    background: 'black',
                    flash: false,
                  };
                  this.setPen(styles);
                }
                /**
                 * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
                 */
                ;

                _proto4.setBkgData = function setBkgData(bkgData) {
                  logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
                  this.backSpace();
                  this.setPen(bkgData);
                  this.insertChar(0x20); // Space
                };

                _proto4.setRollUpRows = function setRollUpRows(nrRows) {
                  this.nrRollUpRows = nrRows;
                };

                _proto4.rollUp = function rollUp() {
                  if (this.nrRollUpRows === null) {
                    logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
                    return; // Not properly setup
                  }

                  logger.log('TEXT', this.getDisplayText());
                  var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
                  var topRow = this.rows.splice(topRowIndex, 1)[0];
                  topRow.clear();
                  this.rows.splice(this.currRow, 0, topRow);
                  logger.log('INFO', 'Rolling up'); // logger.log('TEXT', this.get_display_text())
                }
                /**
                 * Get all non-empty rows with as unicode text.
                 */
                ;

                _proto4.getDisplayText = function getDisplayText(asOneRow) {
                  asOneRow = asOneRow || false;
                  var displayText = [];
                  var text = '';
                  var rowNr = -1;

                  for (var i = 0; i < NR_ROWS; i++) {
                    var rowText = this.rows[i].getTextString();

                    if (rowText) {
                      rowNr = i + 1;

                      if (asOneRow) {
                        displayText.push(
                            'Row ' + rowNr + ': \'' + rowText + '\'');
                      } else {
                        displayText.push(rowText.trim());
                      }
                    }
                  }

                  if (displayText.length > 0) {
                    if (asOneRow) {
                      text = '[' + displayText.join(' | ') + ']';
                    } else {
                      text = displayText.join('\n');
                    }
                  }

                  return text;
                };

                _proto4.getTextAndFormat = function getTextAndFormat() {
                  return this.rows;
                };

                return CaptionScreen;
              }(); // var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

          var Cea608Channel =
              /*#__PURE__*/
              function() {
                function Cea608Channel(channelNumber, outputFilter) {
                  this.chNr = void 0;
                  this.outputFilter = void 0;
                  this.mode = void 0;
                  this.verbose = void 0;
                  this.displayedMemory = void 0;
                  this.nonDisplayedMemory = void 0;
                  this.lastOutputScreen = void 0;
                  this.currRollUpRow = void 0;
                  this.writeScreen = void 0;
                  this.cueStartTime = void 0;
                  this.lastCueEndTime = void 0;
                  this.chNr = channelNumber;
                  this.outputFilter = outputFilter;
                  this.mode = null;
                  this.verbose = 0;
                  this.displayedMemory = new CaptionScreen();
                  this.nonDisplayedMemory = new CaptionScreen();
                  this.lastOutputScreen = new CaptionScreen();
                  this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
                  this.writeScreen = this.displayedMemory;
                  this.mode = null;
                  this.cueStartTime = null; // Keeps track of where a cue started.
                }

                var _proto5 = Cea608Channel.prototype;

                _proto5.reset = function reset() {
                  this.mode = null;
                  this.displayedMemory.reset();
                  this.nonDisplayedMemory.reset();
                  this.lastOutputScreen.reset();
                  this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
                  this.writeScreen = this.displayedMemory;
                  this.mode = null;
                  this.cueStartTime = null;
                };

                _proto5.getHandler = function getHandler() {
                  return this.outputFilter;
                };

                _proto5.setHandler = function setHandler(newHandler) {
                  this.outputFilter = newHandler;
                };

                _proto5.setPAC = function setPAC(pacData) {
                  this.writeScreen.setPAC(pacData);
                };

                _proto5.setBkgData = function setBkgData(bkgData) {
                  this.writeScreen.setBkgData(bkgData);
                };

                _proto5.setMode = function setMode(newMode) {
                  if (newMode === this.mode) {
                    return;
                  }

                  this.mode = newMode;
                  logger.log('INFO', 'MODE=' + newMode);

                  if (this.mode === 'MODE_POP-ON') {
                    this.writeScreen = this.nonDisplayedMemory;
                  } else {
                    this.writeScreen = this.displayedMemory;
                    this.writeScreen.reset();
                  }

                  if (this.mode !== 'MODE_ROLL-UP') {
                    this.displayedMemory.nrRollUpRows = null;
                    this.nonDisplayedMemory.nrRollUpRows = null;
                  }

                  this.mode = newMode;
                };

                _proto5.insertChars = function insertChars(chars) {
                  for (var i = 0; i < chars.length; i++) {
                    this.writeScreen.insertChar(chars[i]);
                  }

                  var screen = this.writeScreen === this.displayedMemory
                      ? 'DISP'
                      : 'NON_DISP';
                  logger.log('INFO',
                      screen + ': ' + this.writeScreen.getDisplayText(true));

                  if (this.mode === 'MODE_PAINT-ON' || this.mode ===
                      'MODE_ROLL-UP') {
                    logger.log('TEXT', 'DISPLAYED: ' +
                        this.displayedMemory.getDisplayText(true));
                    this.outputDataUpdate();
                  }
                };

                _proto5.ccRCL = function ccRCL() {
                  // Resume Caption Loading (switch mode to Pop On)
                  logger.log('INFO', 'RCL - Resume Caption Loading');
                  this.setMode('MODE_POP-ON');
                };

                _proto5.ccBS = function ccBS() {
                  // BackSpace
                  logger.log('INFO', 'BS - BackSpace');

                  if (this.mode === 'MODE_TEXT') {
                    return;
                  }

                  this.writeScreen.backSpace();

                  if (this.writeScreen === this.displayedMemory) {
                    this.outputDataUpdate();
                  }
                };

                _proto5.ccAOF = function ccAOF() {// Reserved (formerly Alarm Off)
                };

                _proto5.ccAON = function ccAON() {// Reserved (formerly Alarm On)
                };

                _proto5.ccDER = function ccDER() {
                  // Delete to End of Row
                  logger.log('INFO', 'DER- Delete to End of Row');
                  this.writeScreen.clearToEndOfRow();
                  this.outputDataUpdate();
                };

                _proto5.ccRU = function ccRU(nrRows) {
                  // Roll-Up Captions-2,3,or 4 Rows
                  logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
                  this.writeScreen = this.displayedMemory;
                  this.setMode('MODE_ROLL-UP');
                  this.writeScreen.setRollUpRows(nrRows);
                };

                _proto5.ccFON = function ccFON() {
                  // Flash On
                  logger.log('INFO', 'FON - Flash On');
                  this.writeScreen.setPen({
                    flash: true,
                  });
                };

                _proto5.ccRDC = function ccRDC() {
                  // Resume Direct Captioning (switch mode to PaintOn)
                  logger.log('INFO', 'RDC - Resume Direct Captioning');
                  this.setMode('MODE_PAINT-ON');
                };

                _proto5.ccTR = function ccTR() {
                  // Text Restart in text mode (not supported, however)
                  logger.log('INFO', 'TR');
                  this.setMode('MODE_TEXT');
                };

                _proto5.ccRTD = function ccRTD() {
                  // Resume Text Display in Text mode (not supported, however)
                  logger.log('INFO', 'RTD');
                  this.setMode('MODE_TEXT');
                };

                _proto5.ccEDM = function ccEDM() {
                  // Erase Displayed Memory
                  logger.log('INFO', 'EDM - Erase Displayed Memory');
                  this.displayedMemory.reset();
                  this.outputDataUpdate(true);
                };

                _proto5.ccCR = function ccCR() {
                  // Carriage Return
                  logger.log('INFO', 'CR - Carriage Return');
                  this.writeScreen.rollUp();
                  this.outputDataUpdate(true);
                };

                _proto5.ccENM = function ccENM() {
                  // Erase Non-Displayed Memory
                  logger.log('INFO', 'ENM - Erase Non-displayed Memory');
                  this.nonDisplayedMemory.reset();
                };

                _proto5.ccEOC = function ccEOC() {
                  // End of Caption (Flip Memories)
                  logger.log('INFO', 'EOC - End Of Caption');

                  if (this.mode === 'MODE_POP-ON') {
                    var tmp = this.displayedMemory;
                    this.displayedMemory = this.nonDisplayedMemory;
                    this.nonDisplayedMemory = tmp;
                    this.writeScreen = this.nonDisplayedMemory;
                    logger.log('TEXT',
                        'DISP: ' + this.displayedMemory.getDisplayText());
                  }

                  this.outputDataUpdate(true);
                };

                _proto5.ccTO = function ccTO(nrCols) {
                  // Tab Offset 1,2, or 3 columns
                  logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
                  this.writeScreen.moveCursor(nrCols);
                };

                _proto5.ccMIDROW = function ccMIDROW(secondByte) {
                  // Parse MIDROW command
                  var styles = {
                    flash: false,
                  };
                  styles.underline = secondByte % 2 === 1;
                  styles.italics = secondByte >= 0x2e;

                  if (!styles.italics) {
                    var colorIndex = Math.floor(secondByte / 2) - 0x10;
                    var colors = [
                      'white',
                      'green',
                      'blue',
                      'cyan',
                      'red',
                      'yellow',
                      'magenta'];
                    styles.foreground = colors[colorIndex];
                  } else {
                    styles.foreground = 'white';
                  }

                  logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
                  this.writeScreen.setPen(styles);
                };

                _proto5.outputDataUpdate = function outputDataUpdate(dispatch) {
                  if (dispatch === void 0) {
                    dispatch = false;
                  }

                  var t = logger.time;

                  if (t === null) {
                    return;
                  }

                  if (this.outputFilter) {
                    if (this.cueStartTime === null &&
                        !this.displayedMemory.isEmpty()) {
                      // Start of a new cue
                      this.cueStartTime = t;
                    } else {
                      if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                        this.outputFilter.newCue(this.cueStartTime, t,
                            this.lastOutputScreen);

                        if (dispatch && this.outputFilter.dispatchCue) {
                          this.outputFilter.dispatchCue();
                        }

                        this.cueStartTime = this.displayedMemory.isEmpty()
                            ? null
                            : t;
                      }
                    }

                    this.lastOutputScreen.copy(this.displayedMemory);
                  }
                };

                _proto5.cueSplitAtTime = function cueSplitAtTime(t) {
                  if (this.outputFilter) {
                    if (!this.displayedMemory.isEmpty()) {
                      if (this.outputFilter.newCue) {
                        this.outputFilter.newCue(this.cueStartTime, t,
                            this.displayedMemory);
                      }

                      this.cueStartTime = t;
                    }
                  }
                };

                return Cea608Channel;
              }();

          var Cea608Parser =
              /*#__PURE__*/
              function() {
                function Cea608Parser(field, out1, out2) {
                  this.field = void 0;
                  this.outputs = void 0;
                  this.channels = void 0;
                  this.currChNr = void 0;
                  this.lastCmdA = void 0;
                  this.lastCmdB = void 0;
                  this.lastTime = void 0;
                  this.dataCounters = void 0;
                  this.field = field || 1;
                  this.outputs = [out1, out2];
                  this.channels = [
                    new Cea608Channel(1, out1),
                    new Cea608Channel(2, out2)];
                  this.currChNr = -1; // Will be 1 or 2

                  this.lastCmdA = null; // First byte of last command

                  this.lastCmdB = null; // Second byte of last command

                  this.lastTime = null;
                  this.dataCounters = {
                    'padding': 0,
                    'char': 0,
                    'cmd': 0,
                    'other': 0,
                  };
                }

                var _proto6 = Cea608Parser.prototype;

                _proto6.getHandler = function getHandler(index) {
                  return this.channels[index].getHandler();
                };

                _proto6.setHandler = function setHandler(index, newHandler) {
                  this.channels[index].setHandler(newHandler);
                }
                /**
                 * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
                 */
                ;

                _proto6.addData = function addData(t, byteList) {
                  var cmdFound,
                      a,
                      b,
                      charsFound = false;
                  this.lastTime = t;
                  logger.setTime(t);

                  for (var i = 0; i < byteList.length; i += 2) {
                    a = byteList[i] & 0x7f;
                    b = byteList[i + 1] & 0x7f;

                    if (a === 0 && b === 0) {
                      this.dataCounters.padding += 2;
                      continue;
                    } else {
                      logger.log('DATA', '[' +
                          numArrayToHexArray([byteList[i], byteList[i + 1]]) +
                          '] -> (' + numArrayToHexArray([a, b]) + ')');
                    }

                    cmdFound = this.parseCmd(a, b);

                    if (!cmdFound) {
                      cmdFound = this.parseMidrow(a, b);
                    }

                    if (!cmdFound) {
                      cmdFound = this.parsePAC(a, b);
                    }

                    if (!cmdFound) {
                      cmdFound = this.parseBackgroundAttributes(a, b);
                    }

                    if (!cmdFound) {
                      charsFound = this.parseChars(a, b);

                      if (charsFound) {
                        if (this.currChNr && this.currChNr >= 0) {
                          var channel = this.channels[this.currChNr - 1];
                          channel.insertChars(charsFound);
                        } else {
                          logger.log('WARNING',
                              'No channel found yet. TEXT-MODE?');
                        }
                      }
                    }

                    if (cmdFound) {
                      this.dataCounters.cmd += 2;
                    } else if (charsFound) {
                      this.dataCounters.char += 2;
                    } else {
                      this.dataCounters.other += 2;
                      logger.log('WARNING', 'Couldn\'t parse cleaned data ' +
                          numArrayToHexArray([a, b]) + ' orig: ' +
                          numArrayToHexArray([byteList[i], byteList[i + 1]]));
                    }
                  }
                }
                /**
                 * Parse Command.
                 * @returns {Boolean} Tells if a command was found
                 */
                ;

                _proto6.parseCmd = function parseCmd(a, b) {
                  var chNr = null;
                  var cond1 = (a === 0x14 || a === 0x1C) && b >= 0x20 && b <=
                      0x2F;
                  var cond2 = (a === 0x17 || a === 0x1F) && b >= 0x21 && b <=
                      0x23;

                  if (!(cond1 || cond2)) {
                    return false;
                  }

                  if (a === this.lastCmdA && b === this.lastCmdB) {
                    this.lastCmdA = null;
                    this.lastCmdB = null; // Repeated commands are dropped (once)

                    logger.log('DEBUG',
                        'Repeated command (' + numArrayToHexArray([a, b]) +
                        ') is dropped');
                    return true;
                  }

                  if (a === 0x14 || a === 0x17) {
                    chNr = 1;
                  } else {
                    chNr = 2;
                  } // (a === 0x1C || a=== 0x1f)

                  var channel = this.channels[chNr - 1];

                  if (a === 0x14 || a === 0x1C) {
                    if (b === 0x20) {
                      channel.ccRCL();
                    } else if (b === 0x21) {
                      channel.ccBS();
                    } else if (b === 0x22) {
                      channel.ccAOF();
                    } else if (b === 0x23) {
                      channel.ccAON();
                    } else if (b === 0x24) {
                      channel.ccDER();
                    } else if (b === 0x25) {
                      channel.ccRU(2);
                    } else if (b === 0x26) {
                      channel.ccRU(3);
                    } else if (b === 0x27) {
                      channel.ccRU(4);
                    } else if (b === 0x28) {
                      channel.ccFON();
                    } else if (b === 0x29) {
                      channel.ccRDC();
                    } else if (b === 0x2A) {
                      channel.ccTR();
                    } else if (b === 0x2B) {
                      channel.ccRTD();
                    } else if (b === 0x2C) {
                      channel.ccEDM();
                    } else if (b === 0x2D) {
                      channel.ccCR();
                    } else if (b === 0x2E) {
                      channel.ccENM();
                    } else if (b === 0x2F) {
                      channel.ccEOC();
                    }
                  } else {
                    // a == 0x17 || a == 0x1F
                    channel.ccTO(b - 0x20);
                  }

                  this.lastCmdA = a;
                  this.lastCmdB = b;
                  this.currChNr = chNr;
                  return true;
                }
                /**
                 * Parse midrow styling command
                 * @returns {Boolean}
                 */
                ;

                _proto6.parseMidrow = function parseMidrow(a, b) {
                  var chNr = null;

                  if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {
                    if (a === 0x11) {
                      chNr = 1;
                    } else {
                      chNr = 2;
                    }

                    if (chNr !== this.currChNr) {
                      logger.log('ERROR', 'Mismatch channel in midrow parsing');
                      return false;
                    }

                    var channel = this.channels[chNr - 1];
                    channel.ccMIDROW(b);
                    logger.log('DEBUG',
                        'MIDROW (' + numArrayToHexArray([a, b]) + ')');
                    return true;
                  }

                  return false;
                }
                /**
                 * Parse Preable Access Codes (Table 53).
                 * @returns {Boolean} Tells if PAC found
                 */
                ;

                _proto6.parsePAC = function parsePAC(a, b) {
                  var chNr = null;
                  var row = null;
                  var case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <=
                      0x1F) && b >= 0x40 && b <= 0x7F;
                  var case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <=
                      0x5F;

                  if (!(case1 || case2)) {
                    return false;
                  }

                  if (a === this.lastCmdA && b === this.lastCmdB) {
                    this.lastCmdA = null;
                    this.lastCmdB = null;
                    return true; // Repeated commands are dropped (once)
                  }

                  chNr = a <= 0x17 ? 1 : 2;

                  if (b >= 0x40 && b <= 0x5F) {
                    row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
                  } else {
                    // 0x60 <= b <= 0x7F
                    row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
                  }

                  var pacData = this.interpretPAC(row, b);
                  var channel = this.channels[chNr - 1];
                  channel.setPAC(pacData);
                  this.lastCmdA = a;
                  this.lastCmdB = b;
                  this.currChNr = chNr;
                  return true;
                }
                /**
                 * Interpret the second byte of the pac, and return the information.
                 * @returns {Object} pacData with style parameters.
                 */
                ;

                _proto6.interpretPAC = function interpretPAC(row, _byte3) {
                  var pacIndex = _byte3;
                  var pacData = {
                    color: null,
                    italics: false,
                    indent: null,
                    underline: false,
                    row: row,
                  };

                  if (_byte3 > 0x5F) {
                    pacIndex = _byte3 - 0x60;
                  } else {
                    pacIndex = _byte3 - 0x40;
                  }

                  pacData.underline = (pacIndex & 1) === 1;

                  if (pacIndex <= 0xd) {
                    pacData.color = [
                      'white',
                      'green',
                      'blue',
                      'cyan',
                      'red',
                      'yellow',
                      'magenta',
                      'white'][Math.floor(pacIndex / 2)];
                  } else if (pacIndex <= 0xf) {
                    pacData.italics = true;
                    pacData.color = 'white';
                  } else {
                    pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
                  }

                  return pacData; // Note that row has zero offset. The spec uses 1.
                }
                /**
                 * Parse characters.
                 * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
                 */
                ;

                _proto6.parseChars = function parseChars(a, b) {
                  var channelNr = null,
                      charCodes = null,
                      charCode1 = null;

                  if (a >= 0x19) {
                    channelNr = 2;
                    charCode1 = a - 8;
                  } else {
                    channelNr = 1;
                    charCode1 = a;
                  }

                  if (charCode1 >= 0x11 && charCode1 <= 0x13) {
                    // Special character
                    var oneCode = b;

                    if (charCode1 === 0x11) {
                      oneCode = b + 0x50;
                    } else if (charCode1 === 0x12) {
                      oneCode = b + 0x70;
                    } else {
                      oneCode = b + 0x90;
                    }

                    logger.log('INFO',
                        'Special char \'' + getCharForByte(oneCode) +
                        '\' in channel ' + channelNr);
                    charCodes = [oneCode];
                  } else if (a >= 0x20 && a <= 0x7f) {
                    charCodes = b === 0 ? [a] : [a, b];
                  }

                  if (charCodes) {
                    var hexCodes = numArrayToHexArray(charCodes);
                    logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
                    this.lastCmdA = null;
                    this.lastCmdB = null;
                  }

                  return charCodes;
                }
                /**
                 * Parse extended background attributes as well as new foreground color black.
                 * @returns {Boolean} Tells if background attributes are found
                 */
                ;

                _proto6.parseBackgroundAttributes = function parseBackgroundAttributes(
                    a, b) {
                  var bkgData, index, chNr, channel;
                  var case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <=
                      0x2f;
                  var case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <=
                      0x2f;

                  if (!(case1 || case2)) {
                    return false;
                  }

                  bkgData = {};

                  if (a === 0x10 || a === 0x18) {
                    index = Math.floor((b - 0x20) / 2);
                    bkgData.background = backgroundColors[index];

                    if (b % 2 === 1) {
                      bkgData.background = bkgData.background + '_semi';
                    }
                  } else if (b === 0x2d) {
                    bkgData.background = 'transparent';
                  } else {
                    bkgData.foreground = 'black';

                    if (b === 0x2f) {
                      bkgData.underline = true;
                    }
                  }

                  chNr = a < 0x18 ? 1 : 2;
                  channel = this.channels[chNr - 1];
                  channel.setBkgData(bkgData);
                  this.lastCmdA = null;
                  this.lastCmdB = null;
                  return true;
                }
                /**
                 * Reset state of parser and its channels.
                 */
                ;

                _proto6.reset = function reset() {
                  for (var i = 0; i < this.channels.length; i++) {
                    if (this.channels[i]) {
                      this.channels[i].reset();
                    }
                  }

                  this.lastCmdA = null;
                  this.lastCmdB = null;
                }
                /**
                 * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
                 */
                ;

                _proto6.cueSplitAtTime = function cueSplitAtTime(t) {
                  for (var i = 0; i < this.channels.length; i++) {
                    if (this.channels[i]) {
                      this.channels[i].cueSplitAtTime(t);
                    }
                  }
                };

                return Cea608Parser;
              }();

          /* harmony default export */
          __webpack_exports__['a'] = (Cea608Parser);

          /***/
        }),
        /* 76 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return OutputFilter; });
          var OutputFilter =
              /*#__PURE__*/
              function() {
                // TODO(typescript-timelineController)
                function OutputFilter(timelineController, trackName) {
                  this.timelineController = void 0;
                  this.trackName = void 0;
                  this.startTime = void 0;
                  this.endTime = void 0;
                  this.screen = void 0;
                  this.timelineController = timelineController;
                  this.trackName = trackName;
                  this.startTime = null;
                  this.endTime = null;
                  this.screen = null;
                }

                var _proto = OutputFilter.prototype;

                _proto.dispatchCue = function dispatchCue() {
                  if (this.startTime === null) {
                    return;
                  }

                  this.timelineController.addCues(this.trackName,
                      this.startTime, this.endTime, this.screen);
                  this.startTime = null;
                };

                _proto.newCue = function newCue(startTime, endTime, screen) {
                  if (this.startTime === null || this.startTime > startTime) {
                    this.startTime = startTime;
                  }

                  this.endTime = endTime;
                  this.screen = screen;
                  this.timelineController.createCaptionsTrack(this.trackName);
                };

                return OutputFilter;
              }();

          /***/
        }),
        /* 77 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__vttparser__ = __webpack_require__(
              32);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__demux_id3__ = __webpack_require__(8);

          // String.prototype.startsWith is not supported in IE11

          var startsWith = function startsWith(
              inputString, searchString, position) {
            return inputString.substr(position || 0, searchString.length) ===
                searchString;
          };

          var cueString2millis = function cueString2millis(timeString) {
            var ts = parseInt(timeString.substr(-3));
            var secs = parseInt(timeString.substr(-6, 2));
            var mins = parseInt(timeString.substr(-9, 2));
            var hours = timeString.length > 9 ? parseInt(
                timeString.substr(0, timeString.indexOf(':'))) : 0;

            if (!Object(
                __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                ts) || !Object(
                __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                secs) || !Object(
                __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                mins) || !Object(
                __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                hours)) {
              throw Error('Malformed X-TIMESTAMP-MAP: Local:' + timeString);
            }

            ts += 1000 * secs;
            ts += 60 * 1000 * mins;
            ts += 60 * 60 * 1000 * hours;
            return ts;
          }; // From https://github.com/darkskyapp/string-hash

          var hash = function hash(text) {
            var hash = 5381;
            var i = text.length;

            while (i) {
              hash = hash * 33 ^ text.charCodeAt(--i);
            }

            return (hash >>> 0).toString();
          };

          var calculateOffset = function calculateOffset(
              vttCCs, cc, presentationTime) {
            var currCC = vttCCs[cc];
            var prevCC = vttCCs[currCC.prevCC]; // This is the first discontinuity or cues have been processed since the last discontinuity
            // Offset = current discontinuity time

            if (!prevCC || !prevCC.new && currCC.new) {
              vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
              currCC.new = false;
              return;
            } // There have been discontinuities since cues were last parsed.
            // Offset = time elapsed

            while (prevCC && prevCC.new) {
              vttCCs.ccOffset += currCC.start - prevCC.start;
              currCC.new = false;
              currCC = prevCC;
              prevCC = vttCCs[currCC.prevCC];
            }

            vttCCs.presentationOffset = presentationTime;
          };

          var WebVTTParser = {
            parse: function parse(
                vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
              // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
              var re = /\r\n|\n\r|\n|\r/g; // Uint8Array.prototype.reduce is not implemented in IE11

              var vttLines = Object(
                  __WEBPACK_IMPORTED_MODULE_2__demux_id3__['b' /* utf8ArrayToStr */])(
                  new Uint8Array(vttByteArray)).
                  trim().
                  replace(re, '\n').
                  split('\n');
              var cueTime = '00:00.000';
              var mpegTs = 0;
              var localTime = 0;
              var presentationTime = 0;
              var cues = [];
              var parsingError;
              var inHeader = true;
              var timestampMap = false; // let VTTCue = VTTCue || window.TextTrackCue;
              // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.

              var parser = new __WEBPACK_IMPORTED_MODULE_1__vttparser__['a' /* default */]();

              parser.oncue = function(cue) {
                // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
                var currCC = vttCCs[cc];
                var cueOffset = vttCCs.ccOffset; // Update offsets for new discontinuities

                if (currCC && currCC.new) {
                  if (localTime !== undefined) {
                    // When local time is provided, offset = discontinuity start time - local time
                    cueOffset = vttCCs.ccOffset = currCC.start;
                  } else {
                    calculateOffset(vttCCs, cc, presentationTime);
                  }
                }

                if (presentationTime) {
                  // If we have MPEGTS, offset = presentation time + discontinuity offset
                  cueOffset = presentationTime - vttCCs.presentationOffset;
                }

                if (timestampMap) {
                  cue.startTime += cueOffset - localTime;
                  cue.endTime += cueOffset - localTime;
                } // Create a unique hash id for a cue based on start/end times and text.
                // This helps timeline-controller to avoid showing repeated captions.

                cue.id = hash(cue.startTime.toString()) +
                    hash(cue.endTime.toString()) + hash(cue.text); // Fix encoding of special characters. TODO: Test with all sorts of weird characters.

                cue.text = decodeURIComponent(encodeURIComponent(cue.text));

                if (cue.endTime > 0) {
                  cues.push(cue);
                }
              };

              parser.onparsingerror = function(e) {
                parsingError = e;
              };

              parser.onflush = function() {
                if (parsingError && errorCallBack) {
                  errorCallBack(parsingError);
                  return;
                }

                callBack(cues);
              }; // Go through contents line by line.

              vttLines.forEach(function(line) {
                if (inHeader) {
                  // Look for X-TIMESTAMP-MAP in header.
                  if (startsWith(line, 'X-TIMESTAMP-MAP=')) {
                    // Once found, no more are allowed anyway, so stop searching.
                    inHeader = false;
                    timestampMap = true; // Extract LOCAL and MPEGTS.

                    line.substr(16).split(',').forEach(function(timestamp) {
                      if (startsWith(timestamp, 'LOCAL:')) {
                        cueTime = timestamp.substr(6);
                      } else if (startsWith(timestamp, 'MPEGTS:')) {
                        mpegTs = parseInt(timestamp.substr(7));
                      }
                    });

                    try {
                      // Calculate subtitle offset in milliseconds.
                      if (syncPTS + (vttCCs[cc].start * 90000 || 0) < 0) {
                        syncPTS += 8589934592;
                      } // Adjust MPEGTS by sync PTS.

                      mpegTs -= syncPTS; // Convert cue time to seconds

                      localTime = cueString2millis(cueTime) / 1000; // Convert MPEGTS to seconds from 90kHz.

                      presentationTime = mpegTs / 90000;
                    } catch (e) {
                      timestampMap = false;
                      parsingError = e;
                    } // Return without parsing X-TIMESTAMP-MAP line.

                    return;
                  } else if (line === '') {
                    inHeader = false;
                  }
                } // Parse line by default.

                parser.parse(line + '\n');
              });
              parser.flush();
            },
          };
          /* harmony default export */
          __webpack_exports__['a'] = (WebVTTParser);

          /***/
        }),
        /* 78 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__ = __webpack_require__(
              0);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__event_handler__ = __webpack_require__(
              4);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__level_helper__ = __webpack_require__(
              9);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__utils_texttrack_utils__ = __webpack_require__(
              18);

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(
              Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype,
                protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          var SubtitleTrackController =
              /*#__PURE__*/
              function(_EventHandler) {
                _inheritsLoose(SubtitleTrackController, _EventHandler);

                function SubtitleTrackController(hls) {
                  var _this;

                  _this = _EventHandler.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MEDIA_ATTACHED,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MEDIA_DETACHING,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MANIFEST_LOADED,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].SUBTITLE_TRACK_LOADED) ||
                      this;
                  _this.tracks = [];
                  _this.trackId = -1;
                  _this.media = null;
                  _this.stopped = true;
                  /**
                   * @member {boolean} subtitleDisplay Enable/disable subtitle display rendering
                   */

                  _this.subtitleDisplay = true;
                  /**
                   * Keeps reference to a default track id when media has not been attached yet
                   * @member {number}
                   */

                  _this.queuedDefaultTrack = null;
                  return _this;
                }

                var _proto = SubtitleTrackController.prototype;

                _proto.destroy = function destroy() {
                  __WEBPACK_IMPORTED_MODULE_2__event_handler__['a' /* default */].prototype.destroy.call(
                      this);
                } // Listen for subtitle track change, then extract the current track ID.
                ;

                _proto.onMediaAttached = function onMediaAttached(data) {
                  var _this2 = this;

                  this.media = data.media;

                  if (!this.media) {
                    return;
                  }

                  if (Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      this.queuedDefaultTrack)) {
                    this.subtitleTrack = this.queuedDefaultTrack;
                    this.queuedDefaultTrack = null;
                  }

                  this.trackChangeListener = this._onTextTracksChanged.bind(
                      this);
                  this.useTextTrackPolling = !(this.media.textTracks &&
                      'onchange' in this.media.textTracks);

                  if (this.useTextTrackPolling) {
                    this.subtitlePollingInterval = setInterval(function() {
                      _this2.trackChangeListener();
                    }, 500);
                  } else {
                    this.media.textTracks.addEventListener('change',
                        this.trackChangeListener);
                  }
                };

                _proto.onMediaDetaching = function onMediaDetaching() {
                  if (!this.media) {
                    return;
                  }

                  if (this.useTextTrackPolling) {
                    clearInterval(this.subtitlePollingInterval);
                  } else {
                    this.media.textTracks.removeEventListener('change',
                        this.trackChangeListener);
                  }

                  if (Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      this.subtitleTrack)) {
                    this.queuedDefaultTrack = this.subtitleTrack;
                  }

                  var textTracks = filterSubtitleTracks(this.media.textTracks); // Clear loaded cues on media detachment from tracks

                  textTracks.forEach(function(track) {
                    Object(
                        __WEBPACK_IMPORTED_MODULE_5__utils_texttrack_utils__['a' /* clearCurrentCues */])(
                        track);
                  }); // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.

                  this.subtitleTrack = -1;
                  this.media = null;
                } // Fired whenever a new manifest is loaded.
                ;

                _proto.onManifestLoaded = function onManifestLoaded(data) {
                  var _this3 = this;

                  var tracks = data.subtitles || [];
                  this.tracks = tracks;
                  this.hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].SUBTITLE_TRACKS_UPDATED,
                      {
                        subtitleTracks: tracks,
                      }); // loop through available subtitle tracks and autoselect default if needed
                  // TODO: improve selection logic to handle forced, etc

                  tracks.forEach(function(track) {
                    if (track.default) {
                      // setting this.subtitleTrack will trigger internal logic
                      // if media has not been attached yet, it will fail
                      // we keep a reference to the default track id
                      // and we'll set subtitleTrack when onMediaAttached is triggered
                      if (_this3.media) {
                        _this3.subtitleTrack = track.id;
                      } else {
                        _this3.queuedDefaultTrack = track.id;
                      }
                    }
                  });
                };

                _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(data) {
                  var _this4 = this;

                  var id = data.id,
                      details = data.details;
                  var trackId = this.trackId,
                      tracks = this.tracks;
                  var currentTrack = tracks[trackId];

                  if (id >= tracks.length || id !== trackId || !currentTrack ||
                      this.stopped) {
                    this._clearReloadTimer();

                    return;
                  }

                  __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                      'subtitle track ' + id + ' loaded');

                  if (details.live) {
                    var reloadInterval = Object(
                        __WEBPACK_IMPORTED_MODULE_4__level_helper__['b' /* computeReloadInterval */])(
                        currentTrack.details, details, data.stats.trequest);
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                        'Reloading live subtitle playlist in ' +
                        reloadInterval + 'ms');
                    this.timer = setTimeout(function() {
                      _this4._loadCurrentTrack();
                    }, reloadInterval);
                  } else {
                    this._clearReloadTimer();
                  }
                };

                _proto.startLoad = function startLoad() {
                  this.stopped = false;

                  this._loadCurrentTrack();
                };

                _proto.stopLoad = function stopLoad() {
                  this.stopped = true;

                  this._clearReloadTimer();
                }
                /** get alternate subtitle tracks list from playlist **/
                ;

                _proto._clearReloadTimer = function _clearReloadTimer() {
                  if (this.timer) {
                    clearTimeout(this.timer);
                    this.timer = null;
                  }
                };

                _proto._loadCurrentTrack = function _loadCurrentTrack() {
                  var trackId = this.trackId,
                      tracks = this.tracks,
                      hls = this.hls;
                  var currentTrack = tracks[trackId];

                  if (trackId < 0 || !currentTrack || currentTrack.details &&
                      !currentTrack.details.live) {
                    return;
                  }

                  __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                      'Loading subtitle track ' + trackId);
                  hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].SUBTITLE_TRACK_LOADING,
                      {
                        url: currentTrack.url,
                        id: trackId,
                      });
                }
                /**
                 * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
                 * This operates on the DOM textTracks.
                 * A value of -1 will disable all subtitle tracks.
                 * @param newId - The id of the next track to enable
                 * @private
                 */
                ;

                _proto._toggleTrackModes = function _toggleTrackModes(newId) {
                  var media = this.media,
                      subtitleDisplay = this.subtitleDisplay,
                      trackId = this.trackId;

                  if (!media) {
                    return;
                  }

                  var textTracks = filterSubtitleTracks(media.textTracks);

                  if (newId === -1) {
                    [].slice.call(textTracks).forEach(function(track) {
                      track.mode = 'disabled';
                    });
                  } else {
                    var oldTrack = textTracks[trackId];

                    if (oldTrack) {
                      oldTrack.mode = 'disabled';
                    }
                  }

                  var nextTrack = textTracks[newId];

                  if (nextTrack) {
                    nextTrack.mode = subtitleDisplay ? 'showing' : 'hidden';
                  }
                }
                /**
                 * This method is responsible for validating the subtitle index and periodically reloading if live.
                 * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
                 * @param newId - The id of the subtitle track to activate.
                 */
                ;

                _proto._setSubtitleTrackInternal = function _setSubtitleTrackInternal(newId) {
                  var hls = this.hls,
                      tracks = this.tracks;

                  if (!Object(
                      __WEBPACK_IMPORTED_MODULE_0_H_www_test_videojs_hlsjs_plugin_src_polyfills_number_isFinite__['a' /* isFiniteNumber */])(
                      newId) || newId < -1 || newId >= tracks.length) {
                    return;
                  }

                  this.trackId = newId;
                  __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                      'Switching to subtitle track ' + newId);
                  hls.trigger(
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].SUBTITLE_TRACK_SWITCH,
                      {
                        id: newId,
                      });

                  this._loadCurrentTrack();
                };

                _proto._onTextTracksChanged = function _onTextTracksChanged() {
                  // Media is undefined when switching streams via loadSource()
                  if (!this.media) {
                    return;
                  }

                  var trackId = -1;
                  var tracks = filterSubtitleTracks(this.media.textTracks);

                  for (var id = 0; id < tracks.length; id++) {
                    if (tracks[id].mode === 'hidden') {
                      // Do not break in case there is a following track with showing.
                      trackId = id;
                    } else if (tracks[id].mode === 'showing') {
                      trackId = id;
                      break;
                    }
                  } // Setting current subtitleTrack will invoke code.

                  this.subtitleTrack = trackId;
                };

                _createClass(SubtitleTrackController, [
                  {
                    key: 'subtitleTracks',
                    get: function get() {
                      return this.tracks;
                    },
                    /** get index of the selected subtitle track (index in subtitle track lists) **/

                  }, {
                    key: 'subtitleTrack',
                    get: function get() {
                      return this.trackId;
                    }
                    /** select a subtitle track, based on its index in subtitle track lists**/
                    ,
                    set: function set(subtitleTrackId) {
                      if (this.trackId !== subtitleTrackId) {
                        this._toggleTrackModes(subtitleTrackId);

                        this._setSubtitleTrackInternal(subtitleTrackId);
                      }
                    },
                  }]);

                return SubtitleTrackController;
              }(__WEBPACK_IMPORTED_MODULE_2__event_handler__['a' /* default */]);

          function filterSubtitleTracks(textTrackList) {
            var tracks = [];

            for (var i = 0; i < textTrackList.length; i++) {
              var track = textTrackList[i]; // Edge adds a track without a label; we don't want to use it

              if (track.kind === 'subtitles' && track.label) {
                tracks.push(textTrackList[i]);
              }
            }

            return tracks;
          }

          /* harmony default export */
          __webpack_exports__['a'] = (SubtitleTrackController);

          /***/
        }),
        /* 79 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony export (binding) */
          __webpack_require__.d(__webpack_exports__, 'a',
              function() { return SubtitleStreamController; });
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__crypt_decrypter__ = __webpack_require__(
              12);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__utils_buffer_helper__ = __webpack_require__(
              6);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__fragment_finders__ = __webpack_require__(
              29);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_5__fragment_tracker__ = __webpack_require__(
              7);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_6__base_stream_controller__ = __webpack_require__(
              17);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_7__level_helper__ = __webpack_require__(
              9);

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError(
                  'this hasn\'t been initialised - super() hasn\'t been called');
            }
            return self;
          }

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /**
           * @class SubtitleStreamController
           */








          var _window = window,
              performance = _window.performance;
          var TICK_INTERVAL = 500; // how often to tick in ms

          var SubtitleStreamController =
              /*#__PURE__*/
              function(_BaseStreamController) {
                _inheritsLoose(SubtitleStreamController, _BaseStreamController);

                function SubtitleStreamController(hls, fragmentTracker) {
                  var _this;

                  _this = _BaseStreamController.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].MEDIA_ATTACHED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].MEDIA_DETACHING,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].ERROR,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].KEY_LOADED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].FRAG_LOADED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].SUBTITLE_TRACKS_UPDATED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].SUBTITLE_TRACK_SWITCH,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].SUBTITLE_TRACK_LOADED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].SUBTITLE_FRAG_PROCESSED,
                      __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].LEVEL_UPDATED) ||
                      this;
                  _this.fragmentTracker = fragmentTracker;
                  _this.config = hls.config;
                  _this.state = __WEBPACK_IMPORTED_MODULE_6__base_stream_controller__['a' /* State */].STOPPED;
                  _this.tracks = [];
                  _this.tracksBuffered = [];
                  _this.currentTrackId = -1;
                  _this.decrypter = new __WEBPACK_IMPORTED_MODULE_2__crypt_decrypter__['a' /* default */](
                      hls, hls.config); // lastAVStart stores the time in seconds for the start time of a level load

                  _this.lastAVStart = 0;
                  _this._onMediaSeeking = _this.onMediaSeeking.bind(
                      _assertThisInitialized(_this));
                  return _this;
                }

                var _proto = SubtitleStreamController.prototype;

                _proto.onSubtitleFragProcessed = function onSubtitleFragProcessed(data) {
                  var frag = data.frag,
                      success = data.success;
                  this.fragPrevious = frag;
                  this.state = __WEBPACK_IMPORTED_MODULE_6__base_stream_controller__['a' /* State */].IDLE;

                  if (!success) {
                    return;
                  }

                  var buffered = this.tracksBuffered[this.currentTrackId];

                  if (!buffered) {
                    return;
                  } // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo
                  // so we can re-use the logic used to detect how much have been buffered

                  var timeRange;
                  var fragStart = frag.start;

                  for (var i = 0; i < buffered.length; i++) {
                    if (fragStart >= buffered[i].start && fragStart <=
                        buffered[i].end) {
                      timeRange = buffered[i];
                      break;
                    }
                  }

                  var fragEnd = frag.start + frag.duration;

                  if (timeRange) {
                    timeRange.end = fragEnd;
                  } else {
                    timeRange = {
                      start: fragStart,
                      end: fragEnd,
                    };
                    buffered.push(timeRange);
                  }
                };

                _proto.onMediaAttached = function onMediaAttached(_ref) {
                  var media = _ref.media;
                  this.media = media;
                  media.addEventListener('seeking', this._onMediaSeeking);
                  this.state = __WEBPACK_IMPORTED_MODULE_6__base_stream_controller__['a' /* State */].IDLE;
                };

                _proto.onMediaDetaching = function onMediaDetaching() {
                  var _this2 = this;

                  if (!this.media) {
                    return;
                  }

                  this.media.removeEventListener('seeking',
                      this._onMediaSeeking);
                  this.fragmentTracker.removeAllFragments();
                  this.currentTrackId = -1;
                  this.tracks.forEach(function(track) {
                    _this2.tracksBuffered[track.id] = [];
                  });
                  this.media = null;
                  this.state = __WEBPACK_IMPORTED_MODULE_6__base_stream_controller__['a' /* State */].STOPPED;
                } // If something goes wrong, proceed to next frag, if we were processing one.
                ;

                _proto.onError = function onError(data) {
                  var frag = data.frag; // don't handle error not related to subtitle fragment

                  if (!frag || frag.type !== 'subtitle') {
                    return;
                  }

                  this.state = __WEBPACK_IMPORTED_MODULE_6__base_stream_controller__['a' /* State */].IDLE;
                } // Got all new subtitle tracks.
                ;

                _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(data) {
                  var _this3 = this;

                  __WEBPACK_IMPORTED_MODULE_1__utils_logger__['b' /* logger */].log(
                      'subtitle tracks updated');
                  this.tracksBuffered = [];
                  this.tracks = data.subtitleTracks;
                  this.tracks.forEach(function(track) {
                    _this3.tracksBuffered[track.id] = [];
                  });
                };

                _proto.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(data) {
                  this.currentTrackId = data.id;

                  if (!this.tracks || !this.tracks.length ||
                      this.currentTrackId === -1) {
                    this.clearInterval();
                    return;
                  } // Check if track has the necessary details to load fragments

                  var currentTrack = this.tracks[this.currentTrackId];

                  if (currentTrack && currentTrack.details) {
                    this.setInterval(TICK_INTERVAL);
                  }
                } // Got a new set of subtitle fragments.
                ;

                _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(data) {
                  var id = data.id,
                      details = data.details;
                  var currentTrackId = this.currentTrackId,
                      tracks = this.tracks;
                  var currentTrack = tracks[currentTrackId];

                  if (id >= tracks.length || id !== currentTrackId ||
                      !currentTrack) {
                    return;
                  }

                  if (details.live) {
                    Object(
                        __WEBPACK_IMPORTED_MODULE_7__level_helper__['d' /* mergeSubtitlePlaylists */])(
                        currentTrack.details, details, this.lastAVStart);
                  }

                  currentTrack.details = details;
                  this.setInterval(TICK_INTERVAL);
                };

                _proto.onKeyLoaded = function onKeyLoaded() {
                  if (this.state ===
                      __WEBPACK_IMPORTED_MODULE_6__base_stream_controller__['a' /* State */].KEY_LOADING) {
                    this.state = __WEBPACK_IMPORTED_MODULE_6__base_stream_controller__['a' /* State */].IDLE;
                  }
                };

                _proto.onFragLoaded = function onFragLoaded(data) {
                  var fragCurrent = this.fragCurrent;
                  var decryptData = data.frag.decryptdata;
                  var fragLoaded = data.frag;
                  var hls = this.hls;

                  if (this.state ===
                      __WEBPACK_IMPORTED_MODULE_6__base_stream_controller__['a' /* State */].FRAG_LOADING &&
                      fragCurrent && data.frag.type === 'subtitle' &&
                      fragCurrent.sn === data.frag.sn) {
                    // check to see if the payload needs to be decrypted
                    if (data.payload.byteLength > 0 && decryptData &&
                        decryptData.key && decryptData.method === 'AES-128') {
                      var startTime = performance.now(); // decrypt the subtitles

                      this.decrypter.decrypt(data.payload,
                          decryptData.key.buffer, decryptData.iv.buffer,
                          function(decryptedData) {
                            var endTime = performance.now();
                            hls.trigger(
                                __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].FRAG_DECRYPTED,
                                {
                                  frag: fragLoaded,
                                  payload: decryptedData,
                                  stats: {
                                    tstart: startTime,
                                    tdecrypt: endTime,
                                  },
                                });
                          });
                    }
                  }
                };

                _proto.onLevelUpdated = function onLevelUpdated(_ref2) {
                  var details = _ref2.details;
                  var frags = details.fragments;
                  this.lastAVStart = frags.length ? frags[0].start : 0;
                };

                _proto.doTick = function doTick() {
                  if (!this.media) {
                    this.state = __WEBPACK_IMPORTED_MODULE_6__base_stream_controller__['a' /* State */].IDLE;
                    return;
                  }

                  switch (this.state) {
                    case __WEBPACK_IMPORTED_MODULE_6__base_stream_controller__['a' /* State */].IDLE: {
                      var config = this.config,
                          currentTrackId = this.currentTrackId,
                          fragmentTracker = this.fragmentTracker,
                          media = this.media,
                          tracks = this.tracks;

                      if (!tracks || !tracks[currentTrackId] ||
                          !tracks[currentTrackId].details) {
                        break;
                      }

                      var maxBufferHole = config.maxBufferHole,
                          maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                      var maxConfigBuffer = Math.min(config.maxBufferLength,
                          config.maxMaxBufferLength);
                      var bufferedInfo = __WEBPACK_IMPORTED_MODULE_3__utils_buffer_helper__['a' /* BufferHelper */].bufferedInfo(
                          this._getBuffered(), media.currentTime,
                          maxBufferHole);
                      var bufferEnd = bufferedInfo.end,
                          bufferLen = bufferedInfo.len;
                      var trackDetails = tracks[currentTrackId].details;
                      var fragments = trackDetails.fragments;
                      var fragLen = fragments.length;
                      var end = fragments[fragLen - 1].start +
                          fragments[fragLen - 1].duration;

                      if (bufferLen > maxConfigBuffer) {
                        return;
                      }

                      var foundFrag;
                      var fragPrevious = this.fragPrevious;

                      if (bufferEnd < end) {
                        if (fragPrevious && trackDetails.hasProgramDateTime) {
                          foundFrag = Object(
                              __WEBPACK_IMPORTED_MODULE_4__fragment_finders__['a' /* findFragmentByPDT */])(
                              fragments, fragPrevious.endProgramDateTime,
                              maxFragLookUpTolerance);
                        }

                        if (!foundFrag) {
                          foundFrag = Object(
                              __WEBPACK_IMPORTED_MODULE_4__fragment_finders__['b' /* findFragmentByPTS */])(
                              fragPrevious, fragments, bufferEnd,
                              maxFragLookUpTolerance);
                        }
                      } else {
                        foundFrag = fragments[fragLen - 1];
                      }

                      if (foundFrag && foundFrag.encrypted) {
                        __WEBPACK_IMPORTED_MODULE_1__utils_logger__['b' /* logger */].log(
                            'Loading key for ' + foundFrag.sn);
                        this.state = __WEBPACK_IMPORTED_MODULE_6__base_stream_controller__['a' /* State */].KEY_LOADING;
                        this.hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].KEY_LOADING,
                            {
                              frag: foundFrag,
                            });
                      } else if (foundFrag &&
                          fragmentTracker.getState(foundFrag) ===
                          __WEBPACK_IMPORTED_MODULE_5__fragment_tracker__['a' /* FragmentState */].NOT_LOADED) {
                        // only load if fragment is not loaded
                        this.fragCurrent = foundFrag;
                        this.state = __WEBPACK_IMPORTED_MODULE_6__base_stream_controller__['a' /* State */].FRAG_LOADING;
                        this.hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_0__events__['a' /* default */].FRAG_LOADING,
                            {
                              frag: foundFrag,
                            });
                      }
                    }
                  }
                };

                _proto.stopLoad = function stopLoad() {
                  this.lastAVStart = 0;

                  _BaseStreamController.prototype.stopLoad.call(this);
                };

                _proto._getBuffered = function _getBuffered() {
                  return this.tracksBuffered[this.currentTrackId] || [];
                };

                _proto.onMediaSeeking = function onMediaSeeking() {
                  this.fragPrevious = null;
                };

                return SubtitleStreamController;
              }(__WEBPACK_IMPORTED_MODULE_6__base_stream_controller__['b' /* default */]);

          /***/
        }),
        /* 80 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__event_handler__ = __webpack_require__(
              4);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(2);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__errors__ = __webpack_require__(3);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_4__utils_mediakeys_helper__ = __webpack_require__(
              33);

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(
              Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype,
                protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          /**
           * @author Stephan Hesse <disparat@gmail.com> | <tchakabam@gmail.com>
           *
           * DRM support for Hls.js
           */





          var MAX_LICENSE_REQUEST_FAILURES = 3;
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration
           * @param {Array<string>} audioCodecs List of required audio codecs to support
           * @param {Array<string>} videoCodecs List of required video codecs to support
           * @param {object} drmSystemOptions Optional parameters/requirements for the key-system
           * @returns {Array<MediaSystemConfiguration>} An array of supported configurations
           */

          var createWidevineMediaKeySystemConfigurations = function createWidevineMediaKeySystemConfigurations(
              audioCodecs, videoCodecs) {
            /* jshint ignore:line */
            var baseConfig = {
              // initDataTypes: ['keyids', 'mp4'],
              // label: "",
              // persistentState: "not-allowed", // or "required" ?
              // distinctiveIdentifier: "not-allowed", // or "required" ?
              // sessionTypes: ['temporary'],
              videoCapabilities: [], // { contentType: 'video/mp4; codecs="avc1.42E01E"' }

            };
            videoCodecs.forEach(function(codec) {
              baseConfig.videoCapabilities.push({
                contentType: 'video/mp4; codecs="' + codec + '"',
              });
            });
            return [baseConfig];
          };
          /**
           * The idea here is to handle key-system (and their respective platforms) specific configuration differences
           * in order to work with the local requestMediaKeySystemAccess method.
           *
           * We can also rule-out platform-related key-system support at this point by throwing an error.
           *
           * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
           * @param {Array<string>} audioCodecs List of required audio codecs to support
           * @param {Array<string>} videoCodecs List of required video codecs to support
           * @throws will throw an error if a unknown key system is passed
           * @returns {Array<MediaSystemConfiguration>} A non-empty Array of MediaKeySystemConfiguration objects
           */


          var getSupportedMediaKeySystemConfigurations = function getSupportedMediaKeySystemConfigurations(
              keySystem, audioCodecs, videoCodecs) {
            switch (keySystem) {
              case __WEBPACK_IMPORTED_MODULE_4__utils_mediakeys_helper__['a' /* KeySystems */].WIDEVINE:
                return createWidevineMediaKeySystemConfigurations(audioCodecs,
                    videoCodecs);

              default:
                throw new Error('Unknown key-system: ' + keySystem);
            }
          };

          /**
           * Controller to deal with encrypted media extensions (EME)
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API
           *
           * @class
           * @constructor
           */
          var EMEController =
              /*#__PURE__*/
              function(_EventHandler) {
                _inheritsLoose(EMEController, _EventHandler);

                /**
                 * @constructs
                 * @param {Hls} hls Our Hls.js instance
                 */
                function EMEController(hls) {
                  var _this;

                  _this = _EventHandler.call(this, hls,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MEDIA_ATTACHED,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MEDIA_DETACHED,
                      __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].MANIFEST_PARSED) ||
                      this;
                  _this._widevineLicenseUrl = void 0;
                  _this._licenseXhrSetup = void 0;
                  _this._emeEnabled = void 0;
                  _this._requestMediaKeySystemAccess = void 0;
                  _this._config = void 0;
                  _this._mediaKeysList = [];
                  _this._media = null;
                  _this._hasSetMediaKeys = false;
                  _this._requestLicenseFailureCount = 0;

                  _this._onMediaEncrypted = function(e) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                        'Media is encrypted using "' + e.initDataType +
                        '" init data type');

                    _this._attemptSetMediaKeys();

                    _this._generateRequestWithPreferredKeySession(
                        e.initDataType, e.initData);
                  };

                  _this._config = hls.config;
                  _this._widevineLicenseUrl = _this._config.widevineLicenseUrl;
                  _this._licenseXhrSetup = _this._config.licenseXhrSetup;
                  _this._emeEnabled = _this._config.emeEnabled;
                  _this._requestMediaKeySystemAccess = _this._config.requestMediaKeySystemAccessFunc;
                  return _this;
                }

                /**
                 * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
                 * @returns {string} License server URL for key-system (if any configured, otherwise causes error)
                 * @throws if a unsupported keysystem is passed
                 */


                var _proto = EMEController.prototype;

                _proto.getLicenseServerUrl = function getLicenseServerUrl(keySystem) {
                  switch (keySystem) {
                    case __WEBPACK_IMPORTED_MODULE_4__utils_mediakeys_helper__['a' /* KeySystems */].WIDEVINE:
                      if (!this._widevineLicenseUrl) {
                        break;
                      }

                      return this._widevineLicenseUrl;
                  }

                  throw new Error(
                      'no license server URL configured for key-system "' +
                      keySystem + '"');
                }
                /**
                 * Requests access object and adds it to our list upon success
                 * @private
                 * @param {string} keySystem System ID (see `KeySystems`)
                 * @param {Array<string>} audioCodecs List of required audio codecs to support
                 * @param {Array<string>} videoCodecs List of required video codecs to support
                 * @throws When a unsupported KeySystem is passed
                 */
                ;

                _proto._attemptKeySystemAccess = function _attemptKeySystemAccess(
                    keySystem, audioCodecs, videoCodecs) {
                  var _this2 = this;

                  // TODO: add other DRM "options"
                  // This can throw, but is caught in event handler callpath
                  var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(
                      keySystem, audioCodecs, videoCodecs);
                  __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                      'Requesting encrypted media key-system access'); // expecting interface like window.navigator.requestMediaKeySystemAccess

                  this.requestMediaKeySystemAccess(keySystem,
                      mediaKeySystemConfigs).
                      then(function(mediaKeySystemAccess) {
                        _this2._onMediaKeySystemAccessObtained(keySystem,
                            mediaKeySystemAccess);
                      }).
                      catch(function(err) {
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                            'Failed to obtain key-system "' + keySystem +
                            '" access:', err);
                      });
                };

                /**
                 * Handles obtaining access to a key-system
                 * @private
                 * @param {string} keySystem
                 * @param {MediaKeySystemAccess} mediaKeySystemAccess https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemAccess
                 */
                _proto._onMediaKeySystemAccessObtained = function _onMediaKeySystemAccessObtained(
                    keySystem, mediaKeySystemAccess) {
                  var _this3 = this;

                  __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                      'Access for key-system "' + keySystem + '" obtained');
                  var mediaKeysListItem = {
                    mediaKeysSessionInitialized: false,
                    mediaKeySystemAccess: mediaKeySystemAccess,
                    mediaKeySystemDomain: keySystem,
                  };

                  this._mediaKeysList.push(mediaKeysListItem);

                  mediaKeySystemAccess.createMediaKeys().
                      then(function(mediaKeys) {
                        mediaKeysListItem.mediaKeys = mediaKeys;
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                            'Media-keys created for key-system "' + keySystem +
                            '"');

                        _this3._onMediaKeysCreated();
                      }).
                      catch(function(err) {
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                            'Failed to create media-keys:', err);
                      });
                }
                /**
                 * Handles key-creation (represents access to CDM). We are going to create key-sessions upon this
                 * for all existing keys where no session exists yet.
                 *
                 * @private
                 */
                ;

                _proto._onMediaKeysCreated = function _onMediaKeysCreated() {
                  var _this4 = this;

                  // check for all key-list items if a session exists, otherwise, create one
                  this._mediaKeysList.forEach(function(mediaKeysListItem) {
                    if (!mediaKeysListItem.mediaKeysSession) {
                      // mediaKeys is definitely initialized here
                      mediaKeysListItem.mediaKeysSession = mediaKeysListItem.mediaKeys.createSession();

                      _this4._onNewMediaKeySession(
                          mediaKeysListItem.mediaKeysSession);
                    }
                  });
                }
                /**
                 * @private
                 * @param {*} keySession
                 */
                ;

                _proto._onNewMediaKeySession = function _onNewMediaKeySession(keySession) {
                  var _this5 = this;

                  __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                      'New key-system session ' + keySession.sessionId);
                  keySession.addEventListener('message', function(event) {
                    _this5._onKeySessionMessage(keySession, event.message);
                  }, false);
                }
                /**
                 * @private
                 * @param {MediaKeySession} keySession
                 * @param {ArrayBuffer} message
                 */
                ;

                _proto._onKeySessionMessage = function _onKeySessionMessage(
                    keySession, message) {
                  __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                      'Got EME message event, creating license request');

                  this._requestLicense(message, function(data) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                        'Received license data (length: ' +
                        (data ? data.byteLength : data) +
                        '), updating key-session');
                    keySession.update(data);
                  });
                }
                /**
                 * @private
                 * @param {string} initDataType
                 * @param {ArrayBuffer|null} initData
                 */
                ;

                /**
                 * @private
                 */
                _proto._attemptSetMediaKeys = function _attemptSetMediaKeys() {
                  if (!this._media) {
                    throw new Error(
                        'Attempted to set mediaKeys without first attaching a media element');
                  }

                  if (!this._hasSetMediaKeys) {
                    // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
                    var keysListItem = this._mediaKeysList[0];

                    if (!keysListItem || !keysListItem.mediaKeys) {
                      __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                          'Fatal: Media is encrypted but no CDM access or no keys have been obtained yet');
                      this.hls.trigger(
                          __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                          {
                            type: __WEBPACK_IMPORTED_MODULE_2__errors__['b' /* ErrorTypes */].KEY_SYSTEM_ERROR,
                            details: __WEBPACK_IMPORTED_MODULE_2__errors__['a' /* ErrorDetails */].KEY_SYSTEM_NO_KEYS,
                            fatal: true,
                          });
                      return;
                    }

                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                        'Setting keys for encrypted media');

                    this._media.setMediaKeys(keysListItem.mediaKeys);

                    this._hasSetMediaKeys = true;
                  }
                }
                /**
                 * @private
                 */
                ;

                _proto._generateRequestWithPreferredKeySession = function _generateRequestWithPreferredKeySession(
                    initDataType, initData) {
                  var _this6 = this;

                  // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
                  var keysListItem = this._mediaKeysList[0];

                  if (!keysListItem) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                        'Fatal: Media is encrypted but not any key-system access has been obtained yet');
                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_2__errors__['b' /* ErrorTypes */].KEY_SYSTEM_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_2__errors__['a' /* ErrorDetails */].KEY_SYSTEM_NO_ACCESS,
                          fatal: true,
                        });
                    return;
                  }

                  if (keysListItem.mediaKeysSessionInitialized) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                        'Key-Session already initialized but requested again');
                    return;
                  }

                  var keySession = keysListItem.mediaKeysSession;

                  if (!keySession) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                        'Fatal: Media is encrypted but no key-session existing');
                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_2__errors__['b' /* ErrorTypes */].KEY_SYSTEM_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_2__errors__['a' /* ErrorDetails */].KEY_SYSTEM_NO_SESSION,
                          fatal: true,
                        });
                    return;
                  } // initData is null if the media is not CORS-same-origin

                  if (!initData) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                        'Fatal: initData required for generating a key session is null');
                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_2__errors__['b' /* ErrorTypes */].KEY_SYSTEM_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_2__errors__['a' /* ErrorDetails */].KEY_SYSTEM_NO_INIT_DATA,
                          fatal: true,
                        });
                    return;
                  }

                  __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                      'Generating key-session request for "' + initDataType +
                      '" init data type');
                  keysListItem.mediaKeysSessionInitialized = true;
                  keySession.generateRequest(initDataType, initData).
                      then(function() {
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].debug(
                            'Key-session generation succeeded');
                      }).
                      catch(function(err) {
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                            'Error generating key-session request:', err);

                        _this6.hls.trigger(
                            __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                            {
                              type: __WEBPACK_IMPORTED_MODULE_2__errors__['b' /* ErrorTypes */].KEY_SYSTEM_ERROR,
                              details: __WEBPACK_IMPORTED_MODULE_2__errors__['a' /* ErrorDetails */].KEY_SYSTEM_NO_SESSION,
                              fatal: false,
                            });
                      });
                }
                /**
                 * @private
                 * @param {string} url License server URL
                 * @param {ArrayBuffer} keyMessage Message data issued by key-system
                 * @param {function} callback Called when XHR has succeeded
                 * @returns {XMLHttpRequest} Unsent (but opened state) XHR object
                 * @throws if XMLHttpRequest construction failed
                 */
                ;

                _proto._createLicenseXhr = function _createLicenseXhr(
                    url, keyMessage, callback) {
                  var xhr = new XMLHttpRequest();
                  var licenseXhrSetup = this._licenseXhrSetup;

                  try {
                    if (licenseXhrSetup) {
                      try {
                        licenseXhrSetup(xhr, url);
                      } catch (e) {
                        // let's try to open before running setup
                        xhr.open('POST', url, true);
                        licenseXhrSetup(xhr, url);
                      }
                    } // if licenseXhrSetup did not yet call open, let's do it now

                    if (!xhr.readyState) {
                      xhr.open('POST', url, true);
                    }
                  } catch (e) {
                    // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
                    throw new Error(
                        'issue setting up KeySystem license XHR ' + e);
                  } // Because we set responseType to ArrayBuffer here, callback is typed as handling only array buffers

                  xhr.responseType = 'arraybuffer';
                  xhr.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(
                      this, xhr, url, keyMessage, callback);
                  return xhr;
                }
                /**
                 * @private
                 * @param {XMLHttpRequest} xhr
                 * @param {string} url License server URL
                 * @param {ArrayBuffer} keyMessage Message data issued by key-system
                 * @param {function} callback Called when XHR has succeeded
                 */
                ;

                _proto._onLicenseRequestReadyStageChange = function _onLicenseRequestReadyStageChange(
                    xhr, url, keyMessage, callback) {
                  switch (xhr.readyState) {
                    case 4:
                      if (xhr.status === 200) {
                        this._requestLicenseFailureCount = 0;
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                            'License request succeeded');

                        if (xhr.responseType !== 'arraybuffer') {
                          __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                              'xhr response type was not set to the expected arraybuffer for license request');
                        }

                        callback(xhr.response);
                      } else {
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                            'License Request XHR failed (' + url +
                            '). Status: ' + xhr.status + ' (' + xhr.statusText +
                            ')');
                        this._requestLicenseFailureCount++;

                        if (this._requestLicenseFailureCount >
                            MAX_LICENSE_REQUEST_FAILURES) {
                          this.hls.trigger(
                              __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                              {
                                type: __WEBPACK_IMPORTED_MODULE_2__errors__['b' /* ErrorTypes */].KEY_SYSTEM_ERROR,
                                details: __WEBPACK_IMPORTED_MODULE_2__errors__['a' /* ErrorDetails */].KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                                fatal: true,
                              });
                          return;
                        }

                        var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES -
                            this._requestLicenseFailureCount + 1;
                        __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].warn(
                            'Retrying license request, ' + attemptsLeft +
                            ' attempts left');

                        this._requestLicense(keyMessage, callback);
                      }

                      break;
                  }
                }
                /**
                 * @private
                 * @param {MediaKeysListItem} keysListItem
                 * @param {ArrayBuffer} keyMessage
                 * @returns {ArrayBuffer} Challenge data posted to license server
                 * @throws if KeySystem is unsupported
                 */
                ;

                _proto._generateLicenseRequestChallenge = function _generateLicenseRequestChallenge(
                    keysListItem, keyMessage) {
                  switch (keysListItem.mediaKeySystemDomain) {
                      // case KeySystems.PLAYREADY:
                      // from https://github.com/MicrosoftEdge/Demos/blob/master/eme/scripts/demo.js

                      /*
        if (this.licenseType !== this.LICENSE_TYPE_WIDEVINE) {
          // For PlayReady CDMs, we need to dig the Challenge out of the XML.
          var keyMessageXml = new DOMParser().parseFromString(String.fromCharCode.apply(null, new Uint16Array(keyMessage)), 'application/xml');
          if (keyMessageXml.getElementsByTagName('Challenge')[0]) {
              challenge = atob(keyMessageXml.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue);
          } else {
              throw 'Cannot find <Challenge> in key message';
          }
          var headerNames = keyMessageXml.getElementsByTagName('name');
          var headerValues = keyMessageXml.getElementsByTagName('value');
          if (headerNames.length !== headerValues.length) {
              throw 'Mismatched header <name>/<value> pair in key message';
          }
          for (var i = 0; i < headerNames.length; i++) {
              xhr.setRequestHeader(headerNames[i].childNodes[0].nodeValue, headerValues[i].childNodes[0].nodeValue);
          }
        }
        break;
      */
                    case __WEBPACK_IMPORTED_MODULE_4__utils_mediakeys_helper__['a' /* KeySystems */].WIDEVINE:
                      // For Widevine CDMs, the challenge is the keyMessage.
                      return keyMessage;
                  }

                  throw new Error('unsupported key-system: ' +
                      keysListItem.mediaKeySystemDomain);
                }
                /**
                 * @private
                 * @param keyMessage
                 * @param callback
                 */
                ;

                _proto._requestLicense = function _requestLicense(
                    keyMessage, callback) {
                  __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                      'Requesting content license for key-system');
                  var keysListItem = this._mediaKeysList[0];

                  if (!keysListItem) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                        'Fatal error: Media is encrypted but no key-system access has been obtained yet');
                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_2__errors__['b' /* ErrorTypes */].KEY_SYSTEM_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_2__errors__['a' /* ErrorDetails */].KEY_SYSTEM_NO_ACCESS,
                          fatal: true,
                        });
                    return;
                  }

                  try {
                    var _url = this.getLicenseServerUrl(
                        keysListItem.mediaKeySystemDomain);

                    var _xhr = this._createLicenseXhr(_url, keyMessage,
                        callback);

                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].log(
                        'Sending license request to URL: ' + _url);

                    var challenge = this._generateLicenseRequestChallenge(
                        keysListItem, keyMessage);

                    _xhr.send(challenge);
                  } catch (e) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_logger__['b' /* logger */].error(
                        'Failure requesting DRM license: ' + e);
                    this.hls.trigger(
                        __WEBPACK_IMPORTED_MODULE_1__events__['a' /* default */].ERROR,
                        {
                          type: __WEBPACK_IMPORTED_MODULE_2__errors__['b' /* ErrorTypes */].KEY_SYSTEM_ERROR,
                          details: __WEBPACK_IMPORTED_MODULE_2__errors__['a' /* ErrorDetails */].KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                          fatal: true,
                        });
                  }
                };

                _proto.onMediaAttached = function onMediaAttached(data) {
                  if (!this._emeEnabled) {
                    return;
                  }

                  var media = data.media; // keep reference of media

                  this._media = media;
                  media.addEventListener('encrypted', this._onMediaEncrypted);
                };

                _proto.onMediaDetached = function onMediaDetached() {
                  if (this._media) {
                    this._media.removeEventListener('encrypted',
                        this._onMediaEncrypted);

                    this._media = null; // release reference
                  }
                } // TODO: Use manifest types here when they are defined
                ;

                _proto.onManifestParsed = function onManifestParsed(data) {
                  if (!this._emeEnabled) {
                    return;
                  }

                  var audioCodecs = data.levels.map(function(level) {
                    return level.audioCodec;
                  });
                  var videoCodecs = data.levels.map(function(level) {
                    return level.videoCodec;
                  });

                  this._attemptKeySystemAccess(
                      __WEBPACK_IMPORTED_MODULE_4__utils_mediakeys_helper__['a' /* KeySystems */].WIDEVINE,
                      audioCodecs, videoCodecs);
                };

                _createClass(EMEController, [
                  {
                    key: 'requestMediaKeySystemAccess',
                    get: function get() {
                      if (!this._requestMediaKeySystemAccess) {
                        throw new Error(
                            'No requestMediaKeySystemAccess function configured');
                      }

                      return this._requestMediaKeySystemAccess;
                    },
                  }]);

                return EMEController;
              }(__WEBPACK_IMPORTED_MODULE_0__event_handler__['a' /* default */]);

          /* harmony default export */
          __webpack_exports__['a'] = (EMEController);

          /***/
        }),
        /* 81 */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

          'use strict';
          Object.defineProperty(__webpack_exports__, '__esModule',
              {value: true});
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_0__xhr_loader__ = __webpack_require__(
              31);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_1__observer__ = __webpack_require__(16);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_2__utils_logger__ = __webpack_require__(
              1);
          /* harmony import */
          var __WEBPACK_IMPORTED_MODULE_3__crypt_decrypter__ = __webpack_require__(
              12);

          function _inheritsLoose(
              subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          var XhrAesLoader =
              /*#__PURE__*/
              function(_XhrLoader) {
                _inheritsLoose(XhrAesLoader, _XhrLoader);

                function XhrAesLoader(config) {
                  var _this;

                  _this = _XhrLoader.call(this, config) || this;

                  if (config && config.aesSetup) {
                    _this.aesSetup = config.aesSetup;
                  }

                  _this.observer = new __WEBPACK_IMPORTED_MODULE_1__observer__['a' /* Observer */]();
                  _this.decrypter = new __WEBPACK_IMPORTED_MODULE_3__crypt_decrypter__['a' /* default */](
                      _this.observer, config);
                  return _this;
                }

                var _proto = XhrAesLoader.prototype;

                _proto.str2ab = function str2ab(str) {
                  var buf = new ArrayBuffer(str.length); // 2 bytes for each char

                  var bufView = new Uint8Array(buf);

                  for (var i = 0, strLen = str.length; i < strLen; i++) {
                    bufView[i] = str.charCodeAt(i);
                  }

                  return buf;
                };

                _proto.ab2str = function ab2str(buf) {
                  return String.fromCharCode.apply(null, new Uint8Array(buf));
                };

                _proto.load = function load(context, config, callbacks) {
                  var _this2 = this;

                  var needConvertToStr = context.responseType !== 'arraybuffer';
                  context.responseType = 'arraybuffer';

                  _XhrLoader.prototype.load.call(this, context, config,
                      callbacks);

                  var onSuccess = this.callbacks.onSuccess;

                  this.callbacks.onSuccess = function(
                      response, stats, context, xhr) {
                    _this2.decrypter.decrypt(response.data,
                        _this2.str2ab(_this2.aesSetup.key),
                        _this2.str2ab(_this2.aesSetup.iv),
                        function(decryptedData) {
                          response.data = needConvertToStr ? _this2.ab2str(
                              decryptedData) : decryptedData;

                          if (typeof onSuccess === 'function') {
                            onSuccess(response, stats, context, xhr);
                          }
                        });
                  };
                };

                return XhrAesLoader;
              }(__WEBPACK_IMPORTED_MODULE_0__xhr_loader__['a' /* default */]);

          /* harmony default export */
          __webpack_exports__['default'] = (XhrAesLoader);

          /***/
        })
        /******/]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAzZTE0MTQyZDk5NTY0MzgwMTcyMiIsIndlYnBhY2s6Ly8vLi9zcmMvcG9seWZpbGxzL251bWJlci1pc0Zpbml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy91dGlscy9sb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2Vycm9ycy50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9ldmVudC1oYW5kbGVyLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL2dldC1zZWxmLXNjb3BlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2RlbXV4L2lkMy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jb250cm9sbGVyL2xldmVsLWhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsLXRvb2xraXQvc3JjL3VybC10b29sa2l0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL2JpbmFyeS1zZWFyY2gudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY3J5cHQvZGVjcnlwdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2xvYWRlci9mcmFnbWVudC50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvb2JzZXJ2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy90eXBlcy9sb2FkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvZGVtdXgvbXA0ZGVtdXhlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9sb2FkZXIvbGV2ZWwta2V5LnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL2NvZGVjcy50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9kZW11eC9kZW11eGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2RlbXV4L2RlbXV4ZXItaW5saW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2RlbXV4L2FkdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvZGVtdXgvbXBlZ2F1ZGlvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL3RpbWUtcmFuZ2VzLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL2Rpc2NvbnRpbnVpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LWZpbmRlcnMudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdGFzay1sb29wLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL3hoci1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMvdnR0cGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL21lZGlha2V5cy1oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vbGliL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbGliL3ZpZGVvanMtaGxzanMtcGx1Z2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2hscy50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9sb2FkZXIvcGxheWxpc3QtbG9hZGVyLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2xvYWRlci9tM3U4LXBhcnNlci50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9sb2FkZXIvbGV2ZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMvYXR0ci1saXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2xvYWRlci9mcmFnbWVudC1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvbG9hZGVyL2tleS1sb2FkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2NyeXB0L2Flcy1jcnlwdG8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY3J5cHQvZmFzdC1hZXMta2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2NyeXB0L2Flcy1kZWNyeXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvZGVtdXgvYWFjZGVtdXhlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9kZW11eC90c2RlbXV4ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvZGVtdXgvZXhwLWdvbG9tYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9kZW11eC9zYW1wbGUtYWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2RlbXV4L21wM2RlbXV4ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvcmVtdXgvbXA0LXJlbXV4ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvcmVtdXgvYWFjLWhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9yZW11eC9tcDQtZ2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL3RpbWVzY2FsZS1jb252ZXJzaW9uLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3JlbXV4L3Bhc3N0aHJvdWdoLXJlbXV4ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvZGVtdXgvZGVtdXhlci13b3JrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY29udHJvbGxlci9nYXAtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jb250cm9sbGVyL2xldmVsLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9pcy1zdXBwb3J0ZWQudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY29uZmlnLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL2V3bWEudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY29udHJvbGxlci9hdWRpby10cmFjay1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMvY3Vlcy50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy91dGlscy92dHRjdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL2NlYS02MDgtcGFyc2VyLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL291dHB1dC1maWx0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMvd2VidnR0LXBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jb250cm9sbGVyL3N1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL3hoci1hZXMtbG9hZGVyLmpzIl0sIm5hbWVzIjpbImlzRmluaXRlTnVtYmVyIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ2YWx1ZSIsIm5vb3AiLCJmYWtlTG9nZ2VyIiwidHJhY2UiLCJkZWJ1ZyIsImxvZyIsIndhcm4iLCJpbmZvIiwiZXJyb3IiLCJleHBvcnRlZExvZ2dlciIsImZvcm1hdE1zZyIsInR5cGUiLCJtc2ciLCJnbG9iYWwiLCJjb25zb2xlUHJpbnRGbiIsImZ1bmMiLCJjb25zb2xlIiwiYXJncyIsImFwcGx5IiwiZXhwb3J0TG9nZ2VyRnVuY3Rpb25zIiwiZGVidWdDb25maWciLCJmdW5jdGlvbnMiLCJmb3JFYWNoIiwiYmluZCIsImVuYWJsZUxvZ3MiLCJlIiwibG9nZ2VyIiwiSGxzRXZlbnRzIiwiTUVESUFfQVRUQUNISU5HIiwiTUVESUFfQVRUQUNIRUQiLCJNRURJQV9ERVRBQ0hJTkciLCJNRURJQV9ERVRBQ0hFRCIsIkJVRkZFUl9SRVNFVCIsIkJVRkZFUl9DT0RFQ1MiLCJCVUZGRVJfQ1JFQVRFRCIsIkJVRkZFUl9BUFBFTkRJTkciLCJCVUZGRVJfQVBQRU5ERUQiLCJCVUZGRVJfRU9TIiwiQlVGRkVSX0ZMVVNISU5HIiwiQlVGRkVSX0ZMVVNIRUQiLCJNQU5JRkVTVF9MT0FESU5HIiwiTUFOSUZFU1RfTE9BREVEIiwiTUFOSUZFU1RfUEFSU0VEIiwiTEVWRUxfU1dJVENISU5HIiwiTEVWRUxfU1dJVENIRUQiLCJMRVZFTF9MT0FESU5HIiwiTEVWRUxfTE9BREVEIiwiTEVWRUxfVVBEQVRFRCIsIkxFVkVMX1BUU19VUERBVEVEIiwiQVVESU9fVFJBQ0tTX1VQREFURUQiLCJBVURJT19UUkFDS19TV0lUQ0hJTkciLCJBVURJT19UUkFDS19TV0lUQ0hFRCIsIkFVRElPX1RSQUNLX0xPQURJTkciLCJBVURJT19UUkFDS19MT0FERUQiLCJTVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCIsIlNVQlRJVExFX1RSQUNLX1NXSVRDSCIsIlNVQlRJVExFX1RSQUNLX0xPQURJTkciLCJTVUJUSVRMRV9UUkFDS19MT0FERUQiLCJTVUJUSVRMRV9GUkFHX1BST0NFU1NFRCIsIklOSVRfUFRTX0ZPVU5EIiwiRlJBR19MT0FESU5HIiwiRlJBR19MT0FEX1BST0dSRVNTIiwiRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVEIiwiRlJBR19MT0FERUQiLCJGUkFHX0RFQ1JZUFRFRCIsIkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQiLCJGUkFHX1BBUlNJTkdfVVNFUkRBVEEiLCJGUkFHX1BBUlNJTkdfTUVUQURBVEEiLCJGUkFHX1BBUlNJTkdfREFUQSIsIkZSQUdfUEFSU0VEIiwiRlJBR19CVUZGRVJFRCIsIkZSQUdfQ0hBTkdFRCIsIkZQU19EUk9QIiwiRlBTX0RST1BfTEVWRUxfQ0FQUElORyIsIkVSUk9SIiwiREVTVFJPWUlORyIsIktFWV9MT0FESU5HIiwiS0VZX0xPQURFRCIsIlNUUkVBTV9TVEFURV9UUkFOU0lUSU9OIiwiTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVEIiwiRXJyb3JUeXBlcyIsIkVycm9yRGV0YWlscyIsIkZPUkJJRERFTl9FVkVOVF9OQU1FUyIsIkV2ZW50SGFuZGxlciIsImhscyIsImhhbmRsZWRFdmVudHMiLCJ1c2VHZW5lcmljSGFuZGxlciIsIm9uRXZlbnQiLCJldmVudHMiLCJyZWdpc3Rlckxpc3RlbmVycyIsImRlc3Ryb3kiLCJvbkhhbmRsZXJEZXN0cm95aW5nIiwidW5yZWdpc3Rlckxpc3RlbmVycyIsIm9uSGFuZGxlckRlc3Ryb3llZCIsImlzRXZlbnRIYW5kbGVyIiwibGVuZ3RoIiwiZXZlbnQiLCJFcnJvciIsIm9uIiwib2ZmIiwiZGF0YSIsIm9uRXZlbnRHZW5lcmljIiwiZXZlbnRUb0Z1bmN0aW9uIiwiZnVuY05hbWUiLCJyZXBsYWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiY2FsbCIsImVyciIsIm1lc3NhZ2UiLCJ0cmlnZ2VyIiwiT1RIRVJfRVJST1IiLCJkZXRhaWxzIiwiSU5URVJOQUxfRVhDRVBUSU9OIiwiZmF0YWwiLCJnZXRTZWxmU2NvcGUiLCJ3aW5kb3ciLCJzZWxmIiwiQnVmZmVySGVscGVyIiwiaXNCdWZmZXJlZCIsIm1lZGlhIiwicG9zaXRpb24iLCJidWZmZXJlZCIsImkiLCJzdGFydCIsImVuZCIsImJ1ZmZlckluZm8iLCJwb3MiLCJtYXhIb2xlRHVyYXRpb24iLCJ2YnVmZmVyZWQiLCJwdXNoIiwiYnVmZmVyZWRJbmZvIiwibGVuIiwibmV4dFN0YXJ0IiwidW5kZWZpbmVkIiwic29ydCIsImEiLCJiIiwiZGlmZiIsImJ1ZmZlcmVkMiIsImJ1ZjJsZW4iLCJidWYyZW5kIiwiYnVmZmVyTGVuIiwiYnVmZmVyU3RhcnROZXh0IiwiYnVmZmVyU3RhcnQiLCJidWZmZXJFbmQiLCJGcmFnbWVudFN0YXRlIiwiTk9UX0xPQURFRCIsIkFQUEVORElORyIsIlBBUlRJQUwiLCJPSyIsIkZyYWdtZW50VHJhY2tlciIsImJ1ZmZlclBhZGRpbmciLCJmcmFnbWVudHMiLCJPYmplY3QiLCJjcmVhdGUiLCJ0aW1lUmFuZ2VzIiwiY29uZmlnIiwicHJvdG90eXBlIiwiZ2V0QnVmZmVyZWRGcmFnIiwibGV2ZWxUeXBlIiwiYnVmZmVyZWRGcmFncyIsImtleXMiLCJmaWx0ZXIiLCJrZXkiLCJmcmFnbWVudEVudGl0eSIsImJvZHkiLCJmcmFnIiwic3RhcnRQVFMiLCJlbmRQVFMiLCJidWZmZXJlZEZyYWdLZXkiLCJwb3AiLCJkZXRlY3RFdmljdGVkRnJhZ21lbnRzIiwiZWxlbWVudGFyeVN0cmVhbSIsInRpbWVSYW5nZSIsImZyYWdtZW50VGltZXMiLCJ0aW1lIiwiZXNEYXRhIiwicmFuZ2UiLCJpc1RpbWVCdWZmZXJlZCIsInJlbW92ZUZyYWdtZW50IiwiZGV0ZWN0UGFydGlhbEZyYWdtZW50cyIsImZyYWdtZW50IiwiZnJhZ0tleSIsImdldEZyYWdtZW50S2V5IiwiaGFzRWxlbWVudGFyeVN0cmVhbSIsImdldEJ1ZmZlcmVkVGltZXMiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiZnJhZ21lbnRQYXJ0aWFsIiwiTWF0aCIsIm1heCIsIm1pbiIsInBhcnRpYWwiLCJsZXZlbCIsInVybElkIiwic24iLCJnZXRQYXJ0aWFsRnJhZ21lbnQiLCJ0aW1lUGFkZGluZyIsImJlc3RGcmFnbWVudCIsImJlc3RPdmVybGFwIiwiaXNQYXJ0aWFsIiwiZ2V0U3RhdGUiLCJzdGF0ZSIsInZpZGVvIiwiYXVkaW8iLCJvbkZyYWdMb2FkZWQiLCJiaXRyYXRlVGVzdCIsIm9uQnVmZmVyQXBwZW5kZWQiLCJvbkZyYWdCdWZmZXJlZCIsImhhc0ZyYWdtZW50IiwicmVtb3ZlQWxsRnJhZ21lbnRzIiwiSUQzIiwiaXNIZWFkZXIiLCJvZmZzZXQiLCJpc0Zvb3RlciIsImdldElEM0RhdGEiLCJmcm9udCIsInNpemUiLCJfcmVhZFNpemUiLCJzdWJhcnJheSIsImdldFRpbWVTdGFtcCIsImZyYW1lcyIsImdldElEM0ZyYW1lcyIsImZyYW1lIiwiaXNUaW1lU3RhbXBGcmFtZSIsIl9yZWFkVGltZVN0YW1wIiwiX2dldEZyYW1lRGF0YSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImlkM0RhdGEiLCJmcmFtZURhdGEiLCJfZGVjb2RlRnJhbWUiLCJfZGVjb2RlUHJpdkZyYW1lIiwiX2RlY29kZVRleHRGcmFtZSIsIl9kZWNvZGVVUkxGcmFtZSIsInRpbWVTdGFtcEZyYW1lIiwiYnl0ZUxlbmd0aCIsIlVpbnQ4QXJyYXkiLCJwdHMzM0JpdCIsInRpbWVzdGFtcCIsInJvdW5kIiwib3duZXIiLCJfdXRmOEFycmF5VG9TdHIiLCJwcml2YXRlRGF0YSIsImJ1ZmZlciIsImluZGV4IiwiZGVzY3JpcHRpb24iLCJ0ZXh0IiwidXJsIiwiYXJyYXkiLCJleGl0T25OdWxsIiwiZGVjb2RlciIsImdldFRleHREZWNvZGVyIiwiZGVjb2RlZCIsImRlY29kZSIsImlkeCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJjIiwiY2hhcjIiLCJjaGFyMyIsIm91dCIsIlRleHREZWNvZGVyIiwidXRmOEFycmF5VG9TdHIiLCJhZGRHcm91cElkIiwiaWQiLCJhdWRpb0dyb3VwSWRzIiwidGV4dEdyb3VwSWRzIiwidXBkYXRlUFRTIiwiZnJvbUlkeCIsInRvSWR4IiwiZnJhZ0Zyb20iLCJmcmFnVG8iLCJmcmFnVG9QVFMiLCJkdXJhdGlvbiIsInVwZGF0ZUZyYWdQVFNEVFMiLCJzdGFydERUUyIsImVuZERUUyIsIm1heFN0YXJ0UFRTIiwiZGVsdGFQVFMiLCJhYnMiLCJkcmlmdCIsInN0YXJ0U04iLCJlbmRTTiIsImZyYWdJZHgiLCJQVFNLbm93biIsIm1lcmdlRGV0YWlscyIsIm9sZERldGFpbHMiLCJuZXdEZXRhaWxzIiwiaW5pdFNlZ21lbnQiLCJjY09mZnNldCIsIlBUU0ZyYWciLCJtYXBGcmFnbWVudEludGVyc2VjdGlvbiIsIm9sZEZyYWciLCJuZXdGcmFnIiwiY2MiLCJiYWNrdHJhY2tlZCIsImRyb3BwZWQiLCJuZXdGcmFnbWVudHMiLCJhZGp1c3RTbGlkaW5nIiwibWVyZ2VTdWJ0aXRsZVBsYXlsaXN0cyIsIm9sZFBsYXlsaXN0IiwibmV3UGxheWxpc3QiLCJyZWZlcmVuY2VTdGFydCIsImxhc3RJbmRleCIsImZyYWdzIiwiaW50ZXJzZWN0aW9uRm4iLCJkZWx0YSIsIm9sZEZyYWdtZW50cyIsImNvbXB1dGVSZWxvYWRJbnRlcnZhbCIsImN1cnJlbnRQbGF5bGlzdCIsImxhc3RSZXF1ZXN0VGltZSIsInJlbG9hZEludGVydmFsIiwiYXZlcmFnZXRhcmdldGR1cmF0aW9uIiwidGFyZ2V0ZHVyYXRpb24iLCJtaW5SZWxvYWRJbnRlcnZhbCIsInBlcmZvcm1hbmNlIiwibm93Iiwicm9vdCIsIlVSTF9SRUdFWCIsIkZJUlNUX1NFR01FTlRfUkVHRVgiLCJTTEFTSF9ET1RfUkVHRVgiLCJTTEFTSF9ET1RfRE9UX1JFR0VYIiwiVVJMVG9vbGtpdCIsImJ1aWxkQWJzb2x1dGVVUkwiLCJiYXNlVVJMIiwicmVsYXRpdmVVUkwiLCJvcHRzIiwidHJpbSIsImFsd2F5c05vcm1hbGl6ZSIsImJhc2VQYXJ0c0Zvck5vcm1hbGlzZSIsInBhcnNlVVJMIiwicGF0aCIsIm5vcm1hbGl6ZVBhdGgiLCJidWlsZFVSTEZyb21QYXJ0cyIsInJlbGF0aXZlUGFydHMiLCJzY2hlbWUiLCJiYXNlUGFydHMiLCJuZXRMb2MiLCJwYXRoUGFydHMiLCJleGVjIiwiYnVpbHRQYXJ0cyIsInBhcmFtcyIsInF1ZXJ5IiwiYmFzZVVSTFBhdGgiLCJuZXdQYXRoIiwibGFzdEluZGV4T2YiLCJwYXJ0cyIsInNwbGl0IiwicmV2ZXJzZSIsImpvaW4iLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVmaW5lIiwiYW1kIiwiQmluYXJ5U2VhcmNoIiwic2VhcmNoIiwibGlzdCIsImNvbXBhcmlzb25GbiIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJjdXJyZW50SW5kZXgiLCJjdXJyZW50RWxlbWVudCIsImNvbXBhcmlzb25SZXN1bHQiLCJEZWNyeXB0ZXIiLCJvYnNlcnZlciIsInJlbW92ZVBLQ1M3UGFkZGluZyIsImxvZ0VuYWJsZWQiLCJicm93c2VyQ3J5cHRvIiwiY3J5cHRvIiwic3VidGxlIiwid2Via2l0U3VidGxlIiwiZGlzYWJsZVdlYkNyeXB0byIsImlzU3luYyIsImVuYWJsZVNvZnR3YXJlQUVTIiwiZGVjcnlwdCIsIml2IiwiY2FsbGJhY2siLCJkZWNyeXB0b3IiLCJleHBhbmRLZXkiLCJmYXN0QWVzS2V5IiwidGhlbiIsImFlc0tleSIsImNhdGNoIiwib25XZWJDcnlwdG9FcnJvciIsInJlc3VsdCIsIk1FRElBX0VSUk9SIiwiRlJBR19ERUNSWVBUX0VSUk9SIiwicmVhc29uIiwiRWxlbWVudGFyeVN0cmVhbVR5cGVzIiwiRnJhZ21lbnQiLCJfdXJsIiwiX2J5dGVSYW5nZSIsIl9kZWNyeXB0ZGF0YSIsIl9lbGVtZW50YXJ5U3RyZWFtcyIsIkFVRElPIiwiVklERU8iLCJyYXdQcm9ncmFtRGF0ZVRpbWUiLCJwcm9ncmFtRGF0ZVRpbWUiLCJ0aXRsZSIsInRhZ0xpc3QiLCJyZWx1cmwiLCJiYXNldXJsIiwibGV2ZWxrZXkiLCJsb2FkZXIiLCJzZXRCeXRlUmFuZ2UiLCJwcmV2aW91c0ZyYWciLCJieXRlUmFuZ2UiLCJieXRlUmFuZ2VFbmRPZmZzZXQiLCJwYXJzZUludCIsImFkZEVsZW1lbnRhcnlTdHJlYW0iLCJjcmVhdGVJbml0aWFsaXphdGlvblZlY3RvciIsInNlZ21lbnROdW1iZXIiLCJ1aW50OFZpZXciLCJzZXREZWNyeXB0RGF0YUZyb21MZXZlbEtleSIsImRlY3J5cHRkYXRhIiwibWV0aG9kIiwidXJpIiwiYmFzZXVyaSIsInJlbHVyaSIsImhhcyIsImhhc093blByb3BlcnR5IiwicHJlZml4IiwiRXZlbnRzIiwiX19wcm90b19fIiwiRUUiLCJmbiIsImNvbnRleHQiLCJvbmNlIiwiYWRkTGlzdGVuZXIiLCJlbWl0dGVyIiwiVHlwZUVycm9yIiwibGlzdGVuZXIiLCJldnQiLCJfZXZlbnRzIiwiX2V2ZW50c0NvdW50IiwiY2xlYXJFdmVudCIsIkV2ZW50RW1pdHRlciIsImV2ZW50TmFtZXMiLCJuYW1lcyIsInNsaWNlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiY29uY2F0IiwibGlzdGVuZXJzIiwiaGFuZGxlcnMiLCJsIiwiZWUiLCJBcnJheSIsImxpc3RlbmVyQ291bnQiLCJlbWl0IiwiYTEiLCJhMiIsImEzIiwiYTQiLCJhNSIsImFyZ3VtZW50cyIsInJlbW92ZUxpc3RlbmVyIiwiaiIsInJlbW92ZUFsbExpc3RlbmVycyIsInByZWZpeGVkIiwiZ2V0TWVkaWFTb3VyY2UiLCJNZWRpYVNvdXJjZSIsIldlYktpdE1lZGlhU291cmNlIiwiT2JzZXJ2ZXIiLCJTdGF0ZSIsIlNUT1BQRUQiLCJTVEFSVElORyIsIklETEUiLCJQQVVTRUQiLCJGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWSIsIldBSVRJTkdfVFJBQ0siLCJQQVJTSU5HIiwiUEFSU0VEIiwiRU5ERUQiLCJXQUlUSU5HX0lOSVRfUFRTIiwiV0FJVElOR19MRVZFTCIsIkJhc2VTdHJlYW1Db250cm9sbGVyIiwiZG9UaWNrIiwic3RhcnRMb2FkIiwic3RvcExvYWQiLCJmcmFnQ3VycmVudCIsImFib3J0IiwiZnJhZ21lbnRUcmFja2VyIiwiZGVtdXhlciIsImZyYWdQcmV2aW91cyIsImNsZWFySW50ZXJ2YWwiLCJjbGVhck5leHRUaWNrIiwiX3N0cmVhbUVuZGVkIiwibGV2ZWxEZXRhaWxzIiwibGl2ZSIsImZyYWdTdGF0ZSIsIm9uTWVkaWFTZWVraW5nIiwibWVkaWFCdWZmZXIiLCJjdXJyZW50VGltZSIsIm1heEJ1ZmZlckhvbGUiLCJ0b0ZpeGVkIiwidG9sZXJhbmNlIiwibWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSIsImZyYWdTdGFydE9mZnNldCIsImZyYWdFbmRPZmZzZXQiLCJsYXN0Q3VycmVudFRpbWUiLCJsb2FkZWRtZXRhZGF0YSIsIm5leHRMb2FkUG9zaXRpb24iLCJzdGFydFBvc2l0aW9uIiwidGljayIsIm9uTWVkaWFFbmRlZCIsImNvbXB1dGVMaXZlUG9zaXRpb24iLCJzbGlkaW5nIiwidGFyZ2V0TGF0ZW5jeSIsImxpdmVTeW5jRHVyYXRpb24iLCJsaXZlU3luY0R1cmF0aW9uQ291bnQiLCJ0b3RhbGR1cmF0aW9uIiwic2VuZEFkZFRyYWNrRXZlbnQiLCJ0cmFjayIsInZpZGVvRWwiLCJFdmVudCIsImRvY3VtZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiY2xlYXJDdXJyZW50Q3VlcyIsImN1ZXMiLCJyZW1vdmVDdWUiLCJnZXRDbG9zZXN0Q3VlIiwibGVmdCIsInJpZ2h0IiwibWlkIiwiZmxvb3IiLCJQbGF5bGlzdENvbnRleHRUeXBlIiwiUGxheWxpc3RMZXZlbFR5cGUiLCJVSU5UMzJfTUFYIiwicG93IiwiTVA0RGVtdXhlciIsInJlbXV4ZXIiLCJyZXNldFRpbWVTdGFtcCIsImluaXRQVFMiLCJyZXNldEluaXRTZWdtZW50IiwiYXVkaW9Db2RlYyIsInZpZGVvQ29kZWMiLCJpbml0RGF0YSIsInBhcnNlSW5pdFNlZ21lbnQiLCJ0cmFja3MiLCJhdWRpb3ZpZGVvIiwiY29udGFpbmVyIiwiY29kZWMiLCJwcm9iZSIsImZpbmRCb3giLCJiaW4yc3RyIiwicmVhZFVpbnQxNiIsInZhbCIsInJlYWRVaW50MzIiLCJ3cml0ZVVpbnQzMiIsInJlc3VsdHMiLCJzdWJyZXN1bHRzIiwiZW5kYm94IiwicGFyc2VTZWdtZW50SW5kZXgiLCJtb292IiwibW9vdkVuZE9mZnNldCIsInNpZHgiLCJyZWZlcmVuY2VzIiwidmVyc2lvbiIsInRpbWVzY2FsZSIsImVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSIsImZpcnN0T2Zmc2V0Iiwic3RhcnRCeXRlIiwicmVmZXJlbmNlc0NvdW50IiwicmVmZXJlbmNlSW5kZXgiLCJyZWZlcmVuY2VJbmZvIiwicmVmZXJlbmNlU2l6ZSIsInJlZmVyZW5jZVR5cGUiLCJzdWJzZWdtZW50RHVyYXRpb24iLCJ0cmFrcyIsInRyYWsiLCJ0a2hkIiwidHJhY2tJZCIsIm1kaGQiLCJoZGxyIiwiaGRsclR5cGUiLCJjb2RlY0JveCIsImNvZGVjVHlwZSIsImdldFN0YXJ0RFRTIiwidHJhZnMiLCJiYXNlVGltZXMiLCJtYXAiLCJ0cmFmIiwidGZoZCIsInNjYWxlIiwiYmFzZVRpbWUiLCJ0ZmR0Iiwib2Zmc2V0U3RhcnREVFMiLCJ0aW1lT2Zmc2V0IiwiYmFzZU1lZGlhRGVjb2RlVGltZSIsInVwcGVyIiwibG93ZXIiLCJhcHBlbmQiLCJjb250aWd1b3VzIiwiYWNjdXJhdGVUaW1lT2Zmc2V0IiwicmVtdXgiLCJMZXZlbEtleSIsImJhc2VVUkkiLCJyZWxhdGl2ZVVSSSIsIl91cmkiLCJzYW1wbGVFbnRyeUNvZGVzSVNPIiwiaXNDb2RlY1R5cGUiLCJ0eXBlQ29kZXMiLCJpc0NvZGVjU3VwcG9ydGVkSW5NcDQiLCJpc1R5cGVTdXBwb3J0ZWQiLCJEZW11eGVyIiwiZm9yd2FyZE1lc3NhZ2UiLCJldiIsInR5cGVTdXBwb3J0ZWQiLCJtcDQiLCJtcGVnIiwibXAzIiwidmVuZG9yIiwibmF2aWdhdG9yIiwiZW5hYmxlV29ya2VyIiwiV29ya2VyIiwidyIsIm9ud21zZyIsIm9uV29ya2VyTWVzc2FnZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmVycm9yIiwiZmlsZW5hbWUiLCJsaW5lbm8iLCJwb3N0TWVzc2FnZSIsImNtZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJVUkwiLCJyZXZva2VPYmplY3RVUkwiLCJvYmplY3RVUkwiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidGVybWluYXRlIiwiZGVmYXVsdEluaXRQVFMiLCJsYXN0RnJhZyIsImRpc2NvbnRpbnVpdHkiLCJ0cmFja1N3aXRjaCIsIm5leHRTTiIsIkFycmF5QnVmZmVyIiwiZGF0YTEiLCJkYXRhMiIsIkRhdGUiLCJEZW11eGVySW5saW5lIiwiZGVjcnlwdGVyIiwiZGVjcnlwdGVkRGF0YSIsInN0YXRzIiwidHN0YXJ0IiwidGRlY3J5cHQiLCJwdXNoRGVjcnlwdGVkIiwibXV4Q29uZmlnIiwiZGVtdXgiLCJNUDRSZW11eGVyIiwiUGFzc1Rocm91Z2hSZW11eGVyIiwibXV4IiwiRlJBR19QQVJTSU5HX0VSUk9SIiwic2V0RGVjcnlwdERhdGEiLCJnZXRBdWRpb0NvbmZpZyIsImFkdHNPYmplY3RUeXBlIiwiYWR0c1NhbXBsZWluZ0luZGV4IiwiYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4IiwiYWR0c0NoYW5lbENvbmZpZyIsInVzZXJBZ2VudCIsInRvTG93ZXJDYXNlIiwibWFuaWZlc3RDb2RlYyIsImFkdHNTYW1wbGVpbmdSYXRlcyIsInRlc3QiLCJzYW1wbGVyYXRlIiwiY2hhbm5lbENvdW50IiwiaXNIZWFkZXJQYXR0ZXJuIiwiZ2V0SGVhZGVyTGVuZ3RoIiwiZ2V0RnVsbEZyYW1lTGVuZ3RoIiwiaGVhZGVyTGVuZ3RoIiwiZnJhbWVMZW5ndGgiLCJuZXdPZmZzZXQiLCJpbml0VHJhY2tDb25maWciLCJnZXRGcmFtZUR1cmF0aW9uIiwicGFyc2VGcmFtZUhlYWRlciIsInB0cyIsImZyYW1lSW5kZXgiLCJmcmFtZUR1cmF0aW9uIiwic3RhbXAiLCJhcHBlbmRGcmFtZSIsImhlYWRlciIsImFhY1NhbXBsZSIsInVuaXQiLCJkdHMiLCJzYW1wbGVzIiwic2FtcGxlIiwiTXBlZ0F1ZGlvIiwiQml0cmF0ZXNNYXAiLCJTYW1wbGluZ1JhdGVNYXAiLCJTYW1wbGVzQ29lZmZpY2llbnRzIiwiQnl0ZXNJblNsb3QiLCJwYXJzZUhlYWRlciIsInNhbXBsZXNQZXJGcmFtZSIsInNhbXBsZVJhdGUiLCJoZWFkZXJCIiwiaGVhZGVyQyIsImhlYWRlckUiLCJoZWFkZXJGIiwiaGVhZGVyRyIsImNvbHVtbkluQml0cmF0ZXMiLCJiaXRSYXRlIiwiY29sdW1uSW5TYW1wbGVSYXRlcyIsInNhbXBsZUNvZWZmaWNpZW50IiwiYnl0ZXNJblNsb3QiLCJUaW1lUmFuZ2VzIiwidG9TdHJpbmciLCJyIiwiZmluZEZpcnN0RnJhZ1dpdGhDQyIsImZpcnN0RnJhZyIsImN1cnJlbnRGcmFnIiwiZmluZEZyYWdXaXRoQ0MiLCJDQyIsImNhbmRpZGF0ZSIsInNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMiLCJsYXN0TGV2ZWwiLCJzaG91bGRBbGlnbiIsImVuZENDIiwic3RhcnRDQyIsImZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyIsInByZXZEZXRhaWxzIiwiY3VyRGV0YWlscyIsInByZXZGcmFncyIsImN1ckZyYWdzIiwicHJldlN0YXJ0RnJhZyIsImFkanVzdFB0cyIsImFsaWduU3RyZWFtIiwiYWxpZ25EaXNjb250aW51aXRpZXMiLCJhbGlnblBEVCIsInJlZmVyZW5jZUZyYWciLCJsYXN0RGV0YWlscyIsImhhc1Byb2dyYW1EYXRlVGltZSIsImxhc3RQRFQiLCJuZXdQRFQiLCJmaW5kRnJhZ21lbnRCeVBEVCIsIlBEVFZhbHVlIiwiaXNBcnJheSIsInN0YXJ0UERUIiwiZW5kUERUIiwiZW5kUHJvZ3JhbURhdGVUaW1lIiwic2VnIiwicGR0V2l0aGluVG9sZXJhbmNlVGVzdCIsImZpbmRGcmFnbWVudEJ5UFRTIiwiZnJhZ05leHQiLCJmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QiLCJjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UiLCJwZHRCdWZmZXJFbmQiLCJUYXNrTG9vcCIsIl9ib3VuZFRpY2siLCJfdGlja1RpbWVyIiwiX3RpY2tJbnRlcnZhbCIsIl90aWNrQ2FsbENvdW50IiwiaGFzSW50ZXJ2YWwiLCJoYXNOZXh0VGljayIsInNldEludGVydmFsIiwibWlsbGlzIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIlhNTEh0dHBSZXF1ZXN0IiwiWGhyTG9hZGVyIiwieGhyU2V0dXAiLCJyZWFkeVN0YXRlIiwiYWJvcnRlZCIsInJlcXVlc3RUaW1lb3V0IiwicmV0cnlUaW1lb3V0IiwibG9hZCIsImNhbGxiYWNrcyIsInRyZXF1ZXN0IiwicmV0cnkiLCJyZXRyeURlbGF5IiwibG9hZEludGVybmFsIiwieGhyIiwidGZpcnN0IiwibG9hZGVkIiwib3BlbiIsIm9uRXJyb3IiLCJjb2RlIiwic3RhdHVzIiwicmFuZ2VFbmQiLCJzZXRSZXF1ZXN0SGVhZGVyIiwicmFuZ2VTdGFydCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5c3RhdGVjaGFuZ2UiLCJvbnByb2dyZXNzIiwibG9hZHByb2dyZXNzIiwicmVzcG9uc2VUeXBlIiwibG9hZHRpbWVvdXQiLCJ0aW1lb3V0Iiwic2VuZCIsImN1cnJlbnRUYXJnZXQiLCJ0bG9hZCIsInJlc3BvbnNlIiwicmVzcG9uc2VUZXh0IiwidG90YWwiLCJyZXNwb25zZVVSTCIsIm9uU3VjY2VzcyIsIm1heFJldHJ5Iiwic3RhdHVzVGV4dCIsIm1heFJldHJ5RGVsYXkiLCJvblRpbWVvdXQiLCJsZW5ndGhDb21wdXRhYmxlIiwib25Qcm9ncmVzcyIsIlN0cmluZ0RlY29kZXIiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJWVFRQYXJzZXIiLCJyZWdpb25MaXN0IiwicGFyc2VUaW1lU3RhbXAiLCJpbnB1dCIsImNvbXB1dGVTZWNvbmRzIiwiaCIsIm0iLCJzIiwiZiIsIm1hdGNoIiwiU2V0dGluZ3MiLCJ2YWx1ZXMiLCJzZXQiLCJrIiwidiIsImdldCIsImRmbHQiLCJkZWZhdWx0S2V5IiwiYWx0IiwibiIsImludGVnZXIiLCJwZXJjZW50IiwicGFyc2VGbG9hdCIsInBhcnNlT3B0aW9ucyIsImtleVZhbHVlRGVsaW0iLCJncm91cERlbGltIiwiZ3JvdXBzIiwia3YiLCJkZWZhdWx0cyIsImNlbnRlciIsImFsaWduIiwicGFyc2VDdWUiLCJjdWUiLCJvSW5wdXQiLCJjb25zdW1lVGltZVN0YW1wIiwidHMiLCJjb25zdW1lQ3VlU2V0dGluZ3MiLCJzZXR0aW5ncyIsInJlZ2lvbiIsInZhbHMiLCJ2YWxzMCIsInZlcnRpY2FsIiwibGluZSIsImxpbmVBbGlnbiIsInNuYXBUb0xpbmVzIiwic2tpcFdoaXRlc3BhY2UiLCJzdWJzdHIiLCJmaXhMaW5lQnJlYWtzIiwicGFyc2UiLCJzdHJlYW0iLCJjb2xsZWN0TmV4dExpbmUiLCJhbHJlYWR5Q29sbGVjdGVkTGluZSIsImhhc1N1YnN0cmluZyIsIm9uY3VlIiwiZmx1c2giLCJvbmZsdXNoIiwiS2V5U3lzdGVtcyIsInJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyIsInZqc1BsdWdpbiIsInZpZGVvanMiLCJyZWdpc3RlckNvbmZpZ1BsdWdpbiIsInJlZ2lzdGVyU291cmNlSGFuZGxlciIsInJlZ2lzdGVyIiwiSGxzanMiLCJkZWZhdWx0IiwiWGhyQWVzTG9hZGVyIiwiaG9va3MiLCJIdG1sNUhsc2pzIiwic291cmNlIiwidGVjaCIsIm5hbWVfIiwiX3ZpZGVvIiwiZWwiLCJfaGxzIiwiX2Vycm9yQ291bnRzIiwiX2R1cmF0aW9uIiwiX2R2cmNoZWNrIiwiX21ldGFkYXRhIiwiX3BsYXllciIsIm9wdGlvbnNfIiwicGxheWVySWQiLCJfZXhlY3V0ZUhvb2tzRm9yIiwiX2hhbmRsZU1lZGlhRXJyb3IiLCJyZWNvdmVyTWVkaWFFcnJvciIsInN3YXBBdWRpb0NvZGVjIiwiX29uRXJyb3IiLCJORVRXT1JLX0VSUk9SIiwic3dpdGNoUXVhbGl0eSIsInF1YWxpdHlJZCIsImxldmVsU3dpdGNoU3RyYXRlZ3kiLCJjdXJyZW50TGV2ZWwiLCJuZXh0TGV2ZWwiLCJsb2FkTGV2ZWwiLCJfbGV2ZWxMYWJlbCIsImhlaWdodCIsIndpZHRoIiwiYml0cmF0ZSIsIl9ub3RpZnlWaWRlb1F1YWxpdGllcyIsImNsZWFuVHJhY2tsaXN0IiwibGV2ZWxzIiwiYXV0b0xldmVsIiwibGFiZWwiLCJzZWxlY3RlZCIsIm1hbnVhbExldmVsIiwicXVhbGl0eSIsInBheWxvYWQiLCJxdWFsaXR5RGF0YSIsInF1YWxpdHlTd2l0Y2hDYWxsYmFjayIsIl91cGRhdGVIbHNqc0F1ZGlvVHJhY2siLCJwbGF5ZXJBdWRpb1RyYWNrcyIsImF1ZGlvVHJhY2tzIiwiZW5hYmxlZCIsImF1ZGlvVHJhY2siLCJfb25BdWRpb1RyYWNrcyIsImhsc0F1ZGlvVHJhY2tzIiwiYWRkVHJhY2siLCJBdWRpb1RyYWNrIiwia2luZCIsImxhbmciLCJsYW5ndWFnZSIsIl91cGRhdGVIbHNqc1RleHRUcmFjayIsInBsYXllclRleHRUcmFja3MiLCJ0ZXh0VHJhY2tzIiwiYWN0aXZlVHJhY2siLCJtb2RlIiwiaGxzanNUcmFja3MiLCJobHNUcmFja0lkIiwidmpzVHJhY2tJZCIsIl9zdG9wTG9hZGluZ0NodW5rcyIsImlzTGl2ZSIsIl9sb2FkTWFuaWZlc3QiLCJwbGF5IiwiX3N0YXJ0TG9hZCIsIl9vbmVMZXZlbE9iakNsb25lIiwib2JqIiwib2JqS2V5cyIsIl9maWx0ZXJUZXh0VHJhY2tzIiwiZGlzcGxheWFibGVUcmFja3MiLCJfb25BZGRUZXh0VHJhY2siLCJobHNqc1RleHRUcmFjayIsImFkZFJlbW90ZVRleHRUcmFjayIsInNyY2xhbmciLCJfb25MZXZlbExvYWQiLCJJbmZpbml0eSIsInN0cmVhbUNvbnRyb2xsZXIiLCJtYXhNYXhCdWZmZXJMZW5ndGgiLCJfb25NZXRhRGF0YSIsIl9pbml0SGxzanMiLCJobHNqc0NvbmZpZ1JlZiIsImhsc2pzQ29uZmlnIiwiYWVzU2V0dXAiLCJwTG9hZGVyIiwiZkxvYWRlciIsInByZWxvYWQiLCJhdXRvcGxheSIsImF1dG9TdGFydExvYWQiLCJhdHRhY2hNZWRpYSIsImxvYWRTb3VyY2UiLCJzcmMiLCJpbml0aWFsaXplIiwiZ2V0UXVhbGl0eSIsImxldmVsQ29udHJvbGxlciIsImFzc2lnbiIsImRpc3Bvc2UiLCJlcnJvclR4dCIsIm1lZGlhRXJyb3IiLCJNRURJQV9FUlJfQUJPUlRFRCIsIk1FRElBX0VSUl9ERUNPREUiLCJNRURJQV9FUlJfTkVUV09SSyIsIk1FRElBX0VSUl9TUkNfTk9UX1NVUFBPUlRFRCIsImFkZEhvb2siLCJyZW1vdmVIb29rIiwic3BsaWNlIiwiaXNTdXBwb3J0ZWQiLCJodG1sNSIsImdldFRlY2giLCJnZXRDb21wb25lbnQiLCJjYW5IYW5kbGVTb3VyY2UiLCJobHNUeXBlUkUiLCJobHNFeHRSRSIsImhhbmRsZVNvdXJjZSIsImhsc1Byb3ZpZGVyIiwic3RyZWFtcm9vdEhsc2pzQ29uZmlnSGFuZGxlciIsIm9wdGlvbnMiLCJwbGF5ZXIiLCJyZWdpc3RlclZqc1BsdWdpbiIsInJlZ2lzdGVyUGx1Z2luIiwicGx1Z2luIiwiSGxzIiwiZGVmYXVsdENvbmZpZyIsInVzZXJDb25maWciLCJfYXV0b0xldmVsQ2FwcGluZyIsImFickNvbnRyb2xsZXIiLCJjYXBMZXZlbENvbnRyb2xsZXIiLCJuZXR3b3JrQ29udHJvbGxlcnMiLCJhdWRpb1RyYWNrQ29udHJvbGxlciIsInN1YnRpdGxlVHJhY2tDb250cm9sbGVyIiwiZW1lQ29udHJvbGxlciIsImNvcmVDb21wb25lbnRzIiwiRGVmYXVsdENvbmZpZyIsImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCIsImxpdmVNYXhMYXRlbmN5RHVyYXRpb24iLCJidWZmZXJDb250cm9sbGVyIiwiZnBzQ29udHJvbGxlciIsInBsYXlMaXN0TG9hZGVyIiwiZnJhZ21lbnRMb2FkZXIiLCJrZXlMb2FkZXIiLCJpZDNUcmFja0NvbnRyb2xsZXIiLCJDb250cm9sbGVyIiwiYXVkaW9TdHJlYW1Db250cm9sbGVyIiwic3VidGl0bGVTdHJlYW1Db250cm9sbGVyIiwidGltZWxpbmVDb250cm9sbGVyIiwiZGV0YWNoTWVkaWEiLCJjb21wb25lbnQiLCJsb2NhdGlvbiIsImhyZWYiLCJjb250cm9sbGVyIiwibmV3TGV2ZWwiLCJpbW1lZGlhdGVMZXZlbFN3aXRjaCIsIm5leHRMZXZlbFN3aXRjaCIsIm5leHRMb2FkTGV2ZWwiLCJmaXJzdExldmVsIiwibWluQXV0b0xldmVsIiwic3RhcnRMZXZlbCIsInNob3VsZFN0YXJ0Q2FwcGluZyIsIm5ld0NhcExldmVsVG9QbGF5ZXJTaXplIiwiY2FwTGV2ZWxUb1BsYXllclNpemUiLCJzdGFydENhcHBpbmciLCJzdG9wQ2FwcGluZyIsImF1dG9MZXZlbENhcHBpbmciLCJid0VzdGltYXRvciIsIl9id0VzdGltYXRvciIsImdldEVzdGltYXRlIiwiTmFOIiwibWluQXV0b0JpdHJhdGUiLCJsZXZlbE5leHRCaXRyYXRlIiwicmVhbEJpdHJhdGUiLCJtYXhBdXRvTGV2ZWwiLCJuZXh0QXV0b0xldmVsIiwiYXVkaW9UcmFja0lkIiwibGl2ZVN5bmNQb3NpdGlvbiIsInN1YnRpdGxlVHJhY2tzIiwic3VidGl0bGVUcmFjayIsInN1YnRpdGxlVHJhY2tJZCIsInN1YnRpdGxlRGlzcGxheSIsIlBsYXlsaXN0TG9hZGVyIiwibG9hZGVycyIsImNhbkhhdmVRdWFsaXR5TGV2ZWxzIiwiQVVESU9fVFJBQ0siLCJTVUJUSVRMRV9UUkFDSyIsIm1hcENvbnRleHRUb0xldmVsVHlwZSIsIlNVQlRJVExFIiwiTUFJTiIsImdldFJlc3BvbnNlVXJsIiwiY3JlYXRlSW50ZXJuYWxMb2FkZXIiLCJQTG9hZGVyIiwiTG9hZGVyIiwiSW50ZXJuYWxMb2FkZXIiLCJnZXRJbnRlcm5hbExvYWRlciIsInJlc2V0SW50ZXJuYWxMb2FkZXIiLCJjb250ZXh0VHlwZSIsImRlc3Ryb3lJbnRlcm5hbExvYWRlcnMiLCJvbk1hbmlmZXN0TG9hZGluZyIsIk1BTklGRVNUIiwib25MZXZlbExvYWRpbmciLCJMRVZFTCIsIm9uQXVkaW9UcmFja0xvYWRpbmciLCJvblN1YnRpdGxlVHJhY2tMb2FkaW5nIiwibG9hZGVyQ29udGV4dCIsIm1hbmlmZXN0TG9hZGluZ01heFJldHJ5IiwibWFuaWZlc3RMb2FkaW5nVGltZU91dCIsIm1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXkiLCJtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQiLCJsZXZlbExvYWRpbmdUaW1lT3V0IiwibGV2ZWxMb2FkaW5nTWF4UmV0cnkiLCJsZXZlbExvYWRpbmdSZXRyeURlbGF5IiwibGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0IiwibG9hZGVyQ29uZmlnIiwibG9hZGVyQ2FsbGJhY2tzIiwibG9hZHN1Y2Nlc3MiLCJsb2FkZXJyb3IiLCJuZXR3b3JrRGV0YWlscyIsImlzU2lkeFJlcXVlc3QiLCJfaGFuZGxlU2lkeFJlcXVlc3QiLCJfaGFuZGxlUGxheWxpc3RMb2FkZWQiLCJzdHJpbmciLCJfaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IiLCJfaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QiLCJfaGFuZGxlTWFzdGVyUGxheWxpc3QiLCJfaGFuZGxlTmV0d29ya0Vycm9yIiwicGFyc2VNYXN0ZXJQbGF5bGlzdCIsImF1ZGlvR3JvdXBzIiwiYXR0cnMiLCJwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEiLCJzdWJ0aXRsZXMiLCJlbWJlZGRlZEF1ZGlvRm91bmQiLCJ1bnNoaWZ0IiwiYXV0b3NlbGVjdCIsImZvcmNlZCIsImxldmVsVXJsSWQiLCJsZXZlbElkIiwicGFyc2VMZXZlbFBsYXlsaXN0Iiwic2luZ2xlTGV2ZWwiLCJ0cGFyc2VkIiwibmVlZFNpZHhSYW5nZXMiLCJzaWR4VXJsIiwic2lkeEluZm8iLCJzaWR4UmVmZXJlbmNlcyIsInNlZ21lbnRSZWYiLCJzZWdSZWZJbmZvIiwiTUFOSUZFU1RfUEFSU0lOR19FUlJPUiIsIk1BTklGRVNUX0xPQURfVElNRU9VVCIsIk1BTklGRVNUX0xPQURfRVJST1IiLCJMRVZFTF9MT0FEX1RJTUVPVVQiLCJMRVZFTF9MT0FEX0VSUk9SIiwiQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUIiwiQVVESU9fVFJBQ0tfTE9BRF9FUlJPUiIsImVycm9yRGF0YSIsImNhbkhhdmVMZXZlbHMiLCJNQVNURVJfUExBWUxJU1RfUkVHRVgiLCJNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVgiLCJMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNUIiwiUmVnRXhwIiwiTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyIsIk1QNF9SRUdFWF9TVUZGSVgiLCJNM1U4UGFyc2VyIiwiZmluZEdyb3VwIiwibWVkaWFHcm91cElkIiwiZ3JvdXAiLCJjb252ZXJ0QVZDMVRvQVZDT1RJIiwiYXZjZGF0YSIsInNoaWZ0IiwicmVzb2x2ZSIsImJhc2VVcmwiLCJzZXRDb2RlY3MiLCJjb2RlY3MiLCJmaWx0ZXJlZCIsInByZWZlcnJlZCIsInVua25vd25Db2RlY3MiLCJyZXNvbHV0aW9uIiwiZGVjaW1hbFJlc29sdXRpb24iLCJkZWNpbWFsSW50ZWdlciIsIk5BTUUiLCJDT0RFQ1MiLCJtZWRpYXMiLCJUWVBFIiwiZ3JvdXBJZCIsIkxBTkdVQUdFIiwiREVGQVVMVCIsIkFVVE9TRUxFQ1QiLCJGT1JDRUQiLCJVUkkiLCJncm91cENvZGVjIiwiY3VycmVudFNOIiwiZGlzY29udGludWl0eUNvdW50ZXIiLCJwcmV2RnJhZyIsImZpcnN0UGR0SW5kZXgiLCJhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUiLCJ2YWx1ZTEiLCJ2YWx1ZTIiLCJ0b1VwcGVyQ2FzZSIsImRlY3J5cHRwYXJhbXMiLCJrZXlBdHRycyIsImRlY3J5cHRtZXRob2QiLCJlbnVtZXJhdGVkU3RyaW5nIiwiZGVjcnlwdHVyaSIsImRlY3J5cHRpdiIsImhleGFkZWNpbWFsSW50ZWdlciIsInN0YXJ0QXR0cnMiLCJzdGFydFRpbWVPZmZzZXQiLCJkZWNpbWFsRmxvYXRpbmdQb2ludCIsIm1hcEF0dHJzIiwiQllURVJBTkdFIiwiZXZlcnkiLCJiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMiLCJzdGFydEluZGV4IiwiZnJhZ1ByZXYiLCJMZXZlbCIsIkRFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWCIsIkFUVFJfTElTVF9SRUdFWCIsIkF0dHJMaXN0IiwicGFyc2VBdHRyTGlzdCIsImF0dHIiLCJhdHRyTmFtZSIsImludFZhbHVlIiwiTUFYX1NBRkVfSU5URUdFUiIsInN0cmluZ1ZhbHVlIiwiaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXIiLCJyZXMiLCJxdW90ZSIsIkZyYWdtZW50TG9hZGVyIiwibG9hZGVyTmFtZSIsIm9uRnJhZ0xvYWRpbmciLCJGcmFnbWVudElMb2FkZXIiLCJEZWZhdWx0SUxvYWRlciIsInByb2dyZXNzRGF0YSIsImJ5dGVSYW5nZVN0YXJ0T2Zmc2V0IiwiZnJhZ0xvYWRpbmdUaW1lT3V0IiwiZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQiLCJGUkFHX0xPQURfRVJST1IiLCJGUkFHX0xPQURfVElNRU9VVCIsIktleUxvYWRlciIsImRlY3J5cHRrZXkiLCJkZWNyeXB0dXJsIiwib25LZXlMb2FkaW5nIiwiZnJhZ0xvYWRpbmdSZXRyeURlbGF5IiwiS0VZX0xPQURfRVJST1IiLCJLRVlfTE9BRF9USU1FT1VUIiwiVElDS19JTlRFUlZBTCIsIlN0cmVhbUNvbnRyb2xsZXIiLCJhdWRpb0NvZGVjU3dhcCIsIl9zdGF0ZSIsInN0YWxsUmVwb3J0ZWQiLCJnYXBDb250cm9sbGVyIiwiYWx0QXVkaW8iLCJmcmFnTG9hZEVycm9yIiwic3RhcnRGcmFnUmVxdWVzdGVkIiwiZm9yY2VTdGFydExvYWQiLCJfZG9UaWNrSWRsZSIsInJldHJ5RGF0ZSIsInNlZWtpbmciLCJfY2hlY2tCdWZmZXIiLCJfY2hlY2tGcmFnbWVudENoYW5nZWQiLCJsZXZlbExhc3RMb2FkZWQiLCJzdGFydEZyYWdQcmVmZXRjaCIsImxldmVsSW5mbyIsImxldmVsQml0cmF0ZSIsIm1heEJ1ZkxlbiIsIm1heEJ1ZmZlclNpemUiLCJtYXhCdWZmZXJMZW5ndGgiLCJfZmV0Y2hQYXlsb2FkT3JFb3MiLCJmcmFnTGVuIiwiaW5pdGlhbExpdmVNYW5pZmVzdFNpemUiLCJfZW5zdXJlRnJhZ21lbnRBdExpdmVQb2ludCIsIl9maW5kRnJhZ21lbnQiLCJlbmNyeXB0ZWQiLCJfbG9hZEtleSIsIl9sb2FkRnJhZ21lbnQiLCJtYXhMYXRlbmN5IiwicGF1c2VkIiwidGFyZ2V0U04iLCJmcmFnUHJldmlvdXNMb2FkIiwiZnJhZ21lbnRJbmRleFJhbmdlIiwiZnJhZ05leHRMb2FkIiwibG9va3VwVG9sZXJhbmNlIiwiY3VyU05JZHgiLCJzYW1lTGV2ZWwiLCJwcmV2U25GcmFnIiwibmV4dFNuRnJhZyIsImF1dG9MZXZlbEVuYWJsZWQiLCJfcmVkdWNlTWF4QnVmZmVyTGVuZ3RoIiwiZm9sbG93aW5nQnVmZmVyZWRGcmFnIiwiZnJhZ1BsYXlpbmdDdXJyZW50IiwiZnJhZ1BsYXlpbmciLCJmcmFnUGxheWluZ0xldmVsIiwiaW1tZWRpYXRlU3dpdGNoIiwicHJldmlvdXNseVBhdXNlZCIsInBhdXNlIiwiZmx1c2hNYWluQnVmZmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJpbW1lZGlhdGVMZXZlbFN3aXRjaEVuZCIsImZldGNoZGVsYXkiLCJuZXh0QnVmZmVyZWRGcmFnIiwibmV4dExldmVsSWQiLCJmcmFnTGFzdEticHMiLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsImZsdXNoU2NvcGUiLCJvbk1lZGlhQXR0YWNoZWQiLCJvbnZzZWVraW5nIiwib252c2Vla2VkIiwib25NZWRpYVNlZWtlZCIsIm9udmVuZGVkIiwib25NZWRpYURldGFjaGluZyIsImVuZGVkIiwic3RhbGxlZCIsIm9uTWFuaWZlc3RQYXJzZWQiLCJhYWMiLCJoZWFhYyIsImF1ZGlvQ29kZWNTd2l0Y2giLCJvbkxldmVsTG9hZGVkIiwibmV3TGV2ZWxJZCIsImN1ckxldmVsIiwiTGV2ZWxIZWxwZXIiLCJvbktleUxvYWRlZCIsImZyYWdMb2FkZWQiLCJ0YnVmZmVyZWQiLCJwZW5kaW5nQnVmZmVyaW5nIiwiYXBwZW5kZWQiLCJpbml0U2VnbWVudERhdGEiLCJfZ2V0QXVkaW9Db2RlYyIsIm9uRnJhZ1BhcnNpbmdJbml0U2VnbWVudCIsImZyYWdOZXciLCJ0cmFja05hbWUiLCJ1YSIsIm1ldGFkYXRhIiwibGV2ZWxDb2RlYyIsInBhcmVudCIsImNvbnRlbnQiLCJvbkZyYWdQYXJzaW5nRGF0YSIsImhhc0F1ZGlvIiwiaGFzVmlkZW8iLCJuYiIsIm9uRnJhZ1BhcnNlZCIsIl9jaGVja0FwcGVuZGVkUGFyc2VkIiwib25BdWRpb1RyYWNrU3dpdGNoaW5nIiwib25BdWRpb1RyYWNrU3dpdGNoZWQiLCJ2aWRlb0J1ZmZlciIsIm9uQnVmZmVyQ3JlYXRlZCIsIm1lZGlhVHJhY2siLCJhbHRlcm5hdGUiLCJwZW5kaW5nIiwibWVkaWFCdWZmZXJlZCIsImZyYWdMb2FkaW5nTWF4UmV0cnkiLCJkZWxheSIsImxldmVsUmV0cnkiLCJCVUZGRVJfRlVMTF9FUlJPUiIsIm1pbkxlbmd0aCIsIl9zZWVrVG9TdGFydFBvcyIsInBvbGwiLCJvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCIsIm9uQnVmZmVyRmx1c2hlZCIsImRlZmF1bHRBdWRpb0NvZGVjIiwibmV4dFN0YXRlIiwicHJldmlvdXNTdGF0ZSIsIl9saXZlU3luY1Bvc2l0aW9uIiwid2VicGFja0Jvb3RzdHJhcEZ1bmMiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImQiLCJnZXR0ZXIiLCJvIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiX19lc01vZHVsZSIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwib2JqZWN0IiwicHJvcGVydHkiLCJwIiwib2UiLCJFTlRSWV9NT0RVTEUiLCJtb2R1bGVOYW1lUmVxRXhwIiwiZGVwZW5kZW5jeVJlZ0V4cCIsInF1b3RlUmVnRXhwIiwic3RyIiwiaXNOdW1lcmljIiwiaXNOYU4iLCJnZXRNb2R1bGVEZXBlbmRlbmNpZXMiLCJzb3VyY2VzIiwicXVldWVOYW1lIiwicmV0dmFsIiwiZm5TdHJpbmciLCJ3cmFwcGVyU2lnbmF0dXJlIiwid2VicGFja1JlcXVpcmVOYW1lIiwicmUiLCJoYXNWYWx1ZXNJblF1ZXVlcyIsInF1ZXVlcyIsInJlZHVjZSIsImhhc1ZhbHVlcyIsImdldFJlcXVpcmVkTW9kdWxlcyIsIm1vZHVsZXNRdWV1ZSIsIm1haW4iLCJyZXF1aXJlZE1vZHVsZXMiLCJzZWVuTW9kdWxlcyIsInF1ZXVlIiwibW9kdWxlVG9DaGVjayIsIm5ld01vZHVsZXMiLCJuZXdNb2R1bGVzS2V5cyIsIl9fd2VicGFja19tb2R1bGVzX18iLCJhbGwiLCJlbnRyeU1vZHVsZSIsImJsb2IiLCJCbG9iIiwiYmFyZSIsIndlYmtpdFVSTCIsIm1velVSTCIsIm1zVVJMIiwid29ya2VyVXJsIiwiY3JlYXRlT2JqZWN0VVJMIiwid29ya2VyIiwiQUVTQ3J5cHRvIiwiYWVzSVYiLCJGYXN0QUVTS2V5IiwiaW1wb3J0S2V5IiwicmVtb3ZlUGFkZGluZyIsIm91dHB1dEJ5dGVzIiwicGFkZGluZ0J5dGVzIiwiRGF0YVZpZXciLCJnZXRVaW50OCIsIkFFU0RlY3J5cHRvciIsInJjb24iLCJzdWJNaXgiLCJVaW50MzJBcnJheSIsImludlN1Yk1peCIsInNCb3giLCJpbnZTQm94IiwiaW5pdFRhYmxlIiwidWludDhBcnJheVRvVWludDMyQXJyYXlfIiwiYXJyYXlCdWZmZXIiLCJ2aWV3IiwibmV3QXJyYXkiLCJnZXRVaW50MzIiLCJzdWJNaXgwIiwic3ViTWl4MSIsInN1Yk1peDIiLCJzdWJNaXgzIiwiaW52U3ViTWl4MCIsImludlN1Yk1peDEiLCJpbnZTdWJNaXgyIiwiaW52U3ViTWl4MyIsIngiLCJ4aSIsInN4IiwieDIiLCJ4NCIsIng4IiwidCIsImtleUJ1ZmZlciIsInNhbWVLZXkiLCJrZXlTaXplIiwia3NSb3dzIiwia3NSb3ciLCJpbnZLc1JvdyIsImtleVNjaGVkdWxlIiwiaW52S2V5U2NoZWR1bGUiLCJzYm94IiwicHJldiIsIm5ldHdvcmtUb0hvc3RPcmRlclN3YXAiLCJ3b3JkIiwiaW5wdXRBcnJheUJ1ZmZlciIsIm5Sb3VuZHMiLCJpbnZTQk9YIiwiaW5pdFZlY3RvciIsImluaXRWZWN0b3IwIiwiaW5pdFZlY3RvcjEiLCJpbml0VmVjdG9yMiIsImluaXRWZWN0b3IzIiwiaW5wdXRJbnQzMiIsIkludDMyQXJyYXkiLCJvdXRwdXRJbnQzMiIsInQwIiwidDEiLCJ0MiIsInQzIiwiczAiLCJzMSIsInMyIiwiczMiLCJpbnB1dFdvcmRzMCIsImlucHV0V29yZHMxIiwiaW5wdXRXb3JkczIiLCJpbnB1dFdvcmRzMyIsInN3YXBXb3JkIiwiQUFDRGVtdXhlciIsIl9hdWRpb1RyYWNrIiwic2VxdWVuY2VOdW1iZXIiLCJpc0FBQyIsImlucHV0VGltZVNjYWxlIiwiaWQzU2FtcGxlcyIsIkFEVFMiLCJSZW11eGVyVHJhY2tJZENvbmZpZyIsImlkMyIsIlRTRGVtdXhlciIsInNhbXBsZUFlcyIsImRpc2NhcmRFUEIiLCJzeW5jT2Zmc2V0IiwiX3N5bmNPZmZzZXQiLCJzY2Fud2luZG93IiwiY3JlYXRlVHJhY2siLCJwaWQiLCJwbXRQYXJzZWQiLCJfcG10SWQiLCJfYXZjVHJhY2siLCJfaWQzVHJhY2siLCJfdHh0VHJhY2siLCJhYWNPdmVyRmxvdyIsImFhY0xhc3RQVFMiLCJhdmNTYW1wbGUiLCJzdHQiLCJhdGYiLCJwZXMiLCJ1bmtub3duUElEcyIsImF2Y1RyYWNrIiwiaWQzVHJhY2siLCJhdmNJZCIsImF1ZGlvSWQiLCJpZDNJZCIsInBtdElkIiwiYXZjRGF0YSIsInBlc0RhdGEiLCJhdWRpb0RhdGEiLCJwYXJzZVBBVCIsIl9wYXJzZVBBVCIsInBhcnNlUE1UIiwiX3BhcnNlUE1UIiwicGFyc2VQRVMiLCJfcGFyc2VQRVMiLCJwYXJzZUFWQ1BFUyIsIl9wYXJzZUFWQ1BFUyIsInBhcnNlQUFDUEVTIiwiX3BhcnNlQUFDUEVTIiwicGFyc2VNUEVHUEVTIiwiX3BhcnNlTVBFR1BFUyIsInBhcnNlSUQzUEVTIiwiX3BhcnNlSUQzUEVTIiwicGFyc2VkUElEcyIsImF2YyIsImRlY3J5cHRBbmRSZW11eCIsInZpZGVvVHJhY2siLCJ0ZXh0VHJhY2siLCJsb2NhbHRoaXMiLCJkZWNyeXB0QWFjU2FtcGxlcyIsImRlY3J5cHRBbmRSZW11eEF2YyIsImRlY3J5cHRBdmNTYW1wbGVzIiwiX2luaXRQVFMiLCJfaW5pdERUUyIsIm1wZWdTdXBwb3J0ZWQiLCJpc1NhbXBsZUFlcyIsInNlY3Rpb25MZW5ndGgiLCJ0YWJsZUVuZCIsInByb2dyYW1JbmZvTGVuZ3RoIiwicGVzRmxhZ3MiLCJwZXNQcmVmaXgiLCJwZXNMZW4iLCJwZXNIZHJMZW4iLCJwZXNQdHMiLCJwZXNEdHMiLCJwYXlsb2FkU3RhcnRPZmZzZXQiLCJuZXdEYXRhIiwiZGF0YUxlbiIsInB1c2hBY2Nlc1VuaXQiLCJ1bml0cyIsIm5iU2FtcGxlcyIsImxhc3RTYW1wbGUiLCJmb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5Iiwic3BzIiwibGFzdCIsIl9wYXJzZUFWQ05BTHUiLCJleHBHb2xvbWJEZWNvZGVyIiwic3BzZm91bmQiLCJjcmVhdGVBVkNTYW1wbGUiLCJhdWRGb3VuZCIsInNsaWNlVHlwZSIsInJlYWRTbGljZVR5cGUiLCJyZWFkVUJ5dGUiLCJwYXlsb2FkVHlwZSIsInBheWxvYWRTaXplIiwiZW5kT2ZDYXB0aW9ucyIsImJ5dGVzQXZhaWxhYmxlIiwiY291bnRyeUNvZGUiLCJwcm92aWRlckNvZGUiLCJyZWFkVVNob3J0IiwidXNlclN0cnVjdHVyZSIsInJlYWRVSW50IiwidXNlckRhdGFUeXBlIiwiZmlyc3RCeXRlIiwic2Vjb25kQnl0ZSIsInRvdGFsQ0NzIiwiYnl0ZUFycmF5IiwiX2luc2VydFNhbXBsZUluT3JkZXIiLCJieXRlcyIsInV1aWRTdHJBcnJheSIsInVzZXJEYXRhUGF5bG9hZEJ5dGVzIiwidXVpZCIsInVzZXJEYXRhQnl0ZXMiLCJ1c2VyRGF0YSIsInJlYWRTUFMiLCJwaXhlbFJhdGlvIiwiY29kZWNhcnJheSIsImNvZGVjc3RyaW5nIiwicHBzIiwiYXJyIiwiX2dldExhc3ROYWxVbml0IiwibGFzdFVuaXQiLCJvdmVyZmxvdyIsIm5hbHVTdGF0ZSIsImxhc3RTdGF0ZSIsInVuaXRUeXBlIiwibGFzdFVuaXRTdGFydCIsImxhc3RVbml0VHlwZSIsInRtcCIsIkVQQlBvc2l0aW9ucyIsIm5ld0xlbmd0aCIsInNvdXJjZUluZGV4IiwibmV3UFRTIiwiRXhwR29sb21iIiwiYml0c0F2YWlsYWJsZSIsImxvYWRXb3JkIiwid29ya2luZ0J5dGVzIiwiYXZhaWxhYmxlQnl0ZXMiLCJza2lwQml0cyIsImNvdW50Iiwic2tpcEJ5dGVzIiwicmVhZEJpdHMiLCJiaXRzIiwidmFsdSIsInNraXBMWiIsImxlYWRpbmdaZXJvQ291bnQiLCJza2lwVUVHIiwic2tpcEVHIiwicmVhZFVFRyIsImNseiIsInJlYWRFRyIsInJlYWRCb29sZWFuIiwic2tpcFNjYWxpbmdMaXN0IiwibGFzdFNjYWxlIiwibmV4dFNjYWxlIiwiZGVsdGFTY2FsZSIsImZyYW1lQ3JvcExlZnRPZmZzZXQiLCJmcmFtZUNyb3BSaWdodE9mZnNldCIsImZyYW1lQ3JvcFRvcE9mZnNldCIsImZyYW1lQ3JvcEJvdHRvbU9mZnNldCIsInByb2ZpbGVJZGMiLCJwcm9maWxlQ29tcGF0IiwibGV2ZWxJZGMiLCJudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUiLCJwaWNXaWR0aEluTWJzTWludXMxIiwicGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSIsImZyYW1lTWJzT25seUZsYWciLCJzY2FsaW5nTGlzdENvdW50IiwiY2hyb21hRm9ybWF0SWRjIiwicGljT3JkZXJDbnRUeXBlIiwiYXNwZWN0UmF0aW9JZGMiLCJjZWlsIiwiU2FtcGxlQWVzRGVjcnlwdGVyIiwiZGVjcnlwdEJ1ZmZlciIsImVuY3J5cHRlZERhdGEiLCJkZWNyeXB0QWFjU2FtcGxlIiwic2FtcGxlSW5kZXgiLCJzeW5jIiwiY3VyVW5pdCIsImVuY3J5cHRlZEJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJnZXRBdmNFbmNyeXB0ZWREYXRhIiwiZGVjb2RlZERhdGEiLCJlbmNyeXB0ZWREYXRhTGVuIiwiSW50OEFycmF5Iiwib3V0cHV0UG9zIiwiaW5wdXRQb3MiLCJnZXRBdmNEZWNyeXB0ZWRVbml0IiwiZGVjcnlwdEF2Y1NhbXBsZSIsInVuaXRJbmRleCIsImN1clVuaXRzIiwiTVAzRGVtdXhlciIsIk1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT05fOTBLSFoiLCJQVFNfRFRTX1NISUZUX1RPTEVSQU5DRV85MEtIWiIsImlzU2FmYXJpIiwiSVNHZW5lcmF0ZWQiLCJkZWZhdWx0VGltZVN0YW1wIiwiZ2VuZXJhdGVJUyIsIm5iQXVkaW9TYW1wbGVzIiwibmJWaWRlb1NhbXBsZXMiLCJhdWRpb1RpbWVPZmZzZXQiLCJ2aWRlb1RpbWVPZmZzZXQiLCJhdWRpb3ZpZGVvRGVsdGFEdHMiLCJyZW11eEF1ZGlvIiwiYXVkaW9UcmFja0xlbmd0aCIsInJlbXV4VmlkZW8iLCJ2aWRlb0RhdGEiLCJyZW11eEVtcHR5QXVkaW8iLCJyZW11eElEMyIsInJlbXV4VGV4dCIsImF1ZGlvU2FtcGxlcyIsInZpZGVvU2FtcGxlcyIsImNvbXB1dGVQVFNEVFMiLCJpbml0RFRTIiwibXA0U2FtcGxlRHVyYXRpb24iLCJtZGF0IiwibW9vZiIsImZpcnN0UFRTIiwiZmlyc3REVFMiLCJsYXN0UFRTIiwibGFzdERUUyIsInRpbWVTY2FsZSIsImlucHV0U2FtcGxlcyIsIm91dHB1dFNhbXBsZXMiLCJwdHNOb3JtYWxpemUiLCJfUFRTTm9ybWFsaXplIiwibmV4dEF2Y0R0cyIsImRlbHRhZHRzIiwiZGVsdGFwdHMiLCJQVFNEVFNzaGlmdCIsImN1cnIiLCJuYk5hbHUiLCJuYWx1TGVuIiwibmJVbml0cyIsInNhbXBsZUxlbiIsIm1kYXRTaXplIiwiTVVYX0VSUk9SIiwiUkVNVVhfQUxMT0NfRVJST1IiLCJzZXRVaW50MzIiLCJ0eXBlcyIsImF2Y1NhbXBsZVVuaXRzIiwibXA0U2FtcGxlTGVuZ3RoIiwiY29tcG9zaXRpb25UaW1lT2Zmc2V0IiwidW5pdERhdGEiLCJ1bml0RGF0YUxlbiIsImxhc3RGcmFtZUR1cmF0aW9uIiwic3RyZXRjaFNob3J0VmlkZW9UcmFjayIsImdhcFRvbGVyYW5jZSIsImRlbHRhVG9GcmFtZUVuZCIsIm5leHRBdWRpb1B0cyIsImN0cyIsImZsYWdzIiwiaXNMZWFkaW5nIiwiaXNEZXBlbmRlZE9uIiwiaGFzUmVkdW5kYW5jeSIsImRlZ3JhZFByaW8iLCJkZXBlbmRzT24iLCJpc05vblN5bmMiLCJtcDR0aW1lU2NhbGUiLCJzY2FsZUZhY3RvciIsImlucHV0U2FtcGxlRHVyYXRpb24iLCJyYXdNUEVHIiwibXA0U2FtcGxlIiwiZmlsbEZyYW1lIiwibWF4QXVkaW9GcmFtZXNEcmlmdCIsIm5leHRQdHMiLCJtaXNzaW5nIiwibmV3U3RhbXAiLCJnZXRTaWxlbnRGcmFtZSIsImF1ZGlvU2FtcGxlIiwibnVtTWlzc2luZ0ZyYW1lcyIsInVuaXRMZW4iLCJsYXN0U2FtcGxlRHVyYXRpb24iLCJzYW1wbGVEdXJhdGlvbiIsInNpbGVudEZyYW1lIiwicmVmZXJlbmNlIiwiQUFDIiwiTVA0IiwiaW5pdCIsImF2YzEiLCJhdmNDIiwiYnRydCIsImRpbmYiLCJkcmVmIiwiZXNkcyIsImZ0eXAiLCJtZGlhIiwibWZoZCIsIm1pbmYiLCJtcDRhIiwibXZleCIsIm12aGQiLCJwYXNwIiwic2R0cCIsInN0YmwiLCJzdGNvIiwic3RzYyIsInN0c2QiLCJzdHN6Iiwic3R0cyIsInRydW4iLCJ0cmV4Iiwidm1oZCIsInNtaGQiLCJjaGFyQ29kZUF0IiwidmlkZW9IZGxyIiwiYXVkaW9IZGxyIiwiSERMUl9UWVBFUyIsIlNUVFMiLCJTVFNDIiwiU1RDTyIsIlNUU1oiLCJWTUhEIiwiU01IRCIsIlNUU0QiLCJtYWpvckJyYW5kIiwiYXZjMUJyYW5kIiwibWlub3JWZXJzaW9uIiwiRlRZUCIsImJveCIsIkRJTkYiLCJ1cHBlcldvcmREdXJhdGlvbiIsImxvd2VyV29yZER1cmF0aW9uIiwiYm94ZXMiLCJhdmNjIiwiaFNwYWNpbmciLCJ2U3BhY2luZyIsImNvbmZpZ2xlbiIsInNhbXBsZURlcGVuZGVuY3lUYWJsZSIsInVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUiLCJsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lIiwiYXJyYXlsZW4iLCJwYWRkaW5nVmFsdWUiLCJtb3ZpZSIsIk1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiIsInRvVGltZXNjYWxlRnJvbVNjYWxlIiwiZGVzdFNjYWxlIiwic3JjU2NhbGUiLCJ0b1RpbWVzY2FsZUZyb21CYXNlIiwic3JjQmFzZSIsInRvTXNGcm9tTXBlZ1RzQ2xvY2siLCJ0b01wZWdUc0Nsb2NrRnJvbVRpbWVzY2FsZSIsInJhd0RhdGEiLCJzdHJlYW1UeXBlIiwiRGVtdXhlcldvcmtlciIsInRyYW5zZmVyYWJsZSIsIlNUQUxMX01JTklNVU1fRFVSQVRJT05fTVMiLCJNQVhfU1RBUlRfR0FQX0pVTVAiLCJTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EUyIsIlNLSVBfQlVGRkVSX1JBTkdFX1NUQVJUIiwiR2FwQ29udHJvbGxlciIsIm51ZGdlUmV0cnkiLCJtb3ZlZCIsInNlZWtlZCIsImJlZ2luU2VlayIsInN0YWxsZWREdXJhdGlvbiIsInBsYXliYWNrUmF0ZSIsImhhc0Vub3VnaEJ1ZmZlciIsIm5vQnVmZmVyR2FwIiwic3RhcnRKdW1wIiwiX3RyeVNraXBCdWZmZXJIb2xlIiwidG5vdyIsIl9yZXBvcnRTdGFsbCIsImJ1ZmZlcmVkV2l0aEhvbGVzIiwiX3RyeUZpeEJ1ZmZlclN0YWxsIiwic3RhbGxlZER1cmF0aW9uTXMiLCJ0YXJnZXRUaW1lIiwiaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kIiwiX3RyeU51ZGdlQnVmZmVyIiwiQlVGRkVSX1NUQUxMRURfRVJST1IiLCJsYXN0RW5kVGltZSIsIkJVRkZFUl9TRUVLX09WRVJfSE9MRSIsIm51ZGdlTWF4UmV0cnkiLCJudWRnZU9mZnNldCIsIkJVRkZFUl9OVURHRV9PTl9TVEFMTCIsImNocm9tZU9yRmlyZWZveCIsIkxldmVsQ29udHJvbGxlciIsImNhbmxvYWQiLCJjdXJyZW50TGV2ZWxJbmRleCIsIm1hbnVhbExldmVsSW5kZXgiLCJ0aW1lciIsImNsZWFyVGltZXIiLCJfbGV2ZWxzIiwibGV2ZWxSZXRyeUNvdW50IiwibG9hZEVycm9yIiwib25NYW5pZmVzdExvYWRlZCIsImJpdHJhdGVTdGFydCIsImxldmVsU2V0IiwibGV2ZWxGcm9tU2V0IiwidmlkZW9Db2RlY0ZvdW5kIiwiYXVkaW9Db2RlY0ZvdW5kIiwiYXR0cmlidXRlcyIsImZyYWdtZW50RXJyb3IiLCJTVUJUSVRMRVMiLCJfZmlyc3RMZXZlbCIsInNvbWUiLCJNQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SIiwic2V0TGV2ZWxJbnRlcm5hbCIsImxldmVsUHJvcGVydGllcyIsIkxFVkVMX1NXSVRDSF9FUlJPUiIsImxldmVsRXJyb3IiLCJsZXZlbEluZGV4IiwicmVjb3ZlckxldmVsIiwiZXJyb3JFdmVudCIsImVycm9yRGV0YWlscyIsInJlZHVuZGFudExldmVscyIsImF1ZGlvR3JvdXBJZCIsImxldmVsT2JqZWN0IiwiX3N0YXJ0TGV2ZWwiLCJjb25maWdTdGFydExldmVsIiwiSUQzVHJhY2tDb250cm9sbGVyIiwiZ2V0SUQzVHJhY2siLCJhZGRUZXh0VHJhY2siLCJvbkZyYWdQYXJzaW5nTWV0YWRhdGEiLCJDdWUiLCJXZWJLaXREYXRhQ3VlIiwiVlRUQ3VlIiwiVGV4dFRyYWNrQ3VlIiwiYWRkQ3VlIiwib25MaXZlQmFja0J1ZmZlclJlYWNoZWQiLCJmb3VuZEN1ZSIsIm1lZGlhU291cmNlIiwic291cmNlQnVmZmVyIiwiU291cmNlQnVmZmVyIiwiV2ViS2l0U291cmNlQnVmZmVyIiwic291cmNlQnVmZmVyVmFsaWRBUEkiLCJhcHBlbmRCdWZmZXIiLCJyZW1vdmUiLCJobHNEZWZhdWx0Q29uZmlnIiwiY2FwTGV2ZWxPbkZQU0Ryb3AiLCJsb3dCdWZmZXJXYXRjaGRvZ1BlcmlvZCIsImxpdmVEdXJhdGlvbkluZmluaXR5IiwibGl2ZUJhY2tCdWZmZXJMZW5ndGgiLCJmcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZCIsImZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkIiwiYXBwZW5kRXJyb3JNYXhSZXRyeSIsImxpY2Vuc2VYaHJTZXR1cCIsImFickV3bWFGYXN0TGl2ZSIsImFickV3bWFTbG93TGl2ZSIsImFickV3bWFGYXN0Vm9EIiwiYWJyRXdtYVNsb3dWb0QiLCJhYnJFd21hRGVmYXVsdEVzdGltYXRlIiwiYWJyQmFuZFdpZHRoRmFjdG9yIiwiYWJyQmFuZFdpZHRoVXBGYWN0b3IiLCJhYnJNYXhXaXRoUmVhbEJpdHJhdGUiLCJtYXhTdGFydmF0aW9uRGVsYXkiLCJtYXhMb2FkaW5nRGVsYXkiLCJlbWVFbmFibGVkIiwid2lkZXZpbmVMaWNlbnNlVXJsIiwicmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYyIsInRpbWVsaW5lQ29uZmlnIiwiY3VlSGFuZGxlciIsImVuYWJsZUNFQTcwOENhcHRpb25zIiwiZW5hYmxlV2ViVlRUIiwiY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWwiLCJjYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGUiLCJjYXB0aW9uc1RleHRUcmFjazJMYWJlbCIsImNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZSIsIkFickNvbnRyb2xsZXIiLCJsYXN0TG9hZGVkRnJhZ0xldmVsIiwiX25leHRBdXRvTGV2ZWwiLCJvbkNoZWNrIiwiX2FiYW5kb25SdWxlc0NoZWNrIiwiZXdtYUZhc3QiLCJld21hU2xvdyIsInJlcXVlc3REZWxheSIsImxvYWRSYXRlIiwiYnciLCJleHBlY3RlZExlbiIsImZyYWdMb2FkZWREZWxheSIsImJ1ZmZlclN0YXJ2YXRpb25EZWxheSIsImZyYWdMZXZlbE5leHRMb2FkZWREZWxheSIsImxvYWRlZEJ5dGVzIiwibG9hZGVkRHVyYXRpb24iLCJmcmFnTG9hZGluZ1Byb2Nlc3NpbmdNcyIsImJ3RXN0aW1hdGUiLCJiaXRyYXRlVGVzdERlbGF5IiwiX2ZpbmRCZXN0TGV2ZWwiLCJjdXJyZW50RnJhZ0R1cmF0aW9uIiwiY3VycmVudEJ3IiwibWF4RmV0Y2hEdXJhdGlvbiIsImJ3RmFjdG9yIiwiYndVcEZhY3RvciIsImF2Z0R1cmF0aW9uIiwiYWRqdXN0ZWRidyIsImZldGNoRHVyYXRpb24iLCJmb3JjZWRBdXRvTGV2ZWwiLCJjYW5Fc3RpbWF0ZSIsIm5leHRBQlJBdXRvTGV2ZWwiLCJfbmV4dEFCUkF1dG9MZXZlbCIsImF2Z2J3IiwiYmVzdExldmVsIiwiRXdtYUJhbmRXaWR0aEVzdGltYXRvciIsInNsb3ciLCJmYXN0IiwiZGVmYXVsdEVzdGltYXRlIiwiZGVmYXVsdEVzdGltYXRlXyIsIm1pbldlaWdodF8iLCJtaW5EZWxheU1zXyIsInNsb3dfIiwiZmFzdF8iLCJkdXJhdGlvbk1zIiwibnVtQnl0ZXMiLCJudW1CaXRzIiwiZHVyYXRpb25TIiwiYmFuZHdpZHRoSW5CcHMiLCJnZXRUb3RhbFdlaWdodCIsIkVXTUEiLCJoYWxmTGlmZSIsImFscGhhXyIsImVzdGltYXRlXyIsInRvdGFsV2VpZ2h0XyIsImV4cCIsIndlaWdodCIsImFkakFscGhhIiwiemVyb0ZhY3RvciIsIkJ1ZmZlckNvbnRyb2xsZXIiLCJfbXNEdXJhdGlvbiIsIl9sZXZlbER1cmF0aW9uIiwiX2xldmVsVGFyZ2V0RHVyYXRpb24iLCJfbGl2ZSIsIl9vYmplY3RVcmwiLCJfbmVlZHNGbHVzaCIsIl9uZWVkc0VvcyIsImF1ZGlvVGltZXN0YW1wT2Zmc2V0IiwiYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCIsIl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsIiwic2VnbWVudHMiLCJhcHBlbmRpbmciLCJhcHBlbmRFcnJvciIsImZsdXNoQnVmZmVyQ291bnRlciIsInBlbmRpbmdUcmFja3MiLCJmbHVzaFJhbmdlIiwiX29uTWVkaWFTb3VyY2VPcGVuIiwiY2hlY2tQZW5kaW5nVHJhY2tzIiwiX29uTWVkaWFTb3VyY2VDbG9zZSIsIl9vbk1lZGlhU291cmNlRW5kZWQiLCJfb25TQlVwZGF0ZUVuZCIsImF1ZGlvQnVmZmVyIiwidGltZXN0YW1wT2Zmc2V0IiwiZG9GbHVzaCIsImNoZWNrRW9zIiwiY291bnRlciIsInNlZ21lbnQiLCJzYlNldCIsInNiIiwiZG9BcHBlbmRpbmciLCJ1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbiIsImZsdXNoTGl2ZUJhY2tCdWZmZXIiLCJfb25TQlVwZGF0ZUVycm9yIiwiQlVGRkVSX0FQUEVORElOR19FUlJPUiIsIm9uTGV2ZWxQdHNVcGRhdGVkIiwidXBkYXRpbmciLCJvbk1lZGlhQXR0YWNoaW5nIiwibXMiLCJlbmRPZlN0cmVhbSIsInJlbW92ZUF0dHJpYnV0ZSIsInBlbmRpbmdUcmFja3NDb3VudCIsImNyZWF0ZVNvdXJjZUJ1ZmZlcnMiLCJvbkJ1ZmZlclJlc2V0IiwicmVtb3ZlU291cmNlQnVmZmVyIiwib25CdWZmZXJDb2RlY3MiLCJtaW1lVHlwZSIsImFkZFNvdXJjZUJ1ZmZlciIsIkJVRkZFUl9BRERfQ09ERUNfRVJST1IiLCJvbkJ1ZmZlckFwcGVuZGluZyIsIm9uQnVmZmVyRW9zIiwib25CdWZmZXJGbHVzaGluZyIsImJ1ZmZlclR5cGVzIiwidGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uIiwiYnVmZmVyVHlwZSIsInJlbW92ZUJ1ZmZlclJhbmdlIiwib25MZXZlbFVwZGF0ZWQiLCJmbHVzaEJ1ZmZlciIsIkJVRkZFUl9BUFBFTkRfRVJST1IiLCJzYlR5cGUiLCJidWZTdGFydCIsImJ1ZkVuZCIsInJlbW92ZVN0YXJ0IiwicmVtb3ZlRW5kIiwiQ2FwTGV2ZWxDb250cm9sbGVyIiwicmVzdHJpY3RlZExldmVscyIsIm9uRnBzRHJvcExldmVsQ2FwcGluZyIsImlzTGV2ZWxBbGxvd2VkIiwiZHJvcHBlZExldmVsIiwiSFRNTFZpZGVvRWxlbWVudCIsIm9uTGV2ZWxzVXBkYXRlZCIsImRldGVjdFBsYXllclNpemUiLCJsZXZlbHNMZW5ndGgiLCJnZXRNYXhMZXZlbCIsImNhcExldmVsSW5kZXgiLCJ2YWxpZExldmVscyIsImdldE1heExldmVsQnlNZWRpYVNpemUiLCJtZWRpYVdpZHRoIiwibWVkaWFIZWlnaHQiLCJhdEdyZWF0ZXN0QmFuZGl3ZHRoIiwibWF4TGV2ZWxJbmRleCIsImNsaWVudFdpZHRoIiwib2Zmc2V0V2lkdGgiLCJjb250ZW50U2NhbGVGYWN0b3IiLCJjbGllbnRIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJkZXZpY2VQaXhlbFJhdGlvIiwiRlBTQ29udHJvbGxlciIsImlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUiLCJnZXRWaWRlb1BsYXliYWNrUXVhbGl0eSIsImNoZWNrRlBTSW50ZXJ2YWwiLCJjaGVja0ZQUyIsImRlY29kZWRGcmFtZXMiLCJkcm9wcGVkRnJhbWVzIiwibGFzdFRpbWUiLCJjdXJyZW50UGVyaW9kIiwiY3VycmVudERyb3BwZWQiLCJsYXN0RHJvcHBlZEZyYW1lcyIsImN1cnJlbnREZWNvZGVkIiwibGFzdERlY29kZWRGcmFtZXMiLCJkcm9wcGVkRlBTIiwidG90YWxEcm9wcGVkRnJhbWVzIiwidmlkZW9QbGF5YmFja1F1YWxpdHkiLCJ0b3RhbFZpZGVvRnJhbWVzIiwiZHJvcHBlZFZpZGVvRnJhbWVzIiwid2Via2l0RGVjb2RlZEZyYW1lQ291bnQiLCJ3ZWJraXREcm9wcGVkRnJhbWVDb3VudCIsIkF1ZGlvVHJhY2tDb250cm9sbGVyIiwiX3RyYWNrSWQiLCJfc2VsZWN0RGVmYXVsdFRyYWNrIiwidHJhY2tJZEJsYWNrbGlzdCIsIm9uQXVkaW9UcmFja0xvYWRlZCIsInVwZGF0ZVBlcmlvZE1zIiwiX3NlbGVjdEluaXRpYWxBdWRpb1RyYWNrIiwiX2hhbmRsZUxvYWRFcnJvciIsIl9zZXRBdWRpb1RyYWNrIiwibmV3SWQiLCJfbG9hZFRyYWNrRGV0YWlsc0lmTmVlZGVkIiwiX3VwZGF0ZVRyYWNrIiwiY3VycmVudEF1ZGlvVHJhY2siLCJkZWZhdWx0VHJhY2tzIiwidHJhY2tGb3VuZCIsInRyYXZlcnNlVHJhY2tzIiwiX25lZWRzVHJhY2tMb2FkaW5nIiwicHJldmlvdXNJZCIsIm5ld1RyYWNrIiwiQXVkaW9TdHJlYW1Db250cm9sbGVyIiwid2FpdGluZ0ZyYWdtZW50IiwidmlkZW9UcmFja0NDIiwib25Jbml0UHRzRm91bmQiLCJkZW11eGVySWQiLCJ0cmFja0RldGFpbHMiLCJtYWluQnVmZmVySW5mbyIsIm1heENvbmZpZ0J1ZmZlciIsImF1ZGlvU3dpdGNoIiwibG9hZElkeCIsImZyYWdMb2FkSWR4IiwibmV4dEJ1ZmZlcmVkIiwiZm91bmRGcmFnIiwiaXNTZWVraW5nIiwid2FpdGluZ0ZyYWciLCJ3YWl0aW5nRnJhZ0NDIiwib25BdWRpb1RyYWNrc1VwZGF0ZWQiLCJhcHBlbmRPYmoiLCJwZW5kaW5nRGF0YSIsImFwcGVuZE9uQnVmZmVyRmx1c2giLCJuZXdDdWUiLCJjYXB0aW9uU2NyZWVuIiwicm93IiwiaW5kZW50aW5nIiwiaW5kZW50Iiwicm93cyIsImlzRW1wdHkiLCJjaGFycyIsInVjaGFyIiwiY3VlU3RhcnRUaW1lIiwiYXV0b0tleXdvcmQiLCJkaXJlY3Rpb25TZXR0aW5nIiwibHIiLCJybCIsImFsaWduU2V0dGluZyIsIm1pZGRsZSIsImZpbmREaXJlY3Rpb25TZXR0aW5nIiwiZGlyIiwiZmluZEFsaWduU2V0dGluZyIsImV4dGVuZCIsImNvYmoiLCJiYXNlT2JqIiwiaGFzQmVlblJlc2V0IiwiX2lkIiwiX3BhdXNlT25FeGl0IiwiX3N0YXJ0VGltZSIsIl9lbmRUaW1lIiwiX3RleHQiLCJfcmVnaW9uIiwiX3ZlcnRpY2FsIiwiX3NuYXBUb0xpbmVzIiwiX2xpbmUiLCJfbGluZUFsaWduIiwiX3Bvc2l0aW9uIiwiX3Bvc2l0aW9uQWxpZ24iLCJfc2l6ZSIsIl9hbGlnbiIsInNldHRpbmciLCJTeW50YXhFcnJvciIsImRpc3BsYXlTdGF0ZSIsImdldEN1ZUFzSFRNTCIsIldlYlZUVCIsImNvbnZlcnRDdWVUb0RPTVRyZWUiLCJUaW1lbGluZUNvbnRyb2xsZXIiLCJDdWVzIiwidW5wYXJzZWRWdHRGcmFncyIsImN1ZVJhbmdlcyIsImNhcHRpb25zVHJhY2tzIiwiY2FwdGlvbnNQcm9wZXJ0aWVzIiwiY2VhNjA4UGFyc2VyIiwibGFzdFNuIiwicHJldkNDIiwidnR0Q0NzIiwidGV4dFRyYWNrMSIsImxhbmd1YWdlQ29kZSIsInRleHRUcmFjazIiLCJjaGFubmVsMSIsImNoYW5uZWwyIiwiYWRkQ3VlcyIsInNjcmVlbiIsInJhbmdlcyIsIm1lcmdlZCIsImN1ZVJhbmdlIiwib3ZlcmxhcCIsImludGVyc2VjdGlvbiIsImdldEV4aXN0aW5nVHJhY2siLCJjcmVhdGVDYXB0aW9uc1RyYWNrIiwiZXhpc3RpbmdUcmFjayIsImNyZWF0ZVRleHRUcmFjayIsIl9jbGVhblRyYWNrcyIsInByZXNlbnRhdGlvbk9mZnNldCIsIm5ldyIsImluVXNlVHJhY2tzIiwiaW5Vc2VUcmFjayIsImNhblJldXNlVnR0VGV4dFRyYWNrIiwicmVzZXQiLCJzdWNjZXNzIiwiZGVjcnlwdERhdGEiLCJfcGFyc2VWVFRzIiwiV2ViVlRUUGFyc2VyIiwiY3VycmVudFRyYWNrIiwiZ2V0Q3VlQnlJZCIsInRleHRUcmFja0N1ZSIsIm9uRnJhZ0RlY3J5cHRlZCIsIm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSIsImNjQnl0ZXMiLCJjY2RhdGFzIiwiZXh0cmFjdENlYTYwOERhdGEiLCJhZGREYXRhIiwidG1wQnl0ZSIsImNjYnl0ZTEiLCJjY2J5dGUyIiwiY2NWYWxpZCIsImNjVHlwZSIsImFjdHVhbENDQnl0ZXMiLCJtYW5pZmVzdFRyYWNrIiwieDEiLCJ5MSIsInkyIiwic3BlY2lhbENlYTYwOENoYXJzQ29kZXMiLCJnZXRDaGFyRm9yQnl0ZSIsImJ5dGUiLCJjaGFyQ29kZSIsIk5SX1JPV1MiLCJOUl9DT0xTIiwicm93c0xvd0NoMSIsInJvd3NIaWdoQ2gxIiwicm93c0xvd0NoMiIsInJvd3NIaWdoQ2gyIiwiYmFja2dyb3VuZENvbG9ycyIsIlZlcmJvc2VGaWx0ZXIiLCJ2ZXJib3NlRmlsdGVyIiwidmVyYm9zZUxldmVsIiwic2V0VGltZSIsIm5ld1RpbWUiLCJzZXZlcml0eSIsIm1pbkxldmVsIiwibnVtQXJyYXlUb0hleEFycmF5IiwibnVtQXJyYXkiLCJoZXhBcnJheSIsIlBlblN0YXRlIiwiZm9yZWdyb3VuZCIsInVuZGVybGluZSIsIml0YWxpY3MiLCJiYWNrZ3JvdW5kIiwiZmxhc2giLCJzZXRTdHlsZXMiLCJzdHlsZXMiLCJhdHRyaWJzIiwic3R5bGUiLCJpc0RlZmF1bHQiLCJlcXVhbHMiLCJvdGhlciIsImNvcHkiLCJuZXdQZW5TdGF0ZSIsIlN0eWxlZFVuaWNvZGVDaGFyIiwicGVuU3RhdGUiLCJzZXRDaGFyIiwic2V0UGVuU3RhdGUiLCJuZXdDaGFyIiwiUm93IiwiY3VyclBlblN0YXRlIiwiZXF1YWwiLCJlbXB0eSIsInNldEN1cnNvciIsImFic1BvcyIsIm1vdmVDdXJzb3IiLCJyZWxQb3MiLCJuZXdQb3MiLCJiYWNrU3BhY2UiLCJpbnNlcnRDaGFyIiwiY2hhciIsImNsZWFyRnJvbVBvcyIsInN0YXJ0UG9zIiwiY2xlYXIiLCJjbGVhclRvRW5kT2ZSb3ciLCJnZXRUZXh0U3RyaW5nIiwic2V0UGVuU3R5bGVzIiwiY3VyckNoYXIiLCJDYXB0aW9uU2NyZWVuIiwiY3VyclJvdyIsIm5yUm9sbFVwUm93cyIsImxhc3RPdXRwdXRTY3JlZW4iLCJzZXRQZW4iLCJzZXRQQUMiLCJwYWNEYXRhIiwibmV3Um93IiwidG9wUm93SW5kZXgiLCJwcmV2TGluZVRpbWUiLCJwcmV2UG9zIiwiY29sb3IiLCJzZXRCa2dEYXRhIiwiYmtnRGF0YSIsInNldFJvbGxVcFJvd3MiLCJuclJvd3MiLCJyb2xsVXAiLCJnZXREaXNwbGF5VGV4dCIsInRvcFJvdyIsImFzT25lUm93IiwiZGlzcGxheVRleHQiLCJyb3dOciIsInJvd1RleHQiLCJnZXRUZXh0QW5kRm9ybWF0IiwiQ2VhNjA4Q2hhbm5lbCIsImNoYW5uZWxOdW1iZXIiLCJvdXRwdXRGaWx0ZXIiLCJjaE5yIiwidmVyYm9zZSIsImRpc3BsYXllZE1lbW9yeSIsIm5vbkRpc3BsYXllZE1lbW9yeSIsImN1cnJSb2xsVXBSb3ciLCJ3cml0ZVNjcmVlbiIsImxhc3RDdWVFbmRUaW1lIiwiZ2V0SGFuZGxlciIsInNldEhhbmRsZXIiLCJuZXdIYW5kbGVyIiwic2V0TW9kZSIsIm5ld01vZGUiLCJpbnNlcnRDaGFycyIsIm91dHB1dERhdGFVcGRhdGUiLCJjY1JDTCIsImNjQlMiLCJjY0FPRiIsImNjQU9OIiwiY2NERVIiLCJjY1JVIiwiY2NGT04iLCJjY1JEQyIsImNjVFIiLCJjY1JURCIsImNjRURNIiwiY2NDUiIsImNjRU5NIiwiY2NFT0MiLCJjY1RPIiwibnJDb2xzIiwiY2NNSURST1ciLCJjb2xvckluZGV4IiwiY29sb3JzIiwiZGlzcGF0Y2giLCJkaXNwYXRjaEN1ZSIsImN1ZVNwbGl0QXRUaW1lIiwiQ2VhNjA4UGFyc2VyIiwiZmllbGQiLCJvdXQxIiwib3V0MiIsIm91dHB1dHMiLCJjaGFubmVscyIsImN1cnJDaE5yIiwibGFzdENtZEEiLCJsYXN0Q21kQiIsImRhdGFDb3VudGVycyIsImJ5dGVMaXN0IiwiY21kRm91bmQiLCJjaGFyc0ZvdW5kIiwicGFkZGluZyIsInBhcnNlQ21kIiwicGFyc2VNaWRyb3ciLCJwYXJzZVBBQyIsInBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMiLCJwYXJzZUNoYXJzIiwiY2hhbm5lbCIsImNvbmQxIiwiY29uZDIiLCJjYXNlMSIsImNhc2UyIiwiaW50ZXJwcmV0UEFDIiwicGFjSW5kZXgiLCJjaGFubmVsTnIiLCJjaGFyQ29kZXMiLCJjaGFyQ29kZTEiLCJvbmVDb2RlIiwiaGV4Q29kZXMiLCJPdXRwdXRGaWx0ZXIiLCJzdGFydHNXaXRoIiwiaW5wdXRTdHJpbmciLCJzZWFyY2hTdHJpbmciLCJjdWVTdHJpbmcybWlsbGlzIiwidGltZVN0cmluZyIsInNlY3MiLCJtaW5zIiwiaG91cnMiLCJoYXNoIiwiY2FsY3VsYXRlT2Zmc2V0IiwicHJlc2VudGF0aW9uVGltZSIsImN1cnJDQyIsInZ0dEJ5dGVBcnJheSIsInN5bmNQVFMiLCJjYWxsQmFjayIsImVycm9yQ2FsbEJhY2siLCJ2dHRMaW5lcyIsImN1ZVRpbWUiLCJtcGVnVHMiLCJsb2NhbFRpbWUiLCJwYXJzaW5nRXJyb3IiLCJpbkhlYWRlciIsInRpbWVzdGFtcE1hcCIsInBhcnNlciIsImN1ZU9mZnNldCIsIm9ucGFyc2luZ2Vycm9yIiwiU3VidGl0bGVUcmFja0NvbnRyb2xsZXIiLCJzdG9wcGVkIiwicXVldWVkRGVmYXVsdFRyYWNrIiwidHJhY2tDaGFuZ2VMaXN0ZW5lciIsIl9vblRleHRUcmFja3NDaGFuZ2VkIiwidXNlVGV4dFRyYWNrUG9sbGluZyIsInN1YnRpdGxlUG9sbGluZ0ludGVydmFsIiwiZmlsdGVyU3VidGl0bGVUcmFja3MiLCJvblN1YnRpdGxlVHJhY2tMb2FkZWQiLCJfY2xlYXJSZWxvYWRUaW1lciIsIl9sb2FkQ3VycmVudFRyYWNrIiwiX3RvZ2dsZVRyYWNrTW9kZXMiLCJvbGRUcmFjayIsIm5leHRUcmFjayIsIl9zZXRTdWJ0aXRsZVRyYWNrSW50ZXJuYWwiLCJ0ZXh0VHJhY2tMaXN0IiwiU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIiwidHJhY2tzQnVmZmVyZWQiLCJjdXJyZW50VHJhY2tJZCIsImxhc3RBVlN0YXJ0IiwiX29uTWVkaWFTZWVraW5nIiwib25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQiLCJmcmFnU3RhcnQiLCJmcmFnRW5kIiwib25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQiLCJvblN1YnRpdGxlVHJhY2tTd2l0Y2giLCJfZ2V0QnVmZmVyZWQiLCJNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTIiwiY3JlYXRlV2lkZXZpbmVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zIiwiYXVkaW9Db2RlY3MiLCJ2aWRlb0NvZGVjcyIsImJhc2VDb25maWciLCJ2aWRlb0NhcGFiaWxpdGllcyIsImNvbnRlbnRUeXBlIiwiZ2V0U3VwcG9ydGVkTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyIsImtleVN5c3RlbSIsIldJREVWSU5FIiwiRU1FQ29udHJvbGxlciIsIl93aWRldmluZUxpY2Vuc2VVcmwiLCJfbGljZW5zZVhoclNldHVwIiwiX2VtZUVuYWJsZWQiLCJfcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIiwiX2NvbmZpZyIsIl9tZWRpYUtleXNMaXN0IiwiX21lZGlhIiwiX2hhc1NldE1lZGlhS2V5cyIsIl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCIsIl9vbk1lZGlhRW5jcnlwdGVkIiwiaW5pdERhdGFUeXBlIiwiX2F0dGVtcHRTZXRNZWRpYUtleXMiLCJfZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24iLCJnZXRMaWNlbnNlU2VydmVyVXJsIiwiX2F0dGVtcHRLZXlTeXN0ZW1BY2Nlc3MiLCJtZWRpYUtleVN5c3RlbUNvbmZpZ3MiLCJtZWRpYUtleVN5c3RlbUFjY2VzcyIsIl9vbk1lZGlhS2V5U3lzdGVtQWNjZXNzT2J0YWluZWQiLCJtZWRpYUtleXNMaXN0SXRlbSIsIm1lZGlhS2V5c1Nlc3Npb25Jbml0aWFsaXplZCIsIm1lZGlhS2V5U3lzdGVtRG9tYWluIiwiY3JlYXRlTWVkaWFLZXlzIiwibWVkaWFLZXlzIiwiX29uTWVkaWFLZXlzQ3JlYXRlZCIsIm1lZGlhS2V5c1Nlc3Npb24iLCJjcmVhdGVTZXNzaW9uIiwiX29uTmV3TWVkaWFLZXlTZXNzaW9uIiwia2V5U2Vzc2lvbiIsInNlc3Npb25JZCIsIl9vbktleVNlc3Npb25NZXNzYWdlIiwiX3JlcXVlc3RMaWNlbnNlIiwidXBkYXRlIiwia2V5c0xpc3RJdGVtIiwiS0VZX1NZU1RFTV9FUlJPUiIsIktFWV9TWVNURU1fTk9fS0VZUyIsInNldE1lZGlhS2V5cyIsIktFWV9TWVNURU1fTk9fQUNDRVNTIiwiS0VZX1NZU1RFTV9OT19TRVNTSU9OIiwiS0VZX1NZU1RFTV9OT19JTklUX0RBVEEiLCJnZW5lcmF0ZVJlcXVlc3QiLCJfY3JlYXRlTGljZW5zZVhociIsImtleU1lc3NhZ2UiLCJfb25MaWNlbnNlUmVxdWVzdFJlYWR5U3RhZ2VDaGFuZ2UiLCJLRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQiLCJhdHRlbXB0c0xlZnQiLCJfZ2VuZXJhdGVMaWNlbnNlUmVxdWVzdENoYWxsZW5nZSIsImNoYWxsZW5nZSIsIm9uTWVkaWFEZXRhY2hlZCIsInN0cjJhYiIsImJ1ZiIsImJ1ZlZpZXciLCJzdHJMZW4iLCJhYjJzdHIiLCJuZWVkQ29udmVydFRvU3RyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNE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QUFDNUQsWUFBSSxDQUFDakksU0FBTCxDQUFlN1EsT0FBZixDQUF1QmthLFFBQVEsQ0FBQ3RyQixJQUFoQyxFQUFzQyxNQUFJLENBQUN3MUUsTUFBTCxDQUFZLE1BQUksQ0FBQzkvQyxRQUFMLENBQWMxeEIsR0FBMUIsQ0FBdEMsRUFBc0UsTUFBSSxDQUFDd3hFLE1BQUwsQ0FBWSxNQUFJLENBQUM5L0MsUUFBTCxDQUFjcmtCLEVBQTFCLENBQXRFLEVBQXFHLFVBQUM2USxhQUFELEVBQW1CO0FBQ3RIb0osZ0JBQVEsQ0FBQ3RyQixJQUFULEdBQWdCNjFFLGdCQUFnQixHQUFHLE1BQUksQ0FBQ0QsTUFBTCxDQUFZMXpELGFBQVosQ0FBSCxHQUFnQ0EsYUFBaEU7O0FBQ0EsWUFBSSxPQUFPd0osU0FBUCxLQUFxQixVQUF6QixFQUFxQztBQUNuQ0EsbUJBQVMsQ0FBQ0osUUFBRCxFQUFXbkosS0FBWCxFQUFrQjNOLE9BQWxCLEVBQTJCMFYsR0FBM0IsQ0FBVDtBQUNEO0FBQ0YsT0FMRDtBQU1ELEtBUEQ7QUFRRCxHOzs7RUFqQ3dCLDREOztBQW9DM0IsK0RBQWVtRyxZQUFmLEUiLCJmaWxlIjoidmlkZW9qcy1obHNqcy1wbHVnaW4tZnVsbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInZpZGVvanMtaGxzanMtcGx1Z2luXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInZpZGVvanMtaGxzanMtcGx1Z2luXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9kaXN0XCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMzQpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDNlMTQxNDJkOTk1NjQzODAxNzIyIiwiZXhwb3J0IGNvbnN0IGlzRmluaXRlTnVtYmVyID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbHlmaWxscy9udW1iZXItaXNGaW5pdGUuanMiLCJpbXBvcnQgeyBnZXRTZWxmU2NvcGUgfSBmcm9tICcuL2dldC1zZWxmLXNjb3BlJztcclxuXHJcbmZ1bmN0aW9uIG5vb3AgKC4uLmFyZ3MpIHt9XHJcblxyXG5jb25zdCBmYWtlTG9nZ2VyID0ge1xyXG4gIHRyYWNlOiBub29wLFxyXG4gIGRlYnVnOiBub29wLFxyXG4gIGxvZzogbm9vcCxcclxuICB3YXJuOiBub29wLFxyXG4gIGluZm86IG5vb3AsXHJcbiAgZXJyb3I6IG5vb3BcclxufTtcclxuXHJcbmxldCBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XHJcblxyXG4vLyBsZXQgbGFzdENhbGxUaW1lO1xyXG4vLyBmdW5jdGlvbiBmb3JtYXRNc2dXaXRoVGltZUluZm8odHlwZSwgbXNnKSB7XHJcbi8vICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuLy8gICBjb25zdCBkaWZmID0gbGFzdENhbGxUaW1lID8gJysnICsgKG5vdyAtIGxhc3RDYWxsVGltZSkgOiAnMCc7XHJcbi8vICAgbGFzdENhbGxUaW1lID0gbm93O1xyXG4vLyAgIG1zZyA9IChuZXcgRGF0ZShub3cpKS50b0lTT1N0cmluZygpICsgJyB8IFsnICsgIHR5cGUgKyAnXSA+ICcgKyBtc2cgKyAnICggJyArIGRpZmYgKyAnIG1zICknO1xyXG4vLyAgIHJldHVybiBtc2c7XHJcbi8vIH1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdE1zZyAodHlwZSwgbXNnKSB7XHJcbiAgbXNnID0gJ1snICsgdHlwZSArICddID4gJyArIG1zZztcclxuICByZXR1cm4gbXNnO1xyXG59XHJcblxyXG5jb25zdCBnbG9iYWwgPSBnZXRTZWxmU2NvcGUoKTtcclxuXHJcbmZ1bmN0aW9uIGNvbnNvbGVQcmludEZuICh0eXBlKSB7XHJcbiAgY29uc3QgZnVuYyA9IGdsb2JhbC5jb25zb2xlW3R5cGVdO1xyXG4gIGlmIChmdW5jKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgaWYgKGFyZ3NbMF0pIHtcclxuICAgICAgICBhcmdzWzBdID0gZm9ybWF0TXNnKHR5cGUsIGFyZ3NbMF0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jLmFwcGx5KGdsb2JhbC5jb25zb2xlLCBhcmdzKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiBub29wO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHBvcnRMb2dnZXJGdW5jdGlvbnMgKGRlYnVnQ29uZmlnLCAuLi5mdW5jdGlvbnMpIHtcclxuICBmdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgZXhwb3J0ZWRMb2dnZXJbdHlwZV0gPSBkZWJ1Z0NvbmZpZ1t0eXBlXSA/IGRlYnVnQ29uZmlnW3R5cGVdLmJpbmQoZGVidWdDb25maWcpIDogY29uc29sZVByaW50Rm4odHlwZSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBlbmFibGVMb2dzID0gZnVuY3Rpb24gKGRlYnVnQ29uZmlnKSB7XHJcbiAgLy8gY2hlY2sgdGhhdCBjb25zb2xlIGlzIGF2YWlsYWJsZVxyXG4gIGlmICgoZ2xvYmFsLmNvbnNvbGUgJiYgZGVidWdDb25maWcgPT09IHRydWUpIHx8IHR5cGVvZiBkZWJ1Z0NvbmZpZyA9PT0gJ29iamVjdCcpIHtcclxuICAgIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhkZWJ1Z0NvbmZpZyxcclxuICAgICAgLy8gUmVtb3ZlIG91dCBmcm9tIGxpc3QgaGVyZSB0byBoYXJkLWRpc2FibGUgYSBsb2ctbGV2ZWxcclxuICAgICAgLy8gJ3RyYWNlJyxcclxuICAgICAgJ2RlYnVnJyxcclxuICAgICAgJ2xvZycsXHJcbiAgICAgICdpbmZvJyxcclxuICAgICAgJ3dhcm4nLFxyXG4gICAgICAnZXJyb3InXHJcbiAgICApO1xyXG4gICAgLy8gU29tZSBicm93c2VycyBkb24ndCBhbGxvdyB0byB1c2UgYmluZCBvbiBjb25zb2xlIG9iamVjdCBhbnl3YXlcclxuICAgIC8vIGZhbGxiYWNrIHRvIGRlZmF1bHQgaWYgbmVlZGVkXHJcbiAgICB0cnkge1xyXG4gICAgICBleHBvcnRlZExvZ2dlci5sb2coKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy91dGlscy9sb2dnZXIuanMiLCIvKipcclxuICogQHJlYWRvbmx5XHJcbiAqIEBlbnVtIHtzdHJpbmd9XHJcbiAqL1xyXG5jb25zdCBIbHNFdmVudHMgPSB7XHJcbiAgLy8gZmlyZWQgYmVmb3JlIE1lZGlhU291cmNlIGlzIGF0dGFjaGluZyB0byBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyBtZWRpYSB9XHJcbiAgTUVESUFfQVRUQUNISU5HOiAnaGxzTWVkaWFBdHRhY2hpbmcnLFxyXG4gIC8vIGZpcmVkIHdoZW4gTWVkaWFTb3VyY2UgaGFzIGJlZW4gc3VjY2VzZnVsbHkgYXR0YWNoZWQgdG8gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxyXG4gIE1FRElBX0FUVEFDSEVEOiAnaGxzTWVkaWFBdHRhY2hlZCcsXHJcbiAgLy8gZmlyZWQgYmVmb3JlIGRldGFjaGluZyBNZWRpYVNvdXJjZSBmcm9tIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IH1cclxuICBNRURJQV9ERVRBQ0hJTkc6ICdobHNNZWRpYURldGFjaGluZycsXHJcbiAgLy8gZmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBkZXRhY2hlZCBmcm9tIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IH1cclxuICBNRURJQV9ERVRBQ0hFRDogJ2hsc01lZGlhRGV0YWNoZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gd2UgYnVmZmVyIGlzIGdvaW5nIHRvIGJlIHJlc2V0IC0gZGF0YTogeyB9XHJcbiAgQlVGRkVSX1JFU0VUOiAnaGxzQnVmZmVyUmVzZXQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gd2Uga25vdyBhYm91dCB0aGUgY29kZWNzIHRoYXQgd2UgbmVlZCBidWZmZXJzIGZvciB0byBwdXNoIGludG8gLSBkYXRhOiB7dHJhY2tzIDogeyBjb250YWluZXIsIGNvZGVjLCBsZXZlbENvZGVjLCBpbml0U2VnbWVudCwgbWV0YWRhdGEgfX1cclxuICBCVUZGRVJfQ09ERUNTOiAnaGxzQnVmZmVyQ29kZWNzJyxcclxuICAvLyBmaXJlZCB3aGVuIHNvdXJjZWJ1ZmZlcnMgaGF2ZSBiZWVuIGNyZWF0ZWQgLSBkYXRhOiB7IHRyYWNrcyA6IHRyYWNrcyB9XHJcbiAgQlVGRkVSX0NSRUFURUQ6ICdobHNCdWZmZXJDcmVhdGVkJyxcclxuICAvLyBmaXJlZCB3aGVuIHdlIGFwcGVuZCBhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciAtIGRhdGE6IHsgc2VnbWVudDogc2VnbWVudCBvYmplY3QgfVxyXG4gIEJVRkZFUl9BUFBFTkRJTkc6ICdobHNCdWZmZXJBcHBlbmRpbmcnLFxyXG4gIC8vIGZpcmVkIHdoZW4gd2UgYXJlIGRvbmUgd2l0aCBhcHBlbmRpbmcgYSBtZWRpYSBzZWdtZW50IHRvIHRoZSBidWZmZXIgLSBkYXRhIDogeyBwYXJlbnQgOiBzZWdtZW50IHBhcmVudCB0aGF0IHRyaWdnZXJlZCBCVUZGRVJfQVBQRU5ESU5HLCBwZW5kaW5nIDogbmIgb2Ygc2VnbWVudHMgd2FpdGluZyBmb3IgYXBwZW5kaW5nIGZvciB0aGlzIHNlZ21lbnQgcGFyZW50fVxyXG4gIEJVRkZFUl9BUFBFTkRFRDogJ2hsc0J1ZmZlckFwcGVuZGVkJyxcclxuICAvLyBmaXJlZCB3aGVuIHRoZSBzdHJlYW0gaXMgZmluaXNoZWQgYW5kIHdlIHdhbnQgdG8gbm90aWZ5IHRoZSBtZWRpYSBidWZmZXIgdGhhdCB0aGVyZSB3aWxsIGJlIG5vIG1vcmUgZGF0YSAtIGRhdGE6IHsgfVxyXG4gIEJVRkZFUl9FT1M6ICdobHNCdWZmZXJFb3MnLFxyXG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGJ1ZmZlciBzaG91bGQgYmUgZmx1c2hlZCAtIGRhdGEgeyBzdGFydE9mZnNldCwgZW5kT2Zmc2V0IH1cclxuICBCVUZGRVJfRkxVU0hJTkc6ICdobHNCdWZmZXJGbHVzaGluZycsXHJcbiAgLy8gZmlyZWQgd2hlbiB0aGUgbWVkaWEgYnVmZmVyIGhhcyBiZWVuIGZsdXNoZWQgLSBkYXRhOiB7IH1cclxuICBCVUZGRVJfRkxVU0hFRDogJ2hsc0J1ZmZlckZsdXNoZWQnLFxyXG4gIC8vIGZpcmVkIHRvIHNpZ25hbCB0aGF0IGEgbWFuaWZlc3QgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IG1hbmlmZXN0VVJMfVxyXG4gIE1BTklGRVNUX0xPQURJTkc6ICdobHNNYW5pZmVzdExvYWRpbmcnLFxyXG4gIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10sIGF1ZGlvVHJhY2tzIDogWyBhdmFpbGFibGUgYXVkaW8gdHJhY2tzXSwgdXJsIDogbWFuaWZlc3RVUkwsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWV9fVxyXG4gIE1BTklGRVNUX0xPQURFRDogJ2hsc01hbmlmZXN0TG9hZGVkJyxcclxuICAvLyBmaXJlZCBhZnRlciBtYW5pZmVzdCBoYXMgYmVlbiBwYXJzZWQgLSBkYXRhOiB7IGxldmVscyA6IFthdmFpbGFibGUgcXVhbGl0eSBsZXZlbHNdLCBmaXJzdExldmVsIDogaW5kZXggb2YgZmlyc3QgcXVhbGl0eSBsZXZlbCBhcHBlYXJpbmcgaW4gTWFuaWZlc3R9XHJcbiAgTUFOSUZFU1RfUEFSU0VEOiAnaGxzTWFuaWZlc3RQYXJzZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBzd2l0Y2ggaXMgcmVxdWVzdGVkIC0gZGF0YTogeyBsZXZlbCA6IGlkIG9mIG5ldyBsZXZlbCB9XHJcbiAgTEVWRUxfU1dJVENISU5HOiAnaGxzTGV2ZWxTd2l0Y2hpbmcnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBzd2l0Y2ggaXMgZWZmZWN0aXZlIC0gZGF0YTogeyBsZXZlbCA6IGlkIG9mIG5ldyBsZXZlbCB9XHJcbiAgTEVWRUxfU1dJVENIRUQ6ICdobHNMZXZlbFN3aXRjaGVkJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IGxldmVsIFVSTCwgbGV2ZWwgOiBpZCBvZiBsZXZlbCBiZWluZyBsb2FkZWR9XHJcbiAgTEVWRUxfTE9BRElORzogJ2hsc0xldmVsTG9hZGluZycsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHBsYXlsaXN0IGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIGxvYWRlZCBsZXZlbCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX0gfVxyXG4gIExFVkVMX0xPQURFRDogJ2hsc0xldmVsTG9hZGVkJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBkZXRhaWxzIGhhdmUgYmVlbiB1cGRhdGVkIGJhc2VkIG9uIHByZXZpb3VzIGRldGFpbHMsIGFmdGVyIGl0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCB9XHJcbiAgTEVWRUxfVVBEQVRFRDogJ2hsc0xldmVsVXBkYXRlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsJ3MgUFRTIGluZm9ybWF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQgYWZ0ZXIgcGFyc2luZyBhIGZyYWdtZW50IC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiB1cGRhdGVkIGxldmVsLCBkcmlmdDogUFRTIGRyaWZ0IG9ic2VydmVkIHdoZW4gcGFyc2luZyBsYXN0IGZyYWdtZW50IH1cclxuICBMRVZFTF9QVFNfVVBEQVRFRDogJ2hsc0xldmVsUHRzVXBkYXRlZCcsXHJcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgYXVkaW8gdHJhY2sgbGlzdHMgaGFzIGJlZW4gdXBkYXRlZCAtIGRhdGE6IHsgYXVkaW9UcmFja3MgOiBhdWRpb1RyYWNrcyB9XHJcbiAgQVVESU9fVFJBQ0tTX1VQREFURUQ6ICdobHNBdWRpb1RyYWNrc1VwZGF0ZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgc3dpdGNoaW5nIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgaWQgOiBhdWRpbyB0cmFjayBpZCB9XHJcbiAgQVVESU9fVFJBQ0tfU1dJVENISU5HOiAnaGxzQXVkaW9UcmFja1N3aXRjaGluZycsXHJcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2ggYWN0dWFsbHkgb2NjdXJzIC0gZGF0YTogeyBpZCA6IGF1ZGlvIHRyYWNrIGlkIH1cclxuICBBVURJT19UUkFDS19TV0lUQ0hFRDogJ2hsc0F1ZGlvVHJhY2tTd2l0Y2hlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogYXVkaW8gdHJhY2sgVVJMLCBpZCA6IGF1ZGlvIHRyYWNrIGlkIH1cclxuICBBVURJT19UUkFDS19MT0FESU5HOiAnaGxzQXVkaW9UcmFja0xvYWRpbmcnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogYXVkaW8gdHJhY2sgaWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWUgfSB9XHJcbiAgQVVESU9fVFJBQ0tfTE9BREVEOiAnaGxzQXVkaW9UcmFja0xvYWRlZCcsXHJcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgc3VidGl0bGUgdHJhY2sgbGlzdHMgaGFzIGJlZW4gdXBkYXRlZCAtIGRhdGE6IHsgc3VidGl0bGVUcmFja3MgOiBzdWJ0aXRsZVRyYWNrcyB9XHJcbiAgU1VCVElUTEVfVFJBQ0tTX1VQREFURUQ6ICdobHNTdWJ0aXRsZVRyYWNrc1VwZGF0ZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYW4gc3VidGl0bGUgdHJhY2sgc3dpdGNoIG9jY3VycyAtIGRhdGE6IHsgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCB9XHJcbiAgU1VCVElUTEVfVFJBQ0tfU1dJVENIOiAnaGxzU3VidGl0bGVUcmFja1N3aXRjaCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBzdWJ0aXRsZSB0cmFjayBVUkwsIGlkIDogc3VidGl0bGUgdHJhY2sgaWQgfVxyXG4gIFNVQlRJVExFX1RSQUNLX0xPQURJTkc6ICdobHNTdWJ0aXRsZVRyYWNrTG9hZGluZycsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lIH0gfVxyXG4gIFNVQlRJVExFX1RSQUNLX0xPQURFRDogJ2hsc1N1YnRpdGxlVHJhY2tMb2FkZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBzdWJ0aXRsZSBmcmFnbWVudCBoYXMgYmVlbiBwcm9jZXNzZWQgLSBkYXRhOiB7IHN1Y2Nlc3MgOiBib29sZWFuLCBmcmFnIDogdGhlIHByb2Nlc3NlZCBmcmFnIH1cclxuICBTVUJUSVRMRV9GUkFHX1BST0NFU1NFRDogJ2hsc1N1YnRpdGxlRnJhZ1Byb2Nlc3NlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiB0aGUgZmlyc3QgdGltZXN0YW1wIGlzIGZvdW5kIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGluaXRQVFM6IGluaXRQVFMsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxyXG4gIElOSVRfUFRTX0ZPVU5EOiAnaGxzSW5pdFB0c0ZvdW5kJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxyXG4gIEZSQUdfTE9BRElORzogJ2hsc0ZyYWdMb2FkaW5nJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBwcm9ncmVzc2luZyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgeyB0cmVxdWVzdCwgdGZpcnN0LCBsb2FkZWQgfSB9XHJcbiAgRlJBR19MT0FEX1BST0dSRVNTOiAnaGxzRnJhZ0xvYWRQcm9ncmVzcycsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBhYm9ydGluZyBmb3IgZW1lcmdlbmN5IHN3aXRjaCBkb3duIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cclxuICBGUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQ6ICdobHNGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGZyYWdtZW50IHBheWxvYWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbGVuZ3RoIH0gfVxyXG4gIEZSQUdfTE9BREVEOiAnaGxzRnJhZ0xvYWRlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGhhcyBmaW5pc2hlZCBkZWNyeXB0aW5nIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGZyYWdtZW50IHBheWxvYWQsIHN0YXRzIDogeyB0c3RhcnQsIHRkZWNyeXB0IH0gfVxyXG4gIEZSQUdfREVDUllQVEVEOiAnaGxzRnJhZ0RlY3J5cHRlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBJbml0IFNlZ21lbnQgaGFzIGJlZW4gZXh0cmFjdGVkIGZyb20gZnJhZ21lbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBtb292IDogbW9vdiBNUDQgYm94LCBjb2RlY3MgOiBjb2RlY3MgZm91bmQgd2hpbGUgcGFyc2luZyBmcmFnbWVudCB9XHJcbiAgRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVDogJ2hsc0ZyYWdQYXJzaW5nSW5pdFNlZ21lbnQnLFxyXG4gIC8vIGZpcmVkIHdoZW4gcGFyc2luZyBzZWkgdGV4dCBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBzYW1wbGVzIDogWyBzZWkgc2FtcGxlcyBwZXMgXSB9XHJcbiAgRlJBR19QQVJTSU5HX1VTRVJEQVRBOiAnaGxzRnJhZ1BhcnNpbmdVc2VyZGF0YScsXHJcbiAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIGlkMyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBzYW1wbGVzIDogWyBpZDMgc2FtcGxlcyBwZXMgXSB9XHJcbiAgRlJBR19QQVJTSU5HX01FVEFEQVRBOiAnaGxzRnJhZ1BhcnNpbmdNZXRhZGF0YScsXHJcbiAgLy8gZmlyZWQgd2hlbiBkYXRhIGhhdmUgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIGRhdGExIDogbW9vZiBNUDQgYm94IG9yIFRTIGZyYWdtZW50cywgZGF0YTIgOiBtZGF0IE1QNCBib3ggb3IgbnVsbH1cclxuICBGUkFHX1BBUlNJTkdfREFUQTogJ2hsc0ZyYWdQYXJzaW5nRGF0YScsXHJcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCBwYXJzaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QgfVxyXG4gIEZSQUdfUEFSU0VEOiAnaGxzRnJhZ1BhcnNlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCByZW11eGVkIE1QNCBib3hlcyBoYXZlIGFsbCBiZWVuIGFwcGVuZGVkIGludG8gU291cmNlQnVmZmVyIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgdHBhcnNlZCwgdGJ1ZmZlcmVkLCBsZW5ndGgsIGJ3RXN0aW1hdGUgfSB9XHJcbiAgRlJBR19CVUZGRVJFRDogJ2hsc0ZyYWdCdWZmZXJlZCcsXHJcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCBtYXRjaGluZyB3aXRoIGN1cnJlbnQgbWVkaWEgcG9zaXRpb24gaXMgY2hhbmdpbmcgLSBkYXRhIDogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxyXG4gIEZSQUdfQ0hBTkdFRDogJ2hsc0ZyYWdDaGFuZ2VkJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIEZQUyBkcm9wIGV2ZW50IC0gZGF0YTogeyBjdXJlbnREcm9wcGVkLCBjdXJyZW50RGVjb2RlZCwgdG90YWxEcm9wcGVkRnJhbWVzIH1cclxuICBGUFNfRFJPUDogJ2hsc0Zwc0Ryb3AnLFxyXG4gIC8vIHRyaWdnZXJlZCB3aGVuIEZQUyBkcm9wIHRyaWdnZXJzIGF1dG8gbGV2ZWwgY2FwcGluZyAtIGRhdGE6IHsgbGV2ZWwsIGRyb3BwZWRsZXZlbCB9XHJcbiAgRlBTX0RST1BfTEVWRUxfQ0FQUElORzogJ2hsc0Zwc0Ryb3BMZXZlbENhcHBpbmcnLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGVycm9yIGV2ZW50IC0gZGF0YTogeyB0eXBlIDogZXJyb3IgdHlwZSwgZGV0YWlscyA6IGVycm9yIGRldGFpbHMsIGZhdGFsIDogaWYgdHJ1ZSwgaGxzLmpzIGNhbm5vdC93aWxsIG5vdCB0cnkgdG8gcmVjb3ZlciwgaWYgZmFsc2UsIGhscy5qcyB3aWxsIHRyeSB0byByZWNvdmVyLG90aGVyIGVycm9yIHNwZWNpZmljIGRhdGEgfVxyXG4gIEVSUk9SOiAnaGxzRXJyb3InLFxyXG4gIC8vIGZpcmVkIHdoZW4gaGxzLmpzIGluc3RhbmNlIHN0YXJ0cyBkZXN0cm95aW5nLiBEaWZmZXJlbnQgZnJvbSBNRURJQV9ERVRBQ0hFRCBhcyBvbmUgY291bGQgd2FudCB0byBkZXRhY2ggYW5kIHJlYXR0YWNoIGEgbWVkaWEgdG8gdGhlIGluc3RhbmNlIG9mIGhscy5qcyB0byBoYW5kbGUgbWlkLXJvbGxzIGZvciBleGFtcGxlIC0gZGF0YTogeyB9XHJcbiAgREVTVFJPWUlORzogJ2hsc0Rlc3Ryb3lpbmcnLFxyXG4gIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XHJcbiAgS0VZX0xPQURJTkc6ICdobHNLZXlMb2FkaW5nJyxcclxuICAvLyBmaXJlZCB3aGVuIGEgZGVjcnlwdCBrZXkgbG9hZGluZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBrZXkgcGF5bG9hZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBsZW5ndGggfSB9XHJcbiAgS0VZX0xPQURFRDogJ2hsc0tleUxvYWRlZCcsXHJcbiAgLy8gZmlyZWQgdXBvbiBzdHJlYW0gY29udHJvbGxlciBzdGF0ZSB0cmFuc2l0aW9ucyAtIGRhdGE6IHsgcHJldmlvdXNTdGF0ZSwgbmV4dFN0YXRlIH1cclxuICBTVFJFQU1fU1RBVEVfVFJBTlNJVElPTjogJ2hsc1N0cmVhbVN0YXRlVHJhbnNpdGlvbicsXHJcbiAgLy8gZmlyZWQgd2hlbiB0aGUgbGl2ZSBiYWNrIGJ1ZmZlciBpcyByZWFjaGVkIGRlZmluZWQgYnkgdGhlIGxpdmVCYWNrQnVmZmVyTGVuZ3RoIGNvbmZpZyBvcHRpb24gLSBkYXRhIDogeyBidWZmZXJFbmQ6IG51bWJlciB9XHJcbiAgTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVEOiAnaGxzTGl2ZUJhY2tCdWZmZXJSZWFjaGVkJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSGxzRXZlbnRzO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9ldmVudHMuanMiLCJleHBvcnQgZW51bSBFcnJvclR5cGVzIHtcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIG5ldHdvcmsgZXJyb3IgKGxvYWRpbmcgZXJyb3IgLyB0aW1lb3V0IC4uLilcclxuICBORVRXT1JLX0VSUk9SID0gJ25ldHdvcmtFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtZWRpYSBFcnJvciAodmlkZW8vcGFyc2luZy9tZWRpYXNvdXJjZSBlcnJvcilcclxuICBNRURJQV9FUlJPUiA9ICdtZWRpYUVycm9yJyxcclxuICAvLyBFTUUgKGVuY3J5cHRlZCBtZWRpYSBleHRlbnNpb25zKSBlcnJvcnNcclxuICBLRVlfU1lTVEVNX0VSUk9SID0gJ2tleVN5c3RlbUVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIG11eCBFcnJvciAoZGVtdXhpbmcvcmVtdXhpbmcpXHJcbiAgTVVYX0VSUk9SID0gJ211eEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhbGwgb3RoZXIgZXJyb3JzXHJcbiAgT1RIRVJfRVJST1IgPSAnb3RoZXJFcnJvcidcclxufVxyXG5cclxuLyoqXHJcbiAqIEBlbnVtIHtFcnJvckRldGFpbHN9XHJcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IEVycm9yRGV0YWlsXHJcbiAqL1xyXG5leHBvcnQgZW51bSBFcnJvckRldGFpbHMge1xyXG4gIEtFWV9TWVNURU1fTk9fS0VZUyA9ICdrZXlTeXN0ZW1Ob0tleXMnLFxyXG4gIEtFWV9TWVNURU1fTk9fQUNDRVNTID0gJ2tleVN5c3RlbU5vQWNjZXNzJyxcclxuICBLRVlfU1lTVEVNX05PX1NFU1NJT04gPSAna2V5U3lzdGVtTm9TZXNzaW9uJyxcclxuICBLRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQgPSAna2V5U3lzdGVtTGljZW5zZVJlcXVlc3RGYWlsZWQnLFxyXG4gIEtFWV9TWVNURU1fTk9fSU5JVF9EQVRBID0gJ2tleVN5c3RlbU5vSW5pdERhdGEnLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cclxuICBNQU5JRkVTVF9MT0FEX0VSUk9SID0gJ21hbmlmZXN0TG9hZEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cclxuICBNQU5JRkVTVF9MT0FEX1RJTUVPVVQgPSAnbWFuaWZlc3RMb2FkVGltZU91dCcsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBwYXJzaW5nIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb259XHJcbiAgTUFOSUZFU1RfUEFSU0lOR19FUlJPUiA9ICdtYW5pZmVzdFBhcnNpbmdFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCB3aXRoIG9ubHkgaW5jb21wYXRpYmxlIGNvZGVjcyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxyXG4gIE1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IgPSAnbWFuaWZlc3RJbmNvbXBhdGlibGVDb2RlY3NFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxyXG4gIExFVkVMX0xPQURfRVJST1IgPSAnbGV2ZWxMb2FkRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxyXG4gIExFVkVMX0xPQURfVElNRU9VVCA9ICdsZXZlbExvYWRUaW1lT3V0JyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIHN3aXRjaCBlcnJvciAtIGRhdGE6IHsgbGV2ZWwgOiBmYXVsdHkgbGV2ZWwgSWQsIGV2ZW50IDogZXJyb3IgZGVzY3JpcHRpb259XHJcbiAgTEVWRUxfU1dJVENIX0VSUk9SID0gJ2xldmVsU3dpdGNoRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGF1ZGlvIHRyYWNrIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XHJcbiAgQVVESU9fVFJBQ0tfTE9BRF9FUlJPUiA9ICdhdWRpb1RyYWNrTG9hZEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XHJcbiAgQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUID0gJ2F1ZGlvVHJhY2tMb2FkVGltZU91dCcsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cclxuICBGUkFHX0xPQURfRVJST1IgPSAnZnJhZ0xvYWRFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCB0aW1lb3V0IGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxyXG4gIEZSQUdfTE9BRF9USU1FT1VUID0gJ2ZyYWdMb2FkVGltZU91dCcsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBmcmFnbWVudCBkZWNyeXB0aW9uIGVycm9yIGV2ZW50IC0gZGF0YToge2lkIDogZGVtdXhlciBJZCxmcmFnOiBmcmFnbWVudCBvYmplY3QsIHJlYXNvbiA6IHBhcnNpbmcgZXJyb3IgZGVzY3JpcHRpb24gfVxyXG4gIEZSQUdfREVDUllQVF9FUlJPUiA9ICdmcmFnRGVjcnlwdEVycm9yJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IHBhcnNpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgcmVhc29uIDogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvbiB9XHJcbiAgLy8gd2lsbCBiZSByZW5hbWVkIERFTVVYX1BBUlNJTkdfRVJST1IgYW5kIHN3aXRjaGVkIHRvIE1VWF9FUlJPUiBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlXHJcbiAgRlJBR19QQVJTSU5HX0VSUk9SID0gJ2ZyYWdQYXJzaW5nRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgcmVtdXggYWxsb2MgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgYnl0ZXMgOiBuYiBvZiBieXRlcyBvbiB3aGljaCBhbGxvY2F0aW9uIGZhaWxlZCAsIHJlYXNvbiA6IGVycm9yIHRleHQgfVxyXG4gIFJFTVVYX0FMTE9DX0VSUk9SID0gJ3JlbXV4QWxsb2NFcnJvcicsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgZGVjcnlwdCBrZXkgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cclxuICBLRVlfTE9BRF9FUlJPUiA9ICdrZXlMb2FkRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cclxuICBLRVlfTE9BRF9USU1FT1VUID0gJ2tleUxvYWRUaW1lT3V0JyxcclxuICAvLyBUcmlnZ2VyZWQgd2hlbiBhbiBleGNlcHRpb24gb2NjdXJzIHdoaWxlIGFkZGluZyBhIHNvdXJjZUJ1ZmZlciB0byBNZWRpYVNvdXJjZSAtIGRhdGEgOiB7ICBlcnIgOiBleGNlcHRpb24gLCBtaW1lVHlwZSA6IG1pbWVUeXBlIH1cclxuICBCVUZGRVJfQUREX0NPREVDX0VSUk9SID0gJ2J1ZmZlckFkZENvZGVjRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZCBlcnJvciAtIGRhdGE6IGFwcGVuZCBlcnJvciBkZXNjcmlwdGlvblxyXG4gIEJVRkZFUl9BUFBFTkRfRVJST1IgPSAnYnVmZmVyQXBwZW5kRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZGluZyBlcnJvciBldmVudCAtIGRhdGE6IGFwcGVuZGluZyBlcnJvciBkZXNjcmlwdGlvblxyXG4gIEJVRkZFUl9BUFBFTkRJTkdfRVJST1IgPSAnYnVmZmVyQXBwZW5kaW5nRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHN0YWxsZWQgZXJyb3IgZXZlbnRcclxuICBCVUZGRVJfU1RBTExFRF9FUlJPUiA9ICdidWZmZXJTdGFsbGVkRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGZ1bGwgZXZlbnRcclxuICBCVUZGRVJfRlVMTF9FUlJPUiA9ICdidWZmZXJGdWxsRXJyb3InLFxyXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHNlZWsgb3ZlciBob2xlIGV2ZW50XHJcbiAgQlVGRkVSX1NFRUtfT1ZFUl9IT0xFID0gJ2J1ZmZlclNlZWtPdmVySG9sZScsXHJcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgbnVkZ2Ugb24gc3RhbGwgKHBsYXliYWNrIGlzIHN0dWNrIGFsdGhvdWdoIGN1cnJlbnRUaW1lIGlzIGluIGEgYnVmZmVyZWQgYXJlYSlcclxuICBCVUZGRVJfTlVER0VfT05fU1RBTEwgPSAnYnVmZmVyTnVkZ2VPblN0YWxsJyxcclxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBpbnRlcm5hbCBleGNlcHRpb24gaGFwcGVuaW5nIGluc2lkZSBobHMuanMgd2hpbGUgaGFuZGxpbmcgYW4gZXZlbnRcclxuICBJTlRFUk5BTF9FWENFUFRJT04gPSAnaW50ZXJuYWxFeGNlcHRpb24nXHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvZXJyb3JzLnRzIiwiLypcclxuKlxyXG4qIEFsbCBvYmplY3RzIGluIHRoZSBldmVudCBoYW5kbGluZyBjaGFpbiBzaG91bGQgaW5oZXJpdCBmcm9tIHRoaXMgY2xhc3NcclxuKlxyXG4qL1xyXG5cclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuL2Vycm9ycyc7XHJcbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cyc7XHJcbmltcG9ydCBIbHMgZnJvbSAnLi9obHMnO1xyXG5cclxuY29uc3QgRk9SQklEREVOX0VWRU5UX05BTUVTID0ge1xyXG4gICdobHNFdmVudEdlbmVyaWMnOiB0cnVlLFxyXG4gICdobHNIYW5kbGVyRGVzdHJveWluZyc6IHRydWUsXHJcbiAgJ2hsc0hhbmRsZXJEZXN0cm95ZWQnOiB0cnVlXHJcbn07XHJcblxyXG5jbGFzcyBFdmVudEhhbmRsZXIge1xyXG4gIGhsczogSGxzO1xyXG4gIGhhbmRsZWRFdmVudHM6IGFueVtdO1xyXG4gIHVzZUdlbmVyaWNIYW5kbGVyOiBib29sZWFuO1xyXG5cclxuICBjb25zdHJ1Y3RvciAoaGxzOiBIbHMsIC4uLmV2ZW50czogYW55W10pIHtcclxuICAgIHRoaXMuaGxzID0gaGxzO1xyXG4gICAgdGhpcy5vbkV2ZW50ID0gdGhpcy5vbkV2ZW50LmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmhhbmRsZWRFdmVudHMgPSBldmVudHM7XHJcbiAgICB0aGlzLnVzZUdlbmVyaWNIYW5kbGVyID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95ICgpIHtcclxuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWluZygpO1xyXG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XHJcbiAgICB0aGlzLm9uSGFuZGxlckRlc3Ryb3llZCgpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIG9uSGFuZGxlckRlc3Ryb3lpbmcgKCkge31cclxuICBwcm90ZWN0ZWQgb25IYW5kbGVyRGVzdHJveWVkICgpIHt9XHJcblxyXG4gIGlzRXZlbnRIYW5kbGVyICgpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdGhpcy5oYW5kbGVkRXZlbnRzID09PSAnb2JqZWN0JyAmJiB0aGlzLmhhbmRsZWRFdmVudHMubGVuZ3RoICYmIHR5cGVvZiB0aGlzLm9uRXZlbnQgPT09ICdmdW5jdGlvbic7XHJcbiAgfVxyXG5cclxuICByZWdpc3Rlckxpc3RlbmVycyAoKSB7XHJcbiAgICBpZiAodGhpcy5pc0V2ZW50SGFuZGxlcigpKSB7XHJcbiAgICAgIHRoaXMuaGFuZGxlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIGlmIChGT1JCSURERU5fRVZFTlRfTkFNRVNbZXZlbnRdKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvcmJpZGRlbiBldmVudC1uYW1lOiAnICsgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5obHMub24oZXZlbnQsIHRoaXMub25FdmVudCk7XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdW5yZWdpc3Rlckxpc3RlbmVycyAoKSB7XHJcbiAgICBpZiAodGhpcy5pc0V2ZW50SGFuZGxlcigpKSB7XHJcbiAgICAgIHRoaXMuaGFuZGxlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHRoaXMuaGxzLm9mZihldmVudCwgdGhpcy5vbkV2ZW50KTtcclxuICAgICAgfSwgdGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBhcmd1bWVudHM6IGV2ZW50IChzdHJpbmcpLCBkYXRhIChhbnkpXHJcbiAgICovXHJcbiAgb25FdmVudCAoZXZlbnQ6IHN0cmluZywgZGF0YTogYW55KSB7XHJcbiAgICB0aGlzLm9uRXZlbnRHZW5lcmljKGV2ZW50LCBkYXRhKTtcclxuICB9XHJcblxyXG4gIG9uRXZlbnRHZW5lcmljIChldmVudDogc3RyaW5nLCBkYXRhOiBhbnkpIHtcclxuICAgIGxldCBldmVudFRvRnVuY3Rpb24gPSBmdW5jdGlvbiAoZXZlbnQ6IHN0cmluZywgZGF0YTogYW55KSB7XHJcbiAgICAgIGxldCBmdW5jTmFtZSA9ICdvbicgKyBldmVudC5yZXBsYWNlKCdobHMnLCAnJyk7XHJcbiAgICAgIGlmICh0eXBlb2YgdGhpc1tmdW5jTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV2ZW50ICR7ZXZlbnR9IGhhcyBubyBnZW5lcmljIGhhbmRsZXIgaW4gdGhpcyAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gY2xhc3MgKHRyaWVkICR7ZnVuY05hbWV9KWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpc1tmdW5jTmFtZV0uYmluZCh0aGlzLCBkYXRhKTtcclxuICAgIH07XHJcbiAgICB0cnkge1xyXG4gICAgICBldmVudFRvRnVuY3Rpb24uY2FsbCh0aGlzLCBldmVudCwgZGF0YSkuY2FsbCgpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcihgQW4gaW50ZXJuYWwgZXJyb3IgaGFwcGVuZWQgd2hpbGUgaGFuZGxpbmcgZXZlbnQgJHtldmVudH0uIEVycm9yIG1lc3NhZ2U6IFwiJHtlcnIubWVzc2FnZX1cIi4gSGVyZSBpcyBhIHN0YWNrdHJhY2U6YCwgZXJyKTtcclxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLCBmYXRhbDogZmFsc2UsIGV2ZW50OiBldmVudCwgZXJyOiBlcnIgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFdmVudEhhbmRsZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2V2ZW50LWhhbmRsZXIudHMiLCJleHBvcnQgZnVuY3Rpb24gZ2V0U2VsZlNjb3BlICgpIHtcclxuICAvLyBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExMjM3MjU5LzU4OTQ5M1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmICovXHJcbiAgICByZXR1cm4gc2VsZjtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHdpbmRvdztcclxuICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMvZ2V0LXNlbGYtc2NvcGUuanMiLCIvKipcclxuICogQG1vZHVsZSBCdWZmZXJIZWxwZXJcclxuICpcclxuICogUHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyB3aXRoIGJ1ZmZlciBsZW5ndGggcmV0cmlldmFsIGZvciBleGFtcGxlLlxyXG4gKlxyXG4gKiBJbiBnZW5lcmFsLCBhIGhlbHBlciBhcm91bmQgSFRNTDUgTWVkaWFFbGVtZW50IFRpbWVSYW5nZXMgZ2F0aGVyZWQgZnJvbSBgYnVmZmVyZWRgIHByb3BlcnR5LlxyXG4gKlxyXG4gKiBBbHNvIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvYnVmZmVyZWRcclxuKi9cclxuXHJcbnR5cGUgQnVmZmVyVGltZVJhbmdlID0ge1xyXG4gIHN0YXJ0OiBudW1iZXJcclxuICBlbmQ6IG51bWJlclxyXG59O1xyXG5cclxudHlwZSBCdWZmZXJhYmxlID0ge1xyXG4gIGJ1ZmZlcmVkOiBUaW1lUmFuZ2VzXHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgQnVmZmVySGVscGVyIHtcclxuICAvKipcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBgbWVkaWFgJ3MgYnVmZmVyZWQgaW5jbHVkZSBgcG9zaXRpb25gXHJcbiAgICogQHBhcmFtIHtCdWZmZXJhYmxlfSBtZWRpYVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHN0YXRpYyBpc0J1ZmZlcmVkIChtZWRpYTogQnVmZmVyYWJsZSwgcG9zaXRpb246IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKG1lZGlhKSB7XHJcbiAgICAgICAgbGV0IGJ1ZmZlcmVkID0gbWVkaWEuYnVmZmVyZWQ7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKHBvc2l0aW9uID49IGJ1ZmZlcmVkLnN0YXJ0KGkpICYmIHBvc2l0aW9uIDw9IGJ1ZmZlcmVkLmVuZChpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIC8vIHRoaXMgaXMgdG8gY2F0Y2hcclxuICAgICAgLy8gSW52YWxpZFN0YXRlRXJyb3I6IEZhaWxlZCB0byByZWFkIHRoZSAnYnVmZmVyZWQnIHByb3BlcnR5IGZyb20gJ1NvdXJjZUJ1ZmZlcic6XHJcbiAgICAgIC8vIFRoaXMgU291cmNlQnVmZmVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IG1lZGlhIHNvdXJjZVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGJ1ZmZlckluZm8gKFxyXG4gICAgbWVkaWE6IEJ1ZmZlcmFibGUsXHJcbiAgICBwb3M6IG51bWJlcixcclxuICAgIG1heEhvbGVEdXJhdGlvbjogbnVtYmVyXHJcbiAgKToge1xyXG4gICAgbGVuOiBudW1iZXIsXHJcbiAgICBzdGFydDogbnVtYmVyLFxyXG4gICAgZW5kOiBudW1iZXIsXHJcbiAgICBuZXh0U3RhcnQ/OiBudW1iZXIsXHJcbiAgfSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAobWVkaWEpIHtcclxuICAgICAgICBsZXQgdmJ1ZmZlcmVkID0gbWVkaWEuYnVmZmVyZWQ7XHJcbiAgICAgICAgbGV0IGJ1ZmZlcmVkOiBCdWZmZXJUaW1lUmFuZ2VbXSA9IFtdO1xyXG4gICAgICAgIGxldCBpOiBudW1iZXI7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZidWZmZXJlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgYnVmZmVyZWQucHVzaCh7IHN0YXJ0OiB2YnVmZmVyZWQuc3RhcnQoaSksIGVuZDogdmJ1ZmZlcmVkLmVuZChpKSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAvLyB0aGlzIGlzIHRvIGNhdGNoXHJcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxyXG4gICAgICAvLyBUaGlzIFNvdXJjZUJ1ZmZlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhcmVudCBtZWRpYSBzb3VyY2VcclxuICAgIH1cclxuICAgIHJldHVybiB7IGxlbjogMCwgc3RhcnQ6IHBvcywgZW5kOiBwb3MsIG5leHRTdGFydDogdW5kZWZpbmVkIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYnVmZmVyZWRJbmZvIChcclxuICAgIGJ1ZmZlcmVkOiBCdWZmZXJUaW1lUmFuZ2VbXSxcclxuICAgIHBvczogbnVtYmVyLFxyXG4gICAgbWF4SG9sZUR1cmF0aW9uOiBudW1iZXJcclxuICApOiB7XHJcbiAgICBsZW46IG51bWJlcixcclxuICAgIHN0YXJ0OiBudW1iZXIsXHJcbiAgICBlbmQ6IG51bWJlcixcclxuICAgIG5leHRTdGFydD86IG51bWJlcixcclxuICB9IHtcclxuICAgIC8vIHNvcnQgb24gYnVmZmVyLnN0YXJ0L3NtYWxsZXIgZW5kIChJRSBkb2VzIG5vdCBhbHdheXMgcmV0dXJuIHNvcnRlZCBidWZmZXJlZCByYW5nZSlcclxuICAgIGJ1ZmZlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgbGV0IGRpZmYgPSBhLnN0YXJ0IC0gYi5zdGFydDtcclxuICAgICAgaWYgKGRpZmYpIHtcclxuICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYi5lbmQgLSBhLmVuZDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IGJ1ZmZlcmVkMjogQnVmZmVyVGltZVJhbmdlW10gPSBbXTtcclxuICAgIGlmIChtYXhIb2xlRHVyYXRpb24pIHtcclxuICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgc29tZSBzbWFsbCBob2xlcyBiZXR3ZWVuIGJ1ZmZlciB0aW1lIHJhbmdlXHJcbiAgICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxyXG4gICAgICAvLyBidWZmZXIgdGltZSByYW5nZSByZXByZXNlbnRhdGlvbnMgdGhhdCBkaXNjYXJkcyB0aG9zZSBob2xlc1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGJ1ZjJsZW4gPSBidWZmZXJlZDIubGVuZ3RoO1xyXG4gICAgICAgIGlmIChidWYybGVuKSB7XHJcbiAgICAgICAgICBsZXQgYnVmMmVuZCA9IGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kO1xyXG4gICAgICAgICAgLy8gaWYgc21hbGwgaG9sZSAodmFsdWUgYmV0d2VlbiAwIG9yIG1heEhvbGVEdXJhdGlvbiApIG9yIG92ZXJsYXBwaW5nIChuZWdhdGl2ZSlcclxuICAgICAgICAgIGlmICgoYnVmZmVyZWRbaV0uc3RhcnQgLSBidWYyZW5kKSA8IG1heEhvbGVEdXJhdGlvbikge1xyXG4gICAgICAgICAgICAvLyBtZXJnZSBvdmVybGFwcGluZyB0aW1lIHJhbmdlc1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgbGFzdFJhbmdlLmVuZCBvbmx5IGlmIHNtYWxsZXIgdGhhbiBpdGVtLmVuZFxyXG4gICAgICAgICAgICAvLyBlLmcuICBbIDEsIDE1XSB3aXRoICBbIDIsOF0gPT4gWyAxLDE1XSAobm8gbmVlZCB0byBtb2RpZnkgbGFzdFJhbmdlLmVuZClcclxuICAgICAgICAgICAgLy8gd2hlcmVhcyBbIDEsIDhdIHdpdGggIFsgMiwxNV0gPT4gWyAxLDE1XSAoIGxhc3RSYW5nZSBzaG91bGQgc3dpdGNoIGZyb20gWzEsOF0gdG8gWzEsMTVdKVxyXG4gICAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uZW5kID4gYnVmMmVuZCkge1xyXG4gICAgICAgICAgICAgIGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kID0gYnVmZmVyZWRbaV0uZW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBiaWcgaG9sZVxyXG4gICAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGZpcnN0IHZhbHVlXHJcbiAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBidWZmZXJlZDIgPSBidWZmZXJlZDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgYnVmZmVyTGVuID0gMDtcclxuXHJcbiAgICAvLyBidWZmZXJTdGFydE5leHQgY2FuIHBvc3NpYmx5IGJlIHVuZGVmaW5lZCBiYXNlZCBvbiB0aGUgY29uZGl0aW9uYWwgbG9naWMgYmVsb3dcclxuICAgIGxldCBidWZmZXJTdGFydE5leHQ6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvLyBidWZmZXJTdGFydCBhbmQgYnVmZmVyRW5kIGFyZSBidWZmZXIgYm91bmRhcmllcyBhcm91bmQgY3VycmVudCB2aWRlbyBwb3NpdGlvblxyXG4gICAgbGV0IGJ1ZmZlclN0YXJ0OiBudW1iZXIgPSBwb3M7XHJcbiAgICBsZXQgYnVmZmVyRW5kOiBudW1iZXIgPSBwb3M7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkMi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsZXQgc3RhcnQgPSBidWZmZXJlZDJbaV0uc3RhcnQsXHJcbiAgICAgICAgZW5kID0gYnVmZmVyZWQyW2ldLmVuZDtcclxuICAgICAgLy8gbG9nZ2VyLmxvZygnYnVmIHN0YXJ0L2VuZDonICsgYnVmZmVyZWQuc3RhcnQoaSkgKyAnLycgKyBidWZmZXJlZC5lbmQoaSkpO1xyXG4gICAgICBpZiAoKHBvcyArIG1heEhvbGVEdXJhdGlvbikgPj0gc3RhcnQgJiYgcG9zIDwgZW5kKSB7XHJcbiAgICAgICAgLy8gcGxheSBwb3NpdGlvbiBpcyBpbnNpZGUgdGhpcyBidWZmZXIgVGltZVJhbmdlLCByZXRyaWV2ZSBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uIGFuZCBidWZmZXIgbGVuZ3RoXHJcbiAgICAgICAgYnVmZmVyU3RhcnQgPSBzdGFydDtcclxuICAgICAgICBidWZmZXJFbmQgPSBlbmQ7XHJcbiAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVyRW5kIC0gcG9zO1xyXG4gICAgICB9IGVsc2UgaWYgKChwb3MgKyBtYXhIb2xlRHVyYXRpb24pIDwgc3RhcnQpIHtcclxuICAgICAgICBidWZmZXJTdGFydE5leHQgPSBzdGFydDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgbGVuOiBidWZmZXJMZW4sIHN0YXJ0OiBidWZmZXJTdGFydCwgZW5kOiBidWZmZXJFbmQsIG5leHRTdGFydDogYnVmZmVyU3RhcnROZXh0IH07XHJcbiAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHMiLCJpbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuXHJcbmV4cG9ydCBjb25zdCBGcmFnbWVudFN0YXRlID0ge1xyXG4gIE5PVF9MT0FERUQ6ICdOT1RfTE9BREVEJyxcclxuICBBUFBFTkRJTkc6ICdBUFBFTkRJTkcnLFxyXG4gIFBBUlRJQUw6ICdQQVJUSUFMJyxcclxuICBPSzogJ09LJ1xyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIEZyYWdtZW50VHJhY2tlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcbiAgY29uc3RydWN0b3IgKGhscykge1xyXG4gICAgc3VwZXIoaGxzLFxyXG4gICAgICBFdmVudC5CVUZGRVJfQVBQRU5ERUQsXHJcbiAgICAgIEV2ZW50LkZSQUdfQlVGRkVSRUQsXHJcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVEXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuYnVmZmVyUGFkZGluZyA9IDAuMjtcclxuXHJcbiAgICB0aGlzLmZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB0aGlzLnRpbWVSYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcclxuICB9XHJcblxyXG4gIGRlc3Ryb3kgKCkge1xyXG4gICAgdGhpcy5mcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgdGhpcy50aW1lUmFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcclxuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgRnJhZ21lbnQgdGhhdCBtYXRjaCB0aGUgcG9zaXRpb24gYW5kIGxldmVsVHlwZS5cclxuICAgKiBJZiBub3QgZm91bmQgYW55IEZyYWdtZW50LCByZXR1cm4gbnVsbFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxyXG4gICAqIEBwYXJhbSB7TGV2ZWxUeXBlfSBsZXZlbFR5cGVcclxuICAgKiBAcmV0dXJucyB7RnJhZ21lbnR8bnVsbH1cclxuICAgKi9cclxuICBnZXRCdWZmZXJlZEZyYWcgKHBvc2l0aW9uLCBsZXZlbFR5cGUpIHtcclxuICAgIGNvbnN0IGZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzO1xyXG4gICAgY29uc3QgYnVmZmVyZWRGcmFncyA9IE9iamVjdC5rZXlzKGZyYWdtZW50cykuZmlsdGVyKGtleSA9PiB7XHJcbiAgICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gZnJhZ21lbnRzW2tleV07XHJcbiAgICAgIGlmIChmcmFnbWVudEVudGl0eS5ib2R5LnR5cGUgIT09IGxldmVsVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZnJhZyA9IGZyYWdtZW50RW50aXR5LmJvZHk7XHJcbiAgICAgIHJldHVybiBmcmFnLnN0YXJ0UFRTIDw9IHBvc2l0aW9uICYmIHBvc2l0aW9uIDw9IGZyYWcuZW5kUFRTO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoYnVmZmVyZWRGcmFncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzE1NDUjZGlzY3Vzc2lvbl9yMTY2MjI5NTY2XHJcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkRnJhZ0tleSA9IGJ1ZmZlcmVkRnJhZ3MucG9wKCk7XHJcbiAgICAgIHJldHVybiBmcmFnbWVudHNbYnVmZmVyZWRGcmFnS2V5XS5ib2R5O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFydGlhbCBmcmFnbWVudHMgZWZmZWN0ZWQgYnkgY29kZWQgZnJhbWUgZXZpY3Rpb24gd2lsbCBiZSByZW1vdmVkXHJcbiAgICogVGhlIGJyb3dzZXIgd2lsbCB1bmxvYWQgcGFydHMgb2YgdGhlIGJ1ZmZlciB0byBmcmVlIHVwIG1lbW9yeSBmb3IgbmV3IGJ1ZmZlciBkYXRhXHJcbiAgICogRnJhZ21lbnRzIHdpbGwgbmVlZCB0byBiZSByZWxvYWRlZCB3aGVuIHRoZSBidWZmZXIgaXMgZnJlZWQgdXAsIHJlbW92aW5nIHBhcnRpYWwgZnJhZ21lbnRzIHdpbGwgYWxsb3cgdGhlbSB0byByZWxvYWQoc2luY2UgdGhlcmUgbWlnaHQgYmUgcGFydHMgdGhhdCBhcmUgc3RpbGwgcGxheWFibGUpXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVsZW1lbnRhcnlTdHJlYW0gVGhlIGVsZW1lbnRhcnlTdHJlYW0gb2YgbWVkaWEgdGhpcyBpcyAoZWcuIHZpZGVvL2F1ZGlvKVxyXG4gICAqIEBwYXJhbSB7VGltZVJhbmdlc30gdGltZVJhbmdlIFRpbWVSYW5nZSBvYmplY3QgZnJvbSBhIHNvdXJjZUJ1ZmZlclxyXG4gICAqL1xyXG4gIGRldGVjdEV2aWN0ZWRGcmFnbWVudHMgKGVsZW1lbnRhcnlTdHJlYW0sIHRpbWVSYW5nZSkge1xyXG4gICAgbGV0IGZyYWdtZW50VGltZXMsIHRpbWU7XHJcbiAgICAvLyBDaGVjayBpZiBhbnkgZmxhZ2dlZCBmcmFnbWVudHMgaGF2ZSBiZWVuIHVubG9hZGVkXHJcbiAgICBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2tleV07XHJcbiAgICAgIGlmIChmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IGVzRGF0YSA9IGZyYWdtZW50RW50aXR5LnJhbmdlW2VsZW1lbnRhcnlTdHJlYW1dO1xyXG4gICAgICAgIGlmIChlc0RhdGEpIHtcclxuICAgICAgICAgIGZyYWdtZW50VGltZXMgPSBlc0RhdGEudGltZTtcclxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhZ21lbnRUaW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aW1lID0gZnJhZ21lbnRUaW1lc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVGltZUJ1ZmZlcmVkKHRpbWUuc3RhcnRQVFMsIHRpbWUuZW5kUFRTLCB0aW1lUmFuZ2UpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgIC8vIFVucmVnaXN0ZXIgcGFydGlhbCBmcmFnbWVudCBhcyBpdCBuZWVkcyB0byBsb2FkIGFnYWluIHRvIGJlIHJldXNlZFxyXG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoZSBmcmFnbWVudCBwYXNzZWQgaW4gaXMgbG9hZGVkIGluIHRoZSBidWZmZXIgcHJvcGVybHlcclxuICAgKiBQYXJ0aWFsbHkgbG9hZGVkIGZyYWdtZW50cyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgYSBwYXJ0aWFsIGZyYWdtZW50XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGZyYWdtZW50IENoZWNrIHRoZSBmcmFnbWVudCBhZ2FpbnN0IGFsbCBzb3VyY2VCdWZmZXJzIGxvYWRlZFxyXG4gICAqL1xyXG4gIGRldGVjdFBhcnRpYWxGcmFnbWVudHMgKGZyYWdtZW50KSB7XHJcbiAgICBsZXQgZnJhZ0tleSA9IHRoaXMuZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xyXG4gICAgbGV0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XHJcbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcclxuICAgICAgZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgPSB0cnVlO1xyXG5cclxuICAgICAgT2JqZWN0LmtleXModGhpcy50aW1lUmFuZ2VzKS5mb3JFYWNoKGVsZW1lbnRhcnlTdHJlYW0gPT4ge1xyXG4gICAgICAgIGlmIChmcmFnbWVudC5oYXNFbGVtZW50YXJ5U3RyZWFtKGVsZW1lbnRhcnlTdHJlYW0pKSB7XHJcbiAgICAgICAgICBsZXQgdGltZVJhbmdlID0gdGhpcy50aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dO1xyXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIG1hbGZvcm1lZCBmcmFnbWVudHNcclxuICAgICAgICAgIC8vIEdhcHMgbmVlZCB0byBiZSBjYWxjdWxhdGVkIGZvciBlYWNoIGVsZW1lbnRhcnlTdHJlYW1cclxuICAgICAgICAgIGZyYWdtZW50RW50aXR5LnJhbmdlW2VsZW1lbnRhcnlTdHJlYW1dID0gdGhpcy5nZXRCdWZmZXJlZFRpbWVzKGZyYWdtZW50LnN0YXJ0UFRTLCBmcmFnbWVudC5lbmRQVFMsIHRpbWVSYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldEJ1ZmZlcmVkVGltZXMgKHN0YXJ0UFRTLCBlbmRQVFMsIHRpbWVSYW5nZSkge1xyXG4gICAgbGV0IGZyYWdtZW50VGltZXMgPSBbXTtcclxuICAgIGxldCBzdGFydFRpbWUsIGVuZFRpbWU7XHJcbiAgICBsZXQgZnJhZ21lbnRQYXJ0aWFsID0gZmFsc2U7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVSYW5nZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XHJcbiAgICAgIGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xyXG4gICAgICBpZiAoc3RhcnRQVFMgPj0gc3RhcnRUaW1lICYmIGVuZFBUUyA8PSBlbmRUaW1lKSB7XHJcbiAgICAgICAgLy8gRnJhZ21lbnQgaXMgZW50aXJlbHkgY29udGFpbmVkIGluIGJ1ZmZlclxyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIG90aGVyIHRpbWVSYW5nZSB0aW1lcyBzaW5jZSBpdCdzIGNvbXBsZXRlbHkgcGxheWFibGVcclxuICAgICAgICBmcmFnbWVudFRpbWVzLnB1c2goe1xyXG4gICAgICAgICAgc3RhcnRQVFM6IE1hdGgubWF4KHN0YXJ0UFRTLCB0aW1lUmFuZ2Uuc3RhcnQoaSkpLFxyXG4gICAgICAgICAgZW5kUFRTOiBNYXRoLm1pbihlbmRQVFMsIHRpbWVSYW5nZS5lbmQoaSkpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRQVFMgPCBlbmRUaW1lICYmIGVuZFBUUyA+IHN0YXJ0VGltZSkge1xyXG4gICAgICAgIC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aCBidWZmZXJcclxuICAgICAgICAvLyBHZXQgcGxheWFibGUgc2VjdGlvbnMgb2YgdGhlIGZyYWdtZW50XHJcbiAgICAgICAgZnJhZ21lbnRUaW1lcy5wdXNoKHtcclxuICAgICAgICAgIHN0YXJ0UFRTOiBNYXRoLm1heChzdGFydFBUUywgdGltZVJhbmdlLnN0YXJ0KGkpKSxcclxuICAgICAgICAgIGVuZFBUUzogTWF0aC5taW4oZW5kUFRTLCB0aW1lUmFuZ2UuZW5kKGkpKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZyYWdtZW50UGFydGlhbCA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSBpZiAoZW5kUFRTIDw9IHN0YXJ0VGltZSkge1xyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIHJlc3Qgb2YgdGhlIHRpbWVSYW5nZSBhcyBpdCBpcyBpbiBvcmRlclxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGltZTogZnJhZ21lbnRUaW1lcyxcclxuICAgICAgcGFydGlhbDogZnJhZ21lbnRQYXJ0aWFsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZ2V0RnJhZ21lbnRLZXkgKGZyYWdtZW50KSB7XHJcbiAgICByZXR1cm4gYCR7ZnJhZ21lbnQudHlwZX1fJHtmcmFnbWVudC5sZXZlbH1fJHtmcmFnbWVudC51cmxJZH1fJHtmcmFnbWVudC5zbn1gO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgcGFydGlhbCBmcmFnbWVudCBmb3IgYSBjZXJ0YWluIHRpbWVcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGZyYWdtZW50IFJldHVybnMgYSBwYXJ0aWFsIGZyYWdtZW50IGF0IGEgdGltZSBvciBudWxsIGlmIHRoZXJlIGlzIG5vIHBhcnRpYWwgZnJhZ21lbnRcclxuICAgKi9cclxuICBnZXRQYXJ0aWFsRnJhZ21lbnQgKHRpbWUpIHtcclxuICAgIGxldCB0aW1lUGFkZGluZywgc3RhcnRUaW1lLCBlbmRUaW1lO1xyXG4gICAgbGV0IGJlc3RGcmFnbWVudCA9IG51bGw7XHJcbiAgICBsZXQgYmVzdE92ZXJsYXAgPSAwO1xyXG4gICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1trZXldO1xyXG4gICAgICBpZiAodGhpcy5pc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XHJcbiAgICAgICAgc3RhcnRUaW1lID0gZnJhZ21lbnRFbnRpdHkuYm9keS5zdGFydFBUUyAtIHRoaXMuYnVmZmVyUGFkZGluZztcclxuICAgICAgICBlbmRUaW1lID0gZnJhZ21lbnRFbnRpdHkuYm9keS5lbmRQVFMgKyB0aGlzLmJ1ZmZlclBhZGRpbmc7XHJcbiAgICAgICAgaWYgKHRpbWUgPj0gc3RhcnRUaW1lICYmIHRpbWUgPD0gZW5kVGltZSkge1xyXG4gICAgICAgICAgLy8gVXNlIHRoZSBmcmFnbWVudCB0aGF0IGhhcyB0aGUgbW9zdCBwYWRkaW5nIGZyb20gc3RhcnQgYW5kIGVuZCB0aW1lXHJcbiAgICAgICAgICB0aW1lUGFkZGluZyA9IE1hdGgubWluKHRpbWUgLSBzdGFydFRpbWUsIGVuZFRpbWUgLSB0aW1lKTtcclxuICAgICAgICAgIGlmIChiZXN0T3ZlcmxhcCA8PSB0aW1lUGFkZGluZykge1xyXG4gICAgICAgICAgICBiZXN0RnJhZ21lbnQgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xyXG4gICAgICAgICAgICBiZXN0T3ZlcmxhcCA9IHRpbWVQYWRkaW5nO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYmVzdEZyYWdtZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGZyYWdtZW50IFRoZSBmcmFnbWVudCB0byBjaGVja1xyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgdGhlIGZyYWdtZW50IHN0YXRlIHdoZW4gYSBmcmFnbWVudCBuZXZlciBsb2FkZWQgb3IgaWYgaXQgcGFydGlhbGx5IGxvYWRlZFxyXG4gICAqL1xyXG4gIGdldFN0YXRlIChmcmFnbWVudCkge1xyXG4gICAgbGV0IGZyYWdLZXkgPSB0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcclxuICAgIGxldCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xyXG4gICAgbGV0IHN0YXRlID0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEO1xyXG5cclxuICAgIGlmIChmcmFnbWVudEVudGl0eSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQpIHtcclxuICAgICAgICBzdGF0ZSA9IEZyYWdtZW50U3RhdGUuQVBQRU5ESU5HO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHN0YXRlID0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0YXRlID0gRnJhZ21lbnRTdGF0ZS5PSztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcblxyXG4gIGlzUGFydGlhbCAoZnJhZ21lbnRFbnRpdHkpIHtcclxuICAgIHJldHVybiBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9PT0gdHJ1ZSAmJlxyXG4gICAgICAoKGZyYWdtZW50RW50aXR5LnJhbmdlLnZpZGVvICE9PSB1bmRlZmluZWQgJiYgZnJhZ21lbnRFbnRpdHkucmFuZ2UudmlkZW8ucGFydGlhbCA9PT0gdHJ1ZSkgfHxcclxuICAgICAgICAoZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW8gIT09IHVuZGVmaW5lZCAmJiBmcmFnbWVudEVudGl0eS5yYW5nZS5hdWRpby5wYXJ0aWFsID09PSB0cnVlKSk7XHJcbiAgfVxyXG5cclxuICBpc1RpbWVCdWZmZXJlZCAoc3RhcnRQVFMsIGVuZFBUUywgdGltZVJhbmdlKSB7XHJcbiAgICBsZXQgc3RhcnRUaW1lLCBlbmRUaW1lO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xyXG4gICAgICBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcclxuICAgICAgaWYgKHN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBlbmRQVFMgPD0gZW5kVGltZSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZW5kUFRTIDw9IHN0YXJ0VGltZSkge1xyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIHJlc3Qgb2YgdGhlIHRpbWVSYW5nZSBhcyBpdCBpcyBpbiBvcmRlclxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpcmVzIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIGNvbXBsZXRlZFxyXG4gICAqL1xyXG4gIG9uRnJhZ0xvYWRlZCAoZSkge1xyXG4gICAgY29uc3QgZnJhZ21lbnQgPSBlLmZyYWc7XHJcbiAgICAvLyBkb24ndCB0cmFjayBpbml0c2VnbWVudCAoZm9yIHdoaWNoIHNuIGlzIG5vdCBhIG51bWJlcilcclxuICAgIC8vIGRvbid0IHRyYWNrIGZyYWdzIHVzZWQgZm9yIGJpdHJhdGVUZXN0LCB0aGV5J3JlIGlycmVsZXZhbnQuXHJcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFnbWVudC5zbikgfHwgZnJhZ21lbnQuYml0cmF0ZVRlc3QpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZnJhZ21lbnRzW3RoaXMuZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpXSA9IHtcclxuICAgICAgYm9keTogZnJhZ21lbnQsXHJcbiAgICAgIHJhbmdlOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICBidWZmZXJlZDogZmFsc2VcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaXJlcyB3aGVuIHRoZSBidWZmZXIgaXMgdXBkYXRlZFxyXG4gICAqL1xyXG4gIG9uQnVmZmVyQXBwZW5kZWQgKGUpIHtcclxuICAgIC8vIFN0b3JlIHRoZSBsYXRlc3QgdGltZVJhbmdlcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlclxyXG4gICAgdGhpcy50aW1lUmFuZ2VzID0gZS50aW1lUmFuZ2VzO1xyXG4gICAgT2JqZWN0LmtleXModGhpcy50aW1lUmFuZ2VzKS5mb3JFYWNoKGVsZW1lbnRhcnlTdHJlYW0gPT4ge1xyXG4gICAgICBsZXQgdGltZVJhbmdlID0gdGhpcy50aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dO1xyXG4gICAgICB0aGlzLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoZWxlbWVudGFyeVN0cmVhbSwgdGltZVJhbmdlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmlyZXMgYWZ0ZXIgYSBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgc291cmNlIGJ1ZmZlclxyXG4gICAqL1xyXG4gIG9uRnJhZ0J1ZmZlcmVkIChlKSB7XHJcbiAgICB0aGlzLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoZS5mcmFnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIGZyYWdtZW50IHRyYWNrZXIgaGFzIHRoZSBmcmFnbWVudC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZnJhZ21lbnRcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBoYXNGcmFnbWVudCAoZnJhZ21lbnQpIHtcclxuICAgIGNvbnN0IGZyYWdLZXkgPSB0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcclxuICAgIHJldHVybiB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XSAhPT0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGEgZnJhZ21lbnQgZnJvbSBmcmFnbWVudCB0cmFja2VyIHVudGlsIGl0IGlzIGxvYWRlZCBhZ2FpblxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmcmFnbWVudCBUaGUgZnJhZ21lbnQgdG8gcmVtb3ZlXHJcbiAgICovXHJcbiAgcmVtb3ZlRnJhZ21lbnQgKGZyYWdtZW50KSB7XHJcbiAgICBsZXQgZnJhZ0tleSA9IHRoaXMuZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xyXG4gICAgZGVsZXRlIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFsbCBmcmFnbWVudHMgZnJvbSBmcmFnbWVudCB0cmFja2VyLlxyXG4gICAqL1xyXG4gIHJlbW92ZUFsbEZyYWdtZW50cyAoKSB7XHJcbiAgICB0aGlzLmZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci5qcyIsImltcG9ydCB7IGdldFNlbGZTY29wZSB9IGZyb20gJy4uL3V0aWxzL2dldC1zZWxmLXNjb3BlJztcclxuXHJcbi8qKlxyXG4gKiBJRDMgcGFyc2VyXHJcbiAqL1xyXG5jbGFzcyBJRDMge1xyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxyXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGlzIGZvdW5kXHJcbiAgICovXHJcbiAgc3RhdGljIGlzSGVhZGVyIChkYXRhLCBvZmZzZXQpIHtcclxuICAgIC8qXHJcbiAgICAqIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjMuMFxyXG4gICAgKiBbMF0gICAgID0gJ0knXHJcbiAgICAqIFsxXSAgICAgPSAnRCdcclxuICAgICogWzJdICAgICA9ICczJ1xyXG4gICAgKiBbMyw0XSAgID0ge1ZlcnNpb259XHJcbiAgICAqIFs1XSAgICAgPSB7RmxhZ3N9XHJcbiAgICAqIFs2LTldICAgPSB7SUQzIFNpemV9XHJcbiAgICAqXHJcbiAgICAqIEFuIElEM3YyIHRhZyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhdHRlcm46XHJcbiAgICAqICAkNDkgNDQgMzMgeXkgeXkgeHggenogenogenogenpcclxuICAgICogV2hlcmUgeXkgaXMgbGVzcyB0aGFuICRGRiwgeHggaXMgdGhlICdmbGFncycgYnl0ZSBhbmQgenogaXMgbGVzcyB0aGFuICQ4MFxyXG4gICAgKi9cclxuICAgIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xyXG4gICAgICAvLyBsb29rIGZvciAnSUQzJyBpZGVudGlmaWVyXHJcbiAgICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4NDkgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJiBkYXRhW29mZnNldCArIDJdID09PSAweDMzKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcclxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyAzXSA8IDB4RkYgJiYgZGF0YVtvZmZzZXQgKyA0XSA8IDB4RkYpIHtcclxuICAgICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXHJcbiAgICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBmb290ZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXHJcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIGFuIElEMyBmb290ZXIgaXMgZm91bmRcclxuICAgKi9cclxuICBzdGF0aWMgaXNGb290ZXIgKGRhdGEsIG9mZnNldCkge1xyXG4gICAgLypcclxuICAgICogVGhlIGZvb3RlciBpcyBhIGNvcHkgb2YgdGhlIGhlYWRlciwgYnV0IHdpdGggYSBkaWZmZXJlbnQgaWRlbnRpZmllclxyXG4gICAgKi9cclxuICAgIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xyXG4gICAgICAvLyBsb29rIGZvciAnM0RJJyBpZGVudGlmaWVyXHJcbiAgICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4MzMgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJiBkYXRhW29mZnNldCArIDJdID09PSAweDQ5KSB7XHJcbiAgICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcclxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyAzXSA8IDB4RkYgJiYgZGF0YVtvZmZzZXQgKyA0XSA8IDB4RkYpIHtcclxuICAgICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXHJcbiAgICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbnkgYWRqYWNlbnQgSUQzIHRhZ3MgZm91bmQgaW4gZGF0YSBzdGFydGluZyBhdCBvZmZzZXQsIGFzIG9uZSBibG9jayBvZiBkYXRhXHJcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXHJcbiAgICogQHJldHVybiB7VWludDhBcnJheX0gLSBUaGUgYmxvY2sgb2YgZGF0YSBjb250YWluaW5nIGFueSBJRDMgdGFncyBmb3VuZFxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXRJRDNEYXRhIChkYXRhLCBvZmZzZXQpIHtcclxuICAgIGNvbnN0IGZyb250ID0gb2Zmc2V0O1xyXG4gICAgbGV0IGxlbmd0aCA9IDA7XHJcblxyXG4gICAgd2hpbGUgKElEMy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XHJcbiAgICAgIC8vIElEMyBoZWFkZXIgaXMgMTAgYnl0ZXNcclxuICAgICAgbGVuZ3RoICs9IDEwO1xyXG5cclxuICAgICAgY29uc3Qgc2l6ZSA9IElEMy5fcmVhZFNpemUoZGF0YSwgb2Zmc2V0ICsgNik7XHJcbiAgICAgIGxlbmd0aCArPSBzaXplO1xyXG5cclxuICAgICAgaWYgKElEMy5pc0Zvb3RlcihkYXRhLCBvZmZzZXQgKyAxMCkpIHtcclxuICAgICAgICAvLyBJRDMgZm9vdGVyIGlzIDEwIGJ5dGVzXHJcbiAgICAgICAgbGVuZ3RoICs9IDEwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChsZW5ndGggPiAwKSB7XHJcbiAgICAgIHJldHVybiBkYXRhLnN1YmFycmF5KGZyb250LCBmcm9udCArIGxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBfcmVhZFNpemUgKGRhdGEsIG9mZnNldCkge1xyXG4gICAgbGV0IHNpemUgPSAwO1xyXG4gICAgc2l6ZSA9ICgoZGF0YVtvZmZzZXRdICYgMHg3ZikgPDwgMjEpO1xyXG4gICAgc2l6ZSB8PSAoKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDdmKSA8PCAxNCk7XHJcbiAgICBzaXplIHw9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4N2YpIDw8IDcpO1xyXG4gICAgc2l6ZSB8PSAoZGF0YVtvZmZzZXQgKyAzXSAmIDB4N2YpO1xyXG4gICAgcmV0dXJuIHNpemU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZWFyY2hlcyBmb3IgdGhlIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmb3VuZCBpbiB0aGUgSUQzIGRhdGEgY2h1bmtcclxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgLSBCbG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgSUQzIHRhZ3NcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHRpbWVzdGFtcFxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXRUaW1lU3RhbXAgKGRhdGEpIHtcclxuICAgIGNvbnN0IGZyYW1lcyA9IElEMy5nZXRJRDNGcmFtZXMoZGF0YSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tpXTtcclxuICAgICAgaWYgKElEMy5pc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSkge1xyXG4gICAgICAgIHJldHVybiBJRDMuX3JlYWRUaW1lU3RhbXAoZnJhbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSUQzIGZyYW1lIGlzIGFuIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmcmFtZVxyXG4gICAqIEBwYXJhbSB7SUQzIGZyYW1lfSBmcmFtZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBpc1RpbWVTdGFtcEZyYW1lIChmcmFtZSkge1xyXG4gICAgcmV0dXJuIChmcmFtZSAmJiBmcmFtZS5rZXkgPT09ICdQUklWJyAmJiBmcmFtZS5pbmZvID09PSAnY29tLmFwcGxlLnN0cmVhbWluZy50cmFuc3BvcnRTdHJlYW1UaW1lc3RhbXAnKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBfZ2V0RnJhbWVEYXRhIChkYXRhKSB7XHJcbiAgICAvKlxyXG4gICAgRnJhbWUgSUQgICAgICAgJHh4IHh4IHh4IHh4IChmb3VyIGNoYXJhY3RlcnMpXHJcbiAgICBTaXplICAgICAgICAgICAkeHggeHggeHggeHhcclxuICAgIEZsYWdzICAgICAgICAgICR4eCB4eFxyXG4gICAgKi9cclxuICAgIGNvbnN0IHR5cGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0sIGRhdGFbM10pO1xyXG4gICAgY29uc3Qgc2l6ZSA9IElEMy5fcmVhZFNpemUoZGF0YSwgNCk7XHJcblxyXG4gICAgLy8gc2tpcCBmcmFtZSBpZCwgc2l6ZSwgYW5kIGZsYWdzXHJcbiAgICBsZXQgb2Zmc2V0ID0gMTA7XHJcblxyXG4gICAgcmV0dXJuIHsgdHlwZSwgc2l6ZSwgZGF0YTogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHNpemUpIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIElEMyBmcmFtZXMgZm91bmQgaW4gYWxsIHRoZSBJRDMgdGFncyBpbiB0aGUgaWQzRGF0YVxyXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gaWQzRGF0YSAtIFRoZSBJRDMgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXHJcbiAgICogQHJldHVybiB7SUQzIGZyYW1lW119IC0gQXJyYXkgb2YgSUQzIGZyYW1lIG9iamVjdHNcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0SUQzRnJhbWVzIChpZDNEYXRhKSB7XHJcbiAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgIGNvbnN0IGZyYW1lcyA9IFtdO1xyXG5cclxuICAgIHdoaWxlIChJRDMuaXNIZWFkZXIoaWQzRGF0YSwgb2Zmc2V0KSkge1xyXG4gICAgICBjb25zdCBzaXplID0gSUQzLl9yZWFkU2l6ZShpZDNEYXRhLCBvZmZzZXQgKyA2KTtcclxuICAgICAgLy8gc2tpcCBwYXN0IElEMyBoZWFkZXJcclxuICAgICAgb2Zmc2V0ICs9IDEwO1xyXG4gICAgICBjb25zdCBlbmQgPSBvZmZzZXQgKyBzaXplO1xyXG4gICAgICAvLyBsb29wIHRocm91Z2ggZnJhbWVzIGluIHRoZSBJRDMgdGFnXHJcbiAgICAgIHdoaWxlIChvZmZzZXQgKyA4IDwgZW5kKSB7XHJcbiAgICAgICAgY29uc3QgZnJhbWVEYXRhID0gSUQzLl9nZXRGcmFtZURhdGEoaWQzRGF0YS5zdWJhcnJheShvZmZzZXQpKTtcclxuICAgICAgICBjb25zdCBmcmFtZSA9IElEMy5fZGVjb2RlRnJhbWUoZnJhbWVEYXRhKTtcclxuICAgICAgICBpZiAoZnJhbWUpIHtcclxuICAgICAgICAgIGZyYW1lcy5wdXNoKGZyYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNraXAgZnJhbWUgaGVhZGVyIGFuZCBmcmFtZSBkYXRhXHJcbiAgICAgICAgb2Zmc2V0ICs9IGZyYW1lRGF0YS5zaXplICsgMTA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChJRDMuaXNGb290ZXIoaWQzRGF0YSwgb2Zmc2V0KSkge1xyXG4gICAgICAgIG9mZnNldCArPSAxMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmcmFtZXM7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgX2RlY29kZUZyYW1lIChmcmFtZSkge1xyXG4gICAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xyXG4gICAgICByZXR1cm4gSUQzLl9kZWNvZGVQcml2RnJhbWUoZnJhbWUpO1xyXG4gICAgfSBlbHNlIGlmIChmcmFtZS50eXBlWzBdID09PSAnVCcpIHtcclxuICAgICAgcmV0dXJuIElEMy5fZGVjb2RlVGV4dEZyYW1lKGZyYW1lKTtcclxuICAgIH0gZWxzZSBpZiAoZnJhbWUudHlwZVswXSA9PT0gJ1cnKSB7XHJcbiAgICAgIHJldHVybiBJRDMuX2RlY29kZVVSTEZyYW1lKGZyYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIF9yZWFkVGltZVN0YW1wICh0aW1lU3RhbXBGcmFtZSkge1xyXG4gICAgaWYgKHRpbWVTdGFtcEZyYW1lLmRhdGEuYnl0ZUxlbmd0aCA9PT0gOCkge1xyXG4gICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGltZVN0YW1wRnJhbWUuZGF0YSk7XHJcbiAgICAgIC8vIHRpbWVzdGFtcCBpcyAzMyBiaXQgZXhwcmVzc2VkIGFzIGEgYmlnLWVuZGlhbiBlaWdodC1vY3RldCBudW1iZXIsXHJcbiAgICAgIC8vIHdpdGggdGhlIHVwcGVyIDMxIGJpdHMgc2V0IHRvIHplcm8uXHJcbiAgICAgIGNvbnN0IHB0czMzQml0ID0gZGF0YVszXSAmIDB4MTtcclxuICAgICAgbGV0IHRpbWVzdGFtcCA9IChkYXRhWzRdIDw8IDIzKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAoZGF0YVs1XSA8PCAxNSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgKGRhdGFbNl0gPDwgNykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGRhdGFbN107XHJcbiAgICAgIHRpbWVzdGFtcCAvPSA0NTtcclxuXHJcbiAgICAgIGlmIChwdHMzM0JpdCkge1xyXG4gICAgICAgIHRpbWVzdGFtcCArPSA0NzcyMTg1OC44NDtcclxuICAgICAgfSAvLyAyXjMyIC8gOTBcclxuXHJcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBfZGVjb2RlUHJpdkZyYW1lIChmcmFtZSkge1xyXG4gICAgLypcclxuICAgIEZvcm1hdDogPHRleHQgc3RyaW5nPlxcMDxiaW5hcnkgZGF0YT5cclxuICAgICovXHJcbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvd25lciA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YSwgdHJ1ZSk7XHJcbiAgICBjb25zdCBwcml2YXRlRGF0YSA9IG5ldyBVaW50OEFycmF5KGZyYW1lLmRhdGEuc3ViYXJyYXkob3duZXIubGVuZ3RoICsgMSkpO1xyXG5cclxuICAgIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgaW5mbzogb3duZXIsIGRhdGE6IHByaXZhdGVEYXRhLmJ1ZmZlciB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIF9kZWNvZGVUZXh0RnJhbWUgKGZyYW1lKSB7XHJcbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZnJhbWUudHlwZSA9PT0gJ1RYWFgnKSB7XHJcbiAgICAgIC8qXHJcbiAgICAgIEZvcm1hdDpcclxuICAgICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cclxuICAgICAgWzEtP10gPSB7RGVzY3JpcHRpb259XFwwe1ZhbHVlfVxyXG4gICAgICAqL1xyXG4gICAgICBsZXQgaW5kZXggPSAxO1xyXG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCksIHRydWUpO1xyXG5cclxuICAgICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcclxuICAgICAgY29uc3QgdmFsdWUgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcclxuXHJcbiAgICAgIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgaW5mbzogZGVzY3JpcHRpb24sIGRhdGE6IHZhbHVlIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvKlxyXG4gICAgICBGb3JtYXQ6XHJcbiAgICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XHJcbiAgICAgIFsxLT9dID0ge1ZhbHVlfVxyXG4gICAgICAqL1xyXG4gICAgICBjb25zdCB0ZXh0ID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KDEpKTtcclxuICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBkYXRhOiB0ZXh0IH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgX2RlY29kZVVSTEZyYW1lIChmcmFtZSkge1xyXG4gICAgaWYgKGZyYW1lLnR5cGUgPT09ICdXWFhYJykge1xyXG4gICAgICAvKlxyXG4gICAgICBGb3JtYXQ6XHJcbiAgICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XHJcbiAgICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtVUkx9XHJcbiAgICAgICovXHJcbiAgICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBpbmRleCA9IDE7XHJcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XHJcblxyXG4gICAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xyXG5cclxuICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBkZXNjcmlwdGlvbiwgZGF0YTogdmFsdWUgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8qXHJcbiAgICAgIEZvcm1hdDpcclxuICAgICAgWzAtP10gPSB7VVJMfVxyXG4gICAgICAqL1xyXG4gICAgICBjb25zdCB1cmwgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEpO1xyXG4gICAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGRhdGE6IHVybCB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84OTM2OTg0L3VpbnQ4YXJyYXktdG8tc3RyaW5nLWluLWphdmFzY3JpcHQvMjIzNzMxOTdcclxuICAvLyBodHRwOi8vd3d3Lm9uaWNvcy5jb20vc3RhZmYvaXovYW11c2UvamF2YXNjcmlwdC9leHBlcnQvdXRmLnR4dFxyXG4gIC8qIHV0Zi5qcyAtIFVURi04IDw9PiBVVEYtMTYgY29udmVydGlvblxyXG4gICAqXHJcbiAgICogQ29weXJpZ2h0IChDKSAxOTk5IE1hc2FuYW8gSXp1bW8gPGl6QG9uaWNvcy5jby5qcD5cclxuICAgKiBWZXJzaW9uOiAxLjBcclxuICAgKiBMYXN0TW9kaWZpZWQ6IERlYyAyNSAxOTk5XHJcbiAgICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUuICBZb3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0LlxyXG4gICAqL1xyXG4gIHN0YXRpYyBfdXRmOEFycmF5VG9TdHIgKGFycmF5LCBleGl0T25OdWxsID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGRlY29kZXIgPSBnZXRUZXh0RGVjb2RlcigpO1xyXG4gICAgaWYgKGRlY29kZXIpIHtcclxuICAgICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGFycmF5KTtcclxuXHJcbiAgICAgIGlmIChleGl0T25OdWxsKSB7XHJcbiAgICAgICAgLy8gZ3JhYiB1cCB0byB0aGUgZmlyc3QgbnVsbFxyXG4gICAgICAgIGNvbnN0IGlkeCA9IGRlY29kZWQuaW5kZXhPZignXFwwJyk7XHJcbiAgICAgICAgcmV0dXJuIGlkeCAhPT0gLTEgPyBkZWNvZGVkLnN1YnN0cmluZygwLCBpZHgpIDogZGVjb2RlZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcmVtb3ZlIGFueSBudWxsIGNoYXJhY3RlcnNcclxuICAgICAgcmV0dXJuIGRlY29kZWQucmVwbGFjZSgvXFwwL2csICcnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsZW4gPSBhcnJheS5sZW5ndGg7XHJcbiAgICBsZXQgYztcclxuICAgIGxldCBjaGFyMjtcclxuICAgIGxldCBjaGFyMztcclxuICAgIGxldCBvdXQgPSAnJztcclxuICAgIGxldCBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgIGMgPSBhcnJheVtpKytdO1xyXG4gICAgICBpZiAoYyA9PT0gMHgwMCAmJiBleGl0T25OdWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgfSBlbHNlIGlmIChjID09PSAweDAwIHx8IGMgPT09IDB4MDMpIHtcclxuICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIDMgKEVORF9PRl9URVhUKSBvciAwIChOVUxMKSB0aGVuIHNraXAgaXRcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKGMgPj4gNCkge1xyXG4gICAgICBjYXNlIDA6IGNhc2UgMTogY2FzZSAyOiBjYXNlIDM6IGNhc2UgNDogY2FzZSA1OiBjYXNlIDY6IGNhc2UgNzpcclxuICAgICAgICAvLyAweHh4eHh4eFxyXG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDEyOiBjYXNlIDEzOlxyXG4gICAgICAgIC8vIDExMHggeHh4eCAgIDEweHggeHh4eFxyXG4gICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcclxuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDFGKSA8PCA2KSB8IChjaGFyMiAmIDB4M0YpKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAxNDpcclxuICAgICAgICAvLyAxMTEwIHh4eHggIDEweHggeHh4eCAgMTB4eCB4eHh4XHJcbiAgICAgICAgY2hhcjIgPSBhcnJheVtpKytdO1xyXG4gICAgICAgIGNoYXIzID0gYXJyYXlbaSsrXTtcclxuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDBGKSA8PCAxMikgfFxyXG4gICAgICAgICAgICAgICAgICAgICgoY2hhcjIgJiAweDNGKSA8PCA2KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgKChjaGFyMyAmIDB4M0YpIDw8IDApKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dDtcclxuICB9XHJcbn1cclxuXHJcbmxldCBkZWNvZGVyO1xyXG5cclxuZnVuY3Rpb24gZ2V0VGV4dERlY29kZXIgKCkge1xyXG4gIGNvbnN0IGdsb2JhbCA9IGdldFNlbGZTY29wZSgpOyAvLyBzYWZlZ3VhcmQgZm9yIGNvZGUgdGhhdCBtaWdodCBydW4gYm90aCBvbiB3b3JrZXIgYW5kIG1haW4gdGhyZWFkXHJcbiAgaWYgKCFkZWNvZGVyICYmIHR5cGVvZiBnbG9iYWwuVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBkZWNvZGVyID0gbmV3IGdsb2JhbC5UZXh0RGVjb2RlcigndXRmLTgnKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBkZWNvZGVyO1xyXG59XHJcblxyXG5jb25zdCB1dGY4QXJyYXlUb1N0ciA9IElEMy5fdXRmOEFycmF5VG9TdHI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJRDM7XHJcblxyXG5leHBvcnQgeyB1dGY4QXJyYXlUb1N0ciB9O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9kZW11eC9pZDMuanMiLCIvKipcclxuICogQG1vZHVsZSBMZXZlbEhlbHBlclxyXG4gKlxyXG4gKiBQcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIHdpdGggcGxheWxpc3Qgc2xpZGluZyBhbmQgZHJpZnRcclxuICpcclxuICogVE9ETzogQ3JlYXRlIGFuIGFjdHVhbCBgTGV2ZWxgIGNsYXNzL21vZGVsIHRoYXQgZGVhbHMgd2l0aCBhbGwgdGhpcyBsb2dpYyBpbiBhbiBvYmplY3Qtb3JpZW50ZWQtbWFubmVyLlxyXG4gKlxyXG4gKiAqL1xyXG5cclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRHcm91cElkIChsZXZlbCwgdHlwZSwgaWQpIHtcclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICBjYXNlICdhdWRpbyc6XHJcbiAgICBpZiAoIWxldmVsLmF1ZGlvR3JvdXBJZHMpIHtcclxuICAgICAgbGV2ZWwuYXVkaW9Hcm91cElkcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgbGV2ZWwuYXVkaW9Hcm91cElkcy5wdXNoKGlkKTtcclxuICAgIGJyZWFrO1xyXG4gIGNhc2UgJ3RleHQnOlxyXG4gICAgaWYgKCFsZXZlbC50ZXh0R3JvdXBJZHMpIHtcclxuICAgICAgbGV2ZWwudGV4dEdyb3VwSWRzID0gW107XHJcbiAgICB9XHJcbiAgICBsZXZlbC50ZXh0R3JvdXBJZHMucHVzaChpZCk7XHJcbiAgICBicmVhaztcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVQVFMgKGZyYWdtZW50cywgZnJvbUlkeCwgdG9JZHgpIHtcclxuICBsZXQgZnJhZ0Zyb20gPSBmcmFnbWVudHNbZnJvbUlkeF0sIGZyYWdUbyA9IGZyYWdtZW50c1t0b0lkeF0sIGZyYWdUb1BUUyA9IGZyYWdUby5zdGFydFBUUztcclxuICAvLyBpZiB3ZSBrbm93IHN0YXJ0UFRTW3RvSWR4XVxyXG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZ1RvUFRTKSkge1xyXG4gICAgLy8gdXBkYXRlIGZyYWdtZW50IGR1cmF0aW9uLlxyXG4gICAgLy8gaXQgaGVscHMgdG8gZml4IGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0IHJlcG9ydGVkIGR1cmF0aW9uIGFuZCBmcmFnbWVudCByZWFsIGR1cmF0aW9uXHJcbiAgICBpZiAodG9JZHggPiBmcm9tSWR4KSB7XHJcbiAgICAgIGZyYWdGcm9tLmR1cmF0aW9uID0gZnJhZ1RvUFRTIC0gZnJhZ0Zyb20uc3RhcnQ7XHJcbiAgICAgIGlmIChmcmFnRnJvbS5kdXJhdGlvbiA8IDApIHtcclxuICAgICAgICBsb2dnZXIud2FybihgbmVnYXRpdmUgZHVyYXRpb24gY29tcHV0ZWQgZm9yIGZyYWcgJHtmcmFnRnJvbS5zbn0sbGV2ZWwgJHtmcmFnRnJvbS5sZXZlbH0sIHRoZXJlIHNob3VsZCBiZSBzb21lIGR1cmF0aW9uIGRyaWZ0IGJldHdlZW4gcGxheWxpc3QgYW5kIGZyYWdtZW50IWApO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmcmFnVG8uZHVyYXRpb24gPSBmcmFnRnJvbS5zdGFydCAtIGZyYWdUb1BUUztcclxuICAgICAgaWYgKGZyYWdUby5kdXJhdGlvbiA8IDApIHtcclxuICAgICAgICBsb2dnZXIud2FybihgbmVnYXRpdmUgZHVyYXRpb24gY29tcHV0ZWQgZm9yIGZyYWcgJHtmcmFnVG8uc259LGxldmVsICR7ZnJhZ1RvLmxldmVsfSwgdGhlcmUgc2hvdWxkIGJlIHNvbWUgZHVyYXRpb24gZHJpZnQgYmV0d2VlbiBwbGF5bGlzdCBhbmQgZnJhZ21lbnQhYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxyXG4gICAgaWYgKHRvSWR4ID4gZnJvbUlkeCkge1xyXG4gICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIGZyYWdGcm9tLmR1cmF0aW9uO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZnJhZ1RvLnN0YXJ0ID0gTWF0aC5tYXgoZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG8uZHVyYXRpb24sIDApO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUZyYWdQVFNEVFMgKGRldGFpbHMsIGZyYWcsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpIHtcclxuICAvLyB1cGRhdGUgZnJhZyBQVFMvRFRTXHJcbiAgbGV0IG1heFN0YXJ0UFRTID0gc3RhcnRQVFM7XHJcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLnN0YXJ0UFRTKSkge1xyXG4gICAgLy8gZGVsdGEgUFRTIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvXHJcbiAgICBsZXQgZGVsdGFQVFMgPSBNYXRoLmFicyhmcmFnLnN0YXJ0UFRTIC0gc3RhcnRQVFMpO1xyXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhZy5kZWx0YVBUUykpIHtcclxuICAgICAgZnJhZy5kZWx0YVBUUyA9IGRlbHRhUFRTO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZnJhZy5kZWx0YVBUUyA9IE1hdGgubWF4KGRlbHRhUFRTLCBmcmFnLmRlbHRhUFRTKTtcclxuICAgIH1cclxuXHJcbiAgICBtYXhTdGFydFBUUyA9IE1hdGgubWF4KHN0YXJ0UFRTLCBmcmFnLnN0YXJ0UFRTKTtcclxuICAgIHN0YXJ0UFRTID0gTWF0aC5taW4oc3RhcnRQVFMsIGZyYWcuc3RhcnRQVFMpO1xyXG4gICAgZW5kUFRTID0gTWF0aC5tYXgoZW5kUFRTLCBmcmFnLmVuZFBUUyk7XHJcbiAgICBzdGFydERUUyA9IE1hdGgubWluKHN0YXJ0RFRTLCBmcmFnLnN0YXJ0RFRTKTtcclxuICAgIGVuZERUUyA9IE1hdGgubWF4KGVuZERUUywgZnJhZy5lbmREVFMpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZHJpZnQgPSBzdGFydFBUUyAtIGZyYWcuc3RhcnQ7XHJcbiAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydFBUUztcclxuICBmcmFnLm1heFN0YXJ0UFRTID0gbWF4U3RhcnRQVFM7XHJcbiAgZnJhZy5lbmRQVFMgPSBlbmRQVFM7XHJcbiAgZnJhZy5zdGFydERUUyA9IHN0YXJ0RFRTO1xyXG4gIGZyYWcuZW5kRFRTID0gZW5kRFRTO1xyXG4gIGZyYWcuZHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcclxuXHJcbiAgY29uc3Qgc24gPSBmcmFnLnNuO1xyXG4gIC8vIGV4aXQgaWYgc24gb3V0IG9mIHJhbmdlXHJcbiAgaWYgKCFkZXRhaWxzIHx8IHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICBsZXQgZnJhZ0lkeCwgZnJhZ21lbnRzLCBpO1xyXG4gIGZyYWdJZHggPSBzbiAtIGRldGFpbHMuc3RhcnRTTjtcclxuICBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcclxuICAvLyB1cGRhdGUgZnJhZyByZWZlcmVuY2UgaW4gZnJhZ21lbnRzIGFycmF5XHJcbiAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgZnJhZ21lbnRzIGFycmF5IG1pZ2h0IG5vdCBjb250YWluIHRoaXMgZnJhZyBvYmplY3QuXHJcbiAgLy8gdGhpcyB3aWxsIGhhcHBlbiBpZiBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgYmV0d2VlbiBmcmFnIGxvYWRpbmcgYW5kIGNhbGwgdG8gdXBkYXRlRnJhZ1BUU0RUUygpXHJcbiAgLy8gaWYgd2UgZG9uJ3QgdXBkYXRlIGZyYWcsIHdlIHdvbid0IGJlIGFibGUgdG8gcHJvcGFnYXRlIFBUUyBpbmZvIG9uIHRoZSBwbGF5bGlzdFxyXG4gIC8vIHJlc3VsdGluZyBpbiBpbnZhbGlkIHNsaWRpbmcgY29tcHV0YXRpb25cclxuICBmcmFnbWVudHNbZnJhZ0lkeF0gPSBmcmFnO1xyXG4gIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0tMSB0byBmcmFnIDBcclxuICBmb3IgKGkgPSBmcmFnSWR4OyBpID4gMDsgaS0tKSB7XHJcbiAgICB1cGRhdGVQVFMoZnJhZ21lbnRzLCBpLCBpIC0gMSk7XHJcbiAgfVxyXG5cclxuICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtIHRvIGxhc3QgZnJhZ1xyXG4gIGZvciAoaSA9IGZyYWdJZHg7IGkgPCBmcmFnbWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICB1cGRhdGVQVFMoZnJhZ21lbnRzLCBpLCBpICsgMSk7XHJcbiAgfVxyXG5cclxuICBkZXRhaWxzLlBUU0tub3duID0gdHJ1ZTtcclxuICByZXR1cm4gZHJpZnQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZURldGFpbHMgKG9sZERldGFpbHMsIG5ld0RldGFpbHMpIHtcclxuICAvLyBwb3RlbnRpYWxseSByZXRyaWV2ZSBjYWNoZWQgaW5pdHNlZ21lbnRcclxuICBpZiAobmV3RGV0YWlscy5pbml0U2VnbWVudCAmJiBvbGREZXRhaWxzLmluaXRTZWdtZW50KSB7XHJcbiAgICBuZXdEZXRhaWxzLmluaXRTZWdtZW50ID0gb2xkRGV0YWlscy5pbml0U2VnbWVudDtcclxuICB9XHJcblxyXG4gIC8vIGNoZWNrIGlmIG9sZC9uZXcgcGxheWxpc3RzIGhhdmUgZnJhZ21lbnRzIGluIGNvbW1vblxyXG4gIC8vIGxvb3AgdGhyb3VnaCBvdmVybGFwcGluZyBTTiBhbmQgdXBkYXRlIHN0YXJ0UFRTICwgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcclxuICBsZXQgY2NPZmZzZXQgPSAwO1xyXG4gIGxldCBQVFNGcmFnO1xyXG4gIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKG9sZERldGFpbHMsIG5ld0RldGFpbHMsIChvbGRGcmFnLCBuZXdGcmFnKSA9PiB7XHJcbiAgICBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xyXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShvbGRGcmFnLnN0YXJ0UFRTKSkge1xyXG4gICAgICBuZXdGcmFnLnN0YXJ0ID0gbmV3RnJhZy5zdGFydFBUUyA9IG9sZEZyYWcuc3RhcnRQVFM7XHJcbiAgICAgIG5ld0ZyYWcuZW5kUFRTID0gb2xkRnJhZy5lbmRQVFM7XHJcbiAgICAgIG5ld0ZyYWcuZHVyYXRpb24gPSBvbGRGcmFnLmR1cmF0aW9uO1xyXG4gICAgICBuZXdGcmFnLmJhY2t0cmFja2VkID0gb2xkRnJhZy5iYWNrdHJhY2tlZDtcclxuICAgICAgbmV3RnJhZy5kcm9wcGVkID0gb2xkRnJhZy5kcm9wcGVkO1xyXG4gICAgICBQVFNGcmFnID0gbmV3RnJhZztcclxuICAgIH1cclxuICAgIC8vIFBUUyBpcyBrbm93biB3aGVuIHRoZXJlIGFyZSBvdmVybGFwcGluZyBzZWdtZW50c1xyXG4gICAgbmV3RGV0YWlscy5QVFNLbm93biA9IHRydWU7XHJcbiAgfSk7XHJcblxyXG4gIGlmICghbmV3RGV0YWlscy5QVFNLbm93bikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNjT2Zmc2V0KSB7XHJcbiAgICBsb2dnZXIubG9nKCdkaXNjb250aW51aXR5IHNsaWRpbmcgZnJvbSBwbGF5bGlzdCwgdGFrZSBkcmlmdCBpbnRvIGFjY291bnQnKTtcclxuICAgIGNvbnN0IG5ld0ZyYWdtZW50cyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdGcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbmV3RnJhZ21lbnRzW2ldLmNjICs9IGNjT2Zmc2V0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gaWYgYXQgbGVhc3Qgb25lIGZyYWdtZW50IGNvbnRhaW5zIFBUUyBpbmZvLCByZWNvbXB1dGUgUFRTIGluZm9ybWF0aW9uIGZvciBhbGwgZnJhZ21lbnRzXHJcbiAgaWYgKFBUU0ZyYWcpIHtcclxuICAgIHVwZGF0ZUZyYWdQVFNEVFMobmV3RGV0YWlscywgUFRTRnJhZywgUFRTRnJhZy5zdGFydFBUUywgUFRTRnJhZy5lbmRQVFMsIFBUU0ZyYWcuc3RhcnREVFMsIFBUU0ZyYWcuZW5kRFRTKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gZW5zdXJlIHRoYXQgZGVsdGEgaXMgd2l0aGluIG9sZEZyYWdtZW50cyByYW5nZVxyXG4gICAgLy8gYWxzbyBhZGp1c3Qgc2xpZGluZyBpbiBjYXNlIGRlbHRhIGlzIDAgKHdlIGNvdWxkIGhhdmUgb2xkPVs1MC02MF0gYW5kIG5ldz1vbGQ9WzUwLTYxXSlcclxuICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBhbHNvIG5lZWQgdG8gYWRqdXN0IHN0YXJ0IG9mZnNldCBvZiBhbGwgZnJhZ21lbnRzXHJcbiAgICBhZGp1c3RTbGlkaW5nKG9sZERldGFpbHMsIG5ld0RldGFpbHMpO1xyXG4gIH1cclxuICAvLyBpZiB3ZSBhcmUgaGVyZSwgaXQgbWVhbnMgd2UgaGF2ZSBmcmFnbWVudHMgb3ZlcmxhcHBpbmcgYmV0d2VlblxyXG4gIC8vIG9sZCBhbmQgbmV3IGxldmVsLiByZWxpYWJsZSBQVFMgaW5mbyBpcyB0aHVzIHJlbHlpbmcgb24gb2xkIGxldmVsXHJcbiAgbmV3RGV0YWlscy5QVFNLbm93biA9IG9sZERldGFpbHMuUFRTS25vd247XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVN1YnRpdGxlUGxheWxpc3RzIChvbGRQbGF5bGlzdCwgbmV3UGxheWxpc3QsIHJlZmVyZW5jZVN0YXJ0ID0gMCkge1xyXG4gIGxldCBsYXN0SW5kZXggPSAtMTtcclxuICBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGRQbGF5bGlzdCwgbmV3UGxheWxpc3QsIChvbGRGcmFnLCBuZXdGcmFnLCBpbmRleCkgPT4ge1xyXG4gICAgbmV3RnJhZy5zdGFydCA9IG9sZEZyYWcuc3RhcnQ7XHJcbiAgICBsYXN0SW5kZXggPSBpbmRleDtcclxuICB9KTtcclxuXHJcbiAgY29uc3QgZnJhZ3MgPSBuZXdQbGF5bGlzdC5mcmFnbWVudHM7XHJcbiAgaWYgKGxhc3RJbmRleCA8IDApIHtcclxuICAgIGZyYWdzLmZvckVhY2goZnJhZyA9PiB7XHJcbiAgICAgIGZyYWcuc3RhcnQgKz0gcmVmZXJlbmNlU3RhcnQ7XHJcbiAgICB9KTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGZvciAobGV0IGkgPSBsYXN0SW5kZXggKyAxOyBpIDwgZnJhZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGZyYWdzW2ldLnN0YXJ0ID0gKGZyYWdzW2kgLSAxXS5zdGFydCArIGZyYWdzW2kgLSAxXS5kdXJhdGlvbik7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24gKG9sZFBsYXlsaXN0LCBuZXdQbGF5bGlzdCwgaW50ZXJzZWN0aW9uRm4pIHtcclxuICBpZiAoIW9sZFBsYXlsaXN0IHx8ICFuZXdQbGF5bGlzdCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChvbGRQbGF5bGlzdC5zdGFydFNOLCBuZXdQbGF5bGlzdC5zdGFydFNOKSAtIG5ld1BsYXlsaXN0LnN0YXJ0U047XHJcbiAgY29uc3QgZW5kID0gTWF0aC5taW4ob2xkUGxheWxpc3QuZW5kU04sIG5ld1BsYXlsaXN0LmVuZFNOKSAtIG5ld1BsYXlsaXN0LnN0YXJ0U047XHJcbiAgY29uc3QgZGVsdGEgPSBuZXdQbGF5bGlzdC5zdGFydFNOIC0gb2xkUGxheWxpc3Quc3RhcnRTTjtcclxuXHJcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XHJcbiAgICBjb25zdCBvbGRGcmFnID0gb2xkUGxheWxpc3QuZnJhZ21lbnRzW2RlbHRhICsgaV07XHJcbiAgICBjb25zdCBuZXdGcmFnID0gbmV3UGxheWxpc3QuZnJhZ21lbnRzW2ldO1xyXG4gICAgaWYgKCFvbGRGcmFnIHx8ICFuZXdGcmFnKSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgaW50ZXJzZWN0aW9uRm4ob2xkRnJhZywgbmV3RnJhZywgaSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0U2xpZGluZyAob2xkUGxheWxpc3QsIG5ld1BsYXlsaXN0KSB7XHJcbiAgY29uc3QgZGVsdGEgPSBuZXdQbGF5bGlzdC5zdGFydFNOIC0gb2xkUGxheWxpc3Quc3RhcnRTTjtcclxuICBjb25zdCBvbGRGcmFnbWVudHMgPSBvbGRQbGF5bGlzdC5mcmFnbWVudHM7XHJcbiAgY29uc3QgbmV3RnJhZ21lbnRzID0gbmV3UGxheWxpc3QuZnJhZ21lbnRzO1xyXG5cclxuICBpZiAoZGVsdGEgPCAwIHx8IGRlbHRhID4gb2xkRnJhZ21lbnRzLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0ZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgbmV3RnJhZ21lbnRzW2ldLnN0YXJ0ICs9IG9sZEZyYWdtZW50c1tkZWx0YV0uc3RhcnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVJlbG9hZEludGVydmFsIChjdXJyZW50UGxheWxpc3QsIG5ld1BsYXlsaXN0LCBsYXN0UmVxdWVzdFRpbWUpIHtcclxuICBsZXQgcmVsb2FkSW50ZXJ2YWwgPSAxMDAwICogKG5ld1BsYXlsaXN0LmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA/IG5ld1BsYXlsaXN0LmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA6IG5ld1BsYXlsaXN0LnRhcmdldGR1cmF0aW9uKTtcclxuICBjb25zdCBtaW5SZWxvYWRJbnRlcnZhbCA9IHJlbG9hZEludGVydmFsIC8gMjtcclxuICBpZiAoY3VycmVudFBsYXlsaXN0ICYmIG5ld1BsYXlsaXN0LmVuZFNOID09PSBjdXJyZW50UGxheWxpc3QuZW5kU04pIHtcclxuICAgIC8vIGZvbGxvdyBITFMgU3BlYywgSWYgdGhlIGNsaWVudCByZWxvYWRzIGEgUGxheWxpc3QgZmlsZSBhbmQgZmluZHMgdGhhdCBpdCBoYXMgbm90XHJcbiAgICAvLyBjaGFuZ2VkIHRoZW4gaXQgTVVTVCB3YWl0IGZvciBhIHBlcmlvZCBvZiBvbmUtaGFsZiB0aGUgdGFyZ2V0XHJcbiAgICAvLyBkdXJhdGlvbiBiZWZvcmUgcmV0cnlpbmcuXHJcbiAgICByZWxvYWRJbnRlcnZhbCA9IG1pblJlbG9hZEludGVydmFsO1xyXG4gIH1cclxuXHJcbiAgaWYgKGxhc3RSZXF1ZXN0VGltZSkge1xyXG4gICAgcmVsb2FkSW50ZXJ2YWwgPSBNYXRoLm1heChtaW5SZWxvYWRJbnRlcnZhbCwgcmVsb2FkSW50ZXJ2YWwgLSAod2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gbGFzdFJlcXVlc3RUaW1lKSk7XHJcbiAgfVxyXG4gIC8vIGluIGFueSBjYXNlLCBkb24ndCByZWxvYWQgbW9yZSB0aGFuIGhhbGYgb2YgdGFyZ2V0IGR1cmF0aW9uXHJcbiAgcmV0dXJuIE1hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLmpzIiwiLy8gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxODA4XG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbihmdW5jdGlvbihyb290KSB7IFxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICB2YXIgVVJMX1JFR0VYID0gL14oKD86W2EtekEtWjAtOStcXC0uXSs6KT8pKFxcL1xcL1teXFwvPyNdKik/KCg/OlteXFwvXFw/I10qXFwvKSouKj8pPz8oOy4qPyk/KFxcPy4qPyk/KCMuKj8pPyQvO1xuICB2YXIgRklSU1RfU0VHTUVOVF9SRUdFWCA9IC9eKFteXFwvPyNdKikoLiopJC87XG4gIHZhciBTTEFTSF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuKD89XFwvKS9nO1xuICB2YXIgU0xBU0hfRE9UX0RPVF9SRUdFWCA9IC8oPzpcXC98XilcXC5cXC5cXC8oPyFcXC5cXC5cXC8pLio/KD89XFwvKS9nO1xuXG4gIHZhciBVUkxUb29sa2l0ID0geyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAvLyBJZiBvcHRzLmFsd2F5c05vcm1hbGl6ZSBpcyB0cnVlIHRoZW4gdGhlIHBhdGggd2lsbCBhbHdheXMgYmUgbm9ybWFsaXplZCBldmVuIHdoZW4gaXQgc3RhcnRzIHdpdGggLyBvciAvL1xuICAgIC8vIEUuZ1xuICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSBmYWxzZSAoZGVmYXVsdCwgc3BlYyBjb21wbGlhbnQpXG4gICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZi8uLi9nXG4gICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IHRydWUgKG5vdCBzcGVjIGNvbXBsaWFudClcbiAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9nXG4gICAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24oYmFzZVVSTCwgcmVsYXRpdmVVUkwsIG9wdHMpIHtcbiAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgLy8gcmVtb3ZlIGFueSByZW1haW5pbmcgc3BhY2UgYW5kIENSTEZcbiAgICAgIGJhc2VVUkwgPSBiYXNlVVJMLnRyaW0oKTtcbiAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xuICAgICAgaWYgKCFyZWxhdGl2ZVVSTCkge1xuICAgICAgICAvLyAyYSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBpcyBlbnRpcmVseSBlbXB0eSwgaXQgaW5oZXJpdHMgdGhlXG4gICAgICAgIC8vIGVudGlyZSBiYXNlIFVSTCAoaS5lLiwgaXMgc2V0IGVxdWFsIHRvIHRoZSBiYXNlIFVSTClcbiAgICAgICAgLy8gYW5kIHdlIGFyZSBkb25lLlxuICAgICAgICBpZiAoIW9wdHMuYWx3YXlzTm9ybWFsaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VVUkw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZSA9IFVSTFRvb2xraXQucGFyc2VVUkwoYmFzZVVSTCk7XG4gICAgICAgIGlmICghYmFzZVBhcnRzRm9yTm9ybWFsaXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgoYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGgpO1xuICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhiYXNlUGFydHNGb3JOb3JtYWxpc2UpO1xuICAgICAgfVxuICAgICAgdmFyIHJlbGF0aXZlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKHJlbGF0aXZlVVJMKTtcbiAgICAgIGlmICghcmVsYXRpdmVQYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSByZWxhdGl2ZSBVUkwuJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVsYXRpdmVQYXJ0cy5zY2hlbWUpIHtcbiAgICAgICAgLy8gMmIpIElmIHRoZSBlbWJlZGRlZCBVUkwgc3RhcnRzIHdpdGggYSBzY2hlbWUgbmFtZSwgaXQgaXNcbiAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYXMgYW4gYWJzb2x1dGUgVVJMIGFuZCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcbiAgICAgICAgfVxuICAgICAgICByZWxhdGl2ZVBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKTtcbiAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMocmVsYXRpdmVQYXJ0cyk7XG4gICAgICB9XG4gICAgICB2YXIgYmFzZVBhcnRzID0gVVJMVG9vbGtpdC5wYXJzZVVSTChiYXNlVVJMKTtcbiAgICAgIGlmICghYmFzZVBhcnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuICAgICAgfVxuICAgICAgaWYgKCFiYXNlUGFydHMubmV0TG9jICYmIGJhc2VQYXJ0cy5wYXRoICYmIGJhc2VQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgLy8gSWYgbmV0TG9jIG1pc3NpbmcgYW5kIHBhdGggZG9lc24ndCBzdGFydCB3aXRoICcvJywgYXNzdW1lIGV2ZXJ0aGluZyBiZWZvcmUgdGhlIGZpcnN0ICcvJyBpcyB0aGUgbmV0TG9jXG4gICAgICAgIC8vIFRoaXMgY2F1c2VzICdleGFtcGxlLmNvbS9hJyB0byBiZSBoYW5kbGVkIGFzICcvL2V4YW1wbGUuY29tL2EnIGluc3RlYWQgb2YgJy9leGFtcGxlLmNvbS9hJ1xuICAgICAgICB2YXIgcGF0aFBhcnRzID0gRklSU1RfU0VHTUVOVF9SRUdFWC5leGVjKGJhc2VQYXJ0cy5wYXRoKTtcbiAgICAgICAgYmFzZVBhcnRzLm5ldExvYyA9IHBhdGhQYXJ0c1sxXTtcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSBwYXRoUGFydHNbMl07XG4gICAgICB9XG4gICAgICBpZiAoYmFzZVBhcnRzLm5ldExvYyAmJiAhYmFzZVBhcnRzLnBhdGgpIHtcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSAnLyc7XG4gICAgICB9XG4gICAgICB2YXIgYnVpbHRQYXJ0cyA9IHtcbiAgICAgICAgLy8gMmMpIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgc2NoZW1lIG9mXG4gICAgICAgIC8vIHRoZSBiYXNlIFVSTC5cbiAgICAgICAgc2NoZW1lOiBiYXNlUGFydHMuc2NoZW1lLFxuICAgICAgICBuZXRMb2M6IHJlbGF0aXZlUGFydHMubmV0TG9jLFxuICAgICAgICBwYXRoOiBudWxsLFxuICAgICAgICBwYXJhbXM6IHJlbGF0aXZlUGFydHMucGFyYW1zLFxuICAgICAgICBxdWVyeTogcmVsYXRpdmVQYXJ0cy5xdWVyeSxcbiAgICAgICAgZnJhZ21lbnQ6IHJlbGF0aXZlUGFydHMuZnJhZ21lbnRcbiAgICAgIH07XG4gICAgICBpZiAoIXJlbGF0aXZlUGFydHMubmV0TG9jKSB7XG4gICAgICAgIC8vIDMpIElmIHRoZSBlbWJlZGRlZCBVUkwncyA8bmV0X2xvYz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XG4gICAgICAgIC8vIChpZiBhbnkpIG9mIHRoZSBiYXNlIFVSTC5cbiAgICAgICAgYnVpbHRQYXJ0cy5uZXRMb2MgPSBiYXNlUGFydHMubmV0TG9jO1xuICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXG4gICAgICAgIC8vIHBhdGggaXMgbm90IHJlbGF0aXZlIGFuZCB3ZSBza2lwIHRvIFN0ZXAgNy5cbiAgICAgICAgaWYgKHJlbGF0aXZlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcbiAgICAgICAgICAgIC8vIDUpIElmIHRoZSBlbWJlZGRlZCBVUkwgcGF0aCBpcyBlbXB0eSAoYW5kIG5vdCBwcmVjZWRlZCBieSBhXG4gICAgICAgICAgICAvLyBzbGFzaCksIHRoZW4gdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgYmFzZSBVUkwgcGF0aFxuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XG4gICAgICAgICAgICAvLyA1YSkgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxwYXJhbXM+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cGFyYW1zPiBvZiB0aGUgYmFzZVxuICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhcmFtcykge1xuICAgICAgICAgICAgICBidWlsdFBhcnRzLnBhcmFtcyA9IGJhc2VQYXJ0cy5wYXJhbXM7XG4gICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cXVlcnk+IG9mIHRoZSBiYXNlXG4gICAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmQgd2Ugc2tpcCB0byBzdGVwIDcuXG4gICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xuICAgICAgICAgICAgICAgIGJ1aWx0UGFydHMucXVlcnkgPSBiYXNlUGFydHMucXVlcnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gNikgVGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgYmFzZSBVUkwncyBwYXRoIChhbnl0aGluZ1xuICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xuICAgICAgICAgICAgLy8gc2xhc2ggaXMgcHJlc2VudCkgaXMgcmVtb3ZlZCBhbmQgdGhlIGVtYmVkZGVkIFVSTCdzIHBhdGggaXNcbiAgICAgICAgICAgIC8vIGFwcGVuZGVkIGluIGl0cyBwbGFjZS5cbiAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgdmFyIG5ld1BhdGggPSBiYXNlVVJMUGF0aC5zdWJzdHJpbmcoMCwgYmFzZVVSTFBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpICsgcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJ1aWx0UGFydHMucGF0aCA9PT0gbnVsbCkge1xuICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBvcHRzLmFsd2F5c05vcm1hbGl6ZSA/IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpIDogcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYnVpbHRQYXJ0cyk7XG4gICAgfSxcbiAgICBwYXJzZVVSTDogZnVuY3Rpb24odXJsKSB7XG4gICAgICB2YXIgcGFydHMgPSBVUkxfUkVHRVguZXhlYyh1cmwpO1xuICAgICAgaWYgKCFwYXJ0cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogcGFydHNbMV0gfHwgJycsXG4gICAgICAgIG5ldExvYzogcGFydHNbMl0gfHwgJycsXG4gICAgICAgIHBhdGg6IHBhcnRzWzNdIHx8ICcnLFxuICAgICAgICBwYXJhbXM6IHBhcnRzWzRdIHx8ICcnLFxuICAgICAgICBxdWVyeTogcGFydHNbNV0gfHwgJycsXG4gICAgICAgIGZyYWdtZW50OiBwYXJ0c1s2XSB8fCAnJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZVBhdGg6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgb3BlcmF0aW9ucyBhcmVcbiAgICAgIC8vIHRoZW4gYXBwbGllZCwgaW4gb3JkZXIsIHRvIHRoZSBuZXcgcGF0aDpcbiAgICAgIC8vIDZhKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCIuL1wiLCB3aGVyZSBcIi5cIiBpcyBhIGNvbXBsZXRlIHBhdGhcbiAgICAgIC8vIHNlZ21lbnQsIGFyZSByZW1vdmVkLlxuICAgICAgLy8gNmIpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIi5cIiBhcyBhIGNvbXBsZXRlIHBhdGggc2VnbWVudCxcbiAgICAgIC8vIHRoYXQgXCIuXCIgaXMgcmVtb3ZlZC5cbiAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykucmVwbGFjZShTTEFTSF9ET1RfUkVHRVgsICcnKTtcbiAgICAgIC8vIDZjKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCI8c2VnbWVudD4vLi4vXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG4gICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgYXJlIHJlbW92ZWQuXG4gICAgICAvLyBSZW1vdmFsIG9mIHRoZXNlIHBhdGggc2VnbWVudHMgaXMgcGVyZm9ybWVkIGl0ZXJhdGl2ZWx5LFxuICAgICAgLy8gcmVtb3ZpbmcgdGhlIGxlZnRtb3N0IG1hdGNoaW5nIHBhdHRlcm4gb24gZWFjaCBpdGVyYXRpb24sXG4gICAgICAvLyB1bnRpbCBubyBtYXRjaGluZyBwYXR0ZXJuIHJlbWFpbnMuXG4gICAgICAvLyA2ZCkgSWYgdGhlIHBhdGggZW5kcyB3aXRoIFwiPHNlZ21lbnQ+Ly4uXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG4gICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgdGhhdFxuICAgICAgLy8gXCI8c2VnbWVudD4vLi5cIiBpcyByZW1vdmVkLlxuICAgICAgd2hpbGUgKHBhdGgubGVuZ3RoICE9PSAocGF0aCA9IHBhdGgucmVwbGFjZShTTEFTSF9ET1RfRE9UX1JFR0VYLCAnJykpLmxlbmd0aCkge30gLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuICAgIH0sXG4gICAgYnVpbGRVUkxGcm9tUGFydHM6IGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICByZXR1cm4gcGFydHMuc2NoZW1lICsgcGFydHMubmV0TG9jICsgcGFydHMucGF0aCArIHBhcnRzLnBhcmFtcyArIHBhcnRzLnF1ZXJ5ICsgcGFydHMuZnJhZ21lbnQ7XG4gICAgfVxuICB9O1xuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFVSTFRvb2xraXQ7XG4gIGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBVUkxUb29sa2l0OyB9KTtcbiAgZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG4gICAgZXhwb3J0c1tcIlVSTFRvb2xraXRcIl0gPSBVUkxUb29sa2l0O1xuICBlbHNlXG4gICAgcm9vdFtcIlVSTFRvb2xraXRcIl0gPSBVUkxUb29sa2l0O1xufSkodGhpcyk7XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qcyIsInR5cGUgQmluYXJ5U2VhcmNoQ29tcGFyaXNvbiA8IFQgPiA9IChjYW5kaWRhdGU6IFQpID0+IC0xIHwgMCB8IDE7XHJcblxyXG5jb25zdCBCaW5hcnlTZWFyY2ggPSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlYXJjaGVzIGZvciBhbiBpdGVtIGluIGFuIGFycmF5IHdoaWNoIG1hdGNoZXMgYSBjZXJ0YWluIGNvbmRpdGlvbi5cclxuICAgKiBUaGlzIHJlcXVpcmVzIHRoZSBjb25kaXRpb24gdG8gb25seSBtYXRjaCBvbmUgaXRlbSBpbiB0aGUgYXJyYXksXHJcbiAgICogYW5kIGZvciB0aGUgYXJyYXkgdG8gYmUgb3JkZXJlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IGxpc3QgVGhlIGFycmF5IHRvIHNlYXJjaC5cclxuICAgKiBAcGFyYW0ge0JpbmFyeVNlYXJjaENvbXBhcmlzb248VD59IGNvbXBhcmlzb25GblxyXG4gICAqICAgICAgQ2FsbGVkIGFuZCBwcm92aWRlZCBhIGNhbmRpZGF0ZSBpdGVtIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cclxuICAgKiAgICAgIFNob3VsZCByZXR1cm46XHJcbiAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXHJcbiAgICogICAgICAgICAgPiAxIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgaGlnaGVyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXHJcbiAgICogICAgICAgICAgPiAwIGlmIHRoZSBpdGVtIGlzIHRoZSBpdGVtIHlvdSdyZSBsb29raW5nIGZvci5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1QgfCBudWxsfSBUaGUgb2JqZWN0IGlmIGl0IGlzIGZvdW5kIG9yIG51bGwgb3RoZXJ3aXNlLlxyXG4gICAqL1xyXG4gIHNlYXJjaDogZnVuY3Rpb248VD4gKGxpc3Q6IFRbXSwgY29tcGFyaXNvbkZuOiBCaW5hcnlTZWFyY2hDb21wYXJpc29uPFQ+KTogVCB8IG51bGwge1xyXG4gICAgbGV0IG1pbkluZGV4OiBudW1iZXIgPSAwO1xyXG4gICAgbGV0IG1heEluZGV4OiBudW1iZXIgPSBsaXN0Lmxlbmd0aCAtIDE7XHJcbiAgICBsZXQgY3VycmVudEluZGV4OiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuICAgIGxldCBjdXJyZW50RWxlbWVudDogVCB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIHdoaWxlIChtaW5JbmRleCA8PSBtYXhJbmRleCkge1xyXG4gICAgICBjdXJyZW50SW5kZXggPSAobWluSW5kZXggKyBtYXhJbmRleCkgLyAyIHwgMDtcclxuICAgICAgY3VycmVudEVsZW1lbnQgPSBsaXN0W2N1cnJlbnRJbmRleF07XHJcblxyXG4gICAgICBsZXQgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GbihjdXJyZW50RWxlbWVudCk7XHJcbiAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xyXG4gICAgICAgIG1pbkluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcclxuICAgICAgfSBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xyXG4gICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCaW5hcnlTZWFyY2g7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL2JpbmFyeS1zZWFyY2gudHMiLCJpbXBvcnQgQUVTQ3J5cHRvIGZyb20gJy4vYWVzLWNyeXB0byc7XHJcbmltcG9ydCBGYXN0QUVTS2V5IGZyb20gJy4vZmFzdC1hZXMta2V5JztcclxuaW1wb3J0IEFFU0RlY3J5cHRvciBmcm9tICcuL2Flcy1kZWNyeXB0b3InO1xyXG5cclxuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5cclxuaW1wb3J0IHsgZ2V0U2VsZlNjb3BlIH0gZnJvbSAnLi4vdXRpbHMvZ2V0LXNlbGYtc2NvcGUnO1xyXG5cclxuLy8gc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTIzNzI1OS81ODk0OTNcclxuY29uc3QgZ2xvYmFsID0gZ2V0U2VsZlNjb3BlKCk7IC8vIHNhZmVndWFyZCBmb3IgY29kZSB0aGF0IG1pZ2h0IHJ1biBib3RoIG9uIHdvcmtlciBhbmQgbWFpbiB0aHJlYWRcclxuXHJcbmNsYXNzIERlY3J5cHRlciB7XHJcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyLCBjb25maWcsIHsgcmVtb3ZlUEtDUzdQYWRkaW5nID0gdHJ1ZSB9ID0ge30pIHtcclxuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XHJcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nID0gcmVtb3ZlUEtDUzdQYWRkaW5nO1xyXG4gICAgLy8gYnVpbHQgaW4gZGVjcnlwdG9yIGV4cGVjdHMgUEtDUzcgcGFkZGluZ1xyXG4gICAgaWYgKHJlbW92ZVBLQ1M3UGFkZGluZykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGJyb3dzZXJDcnlwdG8gPSBnbG9iYWwuY3J5cHRvO1xyXG4gICAgICAgIGlmIChicm93c2VyQ3J5cHRvKSB7XHJcbiAgICAgICAgICB0aGlzLnN1YnRsZSA9IGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8IGJyb3dzZXJDcnlwdG8ud2Via2l0U3VidGxlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgIH1cclxuICAgIHRoaXMuZGlzYWJsZVdlYkNyeXB0byA9ICF0aGlzLnN1YnRsZTtcclxuICB9XHJcblxyXG4gIGlzU3luYyAoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMuZGlzYWJsZVdlYkNyeXB0byAmJiB0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUyk7XHJcbiAgfVxyXG5cclxuICBkZWNyeXB0IChkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xyXG4gICAgaWYgKHRoaXMuZGlzYWJsZVdlYkNyeXB0byAmJiB0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xyXG4gICAgICBpZiAodGhpcy5sb2dFbmFibGVkKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnSlMgQUVTIGRlY3J5cHQnKTtcclxuICAgICAgICB0aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgZGVjcnlwdG9yID0gdGhpcy5kZWNyeXB0b3I7XHJcbiAgICAgIGlmICghZGVjcnlwdG9yKSB7XHJcbiAgICAgICAgdGhpcy5kZWNyeXB0b3IgPSBkZWNyeXB0b3IgPSBuZXcgQUVTRGVjcnlwdG9yKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRlY3J5cHRvci5leHBhbmRLZXkoa2V5KTtcclxuICAgICAgY2FsbGJhY2soZGVjcnlwdG9yLmRlY3J5cHQoZGF0YSwgMCwgaXYsIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodGhpcy5sb2dFbmFibGVkKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnV2ViQ3J5cHRvIEFFUyBkZWNyeXB0Jyk7XHJcbiAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc3VidGxlID0gdGhpcy5zdWJ0bGU7XHJcbiAgICAgIGlmICh0aGlzLmtleSAhPT0ga2V5KSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5mYXN0QWVzS2V5ID0gbmV3IEZhc3RBRVNLZXkoc3VidGxlLCBrZXkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KClcclxuICAgICAgICAudGhlbigoYWVzS2V5KSA9PiB7XHJcbiAgICAgICAgICAvLyBkZWNyeXB0IHVzaW5nIHdlYiBjcnlwdG9cclxuICAgICAgICAgIGxldCBjcnlwdG8gPSBuZXcgQUVTQ3J5cHRvKHN1YnRsZSwgaXYpO1xyXG4gICAgICAgICAgY3J5cHRvLmRlY3J5cHQoZGF0YSwgYWVzS2V5KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgIHRoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICAgIHRoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uV2ViQ3J5cHRvRXJyb3IgKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spIHtcclxuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xyXG4gICAgICBsb2dnZXIubG9nKCdXZWJDcnlwdG8gRXJyb3IsIGRpc2FibGUgV2ViQ3J5cHRvIEFQSScpO1xyXG4gICAgICB0aGlzLmRpc2FibGVXZWJDcnlwdG8gPSB0cnVlO1xyXG4gICAgICB0aGlzLmxvZ0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLmRlY3J5cHQoZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKGBkZWNyeXB0aW5nIGVycm9yIDogJHtlcnIubWVzc2FnZX1gKTtcclxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1IsIGZhdGFsOiB0cnVlLCByZWFzb246IGVyci5tZXNzYWdlIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVzdHJveSAoKSB7XHJcbiAgICBsZXQgZGVjcnlwdG9yID0gdGhpcy5kZWNyeXB0b3I7XHJcbiAgICBpZiAoZGVjcnlwdG9yKSB7XHJcbiAgICAgIGRlY3J5cHRvci5kZXN0cm95KCk7XHJcbiAgICAgIHRoaXMuZGVjcnlwdG9yID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGVjcnlwdGVyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jcnlwdC9kZWNyeXB0ZXIuanMiLCJcclxuaW1wb3J0IHsgYnVpbGRBYnNvbHV0ZVVSTCB9IGZyb20gJ3VybC10b29sa2l0JztcclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuaW1wb3J0IExldmVsS2V5IGZyb20gJy4vbGV2ZWwta2V5JztcclxuaW1wb3J0IHsgUGxheWxpc3RMZXZlbFR5cGUgfSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xyXG5cclxuZXhwb3J0IGVudW0gRWxlbWVudGFyeVN0cmVhbVR5cGVzIHtcclxuICBBVURJTyA9ICdhdWRpbycsXHJcbiAgVklERU8gPSAndmlkZW8nLFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGcmFnbWVudCB7XHJcbiAgcHJpdmF0ZSBfdXJsOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIF9ieXRlUmFuZ2U6IG51bWJlcltdIHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBfZGVjcnlwdGRhdGE6IExldmVsS2V5IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIC8vIEhvbGRzIHRoZSB0eXBlcyBvZiBkYXRhIHRoaXMgZnJhZ21lbnQgc3VwcG9ydHNcclxuICBwcml2YXRlIF9lbGVtZW50YXJ5U3RyZWFtczogUmVjb3JkPEVsZW1lbnRhcnlTdHJlYW1UeXBlcywgYm9vbGVhbj4gPSB7XHJcbiAgICBbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXTogZmFsc2UsXHJcbiAgICBbRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXTogZmFsc2VcclxuICB9O1xyXG5cclxuICAvLyBkZWx0YVBUUyB0cmFja3MgdGhlIGNoYW5nZSBpbiBwcmVzZW50YXRpb24gdGltZXN0YW1wIGJldHdlZW4gZnJhZ21lbnRzXHJcbiAgcHVibGljIGRlbHRhUFRTOiBudW1iZXIgPSAwO1xyXG5cclxuICBwdWJsaWMgcmF3UHJvZ3JhbURhdGVUaW1lOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICBwdWJsaWMgcHJvZ3JhbURhdGVUaW1lOiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuICBwdWJsaWMgdGl0bGU6IHN0cmluZyB8IG51bGwgPSBudWxsO1xyXG4gIHB1YmxpYyB0YWdMaXN0OiBBcnJheTxzdHJpbmdbXT4gPSBbXTtcclxuXHJcbiAgLy8gVE9ETzogTW92ZSBhdCBsZWFzdCBiYXNldXJsIHRvIGNvbnN0cnVjdG9yLlxyXG4gIC8vIEN1cnJlbnRseSB3ZSBkbyBhIHR3by1wYXNzIGNvbnN0cnVjdGlvbiBhcyB1c2UgdGhlIEZyYWdtZW50IGNsYXNzIGFsbW9zdCBsaWtlIGEgb2JqZWN0IGZvciBob2xkaW5nIHBhcnNpbmcgc3RhdGUuXHJcbiAgLy8gSXQgbWF5IG1ha2UgbW9yZSBzZW5zZSB0byBqdXN0IHVzZSBhIFBPSk8gdG8ga2VlcCBzdGF0ZSBkdXJpbmcgdGhlIHBhcnNpbmcgcGhhc2UuXHJcbiAgLy8gSGF2ZSBGcmFnbWVudCBiZSB0aGUgcmVwcmVzZW50YXRpb24gb25jZSB3ZSBoYXZlIGEga25vd24gc3RhdGU/XHJcbiAgLy8gU29tZXRoaW5nIHRvIHRoaW5rIG9uLlxyXG5cclxuICAvLyBEaXNjb250aW51aXR5IENvdW50ZXJcclxuICBwdWJsaWMgY2MhOiBudW1iZXI7XHJcblxyXG4gIHB1YmxpYyB0eXBlITogUGxheWxpc3RMZXZlbFR5cGU7XHJcbiAgLy8gcmVsdXJsIGlzIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgdGhhdCBjb21lcyBmcm9tIGluc2lkZSB0aGUgcGxheWxpc3QuXHJcbiAgcHVibGljIHJlbHVybCE6IHN0cmluZztcclxuICAvLyBiYXNldXJsIGlzIHRoZSBVUkwgdG8gdGhlIHBsYXlsaXN0XHJcbiAgcHVibGljIGJhc2V1cmwhOiBzdHJpbmc7XHJcbiAgLy8gRVhUSU5GIGhhcyB0byBiZSBwcmVzZW50IGZvciBhIG0zdTggdG8gYmUgY29uc2lkZXJlZCB2YWxpZFxyXG4gIHB1YmxpYyBkdXJhdGlvbiE6IG51bWJlcjtcclxuICAvLyBXaGVuIHRoaXMgc2VnbWVudCBzdGFydHMgaW4gdGhlIHRpbWVsaW5lXHJcbiAgcHVibGljIHN0YXJ0ITogbnVtYmVyO1xyXG4gIC8vIHNuIG5vdGF0ZXMgdGhlIHNlcXVlbmNlIG51bWJlciBmb3IgYSBzZWdtZW50LCBhbmQgaWYgc2V0IHRvIGEgc3RyaW5nIGNhbiBiZSAnaW5pdFNlZ21lbnQnXHJcbiAgcHVibGljIHNuOiBudW1iZXIgfCAnaW5pdFNlZ21lbnQnID0gMDtcclxuXHJcbiAgcHVibGljIHVybElkOiBudW1iZXIgPSAwO1xyXG4gIC8vIGxldmVsIG1hdGNoZXMgdGhpcyBmcmFnbWVudCB0byBhIGluZGV4IHBsYXlsaXN0XHJcbiAgcHVibGljIGxldmVsOiBudW1iZXIgPSAwO1xyXG4gIC8vIGxldmVsa2V5IGlzIHRoZSBFWFQtWC1LRVkgdGhhdCBhcHBsaWVzIHRvIHRoaXMgc2VnbWVudCBmb3IgZGVjcnlwdGlvblxyXG4gIC8vIGNvcmUgZGlmZmVyZW5jZSBmcm9tIHRoZSBwcml2YXRlIGZpZWxkIF9kZWNyeXB0ZGF0YSBpcyB0aGUgbGFjayBvZiB0aGUgaW5pdGlhbGl6ZWQgSVZcclxuICAvLyBfZGVjcnlwdGRhdGEgd2lsbCBzZXQgdGhlIElWIGZvciB0aGlzIHNlZ21lbnQgYmFzZWQgb24gdGhlIHNlZ21lbnQgbnVtYmVyIGluIHRoZSBmcmFnbWVudFxyXG4gIHB1YmxpYyBsZXZlbGtleT86IExldmVsS2V5O1xyXG5cclxuICAvLyBUT0RPKHR5cGVzY3JpcHQteGhybG9hZGVyKVxyXG4gIHB1YmxpYyBsb2FkZXI6IGFueTtcclxuXHJcbiAgLy8gc2V0Qnl0ZVJhbmdlIGNvbnZlcnRzIGEgRVhULVgtQllURVJBTkdFIGF0dHJpYnV0ZSBpbnRvIGEgdHdvIGVsZW1lbnQgYXJyYXlcclxuICBzZXRCeXRlUmFuZ2UgKHZhbHVlOiBzdHJpbmcsIHByZXZpb3VzRnJhZz86IEZyYWdtZW50KSB7XHJcbiAgICBjb25zdCBwYXJhbXMgPSB2YWx1ZS5zcGxpdCgnQCcsIDIpO1xyXG4gICAgY29uc3QgYnl0ZVJhbmdlOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgYnl0ZVJhbmdlWzBdID0gcHJldmlvdXNGcmFnID8gcHJldmlvdXNGcmFnLmJ5dGVSYW5nZUVuZE9mZnNldCA6IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBieXRlUmFuZ2VbMF0gPSBwYXJzZUludChwYXJhbXNbMV0pO1xyXG4gICAgfVxyXG4gICAgYnl0ZVJhbmdlWzFdID0gcGFyc2VJbnQocGFyYW1zWzBdKSArIGJ5dGVSYW5nZVswXTtcclxuICAgIHRoaXMuX2J5dGVSYW5nZSA9IGJ5dGVSYW5nZTtcclxuICB9XHJcblxyXG4gIGdldCB1cmwgKCkge1xyXG4gICAgaWYgKCF0aGlzLl91cmwgJiYgdGhpcy5yZWx1cmwpIHtcclxuICAgICAgdGhpcy5fdXJsID0gYnVpbGRBYnNvbHV0ZVVSTCh0aGlzLmJhc2V1cmwsIHRoaXMucmVsdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fdXJsO1xyXG4gIH1cclxuXHJcbiAgc2V0IHVybCAodmFsdWUpIHtcclxuICAgIHRoaXMuX3VybCA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGJ5dGVSYW5nZSAoKTogbnVtYmVyW10ge1xyXG4gICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UpIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9ieXRlUmFuZ2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBieXRlUmFuZ2VTdGFydE9mZnNldCAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMF07XHJcbiAgfVxyXG5cclxuICBnZXQgYnl0ZVJhbmdlRW5kT2Zmc2V0ICgpIHtcclxuICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVsxXTtcclxuICB9XHJcblxyXG4gIGdldCBkZWNyeXB0ZGF0YSAoKTogTGV2ZWxLZXkgfCBudWxsIHtcclxuICAgIGlmICghdGhpcy5sZXZlbGtleSAmJiAhdGhpcy5fZGVjcnlwdGRhdGEpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl9kZWNyeXB0ZGF0YSAmJiB0aGlzLmxldmVsa2V5KSB7XHJcbiAgICAgIGxldCBzbiA9IHRoaXMuc247XHJcbiAgICAgIGlmICh0eXBlb2Ygc24gIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgLy8gV2UgYXJlIGZldGNoaW5nIGRlY3J5cHRpb24gZGF0YSBmb3IgYSBpbml0aWFsaXphdGlvbiBzZWdtZW50XHJcbiAgICAgICAgLy8gSWYgdGhlIHNlZ21lbnQgd2FzIGVuY3J5cHRlZCB3aXRoIEFFUy0xMjhcclxuICAgICAgICAvLyBJdCBtdXN0IGhhdmUgYW4gSVYgZGVmaW5lZC4gV2UgY2Fubm90IHN1YnN0aXR1dGUgdGhlIFNlZ21lbnQgTnVtYmVyIGluLlxyXG4gICAgICAgIGlmICh0aGlzLmxldmVsa2V5ICYmIHRoaXMubGV2ZWxrZXkubWV0aG9kID09PSAnQUVTLTEyOCcgJiYgIXRoaXMubGV2ZWxrZXkuaXYpIHtcclxuICAgICAgICAgIGxvZ2dlci53YXJuKGBtaXNzaW5nIElWIGZvciBpbml0aWFsaXphdGlvbiBzZWdtZW50IHdpdGggbWV0aG9kPVwiJHt0aGlzLmxldmVsa2V5Lm1ldGhvZH1cIiAtIGNvbXBsaWFuY2UgaXNzdWVgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgQmUgY29udmVydGVkIHRvIGEgTnVtYmVyLlxyXG4gICAgICAgICdpbml0U2VnbWVudCcgd2lsbCBiZWNvbWUgTmFOLlxyXG4gICAgICAgIE5hTiwgd2hpY2ggd2hlbiBjb252ZXJ0ZWQgdGhyb3VnaCBUb0ludDMyKCkgLT4gKzAuXHJcbiAgICAgICAgLS0tXHJcbiAgICAgICAgRXhwbGljaXRseSBzZXQgc24gdG8gcmVzdWx0aW5nIHZhbHVlIGZyb20gaW1wbGljaXQgY29udmVyc2lvbnMgJ2luaXRTZWdtZW50JyB2YWx1ZXMgZm9yIElWIGdlbmVyYXRpb24uXHJcbiAgICAgICAgKi9cclxuICAgICAgICBzbiA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fZGVjcnlwdGRhdGEgPSB0aGlzLnNldERlY3J5cHREYXRhRnJvbUxldmVsS2V5KHRoaXMubGV2ZWxrZXksIHNuKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fZGVjcnlwdGRhdGE7XHJcbiAgfVxyXG5cclxuICBnZXQgZW5kUHJvZ3JhbURhdGVUaW1lICgpIHtcclxuICAgIGlmICh0aGlzLnByb2dyYW1EYXRlVGltZSA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0aGlzLnByb2dyYW1EYXRlVGltZSkpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGR1cmF0aW9uID0gIU51bWJlci5pc0Zpbml0ZSh0aGlzLmR1cmF0aW9uKSA/IDAgOiB0aGlzLmR1cmF0aW9uO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnByb2dyYW1EYXRlVGltZSArIChkdXJhdGlvbiAqIDEwMDApO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGVuY3J5cHRlZCAoKSB7XHJcbiAgICByZXR1cm4gISEoKHRoaXMuZGVjcnlwdGRhdGEgJiYgdGhpcy5kZWNyeXB0ZGF0YS51cmkgIT09IG51bGwpICYmICh0aGlzLmRlY3J5cHRkYXRhLmtleSA9PT0gbnVsbCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50YXJ5U3RyZWFtVHlwZXN9IHR5cGVcclxuICAgKi9cclxuICBhZGRFbGVtZW50YXJ5U3RyZWFtICh0eXBlOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMpIHtcclxuICAgIHRoaXMuX2VsZW1lbnRhcnlTdHJlYW1zW3R5cGVdID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudGFyeVN0cmVhbVR5cGVzfSB0eXBlXHJcbiAgICovXHJcbiAgaGFzRWxlbWVudGFyeVN0cmVhbSAodHlwZTogRWxlbWVudGFyeVN0cmVhbVR5cGVzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudGFyeVN0cmVhbXNbdHlwZV0gPT09IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgcGFyc2VMZXZlbFBsYXlsaXN0IHRvIGNyZWF0ZSBhbiBpbml0aWFsaXphdGlvbiB2ZWN0b3IgZm9yIGEgZ2l2ZW4gc2VnbWVudFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50TnVtYmVyIC0gc2VnbWVudCBudW1iZXIgdG8gZ2VuZXJhdGUgSVYgd2l0aFxyXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxyXG4gICAqL1xyXG4gIGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yIChzZWdtZW50TnVtYmVyOiBudW1iZXIpOiBVaW50OEFycmF5IHtcclxuICAgIGxldCB1aW50OFZpZXcgPSBuZXcgVWludDhBcnJheSgxNik7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xyXG4gICAgICB1aW50OFZpZXdbaV0gPSAoc2VnbWVudE51bWJlciA+PiA4ICogKDE1IC0gaSkpICYgMHhmZjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdWludDhWaWV3O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXRpbGl0eSBtZXRob2QgZm9yIHBhcnNlTGV2ZWxQbGF5bGlzdCB0byBnZXQgYSBmcmFnbWVudCdzIGRlY3J5cHRpb24gZGF0YSBmcm9tIHRoZSBjdXJyZW50bHkgcGFyc2VkIGVuY3J5cHRpb24ga2V5IGRhdGFcclxuICAgKiBAcGFyYW0gbGV2ZWxrZXkgLSBhIHBsYXlsaXN0J3MgZW5jcnlwdGlvbiBpbmZvXHJcbiAgICogQHBhcmFtIHNlZ21lbnROdW1iZXIgLSB0aGUgZnJhZ21lbnQncyBzZWdtZW50IG51bWJlclxyXG4gICAqIEByZXR1cm5zIHtMZXZlbEtleX0gLSBhbiBvYmplY3QgdG8gYmUgYXBwbGllZCBhcyBhIGZyYWdtZW50J3MgZGVjcnlwdGRhdGFcclxuICAgKi9cclxuICBzZXREZWNyeXB0RGF0YUZyb21MZXZlbEtleSAobGV2ZWxrZXk6IExldmVsS2V5LCBzZWdtZW50TnVtYmVyOiBudW1iZXIpOiBMZXZlbEtleSB7XHJcbiAgICBsZXQgZGVjcnlwdGRhdGEgPSBsZXZlbGtleTtcclxuXHJcbiAgICBpZiAobGV2ZWxrZXkgJiYgbGV2ZWxrZXkubWV0aG9kICYmIGxldmVsa2V5LnVyaSAmJiAhbGV2ZWxrZXkuaXYpIHtcclxuICAgICAgZGVjcnlwdGRhdGEgPSBuZXcgTGV2ZWxLZXkobGV2ZWxrZXkuYmFzZXVyaSwgbGV2ZWxrZXkucmVsdXJpKTtcclxuICAgICAgZGVjcnlwdGRhdGEubWV0aG9kID0gbGV2ZWxrZXkubWV0aG9kO1xyXG4gICAgICBkZWNyeXB0ZGF0YS5pdiA9IHRoaXMuY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc2VnbWVudE51bWJlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xyXG4gIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9sb2FkZXIvZnJhZ21lbnQudHMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIi8qKlxyXG4gKiBNZWRpYVNvdXJjZSBoZWxwZXJcclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVkaWFTb3VyY2UgKCk6IHR5cGVvZiBNZWRpYVNvdXJjZSB8IHVuZGVmaW5lZCB7XHJcbiAgcmV0dXJuICh3aW5kb3cgYXMgYW55KS5NZWRpYVNvdXJjZSB8fCAod2luZG93IGFzIGFueSkuV2ViS2l0TWVkaWFTb3VyY2U7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyLnRzIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XHJcblxyXG4vKipcclxuICogU2ltcGxlIGFkYXB0ZXIgc3ViLWNsYXNzIG9mIE5vZGVqcy1saWtlIEV2ZW50RW1pdHRlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBPYnNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgLyoqXHJcbiAgICogV2Ugc2ltcGx5IHdhbnQgdG8gcGFzcyBhbG9uZyB0aGUgZXZlbnQtbmFtZSBpdHNlbGZcclxuICAgKiBpbiBldmVyeSBjYWxsIHRvIGEgaGFuZGxlciwgd2hpY2ggaXMgdGhlIHB1cnBvc2Ugb2Ygb3VyIGB0cmlnZ2VyYCBtZXRob2RcclxuICAgKiBleHRlbmRpbmcgdGhlIHN0YW5kYXJkIEFQSS5cclxuICAgKi9cclxuICB0cmlnZ2VyIChldmVudDogc3RyaW5nLCAuLi5kYXRhOiBBcnJheTxhbnk+KTogdm9pZCB7XHJcbiAgICB0aGlzLmVtaXQoZXZlbnQsIGV2ZW50LCAuLi5kYXRhKTtcclxuICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvb2JzZXJ2ZXIudHMiLCJpbXBvcnQgVGFza0xvb3AgZnJvbSAnLi4vdGFzay1sb29wJztcclxuaW1wb3J0IHsgRnJhZ21lbnRTdGF0ZSB9IGZyb20gJy4vZnJhZ21lbnQtdHJhY2tlcic7XHJcbmltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5cclxuZXhwb3J0IGNvbnN0IFN0YXRlID0ge1xyXG4gIFNUT1BQRUQ6ICdTVE9QUEVEJyxcclxuICBTVEFSVElORzogJ1NUQVJUSU5HJyxcclxuICBJRExFOiAnSURMRScsXHJcbiAgUEFVU0VEOiAnUEFVU0VEJyxcclxuICBLRVlfTE9BRElORzogJ0tFWV9MT0FESU5HJyxcclxuICBGUkFHX0xPQURJTkc6ICdGUkFHX0xPQURJTkcnLFxyXG4gIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxyXG4gIFdBSVRJTkdfVFJBQ0s6ICdXQUlUSU5HX1RSQUNLJyxcclxuICBQQVJTSU5HOiAnUEFSU0lORycsXHJcbiAgUEFSU0VEOiAnUEFSU0VEJyxcclxuICBCVUZGRVJfRkxVU0hJTkc6ICdCVUZGRVJfRkxVU0hJTkcnLFxyXG4gIEVOREVEOiAnRU5ERUQnLFxyXG4gIEVSUk9SOiAnRVJST1InLFxyXG4gIFdBSVRJTkdfSU5JVF9QVFM6ICdXQUlUSU5HX0lOSVRfUFRTJyxcclxuICBXQUlUSU5HX0xFVkVMOiAnV0FJVElOR19MRVZFTCdcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgVGFza0xvb3Age1xyXG4gIGRvVGljayAoKSB7fVxyXG5cclxuICBzdGFydExvYWQgKCkge31cclxuXHJcbiAgc3RvcExvYWQgKCkge1xyXG4gICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xyXG4gICAgaWYgKGZyYWcpIHtcclxuICAgICAgaWYgKGZyYWcubG9hZGVyKSB7XHJcbiAgICAgICAgZnJhZy5sb2FkZXIuYWJvcnQoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcclxuICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcclxuICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xyXG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xyXG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XHJcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcclxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xyXG4gIH1cclxuXHJcbiAgX3N0cmVhbUVuZGVkIChidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpIHtcclxuICAgIGNvbnN0IHsgZnJhZ0N1cnJlbnQsIGZyYWdtZW50VHJhY2tlciB9ID0gdGhpcztcclxuICAgIC8vIHdlIGp1c3QgZ290IGRvbmUgbG9hZGluZyB0aGUgZmluYWwgZnJhZ21lbnQgYW5kIHRoZXJlIGlzIG5vIG90aGVyIGJ1ZmZlcmVkIHJhbmdlIGFmdGVyIC4uLlxyXG4gICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgaW4gY2FzZSB0aGVyZSBhcmUgYW55IGJ1ZmZlcmVkIHJhbmdlcyBhZnRlciwgaXQgbWVhbnMgdGhhdCB0aGVyZSBhcmUgdW5idWZmZXJlZCBwb3J0aW9uIGluIGJldHdlZW5cclxuICAgIC8vIHNvIHdlIHNob3VsZCBub3Qgc3dpdGNoIHRvIEVOREVEIGluIHRoYXQgY2FzZSwgdG8gYmUgYWJsZSB0byBidWZmZXIgdGhlbVxyXG4gICAgLy8gZG9udCBzd2l0Y2ggdG8gRU5ERUQgaWYgd2UgbmVlZCB0byBiYWNrdHJhY2sgbGFzdCBmcmFnbWVudFxyXG4gICAgaWYgKCFsZXZlbERldGFpbHMubGl2ZSAmJiBmcmFnQ3VycmVudCAmJiAhZnJhZ0N1cnJlbnQuYmFja3RyYWNrZWQgJiYgZnJhZ0N1cnJlbnQuc24gPT09IGxldmVsRGV0YWlscy5lbmRTTiAmJiAhYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcclxuICAgICAgY29uc3QgZnJhZ1N0YXRlID0gZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWdDdXJyZW50KTtcclxuICAgICAgcmV0dXJuIGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5PSztcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIG9uTWVkaWFTZWVraW5nICgpIHtcclxuICAgIGNvbnN0IHsgY29uZmlnLCBtZWRpYSwgbWVkaWFCdWZmZXIsIHN0YXRlIH0gPSB0aGlzO1xyXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogbnVsbDtcclxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYUJ1ZmZlciB8fCBtZWRpYSwgY3VycmVudFRpbWUsIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xyXG5cclxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY3VycmVudFRpbWUpKSB7XHJcbiAgICAgIGxvZ2dlci5sb2coYG1lZGlhIHNlZWtpbmcgdG8gJHtjdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HKSB7XHJcbiAgICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XHJcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBzZWVraW5nIHRvIGEgdW5idWZmZXJlZCBhcmVhIEFORCBpZiBmcmFnIGxvYWRpbmcgaXMgaW4gcHJvZ3Jlc3NcclxuICAgICAgaWYgKGJ1ZmZlckluZm8ubGVuID09PSAwICYmIGZyYWdDdXJyZW50KSB7XHJcbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XHJcbiAgICAgICAgY29uc3QgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2U7XHJcbiAgICAgICAgY29uc3QgZnJhZ0VuZE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0ICsgZnJhZ0N1cnJlbnQuZHVyYXRpb24gKyB0b2xlcmFuY2U7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgd2Ugc2VlayBwb3NpdGlvbiB3aWxsIGJlIG91dCBvZiBjdXJyZW50bHkgbG9hZGVkIGZyYWcgcmFuZ2UgOiBpZiBvdXQgY2FuY2VsIGZyYWcgbG9hZCwgaWYgaW4sIGRvbid0IGRvIGFueXRoaW5nXHJcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgZnJhZ1N0YXJ0T2Zmc2V0IHx8IGN1cnJlbnRUaW1lID4gZnJhZ0VuZE9mZnNldCkge1xyXG4gICAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdzZWVraW5nIG91dHNpZGUgb2YgYnVmZmVyIHdoaWxlIGZyYWdtZW50IGxvYWQgaW4gcHJvZ3Jlc3MsIGNhbmNlbCBmcmFnbWVudCBsb2FkJyk7XHJcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XHJcbiAgICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxyXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgYnV0IHdpdGhpbiBjdXJyZW50bHkgbG9hZGVkIGZyYWdtZW50IHJhbmdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xyXG4gICAgICAvLyBpZiBzZWVraW5nIHRvIHVuYnVmZmVyZWQgYXJlYSwgY2xlYW4gdXAgZnJhZ1ByZXZpb3VzXHJcbiAgICAgIGlmIChidWZmZXJJbmZvLmxlbiA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gY2hlY2sgZm9yIHBvdGVudGlhbCBuZXcgZnJhZ21lbnRcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICB9XHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpbiBjYXNlIHNlZWtpbmcgb2NjdXJzIGFsdGhvdWdoIG5vIG1lZGlhIGJ1ZmZlcmVkLCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiBhbmQgbmV4dExvYWRQb3NpdGlvbiB0byBzZWVrIHRhcmdldFxyXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XHJcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IGN1cnJlbnRUaW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgcHJvY2Vzc2luZ1xyXG4gICAgdGhpcy50aWNrKCk7XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhRW5kZWQgKCkge1xyXG4gICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXHJcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XHJcbiAgfVxyXG5cclxuICBvbkhhbmRsZXJEZXN0cm95aW5nICgpIHtcclxuICAgIHRoaXMuc3RvcExvYWQoKTtcclxuICAgIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcclxuICB9XHJcblxyXG4gIG9uSGFuZGxlckRlc3Ryb3llZCAoKSB7XHJcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcclxuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbXB1dGVMaXZlUG9zaXRpb24gKHNsaWRpbmcsIGxldmVsRGV0YWlscykge1xyXG4gICAgbGV0IHRhcmdldExhdGVuY3kgPSB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uIDogdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xyXG4gICAgcmV0dXJuIHNsaWRpbmcgKyBNYXRoLm1heCgwLCBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbiAtIHRhcmdldExhdGVuY3kpO1xyXG4gIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jb250cm9sbGVyL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJcclxuZXhwb3J0IGZ1bmN0aW9uIHNlbmRBZGRUcmFja0V2ZW50ICh0cmFjazogVGV4dFRyYWNrLCB2aWRlb0VsOiBIVE1MTWVkaWFFbGVtZW50KSB7XHJcbiAgbGV0IGV2ZW50OiBFdmVudDtcclxuICB0cnkge1xyXG4gICAgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHRyYWNrJyk7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAvLyBmb3IgSUUxMVxyXG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxuICAgIGV2ZW50LmluaXRFdmVudCgnYWRkdHJhY2snLCBmYWxzZSwgZmFsc2UpO1xyXG4gIH1cclxuICAoZXZlbnQgYXMgYW55KS50cmFjayA9IHRyYWNrO1xyXG4gIHZpZGVvRWwuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhckN1cnJlbnRDdWVzICh0cmFjazogVGV4dFRyYWNrKSB7XHJcbiAgaWYgKHRyYWNrICYmIHRyYWNrLmN1ZXMpIHtcclxuICAgIHdoaWxlICh0cmFjay5jdWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdHJhY2sucmVtb3ZlQ3VlKHRyYWNrLmN1ZXNbMF0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqICBHaXZlbiBhIGxpc3Qgb2YgQ3VlcywgZmluZHMgdGhlIGNsb3Nlc3QgY3VlIG1hdGNoaW5nIHRoZSBnaXZlbiB0aW1lLlxyXG4gKiAgTW9kaWZpZWQgdmVyaXNvbiBvZiBiaW5hcnkgc2VhcmNoIE8obG9nKG4pKS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0geyhUZXh0VHJhY2tDdWVMaXN0IHwgVGV4dFRyYWNrQ3VlW10pfSBjdWVzIC0gTGlzdCBvZiBjdWVzLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSAtIFRhcmdldCB0aW1lLCB0byBmaW5kIGNsb3Nlc3QgY3VlIHRvLlxyXG4gKiBAcmV0dXJucyB7VGV4dFRyYWNrQ3VlfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENsb3Nlc3RDdWUgKGN1ZXM6IFRleHRUcmFja0N1ZUxpc3QgfCBUZXh0VHJhY2tDdWVbXSwgdGltZTogbnVtYmVyKTogVGV4dFRyYWNrQ3VlIHtcclxuICAvLyBJZiB0aGUgb2Zmc2V0IGlzIGxlc3MgdGhhbiB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIGNsb3Nlc3QuXHJcbiAgaWYgKHRpbWUgPCBjdWVzWzBdLmVuZFRpbWUpIHtcclxuICAgIHJldHVybiBjdWVzWzBdO1xyXG4gIH1cclxuICAvLyBJZiB0aGUgb2Zmc2V0IGlzIGdyZWF0ZXIgdGhhbiB0aGUgbGFzdCBjdWUsIHRoZSBsYXN0IGlzIHRoZSBjbG9zZXN0LlxyXG4gIGlmICh0aW1lID4gY3Vlc1tjdWVzLmxlbmd0aCAtIDFdLmVuZFRpbWUpIHtcclxuICAgIHJldHVybiBjdWVzW2N1ZXMubGVuZ3RoIC0gMV07XHJcbiAgfVxyXG5cclxuICBsZXQgbGVmdCA9IDA7XHJcbiAgbGV0IHJpZ2h0ID0gY3Vlcy5sZW5ndGggLSAxO1xyXG5cclxuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xyXG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigocmlnaHQgKyBsZWZ0KSAvIDIpO1xyXG5cclxuICAgIGlmICh0aW1lIDwgY3Vlc1ttaWRdLmVuZFRpbWUpIHtcclxuICAgICAgcmlnaHQgPSBtaWQgLSAxO1xyXG4gICAgfSBlbHNlIGlmICh0aW1lID4gY3Vlc1ttaWRdLmVuZFRpbWUpIHtcclxuICAgICAgbGVmdCA9IG1pZCArIDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBJZiBpdCdzIG5vdCBsb3dlciBvciBoaWdoZXIsIGl0IG11c3QgYmUgZXF1YWwuXHJcbiAgICAgIHJldHVybiBjdWVzW21pZF07XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIEF0IHRoaXMgcG9pbnQsIGxlZnQgYW5kIHJpZ2h0IGhhdmUgc3dhcHBlZC5cclxuICAvLyBObyBkaXJlY3QgbWF0Y2ggd2FzIGZvdW5kLCBsZWZ0IG9yIHJpZ2h0IGVsZW1lbnQgbXVzdCBiZSB0aGUgY2xvc2VzdC4gQ2hlY2sgd2hpY2ggb25lIGhhcyB0aGUgc21hbGxlc3QgZGlmZi5cclxuICByZXR1cm4gKGN1ZXNbbGVmdF0uZW5kVGltZSAtIHRpbWUpIDwgKHRpbWUgLSBjdWVzW3JpZ2h0XS5lbmRUaW1lKSA/IGN1ZXNbbGVmdF0gOiBjdWVzW3JpZ2h0XTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy91dGlscy90ZXh0dHJhY2stdXRpbHMudHMiLCJpbXBvcnQgTGV2ZWwgZnJvbSAnLi4vbG9hZGVyL2xldmVsJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyQ29udGV4dCB7XHJcbiAgLy8gdGFyZ2V0IFVSTFxyXG4gIHVybDogc3RyaW5nXHJcbiAgLy8gbG9hZGVyIHJlc3BvbnNlIHR5cGUgKGFycmF5YnVmZmVyIG9yIGRlZmF1bHQgcmVzcG9uc2UgdHlwZSBmb3IgcGxheWxpc3QpXHJcbiAgcmVzcG9uc2VUeXBlOiBzdHJpbmdcclxuICAvLyBzdGFydCBieXRlIHJhbmdlIG9mZnNldFxyXG4gIHJhbmdlU3RhcnQ/OiBudW1iZXJcclxuICAvLyBlbmQgYnl0ZSByYW5nZSBvZmZzZXRcclxuICByYW5nZUVuZD86IG51bWJlclxyXG4gIC8vIHRydWUgaWYgb25Qcm9ncmVzcyBzaG91bGQgcmVwb3J0IHBhcnRpYWwgY2h1bmsgb2YgbG9hZGVkIGNvbnRlbnRcclxuICBwcm9ncmVzc0RhdGE/OiBib29sZWFuXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyQ29uZmlndXJhdGlvbiB7XHJcbiAgLy8gTWF4IG51bWJlciBvZiBsb2FkIHJldHJpZXNcclxuICBtYXhSZXRyeTogbnVtYmVyXHJcbiAgLy8gVGltZW91dCBhZnRlciB3aGljaCBgb25UaW1lT3V0YCBjYWxsYmFjayB3aWxsIGJlIHRyaWdnZXJlZFxyXG4gIC8vIChpZiBsb2FkaW5nIGlzIHN0aWxsIG5vdCBmaW5pc2hlZCBhZnRlciB0aGF0IGRlbGF5KVxyXG4gIHRpbWVvdXQ6IG51bWJlclxyXG4gIC8vIERlbGF5IGJldHdlZW4gYW4gSS9PIGVycm9yIGFuZCBmb2xsb3dpbmcgY29ubmVjdGlvbiByZXRyeSAobXMpLlxyXG4gIC8vIFRoaXMgdG8gYXZvaWQgc3BhbW1pbmcgdGhlIHNlcnZlclxyXG4gIHJldHJ5RGVsYXk6IG51bWJlclxyXG4gIC8vIG1heCBjb25uZWN0aW9uIHJldHJ5IGRlbGF5IChtcylcclxuICBtYXhSZXRyeURlbGF5OiBudW1iZXJcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMb2FkZXJSZXNwb25zZSB7XHJcbiAgdXJsOiBzdHJpbmcsXHJcbiAgLy8gVE9ETyhqc3RhY2tob3VzZSk6IFNoYXJlZEFycmF5QnVmZmVyLCBlczIwMTcgZXh0ZW5zaW9uIHRvIFRTXHJcbiAgZGF0YTogc3RyaW5nIHwgQXJyYXlCdWZmZXJcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMb2FkZXJTdGF0cyB7XHJcbiAgLy8gcGVyZm9ybWFuY2Uubm93KCkganVzdCBhZnRlciBsb2FkKCkgaGFzIGJlZW4gY2FsbGVkXHJcbiAgdHJlcXVlc3Q6IG51bWJlclxyXG4gIC8vIHBlcmZvcm1hbmNlLm5vdygpIG9mIGZpcnN0IHJlY2VpdmVkIGJ5dGVcclxuICB0Zmlyc3Q6IG51bWJlclxyXG4gIC8vIHBlcmZvcm1hbmNlLm5vdygpIG9uIGxvYWQgY29tcGxldGVcclxuICB0bG9hZDogbnVtYmVyXHJcbiAgLy8gcGVyZm9ybWFuY2Uubm93KCkgb24gcGFyc2UgY29tcGxldGlvblxyXG4gIHRwYXJzZWQ6IG51bWJlclxyXG4gIC8vIG51bWJlciBvZiBsb2FkZWQgYnl0ZXNcclxuICBsb2FkZWQ6IG51bWJlclxyXG4gIC8vIHRvdGFsIG51bWJlciBvZiBieXRlc1xyXG4gIHRvdGFsOiBudW1iZXJcclxufVxyXG5cclxudHlwZSBMb2FkZXJPblN1Y2Nlc3MgPCBUIGV4dGVuZHMgTG9hZGVyQ29udGV4dCA+ID0gKFxyXG4gIHJlc3BvbnNlOiBMb2FkZXJSZXNwb25zZSxcclxuICBzdGF0czogTG9hZGVyU3RhdHMsXHJcbiAgY29udGV4dDogVCxcclxuICBuZXR3b3JrRGV0YWlsczogYW55XHJcbikgPT4gdm9pZDtcclxuXHJcbnR5cGUgTG9hZGVyT25Qcm9ncmVzcyA8IFQgZXh0ZW5kcyBMb2FkZXJDb250ZXh0ID4gPSAoXHJcbiAgc3RhdHM6IExvYWRlclN0YXRzLFxyXG4gIGNvbnRleHQ6IFQsXHJcbiAgZGF0YTogc3RyaW5nIHwgQXJyYXlCdWZmZXIsXHJcbiAgbmV0d29ya0RldGFpbHM6IGFueSxcclxuKSA9PiB2b2lkO1xyXG5cclxudHlwZSBMb2FkZXJPbkVycm9yIDwgVCBleHRlbmRzIExvYWRlckNvbnRleHQgPiA9IChcclxuICBlcnJvcjoge1xyXG4gICAgLy8gZXJyb3Igc3RhdHVzIGNvZGVcclxuICAgIGNvZGU6IG51bWJlcixcclxuICAgIC8vIGVycm9yIGRlc2NyaXB0aW9uXHJcbiAgICB0ZXh0OiBzdHJpbmcsXHJcbiAgfSxcclxuICBjb250ZXh0OiBULFxyXG4gIG5ldHdvcmtEZXRhaWxzOiBhbnksXHJcbikgPT4gdm9pZDtcclxuXHJcbnR5cGUgTG9hZGVyT25UaW1lb3V0IDwgVCBleHRlbmRzIExvYWRlckNvbnRleHQgPiA9IChcclxuICBzdGF0czogTG9hZGVyU3RhdHMsXHJcbiAgY29udGV4dDogVCxcclxuKSA9PiB2b2lkO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMb2FkZXJDYWxsYmFja3M8VCBleHRlbmRzIExvYWRlckNvbnRleHQ+e1xyXG4gIG9uU3VjY2VzczogTG9hZGVyT25TdWNjZXNzPFQ+LFxyXG4gIG9uRXJyb3I6IExvYWRlck9uRXJyb3I8VD4sXHJcbiAgb25UaW1lb3V0OiBMb2FkZXJPblRpbWVvdXQ8VD4sXHJcbiAgb25Qcm9ncmVzcz86IExvYWRlck9uUHJvZ3Jlc3M8VD4sXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyPFQgZXh0ZW5kcyBMb2FkZXJDb250ZXh0PiB7XHJcbiAgZGVzdHJveSgpOiB2b2lkXHJcbiAgYWJvcnQoKTogdm9pZFxyXG4gIGxvYWQoXHJcbiAgICBjb250ZXh0OiBMb2FkZXJDb250ZXh0LFxyXG4gICAgY29uZmlnOiBMb2FkZXJDb25maWd1cmF0aW9uLFxyXG4gICAgY2FsbGJhY2tzOiBMb2FkZXJDYWxsYmFja3M8VD4sXHJcbiAgKTogdm9pZFxyXG5cclxuICBjb250ZXh0OiBUXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBgdHlwZWAgcHJvcGVydHkgdmFsdWVzIGZvciB0aGlzIGxvYWRlcnMnIGNvbnRleHQgb2JqZWN0XHJcbiAqIEBlbnVtXHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgZW51bSBQbGF5bGlzdENvbnRleHRUeXBlIHtcclxuICBNQU5JRkVTVCA9ICdtYW5pZmVzdCcsXHJcbiAgTEVWRUwgPSAnbGV2ZWwnLFxyXG4gIEFVRElPX1RSQUNLID0gJ2F1ZGlvVHJhY2snLFxyXG4gIFNVQlRJVExFX1RSQUNLPSAnc3VidGl0bGVUcmFjaydcclxufVxyXG5cclxuLyoqXHJcbiAqIEBlbnVtIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgZW51bSBQbGF5bGlzdExldmVsVHlwZSB7XHJcbiAgTUFJTiA9ICdtYWluJyxcclxuICBBVURJTyA9ICdhdWRpbycsXHJcbiAgU1VCVElUTEUgPSAnc3VidGl0bGUnXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGxheWxpc3RMb2FkZXJDb250ZXh0IGV4dGVuZHMgTG9hZGVyQ29udGV4dCB7XHJcbiAgbG9hZGVyPzogTG9hZGVyPFBsYXlsaXN0TG9hZGVyQ29udGV4dD5cclxuXHJcbiAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZVxyXG4gIC8vIHRoZSBsZXZlbCBpbmRleCB0byBsb2FkXHJcbiAgbGV2ZWw6IG51bWJlciB8IG51bGxcclxuICAvLyBUT0RPOiB3aGF0IGlzIGlkP1xyXG4gIGlkOiBudW1iZXIgfCBudWxsXHJcbiAgLy8gZGVmaW5lcyBpZiB0aGUgbG9hZGVyIGlzIGhhbmRsaW5nIGEgc2lkeCByZXF1ZXN0IGZvciB0aGUgcGxheWxpc3RcclxuICBpc1NpZHhSZXF1ZXN0PzogYm9vbGVhblxyXG4gIC8vIGludGVybmFsIHJlcHJzZW50YXRpb24gb2YgYSBwYXJzZWQgbTN1OCBsZXZlbCBwbGF5bGlzdFxyXG4gIGxldmVsRGV0YWlscz86IExldmVsXHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdHlwZXMvbG9hZGVyLnRzIiwiLyoqXHJcbiAqIE1QNCBkZW11eGVyXHJcbiAqL1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuXHJcbmNvbnN0IFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xyXG5cclxuY2xhc3MgTVA0RGVtdXhlciB7XHJcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyLCByZW11eGVyKSB7XHJcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgICB0aGlzLnJlbXV4ZXIgPSByZW11eGVyO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRUaW1lU3RhbXAgKGluaXRQVFMpIHtcclxuICAgIHRoaXMuaW5pdFBUUyA9IGluaXRQVFM7XHJcbiAgfVxyXG5cclxuICByZXNldEluaXRTZWdtZW50IChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcclxuICAgIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcclxuICAgIGlmIChpbml0U2VnbWVudCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IGluaXREYXRhID0gdGhpcy5pbml0RGF0YSA9IE1QNERlbXV4ZXIucGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCk7XHJcblxyXG4gICAgICAvLyBkZWZhdWx0IGF1ZGlvIGNvZGVjIGlmIG5vdGhpbmcgc3BlY2lmaWVkXHJcbiAgICAgIC8vIFRPRE8gOiBleHRyYWN0IHRoYXQgZnJvbSBpbml0c2VnbWVudFxyXG4gICAgICBpZiAoYXVkaW9Db2RlYyA9PSBudWxsKSB7XHJcbiAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodmlkZW9Db2RlYyA9PSBudWxsKSB7XHJcbiAgICAgICAgdmlkZW9Db2RlYyA9ICdhdmMxLjQyZTAxZSc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHRyYWNrcyA9IHt9O1xyXG4gICAgICBpZiAoaW5pdERhdGEuYXVkaW8gJiYgaW5pdERhdGEudmlkZW8pIHtcclxuICAgICAgICB0cmFja3MuYXVkaW92aWRlbyA9IHsgY29udGFpbmVyOiAndmlkZW8vbXA0JywgY29kZWM6IGF1ZGlvQ29kZWMgKyAnLCcgKyB2aWRlb0NvZGVjLCBpbml0U2VnbWVudDogZHVyYXRpb24gPyBpbml0U2VnbWVudCA6IG51bGwgfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoaW5pdERhdGEuYXVkaW8pIHtcclxuICAgICAgICAgIHRyYWNrcy5hdWRpbyA9IHsgY29udGFpbmVyOiAnYXVkaW8vbXA0JywgY29kZWM6IGF1ZGlvQ29kZWMsIGluaXRTZWdtZW50OiBkdXJhdGlvbiA/IGluaXRTZWdtZW50IDogbnVsbCB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGluaXREYXRhLnZpZGVvKSB7XHJcbiAgICAgICAgICB0cmFja3MudmlkZW8gPSB7IGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsIGNvZGVjOiB2aWRlb0NvZGVjLCBpbml0U2VnbWVudDogZHVyYXRpb24gPyBpbml0U2VnbWVudCA6IG51bGwgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIHsgdHJhY2tzIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGF1ZGlvQ29kZWMpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodmlkZW9Db2RlYykge1xyXG4gICAgICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBwcm9iZSAoZGF0YSkge1xyXG4gICAgLy8gZW5zdXJlIHdlIGZpbmQgYSBtb29mIGJveCBpbiB0aGUgZmlyc3QgMTYga0JcclxuICAgIHJldHVybiBNUDREZW11eGVyLmZpbmRCb3goeyBkYXRhOiBkYXRhLCBzdGFydDogMCwgZW5kOiBNYXRoLm1pbihkYXRhLmxlbmd0aCwgMTYzODQpIH0sIFsnbW9vZiddKS5sZW5ndGggPiAwO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGJpbjJzdHIgKGJ1ZmZlcikge1xyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmZmVyKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyByZWFkVWludDE2IChidWZmZXIsIG9mZnNldCkge1xyXG4gICAgaWYgKGJ1ZmZlci5kYXRhKSB7XHJcbiAgICAgIG9mZnNldCArPSBidWZmZXIuc3RhcnQ7XHJcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHZhbCA9IGJ1ZmZlcltvZmZzZXRdIDw8IDggfFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDFdO1xyXG5cclxuICAgIHJldHVybiB2YWwgPCAwID8gNjU1MzYgKyB2YWwgOiB2YWw7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcmVhZFVpbnQzMiAoYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIGlmIChidWZmZXIuZGF0YSkge1xyXG4gICAgICBvZmZzZXQgKz0gYnVmZmVyLnN0YXJ0O1xyXG4gICAgICBidWZmZXIgPSBidWZmZXIuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB2YWwgPSBidWZmZXJbb2Zmc2V0XSA8PCAyNCB8XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgMTYgfFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDJdIDw8IDggfFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDNdO1xyXG4gICAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHdyaXRlVWludDMyIChidWZmZXIsIG9mZnNldCwgdmFsdWUpIHtcclxuICAgIGlmIChidWZmZXIuZGF0YSkge1xyXG4gICAgICBvZmZzZXQgKz0gYnVmZmVyLnN0YXJ0O1xyXG4gICAgICBidWZmZXIgPSBidWZmZXIuZGF0YTtcclxuICAgIH1cclxuICAgIGJ1ZmZlcltvZmZzZXRdID0gdmFsdWUgPj4gMjQ7XHJcbiAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4gMTYpICYgMHhmZjtcclxuICAgIGJ1ZmZlcltvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+PiA4KSAmIDB4ZmY7XHJcbiAgICBidWZmZXJbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDB4ZmY7XHJcbiAgfVxyXG5cclxuICAvLyBGaW5kIHRoZSBkYXRhIGZvciBhIGJveCBzcGVjaWZpZWQgYnkgaXRzIHBhdGhcclxuICBzdGF0aWMgZmluZEJveCAoZGF0YSwgcGF0aCkge1xyXG4gICAgbGV0IHJlc3VsdHMgPSBbXSxcclxuICAgICAgaSwgc2l6ZSwgdHlwZSwgZW5kLCBzdWJyZXN1bHRzLCBzdGFydCwgZW5kYm94O1xyXG5cclxuICAgIGlmIChkYXRhLmRhdGEpIHtcclxuICAgICAgc3RhcnQgPSBkYXRhLnN0YXJ0O1xyXG4gICAgICBlbmQgPSBkYXRhLmVuZDtcclxuICAgICAgZGF0YSA9IGRhdGEuZGF0YTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgZW5kID0gZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghcGF0aC5sZW5ndGgpIHtcclxuICAgICAgLy8gc2hvcnQtY2lyY3VpdCB0aGUgc2VhcmNoIGZvciBlbXB0eSBwYXRoc1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDspIHtcclxuICAgICAgc2l6ZSA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihkYXRhLCBpKTtcclxuICAgICAgdHlwZSA9IE1QNERlbXV4ZXIuYmluMnN0cihkYXRhLnN1YmFycmF5KGkgKyA0LCBpICsgOCkpO1xyXG4gICAgICBlbmRib3ggPSBzaXplID4gMSA/IGkgKyBzaXplIDogZW5kO1xyXG5cclxuICAgICAgaWYgKHR5cGUgPT09IHBhdGhbMF0pIHtcclxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgcGF0aCBhbmQgd2UndmUgZm91bmQgdGhlIGJveCB3ZSB3ZXJlXHJcbiAgICAgICAgICAvLyBsb29raW5nIGZvclxyXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHsgZGF0YTogZGF0YSwgc3RhcnQ6IGkgKyA4LCBlbmQ6IGVuZGJveCB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCBib3ggYWxvbmcgdGhlIHBhdGhcclxuICAgICAgICAgIHN1YnJlc3VsdHMgPSBNUDREZW11eGVyLmZpbmRCb3goeyBkYXRhOiBkYXRhLCBzdGFydDogaSArIDgsIGVuZDogZW5kYm94IH0sIHBhdGguc2xpY2UoMSkpO1xyXG4gICAgICAgICAgaWYgKHN1YnJlc3VsdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChzdWJyZXN1bHRzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaSA9IGVuZGJveDtcclxuICAgIH1cclxuXHJcbiAgICAvLyB3ZSd2ZSBmaW5pc2hlZCBzZWFyY2hpbmcgYWxsIG9mIGRhdGFcclxuICAgIHJldHVybiByZXN1bHRzO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHBhcnNlU2VnbWVudEluZGV4IChpbml0U2VnbWVudCkge1xyXG4gICAgY29uc3QgbW9vdiA9IE1QNERlbXV4ZXIuZmluZEJveChpbml0U2VnbWVudCwgWydtb292J10pWzBdO1xyXG4gICAgY29uc3QgbW9vdkVuZE9mZnNldCA9IG1vb3YgPyBtb292LmVuZCA6IG51bGw7IC8vIHdlIG5lZWQgdGhpcyBpbiBjYXNlIHdlIG5lZWQgdG8gY2hvcCBvZiBnYXJiYWdlIG9mIHRoZSBlbmQgb2YgY3VycmVudCBkYXRhXHJcblxyXG4gICAgbGV0IGluZGV4ID0gMDtcclxuICAgIGxldCBzaWR4ID0gTVA0RGVtdXhlci5maW5kQm94KGluaXRTZWdtZW50LCBbJ3NpZHgnXSk7XHJcbiAgICBsZXQgcmVmZXJlbmNlcztcclxuXHJcbiAgICBpZiAoIXNpZHggfHwgIXNpZHhbMF0pIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmVmZXJlbmNlcyA9IFtdO1xyXG4gICAgc2lkeCA9IHNpZHhbMF07XHJcblxyXG4gICAgY29uc3QgdmVyc2lvbiA9IHNpZHguZGF0YVswXTtcclxuXHJcbiAgICAvLyBzZXQgaW5pdGlhbCBvZmZzZXQsIHdlIHNraXAgdGhlIHJlZmVyZW5jZSBJRCAobm90IG5lZWRlZClcclxuICAgIGluZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDggOiAxNjtcclxuXHJcbiAgICBjb25zdCB0aW1lc2NhbGUgPSBNUDREZW11eGVyLnJlYWRVaW50MzIoc2lkeCwgaW5kZXgpO1xyXG4gICAgaW5kZXggKz0gNDtcclxuXHJcbiAgICAvLyBUT0RPOiBwYXJzZSBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgYW5kIGZpcnN0T2Zmc2V0XHJcbiAgICAvLyB1c3VhbGx5IHplcm8gaW4gb3VyIGNhc2VcclxuICAgIGxldCBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgPSAwO1xyXG4gICAgbGV0IGZpcnN0T2Zmc2V0ID0gMDtcclxuXHJcbiAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xyXG4gICAgICBpbmRleCArPSA4O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW5kZXggKz0gMTY7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2tpcCByZXNlcnZlZFxyXG4gICAgaW5kZXggKz0gMjtcclxuXHJcbiAgICBsZXQgc3RhcnRCeXRlID0gc2lkeC5lbmQgKyBmaXJzdE9mZnNldDtcclxuXHJcbiAgICBjb25zdCByZWZlcmVuY2VzQ291bnQgPSBNUDREZW11eGVyLnJlYWRVaW50MTYoc2lkeCwgaW5kZXgpO1xyXG4gICAgaW5kZXggKz0gMjtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZmVyZW5jZXNDb3VudDsgaSsrKSB7XHJcbiAgICAgIGxldCByZWZlcmVuY2VJbmRleCA9IGluZGV4O1xyXG5cclxuICAgICAgY29uc3QgcmVmZXJlbmNlSW5mbyA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XHJcbiAgICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XHJcblxyXG4gICAgICBjb25zdCByZWZlcmVuY2VTaXplID0gcmVmZXJlbmNlSW5mbyAmIDB4N0ZGRkZGRkY7XHJcbiAgICAgIGNvbnN0IHJlZmVyZW5jZVR5cGUgPSAocmVmZXJlbmNlSW5mbyAmIDB4ODAwMDAwMDApID4+PiAzMTtcclxuXHJcbiAgICAgIGlmIChyZWZlcmVuY2VUeXBlID09PSAxKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdTSURYIGhhcyBoaWVyYXJjaGljYWwgcmVmZXJlbmNlcyAobm90IHN1cHBvcnRlZCknKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHN1YnNlZ21lbnREdXJhdGlvbiA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XHJcbiAgICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XHJcblxyXG4gICAgICByZWZlcmVuY2VzLnB1c2goe1xyXG4gICAgICAgIHJlZmVyZW5jZVNpemUsXHJcbiAgICAgICAgc3Vic2VnbWVudER1cmF0aW9uLCAvLyB1bnNjYWxlZFxyXG4gICAgICAgIGluZm86IHtcclxuICAgICAgICAgIGR1cmF0aW9uOiBzdWJzZWdtZW50RHVyYXRpb24gLyB0aW1lc2NhbGUsXHJcbiAgICAgICAgICBzdGFydDogc3RhcnRCeXRlLFxyXG4gICAgICAgICAgZW5kOiBzdGFydEJ5dGUgKyByZWZlcmVuY2VTaXplIC0gMVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzdGFydEJ5dGUgKz0gcmVmZXJlbmNlU2l6ZTtcclxuXHJcbiAgICAgIC8vIFNraXBwaW5nIDEgYml0IGZvciB8c3RhcnRzV2l0aFNhcHwsIDMgYml0cyBmb3IgfHNhcFR5cGV8LCBhbmQgMjggYml0c1xyXG4gICAgICAvLyBmb3IgfHNhcERlbHRhfC5cclxuICAgICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcclxuXHJcbiAgICAgIC8vIHNraXAgdG8gbmV4dCByZWZcclxuICAgICAgaW5kZXggPSByZWZlcmVuY2VJbmRleDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUsXHJcbiAgICAgIHRpbWVzY2FsZSxcclxuICAgICAgdmVyc2lvbixcclxuICAgICAgcmVmZXJlbmNlc0NvdW50LFxyXG4gICAgICByZWZlcmVuY2VzLFxyXG4gICAgICBtb292RW5kT2Zmc2V0XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2VzIGFuIE1QNCBpbml0aWFsaXphdGlvbiBzZWdtZW50IGFuZCBleHRyYWN0cyBzdHJlYW0gdHlwZSBhbmRcclxuICAgKiB0aW1lc2NhbGUgdmFsdWVzIGZvciBhbnkgZGVjbGFyZWQgdHJhY2tzLiBUaW1lc2NhbGUgdmFsdWVzIGluZGljYXRlIHRoZVxyXG4gICAqIG51bWJlciBvZiBjbG9jayB0aWNrcyBwZXIgc2Vjb25kIHRvIGFzc3VtZSBmb3IgdGltZS1iYXNlZCB2YWx1ZXNcclxuICAgKiBlbHNld2hlcmUgaW4gdGhlIE1QNC5cclxuICAgKlxyXG4gICAqIFRvIGRldGVybWluZSB0aGUgc3RhcnQgdGltZSBvZiBhbiBNUDQsIHlvdSBuZWVkIHR3byBwaWVjZXMgb2ZcclxuICAgKiBpbmZvcm1hdGlvbjogdGhlIHRpbWVzY2FsZSB1bml0IGFuZCB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGVcclxuICAgKiB0aW1lLiBNdWx0aXBsZSB0aW1lc2NhbGVzIGNhbiBiZSBzcGVjaWZpZWQgd2l0aGluIGFuIE1QNCBidXQgdGhlXHJcbiAgICogYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBpcyBhbHdheXMgZXhwcmVzc2VkIGluIHRoZSB0aW1lc2NhbGUgZnJvbVxyXG4gICAqIHRoZSBtZWRpYSBoZWFkZXIgYm94IGZvciB0aGUgdHJhY2s6XHJcbiAgICogYGBgXHJcbiAgICogbW9vdiA+IHRyYWsgPiBtZGlhID4gbWRoZC50aW1lc2NhbGVcclxuICAgKiBtb292ID4gdHJhayA+IG1kaWEgPiBoZGxyXHJcbiAgICogYGBgXHJcbiAgICogQHBhcmFtIGluaXQge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiB0aGUgaW5pdCBzZWdtZW50XHJcbiAgICogQHJldHVybiB7b2JqZWN0fSBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzIG9yIG51bGwgaWZcclxuICAgKiB0aGUgaW5pdCBzZWdtZW50IGlzIG1hbGZvcm1lZC5cclxuICAgKi9cclxuICBzdGF0aWMgcGFyc2VJbml0U2VnbWVudCAoaW5pdFNlZ21lbnQpIHtcclxuICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgIGxldCB0cmFrcyA9IE1QNERlbXV4ZXIuZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ3RyYWsnXSk7XHJcblxyXG4gICAgdHJha3MuZm9yRWFjaCh0cmFrID0+IHtcclxuICAgICAgY29uc3QgdGtoZCA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ3RraGQnXSlbMF07XHJcbiAgICAgIGlmICh0a2hkKSB7XHJcbiAgICAgICAgbGV0IHZlcnNpb24gPSB0a2hkLmRhdGFbdGtoZC5zdGFydF07XHJcbiAgICAgICAgbGV0IGluZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDEyIDogMjA7XHJcbiAgICAgICAgbGV0IHRyYWNrSWQgPSBNUDREZW11eGVyLnJlYWRVaW50MzIodGtoZCwgaW5kZXgpO1xyXG5cclxuICAgICAgICBjb25zdCBtZGhkID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWssIFsnbWRpYScsICdtZGhkJ10pWzBdO1xyXG4gICAgICAgIGlmIChtZGhkKSB7XHJcbiAgICAgICAgICB2ZXJzaW9uID0gbWRoZC5kYXRhW21kaGQuc3RhcnRdO1xyXG4gICAgICAgICAgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gMTIgOiAyMDtcclxuICAgICAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihtZGhkLCBpbmRleCk7XHJcblxyXG4gICAgICAgICAgY29uc3QgaGRsciA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnaGRsciddKVswXTtcclxuICAgICAgICAgIGlmIChoZGxyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhkbHJUeXBlID0gTVA0RGVtdXhlci5iaW4yc3RyKGhkbHIuZGF0YS5zdWJhcnJheShoZGxyLnN0YXJ0ICsgOCwgaGRsci5zdGFydCArIDEyKSk7XHJcbiAgICAgICAgICAgIGxldCB0eXBlID0geyAnc291bic6ICdhdWRpbycsICd2aWRlJzogJ3ZpZGVvJyB9W2hkbHJUeXBlXTtcclxuICAgICAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgICAvLyBleHRyYWN0IGNvZGVjIGluZm8uIFRPRE8gOiBwYXJzZSBjb2RlYyBkZXRhaWxzIHRvIGJlIGFibGUgdG8gYnVpbGQgTUlNRSB0eXBlXHJcbiAgICAgICAgICAgICAgbGV0IGNvZGVjQm94ID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWssIFsnbWRpYScsICdtaW5mJywgJ3N0YmwnLCAnc3RzZCddKTtcclxuICAgICAgICAgICAgICBpZiAoY29kZWNCb3gubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlY0JveCA9IGNvZGVjQm94WzBdO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvZGVjVHlwZSA9IE1QNERlbXV4ZXIuYmluMnN0cihjb2RlY0JveC5kYXRhLnN1YmFycmF5KGNvZGVjQm94LnN0YXJ0ICsgMTIsIGNvZGVjQm94LnN0YXJ0ICsgMTYpKTtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYE1QNERlbXV4ZXI6JHt0eXBlfToke2NvZGVjVHlwZX0gZm91bmRgKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmVzdWx0W3RyYWNrSWRdID0geyB0aW1lc2NhbGU6IHRpbWVzY2FsZSwgdHlwZTogdHlwZSB9O1xyXG4gICAgICAgICAgICAgIHJlc3VsdFt0eXBlXSA9IHsgdGltZXNjYWxlOiB0aW1lc2NhbGUsIGlkOiB0cmFja0lkIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gKiBEZXRlcm1pbmUgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHN0YXJ0IHRpbWUsIGluIHNlY29uZHMsIGZvciBhbiBNUDRcclxuICogZnJhZ21lbnQuIElmIG11bHRpcGxlIGZyYWdtZW50cyBhcmUgc3BlY2lmaWVkLCB0aGUgZWFybGllc3QgdGltZSBpc1xyXG4gKiByZXR1cm5lZC5cclxuICpcclxuICogVGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgY2FuIGJlIHBhcnNlZCBmcm9tIHRyYWNrIGZyYWdtZW50XHJcbiAqIG1ldGFkYXRhOlxyXG4gKiBgYGBcclxuICogbW9vZiA+IHRyYWYgPiB0ZmR0LmJhc2VNZWRpYURlY29kZVRpbWVcclxuICogYGBgXHJcbiAqIEl0IHJlcXVpcmVzIHRoZSB0aW1lc2NhbGUgdmFsdWUgZnJvbSB0aGUgbWRoZCB0byBpbnRlcnByZXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB0aW1lc2NhbGUge29iamVjdH0gYSBoYXNoIG9mIHRyYWNrIGlkcyB0byB0aW1lc2NhbGUgdmFsdWVzLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lIGZvciB0aGVcclxuICogZnJhZ21lbnQsIGluIHNlY29uZHNcclxuICovXHJcbiAgc3RhdGljIGdldFN0YXJ0RFRTIChpbml0RGF0YSwgZnJhZ21lbnQpIHtcclxuICAgIGxldCB0cmFmcywgYmFzZVRpbWVzLCByZXN1bHQ7XHJcblxyXG4gICAgLy8gd2UgbmVlZCBpbmZvIGZyb20gdHdvIGNoaWxkcmVuZCBvZiBlYWNoIHRyYWNrIGZyYWdtZW50IGJveFxyXG4gICAgdHJhZnMgPSBNUDREZW11eGVyLmZpbmRCb3goZnJhZ21lbnQsIFsnbW9vZicsICd0cmFmJ10pO1xyXG5cclxuICAgIC8vIGRldGVybWluZSB0aGUgc3RhcnQgdGltZXMgZm9yIGVhY2ggdHJhY2tcclxuICAgIGJhc2VUaW1lcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgdHJhZnMubWFwKGZ1bmN0aW9uICh0cmFmKSB7XHJcbiAgICAgIHJldHVybiBNUDREZW11eGVyLmZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLm1hcChmdW5jdGlvbiAodGZoZCkge1xyXG4gICAgICAgIGxldCBpZCwgc2NhbGUsIGJhc2VUaW1lO1xyXG5cclxuICAgICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcclxuICAgICAgICBpZCA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmhkLCA0KTtcclxuICAgICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxyXG4gICAgICAgIHNjYWxlID0gaW5pdERhdGFbaWRdLnRpbWVzY2FsZSB8fCA5MGUzO1xyXG5cclxuICAgICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxyXG4gICAgICAgIGJhc2VUaW1lID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWYsIFsndGZkdCddKS5tYXAoZnVuY3Rpb24gKHRmZHQpIHtcclxuICAgICAgICAgIGxldCB2ZXJzaW9uLCByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgdmVyc2lvbiA9IHRmZHQuZGF0YVt0ZmR0LnN0YXJ0XTtcclxuICAgICAgICAgIHJlc3VsdCA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmR0LCA0KTtcclxuICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCAqPSBNYXRoLnBvdygyLCAzMik7XHJcblxyXG4gICAgICAgICAgICByZXN1bHQgKz0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmZHQsIDgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KVswXTtcclxuICAgICAgICAvLyBjb252ZXJ0IGJhc2UgdGltZSB0byBzZWNvbmRzXHJcbiAgICAgICAgcmV0dXJuIGJhc2VUaW1lIC8gc2NhbGU7XHJcbiAgICAgIH0pO1xyXG4gICAgfSkpO1xyXG5cclxuICAgIC8vIHJldHVybiB0aGUgbWluaW11bVxyXG4gICAgcmVzdWx0ID0gTWF0aC5taW4uYXBwbHkobnVsbCwgYmFzZVRpbWVzKTtcclxuICAgIHJldHVybiBpc0Zpbml0ZShyZXN1bHQpID8gcmVzdWx0IDogMDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBvZmZzZXRTdGFydERUUyAoaW5pdERhdGEsIGZyYWdtZW50LCB0aW1lT2Zmc2V0KSB7XHJcbiAgICBNUDREZW11eGVyLmZpbmRCb3goZnJhZ21lbnQsIFsnbW9vZicsICd0cmFmJ10pLm1hcChmdW5jdGlvbiAodHJhZikge1xyXG4gICAgICByZXR1cm4gTVA0RGVtdXhlci5maW5kQm94KHRyYWYsIFsndGZoZCddKS5tYXAoZnVuY3Rpb24gKHRmaGQpIHtcclxuICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXHJcbiAgICAgICAgbGV0IGlkID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmaGQsIDQpO1xyXG4gICAgICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXHJcbiAgICAgICAgbGV0IHRpbWVzY2FsZSA9IGluaXREYXRhW2lkXS50aW1lc2NhbGUgfHwgOTBlMztcclxuXHJcbiAgICAgICAgLy8gZ2V0IHRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGZyb20gdGhlIHRmZHRcclxuICAgICAgICBNUDREZW11eGVyLmZpbmRCb3godHJhZiwgWyd0ZmR0J10pLm1hcChmdW5jdGlvbiAodGZkdCkge1xyXG4gICAgICAgICAgbGV0IHZlcnNpb24gPSB0ZmR0LmRhdGFbdGZkdC5zdGFydF07XHJcbiAgICAgICAgICBsZXQgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmR0LCA0KTtcclxuICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XHJcbiAgICAgICAgICAgIE1QNERlbXV4ZXIud3JpdGVVaW50MzIodGZkdCwgNCwgYmFzZU1lZGlhRGVjb2RlVGltZSAtIHRpbWVPZmZzZXQgKiB0aW1lc2NhbGUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAqPSBNYXRoLnBvdygyLCAzMik7XHJcbiAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgKz0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmZHQsIDgpO1xyXG4gICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lIC09IHRpbWVPZmZzZXQgKiB0aW1lc2NhbGU7XHJcbiAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLm1heChiYXNlTWVkaWFEZWNvZGVUaW1lLCAwKTtcclxuICAgICAgICAgICAgY29uc3QgdXBwZXIgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgLyAoVUlOVDMyX01BWCArIDEpKTtcclxuICAgICAgICAgICAgY29uc3QgbG93ZXIgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgJSAoVUlOVDMyX01BWCArIDEpKTtcclxuICAgICAgICAgICAgTVA0RGVtdXhlci53cml0ZVVpbnQzMih0ZmR0LCA0LCB1cHBlcik7XHJcbiAgICAgICAgICAgIE1QNERlbXV4ZXIud3JpdGVVaW50MzIodGZkdCwgOCwgbG93ZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxyXG4gIGFwcGVuZCAoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XHJcbiAgICBsZXQgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xyXG4gICAgaWYgKCFpbml0RGF0YSkge1xyXG4gICAgICB0aGlzLnJlc2V0SW5pdFNlZ21lbnQoZGF0YSwgdGhpcy5hdWRpb0NvZGVjLCB0aGlzLnZpZGVvQ29kZWMsIGZhbHNlKTtcclxuICAgICAgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xyXG4gICAgfVxyXG4gICAgbGV0IHN0YXJ0RFRTLCBpbml0UFRTID0gdGhpcy5pbml0UFRTO1xyXG4gICAgaWYgKGluaXRQVFMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBsZXQgc3RhcnREVFMgPSBNUDREZW11eGVyLmdldFN0YXJ0RFRTKGluaXREYXRhLCBkYXRhKTtcclxuICAgICAgdGhpcy5pbml0UFRTID0gaW5pdFBUUyA9IHN0YXJ0RFRTIC0gdGltZU9mZnNldDtcclxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCB7IGluaXRQVFM6IGluaXRQVFMgfSk7XHJcbiAgICB9XHJcbiAgICBNUDREZW11eGVyLm9mZnNldFN0YXJ0RFRTKGluaXREYXRhLCBkYXRhLCBpbml0UFRTKTtcclxuICAgIHN0YXJ0RFRTID0gTVA0RGVtdXhlci5nZXRTdGFydERUUyhpbml0RGF0YSwgZGF0YSk7XHJcbiAgICB0aGlzLnJlbXV4ZXIucmVtdXgoaW5pdERhdGEuYXVkaW8sIGluaXREYXRhLnZpZGVvLCBudWxsLCBudWxsLCBzdGFydERUUywgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkYXRhKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3kgKCkge31cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTVA0RGVtdXhlcjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvZGVtdXgvbXA0ZGVtdXhlci5qcyIsImltcG9ydCB7IGJ1aWxkQWJzb2x1dGVVUkwgfSBmcm9tICd1cmwtdG9vbGtpdCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXZlbEtleSB7XHJcbiAgcHJpdmF0ZSBfdXJpOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgcHVibGljIGJhc2V1cmk6IHN0cmluZztcclxuICBwdWJsaWMgcmVsdXJpOiBzdHJpbmc7XHJcbiAgcHVibGljIG1ldGhvZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgcHVibGljIGtleTogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xyXG4gIHB1YmxpYyBpdjogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xyXG5cclxuICBjb25zdHJ1Y3RvciAoYmFzZVVSSTogc3RyaW5nLCByZWxhdGl2ZVVSSTogc3RyaW5nKSB7XHJcbiAgICB0aGlzLmJhc2V1cmkgPSBiYXNlVVJJO1xyXG4gICAgdGhpcy5yZWx1cmkgPSByZWxhdGl2ZVVSSTtcclxuICB9XHJcblxyXG4gIGdldCB1cmkgKCkge1xyXG4gICAgaWYgKCF0aGlzLl91cmkgJiYgdGhpcy5yZWx1cmkpIHtcclxuICAgICAgdGhpcy5fdXJpID0gYnVpbGRBYnNvbHV0ZVVSTCh0aGlzLmJhc2V1cmksIHRoaXMucmVsdXJpLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fdXJpO1xyXG4gIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9sb2FkZXIvbGV2ZWwta2V5LnRzIiwiLy8gZnJvbSBodHRwOi8vbXA0cmEub3JnL2NvZGVjcy5odG1sXHJcbmNvbnN0IHNhbXBsZUVudHJ5Q29kZXNJU08gPSB7XHJcbiAgYXVkaW86IHtcclxuICAgICdhM2RzJzogdHJ1ZSxcclxuICAgICdhYy0zJzogdHJ1ZSxcclxuICAgICdhYy00JzogdHJ1ZSxcclxuICAgICdhbGFjJzogdHJ1ZSxcclxuICAgICdhbGF3JzogdHJ1ZSxcclxuICAgICdkcmExJzogdHJ1ZSxcclxuICAgICdkdHMrJzogdHJ1ZSxcclxuICAgICdkdHMtJzogdHJ1ZSxcclxuICAgICdkdHNjJzogdHJ1ZSxcclxuICAgICdkdHNlJzogdHJ1ZSxcclxuICAgICdkdHNoJzogdHJ1ZSxcclxuICAgICdlYy0zJzogdHJ1ZSxcclxuICAgICdlbmNhJzogdHJ1ZSxcclxuICAgICdnNzE5JzogdHJ1ZSxcclxuICAgICdnNzI2JzogdHJ1ZSxcclxuICAgICdtNGFlJzogdHJ1ZSxcclxuICAgICdtaGExJzogdHJ1ZSxcclxuICAgICdtaGEyJzogdHJ1ZSxcclxuICAgICdtaG0xJzogdHJ1ZSxcclxuICAgICdtaG0yJzogdHJ1ZSxcclxuICAgICdtbHBhJzogdHJ1ZSxcclxuICAgICdtcDRhJzogdHJ1ZSxcclxuICAgICdyYXcgJzogdHJ1ZSxcclxuICAgICdPcHVzJzogdHJ1ZSxcclxuICAgICdzYW1yJzogdHJ1ZSxcclxuICAgICdzYXdiJzogdHJ1ZSxcclxuICAgICdzYXdwJzogdHJ1ZSxcclxuICAgICdzZXZjJzogdHJ1ZSxcclxuICAgICdzcWNwJzogdHJ1ZSxcclxuICAgICdzc212JzogdHJ1ZSxcclxuICAgICd0d29zJzogdHJ1ZSxcclxuICAgICd1bGF3JzogdHJ1ZVxyXG4gIH0sXHJcbiAgdmlkZW86IHtcclxuICAgICdhdmMxJzogdHJ1ZSxcclxuICAgICdhdmMyJzogdHJ1ZSxcclxuICAgICdhdmMzJzogdHJ1ZSxcclxuICAgICdhdmM0JzogdHJ1ZSxcclxuICAgICdhdmNwJzogdHJ1ZSxcclxuICAgICdkcmFjJzogdHJ1ZSxcclxuICAgICdkdmF2JzogdHJ1ZSxcclxuICAgICdkdmhlJzogdHJ1ZSxcclxuICAgICdlbmN2JzogdHJ1ZSxcclxuICAgICdoZXYxJzogdHJ1ZSxcclxuICAgICdodmMxJzogdHJ1ZSxcclxuICAgICdtanAyJzogdHJ1ZSxcclxuICAgICdtcDR2JzogdHJ1ZSxcclxuICAgICdtdmMxJzogdHJ1ZSxcclxuICAgICdtdmMyJzogdHJ1ZSxcclxuICAgICdtdmMzJzogdHJ1ZSxcclxuICAgICdtdmM0JzogdHJ1ZSxcclxuICAgICdyZXN2JzogdHJ1ZSxcclxuICAgICdydjYwJzogdHJ1ZSxcclxuICAgICdzMjYzJzogdHJ1ZSxcclxuICAgICdzdmMxJzogdHJ1ZSxcclxuICAgICdzdmMyJzogdHJ1ZSxcclxuICAgICd2Yy0xJzogdHJ1ZSxcclxuICAgICd2cDA4JzogdHJ1ZSxcclxuICAgICd2cDA5JzogdHJ1ZVxyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIENvZGVjVHlwZSA9ICdhdWRpbycgfCAndmlkZW8nO1xyXG5cclxuZnVuY3Rpb24gaXNDb2RlY1R5cGUgKGNvZGVjOiBzdHJpbmcsIHR5cGU6IENvZGVjVHlwZSk6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IHR5cGVDb2RlcyA9IHNhbXBsZUVudHJ5Q29kZXNJU09bdHlwZV07XHJcbiAgcmV0dXJuICEhdHlwZUNvZGVzICYmIHR5cGVDb2Rlc1tjb2RlYy5zbGljZSgwLCA0KV0gPT09IHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQ29kZWNTdXBwb3J0ZWRJbk1wNCAoY29kZWM6IHN0cmluZywgdHlwZTogQ29kZWNUeXBlKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChgJHt0eXBlIHx8ICd2aWRlbyd9L21wNDtjb2RlY3M9XCIke2NvZGVjfVwiYCk7XHJcbn1cclxuXHJcbmV4cG9ydCB7IGlzQ29kZWNUeXBlLCBpc0NvZGVjU3VwcG9ydGVkSW5NcDQgfTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMvY29kZWNzLnRzIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XHJcbmltcG9ydCAqIGFzIHdvcmsgZnJvbSAnd2Vid29ya2lmeS13ZWJwYWNrJztcclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRGVtdXhlcklubGluZSBmcm9tICcuLi9kZW11eC9kZW11eGVyLWlubGluZSc7XHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XHJcbmltcG9ydCB7IGdldE1lZGlhU291cmNlIH0gZnJvbSAnLi4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyJztcclxuaW1wb3J0IHsgZ2V0U2VsZlNjb3BlIH0gZnJvbSAnLi4vdXRpbHMvZ2V0LXNlbGYtc2NvcGUnO1xyXG5cclxuaW1wb3J0IHsgT2JzZXJ2ZXIgfSBmcm9tICcuLi9vYnNlcnZlcic7XHJcblxyXG4vLyBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExMjM3MjU5LzU4OTQ5M1xyXG5jb25zdCBnbG9iYWwgPSBnZXRTZWxmU2NvcGUoKTsgLy8gc2FmZWd1YXJkIGZvciBjb2RlIHRoYXQgbWlnaHQgcnVuIGJvdGggb24gd29ya2VyIGFuZCBtYWluIHRocmVhZFxyXG5jb25zdCBNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKCkgfHwgeyBpc1R5cGVTdXBwb3J0ZWQ6ICgpID0+IGZhbHNlIH07XHJcblxyXG5jbGFzcyBEZW11eGVyIHtcclxuICBjb25zdHJ1Y3RvciAoaGxzLCBpZCkge1xyXG4gICAgdGhpcy5obHMgPSBobHM7XHJcbiAgICB0aGlzLmlkID0gaWQ7XHJcblxyXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyID0gbmV3IE9ic2VydmVyKCk7XHJcbiAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xyXG5cclxuICAgIGNvbnN0IGZvcndhcmRNZXNzYWdlID0gKGV2LCBkYXRhKSA9PiB7XHJcbiAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xyXG4gICAgICBkYXRhLmZyYWcgPSB0aGlzLmZyYWc7XHJcbiAgICAgIGRhdGEuaWQgPSB0aGlzLmlkO1xyXG4gICAgICBobHMudHJpZ2dlcihldiwgZGF0YSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXHJcbiAgICBvYnNlcnZlci5vbihFdmVudC5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGZvcndhcmRNZXNzYWdlKTtcclxuICAgIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0VELCBmb3J3YXJkTWVzc2FnZSk7XHJcbiAgICBvYnNlcnZlci5vbihFdmVudC5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XHJcbiAgICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGZvcndhcmRNZXNzYWdlKTtcclxuICAgIG9ic2VydmVyLm9uKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCBmb3J3YXJkTWVzc2FnZSk7XHJcblxyXG4gICAgY29uc3QgdHlwZVN1cHBvcnRlZCA9IHtcclxuICAgICAgbXA0OiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNCcpLFxyXG4gICAgICBtcGVnOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wZWcnKSxcclxuICAgICAgbXAzOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wNDsgY29kZWNzPVwibXAzXCInKVxyXG4gICAgfTtcclxuICAgIC8vIG5hdmlnYXRvci52ZW5kb3IgaXMgbm90IGFsd2F5cyBhdmFpbGFibGUgaW4gV2ViIFdvcmtlclxyXG4gICAgLy8gcmVmZXIgdG8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dvcmtlckdsb2JhbFNjb3BlL25hdmlnYXRvclxyXG4gICAgY29uc3QgdmVuZG9yID0gbmF2aWdhdG9yLnZlbmRvcjtcclxuICAgIGlmIChjb25maWcuZW5hYmxlV29ya2VyICYmICh0eXBlb2YgKFdvcmtlcikgIT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICBsb2dnZXIubG9nKCdkZW11eGluZyBpbiB3ZWJ3b3JrZXInKTtcclxuICAgICAgbGV0IHc7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdyA9IHRoaXMudyA9IHdvcmsocmVxdWlyZS5yZXNvbHZlKCcuLi9kZW11eC9kZW11eGVyLXdvcmtlci5qcycpKTtcclxuICAgICAgICB0aGlzLm9ud21zZyA9IHRoaXMub25Xb3JrZXJNZXNzYWdlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xyXG4gICAgICAgIHcub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTiwgZmF0YWw6IHRydWUsIGV2ZW50OiAnZGVtdXhlcldvcmtlcicsIGVycjogeyBtZXNzYWdlOiBldmVudC5tZXNzYWdlICsgJyAoJyArIGV2ZW50LmZpbGVuYW1lICsgJzonICsgZXZlbnQubGluZW5vICsgJyknIH0gfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB3LnBvc3RNZXNzYWdlKHsgY21kOiAnaW5pdCcsIHR5cGVTdXBwb3J0ZWQ6IHR5cGVTdXBwb3J0ZWQsIHZlbmRvcjogdmVuZG9yLCBpZDogaWQsIGNvbmZpZzogSlNPTi5zdHJpbmdpZnkoY29uZmlnKSB9KTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgbG9nZ2VyLndhcm4oJ0Vycm9yIGluIHdvcmtlcjonLCBlcnIpO1xyXG4gICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3Igd2hpbGUgaW5pdGlhbGl6aW5nIERlbXV4ZXJXb3JrZXIsIGZhbGxiYWNrIG9uIERlbXV4ZXJJbmxpbmUnKTtcclxuICAgICAgICBpZiAodykge1xyXG4gICAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIGRlbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxyXG4gICAgICAgICAgZ2xvYmFsLlVSTC5yZXZva2VPYmplY3RVUkwody5vYmplY3RVUkwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcklubGluZShvYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IpO1xyXG4gICAgICAgIHRoaXMudyA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXJJbmxpbmUob2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlc3Ryb3kgKCkge1xyXG4gICAgbGV0IHcgPSB0aGlzLnc7XHJcbiAgICBpZiAodykge1xyXG4gICAgICB3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XHJcbiAgICAgIHcudGVybWluYXRlKCk7XHJcbiAgICAgIHRoaXMudyA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcclxuICAgICAgaWYgKGRlbXV4ZXIpIHtcclxuICAgICAgICBkZW11eGVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XHJcbiAgICBpZiAob2JzZXJ2ZXIpIHtcclxuICAgICAgb2JzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVzaCAoZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGZyYWcsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKSB7XHJcbiAgICBjb25zdCB3ID0gdGhpcy53O1xyXG4gICAgY29uc3QgdGltZU9mZnNldCA9IE51bWJlci5pc0Zpbml0ZShmcmFnLnN0YXJ0UFRTKSA/IGZyYWcuc3RhcnRQVFMgOiBmcmFnLnN0YXJ0O1xyXG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xyXG4gICAgY29uc3QgbGFzdEZyYWcgPSB0aGlzLmZyYWc7XHJcbiAgICBjb25zdCBkaXNjb250aW51aXR5ID0gIShsYXN0RnJhZyAmJiAoZnJhZy5jYyA9PT0gbGFzdEZyYWcuY2MpKTtcclxuICAgIGNvbnN0IHRyYWNrU3dpdGNoID0gIShsYXN0RnJhZyAmJiAoZnJhZy5sZXZlbCA9PT0gbGFzdEZyYWcubGV2ZWwpKTtcclxuICAgIGNvbnN0IG5leHRTTiA9IGxhc3RGcmFnICYmIChmcmFnLnNuID09PSAobGFzdEZyYWcuc24gKyAxKSk7XHJcbiAgICBjb25zdCBjb250aWd1b3VzID0gIXRyYWNrU3dpdGNoICYmIG5leHRTTjtcclxuICAgIGlmIChkaXNjb250aW51aXR5KSB7XHJcbiAgICAgIGxvZ2dlci5sb2coYCR7dGhpcy5pZH06ZGlzY29udGludWl0eSBkZXRlY3RlZGApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0cmFja1N3aXRjaCkge1xyXG4gICAgICBsb2dnZXIubG9nKGAke3RoaXMuaWR9OnN3aXRjaCBkZXRlY3RlZGApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZnJhZyA9IGZyYWc7XHJcbiAgICBpZiAodykge1xyXG4gICAgICAvLyBwb3N0IGZyYWdtZW50IHBheWxvYWQgYXMgdHJhbnNmZXJhYmxlIG9iamVjdHMgZm9yIEFycmF5QnVmZmVyIChubyBjb3B5KVxyXG4gICAgICB3LnBvc3RNZXNzYWdlKHsgY21kOiAnZGVtdXgnLCBkYXRhLCBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyB9LCBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBbZGF0YV0gOiBbXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcclxuICAgICAgaWYgKGRlbXV4ZXIpIHtcclxuICAgICAgICBkZW11eGVyLnB1c2goZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbldvcmtlck1lc3NhZ2UgKGV2KSB7XHJcbiAgICBsZXQgZGF0YSA9IGV2LmRhdGEsXHJcbiAgICAgIGhscyA9IHRoaXMuaGxzO1xyXG4gICAgc3dpdGNoIChkYXRhLmV2ZW50KSB7XHJcbiAgICBjYXNlICdpbml0JzpcclxuICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIGRlbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxyXG4gICAgICBnbG9iYWwuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLncub2JqZWN0VVJMKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgRlJBR19QQVJTSU5HX0RBVEE6IGRhdGExIGFuZCBkYXRhMiBhcmUgdHJhbnNmZXJhYmxlIG9iamVjdHNcclxuICAgIGNhc2UgRXZlbnQuRlJBR19QQVJTSU5HX0RBVEE6XHJcbiAgICAgIGRhdGEuZGF0YS5kYXRhMSA9IG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YTEpO1xyXG4gICAgICBpZiAoZGF0YS5kYXRhMikge1xyXG4gICAgICAgIGRhdGEuZGF0YS5kYXRhMiA9IG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YTIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwge307XHJcbiAgICAgIGRhdGEuZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xyXG4gICAgICBkYXRhLmRhdGEuaWQgPSB0aGlzLmlkO1xyXG4gICAgICBobHMudHJpZ2dlcihkYXRhLmV2ZW50LCBkYXRhLmRhdGEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IERlbXV4ZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2RlbXV4L2RlbXV4ZXIuanMiLCIvKipcclxuICpcclxuICogaW5saW5lIGRlbXV4ZXI6IHByb2JlIGZyYWdtZW50cyBhbmQgaW5zdGFudGlhdGVcclxuICogYXBwcm9wcmlhdGUgZGVtdXhlciBkZXBlbmRpbmcgb24gY29udGVudCB0eXBlIChUU0RlbXV4ZXIsIEFBQ0RlbXV4ZXIsIC4uLilcclxuICpcclxuICovXHJcblxyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcclxuaW1wb3J0IERlY3J5cHRlciBmcm9tICcuLi9jcnlwdC9kZWNyeXB0ZXInO1xyXG5pbXBvcnQgQUFDRGVtdXhlciBmcm9tICcuLi9kZW11eC9hYWNkZW11eGVyJztcclxuaW1wb3J0IE1QNERlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvbXA0ZGVtdXhlcic7XHJcbmltcG9ydCBUU0RlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvdHNkZW11eGVyJztcclxuaW1wb3J0IE1QM0RlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvbXAzZGVtdXhlcic7XHJcbmltcG9ydCBNUDRSZW11eGVyIGZyb20gJy4uL3JlbXV4L21wNC1yZW11eGVyJztcclxuaW1wb3J0IFBhc3NUaHJvdWdoUmVtdXhlciBmcm9tICcuLi9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyJztcclxuXHJcbmltcG9ydCB7IGdldFNlbGZTY29wZSB9IGZyb20gJy4uL3V0aWxzL2dldC1zZWxmLXNjb3BlJztcclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbi8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTEyMzcyNTkvNTg5NDkzXHJcbmNvbnN0IGdsb2JhbCA9IGdldFNlbGZTY29wZSgpOyAvLyBzYWZlZ3VhcmQgZm9yIGNvZGUgdGhhdCBtaWdodCBydW4gYm90aCBvbiB3b3JrZXIgYW5kIG1haW4gdGhyZWFkXHJcblxyXG5sZXQgbm93O1xyXG4vLyBwZXJmb3JtYW5jZS5ub3coKSBub3QgYXZhaWxhYmxlIG9uIFdlYldvcmtlciwgYXQgbGVhc3Qgb24gU2FmYXJpIERlc2t0b3BcclxudHJ5IHtcclxuICBub3cgPSBnbG9iYWwucGVyZm9ybWFuY2Uubm93LmJpbmQoZ2xvYmFsLnBlcmZvcm1hbmNlKTtcclxufSBjYXRjaCAoZXJyKSB7XHJcbiAgbG9nZ2VyLmRlYnVnKCdVbmFibGUgdG8gdXNlIFBlcmZvcm1hbmNlIEFQSSBvbiB0aGlzIGVudmlyb25tZW50Jyk7XHJcbiAgbm93ID0gZ2xvYmFsLkRhdGUubm93O1xyXG59XHJcblxyXG5jbGFzcyBEZW11eGVySW5saW5lIHtcclxuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yKSB7XHJcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xyXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB0aGlzLnZlbmRvciA9IHZlbmRvcjtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3kgKCkge1xyXG4gICAgbGV0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XHJcbiAgICBpZiAoZGVtdXhlcikge1xyXG4gICAgICBkZW11eGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1c2ggKGRhdGEsIGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKSB7XHJcbiAgICBpZiAoKGRhdGEuYnl0ZUxlbmd0aCA+IDApICYmIChkZWNyeXB0ZGF0YSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEua2V5ICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5tZXRob2QgPT09ICdBRVMtMTI4JykpIHtcclxuICAgICAgbGV0IGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyO1xyXG4gICAgICBpZiAoZGVjcnlwdGVyID09IG51bGwpIHtcclxuICAgICAgICBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIodGhpcy5vYnNlcnZlciwgdGhpcy5jb25maWcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBub3coKTtcclxuICAgICAgZGVjcnlwdGVyLmRlY3J5cHQoZGF0YSwgZGVjcnlwdGRhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdGRhdGEuaXYuYnVmZmVyLCAoZGVjcnlwdGVkRGF0YSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBub3coKTtcclxuICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19ERUNSWVBURUQsIHsgc3RhdHM6IHsgdHN0YXJ0OiBzdGFydFRpbWUsIHRkZWNyeXB0OiBlbmRUaW1lIH0gfSk7XHJcbiAgICAgICAgdGhpcy5wdXNoRGVjcnlwdGVkKG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpLCBkZWNyeXB0ZGF0YSwgbmV3IFVpbnQ4QXJyYXkoaW5pdFNlZ21lbnQpLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucHVzaERlY3J5cHRlZChuZXcgVWludDhBcnJheShkYXRhKSwgZGVjcnlwdGRhdGEsIG5ldyBVaW50OEFycmF5KGluaXRTZWdtZW50KSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1c2hEZWNyeXB0ZWQgKGRhdGEsIGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKSB7XHJcbiAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcclxuICAgIGlmICghZGVtdXhlciB8fFxyXG4gICAgICAvLyBpbiBjYXNlIG9mIGNvbnRpbnVpdHkgY2hhbmdlLCBvciB0cmFjayBzd2l0Y2hcclxuICAgICAgLy8gd2UgbWlnaHQgc3dpdGNoIGZyb20gY29udGVudCB0eXBlIChBQUMgY29udGFpbmVyIHRvIFRTIGNvbnRhaW5lciwgb3IgVFMgdG8gZm1wNCBmb3IgZXhhbXBsZSlcclxuICAgICAgLy8gc28gbGV0J3MgY2hlY2sgdGhhdCBjdXJyZW50IGRlbXV4ZXIgaXMgc3RpbGwgdmFsaWRcclxuICAgICAgKChkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoKSAmJiAhdGhpcy5wcm9iZShkYXRhKSkpIHtcclxuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xyXG4gICAgICBjb25zdCB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkO1xyXG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcclxuICAgICAgLy8gcHJvYmluZyBvcmRlciBpcyBUUy9NUDQvQUFDL01QM1xyXG4gICAgICBjb25zdCBtdXhDb25maWcgPSBbXHJcbiAgICAgICAgeyBkZW11eDogVFNEZW11eGVyLCByZW11eDogTVA0UmVtdXhlciB9LFxyXG4gICAgICAgIHsgZGVtdXg6IE1QNERlbXV4ZXIsIHJlbXV4OiBQYXNzVGhyb3VnaFJlbXV4ZXIgfSxcclxuICAgICAgICB7IGRlbXV4OiBBQUNEZW11eGVyLCByZW11eDogTVA0UmVtdXhlciB9LFxyXG4gICAgICAgIHsgZGVtdXg6IE1QM0RlbXV4ZXIsIHJlbXV4OiBNUDRSZW11eGVyIH1cclxuICAgICAgXTtcclxuXHJcbiAgICAgIC8vIHByb2JlIGZvciBjb250ZW50IHR5cGVcclxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG11eENvbmZpZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG11eCA9IG11eENvbmZpZ1tpXTtcclxuICAgICAgICBjb25zdCBwcm9iZSA9IG11eC5kZW11eC5wcm9iZTtcclxuICAgICAgICBpZiAocHJvYmUoZGF0YSkpIHtcclxuICAgICAgICAgIGNvbnN0IHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXIgPSBuZXcgbXV4LnJlbXV4KG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIHRoaXMudmVuZG9yKTtcclxuICAgICAgICAgIGRlbXV4ZXIgPSBuZXcgbXV4LmRlbXV4KG9ic2VydmVyLCByZW11eGVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpO1xyXG4gICAgICAgICAgdGhpcy5wcm9iZSA9IHByb2JlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghZGVtdXhlcikge1xyXG4gICAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IHRydWUsIHJlYXNvbjogJ25vIGRlbXV4IG1hdGNoaW5nIHdpdGggY29udGVudCBmb3VuZCcgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZGVtdXhlciA9IGRlbXV4ZXI7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZW11eGVyID0gdGhpcy5yZW11eGVyO1xyXG5cclxuICAgIGlmIChkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoKSB7XHJcbiAgICAgIGRlbXV4ZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pO1xyXG4gICAgICByZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoKTtcclxuICAgIH1cclxuICAgIGlmIChkaXNjb250aW51aXR5KSB7XHJcbiAgICAgIGRlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFMpO1xyXG4gICAgICByZW11eGVyLnJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UFRTKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZGVtdXhlci5zZXREZWNyeXB0RGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBkZW11eGVyLnNldERlY3J5cHREYXRhKGRlY3J5cHRkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBkZW11eGVyLmFwcGVuZChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGVtdXhlcklubGluZTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvZGVtdXgvZGVtdXhlci1pbmxpbmUuanMiLCIvKipcclxuICogQURUUyBwYXJzZXIgaGVscGVyXHJcbiAqIEBsaW5rIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXHJcbiAqL1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5cclxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcblxyXG5pbXBvcnQgeyBnZXRTZWxmU2NvcGUgfSBmcm9tICcuLi91dGlscy9nZXQtc2VsZi1zY29wZSc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXVkaW9Db25maWcgKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcclxuICBsZXQgYWR0c09iamVjdFR5cGUsIC8vIDppbnRcclxuICAgIGFkdHNTYW1wbGVpbmdJbmRleCwgLy8gOmludFxyXG4gICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4LCAvLyA6aW50XHJcbiAgICBhZHRzQ2hhbmVsQ29uZmlnLCAvLyA6aW50XHJcbiAgICBjb25maWcsXHJcbiAgICB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXHJcbiAgICBtYW5pZmVzdENvZGVjID0gYXVkaW9Db2RlYyxcclxuICAgIGFkdHNTYW1wbGVpbmdSYXRlcyA9IFtcclxuICAgICAgOTYwMDAsIDg4MjAwLFxyXG4gICAgICA2NDAwMCwgNDgwMDAsXHJcbiAgICAgIDQ0MTAwLCAzMjAwMCxcclxuICAgICAgMjQwMDAsIDIyMDUwLFxyXG4gICAgICAxNjAwMCwgMTIwMDAsXHJcbiAgICAgIDExMDI1LCA4MDAwLFxyXG4gICAgICA3MzUwXTtcclxuICAvLyBieXRlIDJcclxuICBhZHRzT2JqZWN0VHlwZSA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4QzApID4+PiA2KSArIDE7XHJcbiAgYWR0c1NhbXBsZWluZ0luZGV4ID0gKChkYXRhW29mZnNldCArIDJdICYgMHgzQykgPj4+IDIpO1xyXG4gIGlmIChhZHRzU2FtcGxlaW5nSW5kZXggPiBhZHRzU2FtcGxlaW5nUmF0ZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiBgaW52YWxpZCBBRFRTIHNhbXBsaW5nIGluZGV4OiR7YWR0c1NhbXBsZWluZ0luZGV4fWAgfSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGFkdHNDaGFuZWxDb25maWcgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDAxKSA8PCAyKTtcclxuICAvLyBieXRlIDNcclxuICBhZHRzQ2hhbmVsQ29uZmlnIHw9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4QzApID4+PiA2KTtcclxuICBsb2dnZXIubG9nKGBtYW5pZmVzdCBjb2RlYzoke2F1ZGlvQ29kZWN9LEFEVFMgZGF0YTp0eXBlOiR7YWR0c09iamVjdFR5cGV9LHNhbXBsZWluZ0luZGV4OiR7YWR0c1NhbXBsZWluZ0luZGV4fVske2FkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxlaW5nSW5kZXhdfUh6XSxjaGFubmVsQ29uZmlnOiR7YWR0c0NoYW5lbENvbmZpZ31gKTtcclxuICAvLyBmaXJlZm94OiBmcmVxIGxlc3MgdGhhbiAyNGtIeiA9IEFBQyBTQlIgKEhFLUFBQylcclxuICBpZiAoL2ZpcmVmb3gvaS50ZXN0KHVzZXJBZ2VudCkpIHtcclxuICAgIGlmIChhZHRzU2FtcGxlaW5nSW5kZXggPj0gNikge1xyXG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XHJcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSg0KTtcclxuICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXHJcbiAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXHJcbiAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYmVsb3csIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXHJcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XHJcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcclxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xyXG4gICAgfVxyXG4gICAgLy8gQW5kcm9pZCA6IGFsd2F5cyB1c2UgQUFDXHJcbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSkge1xyXG4gICAgYWR0c09iamVjdFR5cGUgPSAyO1xyXG4gICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xyXG4gICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvKiAgZm9yIG90aGVyIGJyb3dzZXJzIChDaHJvbWUvVml2YWxkaS9PcGVyYSAuLi4pXHJcbiAgICAgICAgYWx3YXlzIGZvcmNlIGF1ZGlvIHR5cGUgdG8gYmUgSEUtQUFDIFNCUiwgYXMgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhdWRpbyBjb2RlYyBzd2l0Y2ggcHJvcGVybHkgKGxpa2UgQ2hyb21lIC4uLilcclxuICAgICovXHJcbiAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XHJcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XHJcbiAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgSEUtQUFDIG9yIEhFLUFBQ3YyKSBPUiAobWFuaWZlc3QgY29kZWMgbm90IHNwZWNpZmllZCBBTkQgZnJlcXVlbmN5IGxlc3MgdGhhbiAyNGtIeilcclxuICAgIGlmICgoYXVkaW9Db2RlYyAmJiAoKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSkgfHxcclxuICAgICAgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSkpIHx8XHJcbiAgICAgICghYXVkaW9Db2RlYyAmJiBhZHRzU2FtcGxlaW5nSW5kZXggPj0gNikpIHtcclxuICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXHJcbiAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXHJcbiAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYmVsb3csIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXHJcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgQUFDKSBBTkQgKGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHogQU5EIG5iIGNoYW5uZWwgaXMgMSkgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgYW5kIG1vbm8gYXVkaW8pXHJcbiAgICAgIC8vIENocm9tZSBmYWlscyB0byBwbGF5IGJhY2sgd2l0aCBsb3cgZnJlcXVlbmN5IEFBQyBMQyBtb25vIHdoZW4gaW5pdGlhbGl6ZWQgd2l0aCBIRS1BQUMuICBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2l0aCBzdGVyZW8uXHJcbiAgICAgIGlmIChhdWRpb0NvZGVjICYmIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xICYmICgoYWR0c1NhbXBsZWluZ0luZGV4ID49IDYgJiYgYWR0c0NoYW5lbENvbmZpZyA9PT0gMSkgfHxcclxuICAgICAgICAgICAgL3ZpdmFsZGkvaS50ZXN0KHVzZXJBZ2VudCkpIHx8XHJcbiAgICAgICAgKCFhdWRpb0NvZGVjICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpKSB7XHJcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xyXG4gICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcclxuICAgICAgfVxyXG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXg7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qIHJlZmVyIHRvIGh0dHA6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPU1QRUctNF9BdWRpbyNBdWRpb19TcGVjaWZpY19Db25maWdcclxuICAgICAgSVNPIDE0NDk2LTMgKEFBQykucGRmIC0gVGFibGUgMS4xMyDigJQgU3ludGF4IG9mIEF1ZGlvU3BlY2lmaWNDb25maWcoKVxyXG4gICAgQXVkaW8gUHJvZmlsZSAvIEF1ZGlvIE9iamVjdCBUeXBlXHJcbiAgICAwOiBOdWxsXHJcbiAgICAxOiBBQUMgTWFpblxyXG4gICAgMjogQUFDIExDIChMb3cgQ29tcGxleGl0eSlcclxuICAgIDM6IEFBQyBTU1IgKFNjYWxhYmxlIFNhbXBsZSBSYXRlKVxyXG4gICAgNDogQUFDIExUUCAoTG9uZyBUZXJtIFByZWRpY3Rpb24pXHJcbiAgICA1OiBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pXHJcbiAgICA2OiBBQUMgU2NhbGFibGVcclxuICAgc2FtcGxpbmcgZnJlcVxyXG4gICAgMDogOTYwMDAgSHpcclxuICAgIDE6IDg4MjAwIEh6XHJcbiAgICAyOiA2NDAwMCBIelxyXG4gICAgMzogNDgwMDAgSHpcclxuICAgIDQ6IDQ0MTAwIEh6XHJcbiAgICA1OiAzMjAwMCBIelxyXG4gICAgNjogMjQwMDAgSHpcclxuICAgIDc6IDIyMDUwIEh6XHJcbiAgICA4OiAxNjAwMCBIelxyXG4gICAgOTogMTIwMDAgSHpcclxuICAgIDEwOiAxMTAyNSBIelxyXG4gICAgMTE6IDgwMDAgSHpcclxuICAgIDEyOiA3MzUwIEh6XHJcbiAgICAxMzogUmVzZXJ2ZWRcclxuICAgIDE0OiBSZXNlcnZlZFxyXG4gICAgMTU6IGZyZXF1ZW5jeSBpcyB3cml0dGVuIGV4cGxpY3RseVxyXG4gICAgQ2hhbm5lbCBDb25maWd1cmF0aW9uc1xyXG4gICAgVGhlc2UgYXJlIHRoZSBjaGFubmVsIGNvbmZpZ3VyYXRpb25zOlxyXG4gICAgMDogRGVmaW5lZCBpbiBBT1QgU3BlY2lmYyBDb25maWdcclxuICAgIDE6IDEgY2hhbm5lbDogZnJvbnQtY2VudGVyXHJcbiAgICAyOiAyIGNoYW5uZWxzOiBmcm9udC1sZWZ0LCBmcm9udC1yaWdodFxyXG4gICovXHJcbiAgLy8gYXVkaW9PYmplY3RUeXBlID0gcHJvZmlsZSA9PiBwcm9maWxlLCB0aGUgTVBFRy00IEF1ZGlvIE9iamVjdCBUeXBlIG1pbnVzIDFcclxuICBjb25maWdbMF0gPSBhZHRzT2JqZWN0VHlwZSA8PCAzO1xyXG4gIC8vIHNhbXBsaW5nRnJlcXVlbmN5SW5kZXhcclxuICBjb25maWdbMF0gfD0gKGFkdHNTYW1wbGVpbmdJbmRleCAmIDB4MEUpID4+IDE7XHJcbiAgY29uZmlnWzFdIHw9IChhZHRzU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3O1xyXG4gIC8vIGNoYW5uZWxDb25maWd1cmF0aW9uXHJcbiAgY29uZmlnWzFdIHw9IGFkdHNDaGFuZWxDb25maWcgPDwgMztcclxuICBpZiAoYWR0c09iamVjdFR5cGUgPT09IDUpIHtcclxuICAgIC8vIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleFxyXG4gICAgY29uZmlnWzFdIHw9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDBFKSA+PiAxO1xyXG4gICAgY29uZmlnWzJdID0gKGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCAmIDB4MDEpIDw8IDc7XHJcbiAgICAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XHJcbiAgICAvLyAgICBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLmdpdC8rL21hc3Rlci9tZWRpYS9mb3JtYXRzL21wNC9hYWMuY2NcclxuICAgIGNvbmZpZ1syXSB8PSAyIDw8IDI7XHJcbiAgICBjb25maWdbM10gPSAwO1xyXG4gIH1cclxuICByZXR1cm4geyBjb25maWc6IGNvbmZpZywgc2FtcGxlcmF0ZTogYWR0c1NhbXBsZWluZ1JhdGVzW2FkdHNTYW1wbGVpbmdJbmRleF0sIGNoYW5uZWxDb3VudDogYWR0c0NoYW5lbENvbmZpZywgY29kZWM6ICgnbXA0YS40MC4nICsgYWR0c09iamVjdFR5cGUpLCBtYW5pZmVzdENvZGVjOiBtYW5pZmVzdENvZGVjIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4gKGRhdGEsIG9mZnNldCkge1xyXG4gIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGY2KSA9PT0gMHhmMDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEhlYWRlckxlbmd0aCAoZGF0YSwgb2Zmc2V0KSB7XHJcbiAgcmV0dXJuIChkYXRhW29mZnNldCArIDFdICYgMHgwMSA/IDcgOiA5KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bGxGcmFtZUxlbmd0aCAoZGF0YSwgb2Zmc2V0KSB7XHJcbiAgcmV0dXJuICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MDMpIDw8IDExKSB8XHJcbiAgICAoZGF0YVtvZmZzZXQgKyA0XSA8PCAzKSB8XHJcbiAgICAoKGRhdGFbb2Zmc2V0ICsgNV0gJiAweEUwKSA+Pj4gNSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0hlYWRlciAoZGF0YSwgb2Zmc2V0KSB7XHJcbiAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXHJcbiAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXHJcbiAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXHJcbiAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwcm9iZSAoZGF0YSwgb2Zmc2V0KSB7XHJcbiAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IEFEVFMgZnJhbWUgZm9sbG93cyBsYXN0IEFEVFMgZnJhbWVcclxuICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXHJcbiAgaWYgKGlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcclxuICAgIC8vIEFEVFMgaGVhZGVyIExlbmd0aFxyXG4gICAgbGV0IGhlYWRlckxlbmd0aCA9IGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xyXG4gICAgLy8gQURUUyBmcmFtZSBMZW5ndGhcclxuICAgIGxldCBmcmFtZUxlbmd0aCA9IGhlYWRlckxlbmd0aDtcclxuICAgIGlmIChvZmZzZXQgKyA1IDwgZGF0YS5sZW5ndGgpIHtcclxuICAgICAgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XHJcbiAgICBpZiAobmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCAobmV3T2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBuZXdPZmZzZXQpKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaW5pdFRyYWNrQ29uZmlnICh0cmFjaywgb2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYykge1xyXG4gIGlmICghdHJhY2suc2FtcGxlcmF0ZSkge1xyXG4gICAgbGV0IGNvbmZpZyA9IGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpO1xyXG4gICAgdHJhY2suY29uZmlnID0gY29uZmlnLmNvbmZpZztcclxuICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBjb25maWcuc2FtcGxlcmF0ZTtcclxuICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XHJcbiAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlYztcclxuICAgIHRyYWNrLm1hbmlmZXN0Q29kZWMgPSBjb25maWcubWFuaWZlc3RDb2RlYztcclxuICAgIGxvZ2dlci5sb2coYHBhcnNlZCBjb2RlYzoke3RyYWNrLmNvZGVjfSxyYXRlOiR7Y29uZmlnLnNhbXBsZXJhdGV9LG5iIGNoYW5uZWw6JHtjb25maWcuY2hhbm5lbENvdW50fWApO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYW1lRHVyYXRpb24gKHNhbXBsZXJhdGUpIHtcclxuICByZXR1cm4gMTAyNCAqIDkwMDAwIC8gc2FtcGxlcmF0ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRnJhbWVIZWFkZXIgKGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4LCBmcmFtZUR1cmF0aW9uKSB7XHJcbiAgbGV0IGhlYWRlckxlbmd0aCwgZnJhbWVMZW5ndGgsIHN0YW1wO1xyXG4gIGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcclxuXHJcbiAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIEFEVFMgaGVhZGVyXHJcbiAgaGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCk7XHJcbiAgLy8gcmV0cmlldmUgZnJhbWUgc2l6ZVxyXG4gIGZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCk7XHJcbiAgZnJhbWVMZW5ndGggLT0gaGVhZGVyTGVuZ3RoO1xyXG5cclxuICBpZiAoKGZyYW1lTGVuZ3RoID4gMCkgJiYgKChvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCkgPD0gbGVuZ3RoKSkge1xyXG4gICAgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcclxuICAgIC8vIGxvZ2dlci5sb2coYEFBQyBmcmFtZSwgb2Zmc2V0L2xlbmd0aC90b3RhbC9wdHM6JHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2ZyYW1lTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH0vJHsoc3RhbXAvOTApLnRvRml4ZWQoMCl9YCk7XHJcbiAgICByZXR1cm4geyBoZWFkZXJMZW5ndGgsIGZyYW1lTGVuZ3RoLCBzdGFtcCB9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZEZyYW1lICh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpIHtcclxuICBsZXQgZnJhbWVEdXJhdGlvbiA9IGdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSk7XHJcbiAgbGV0IGhlYWRlciA9IHBhcnNlRnJhbWVIZWFkZXIoZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgsIGZyYW1lRHVyYXRpb24pO1xyXG4gIGlmIChoZWFkZXIpIHtcclxuICAgIGxldCBzdGFtcCA9IGhlYWRlci5zdGFtcDtcclxuICAgIGxldCBoZWFkZXJMZW5ndGggPSBoZWFkZXIuaGVhZGVyTGVuZ3RoO1xyXG4gICAgbGV0IGZyYW1lTGVuZ3RoID0gaGVhZGVyLmZyYW1lTGVuZ3RoO1xyXG5cclxuICAgIC8vIGxvZ2dlci5sb2coYEFBQyBmcmFtZSwgb2Zmc2V0L2xlbmd0aC90b3RhbC9wdHM6JHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2ZyYW1lTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH0vJHsoc3RhbXAvOTApLnRvRml4ZWQoMCl9YCk7XHJcbiAgICBsZXQgYWFjU2FtcGxlID0ge1xyXG4gICAgICB1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpLFxyXG4gICAgICBwdHM6IHN0YW1wLFxyXG4gICAgICBkdHM6IHN0YW1wXHJcbiAgICB9O1xyXG5cclxuICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNTYW1wbGUpO1xyXG4gICAgcmV0dXJuIHsgc2FtcGxlOiBhYWNTYW1wbGUsIGxlbmd0aDogZnJhbWVMZW5ndGggKyBoZWFkZXJMZW5ndGggfTtcclxuICB9XHJcblxyXG4gIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvZGVtdXgvYWR0cy5qcyIsIi8qKlxyXG4gKiAgTVBFRyBwYXJzZXIgaGVscGVyXHJcbiAqL1xyXG5cclxuY29uc3QgTXBlZ0F1ZGlvID0ge1xyXG5cclxuICBCaXRyYXRlc01hcDogW1xyXG4gICAgMzIsIDY0LCA5NiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDI4OCwgMzIwLCAzNTIsIDM4NCwgNDE2LCA0NDgsXHJcbiAgICAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDM4NCxcclxuICAgIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsXHJcbiAgICAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjAsIDE3NiwgMTkyLCAyMjQsIDI1NixcclxuICAgIDgsIDE2LCAyNCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MF0sXHJcblxyXG4gIFNhbXBsaW5nUmF0ZU1hcDogWzQ0MTAwLCA0ODAwMCwgMzIwMDAsIDIyMDUwLCAyNDAwMCwgMTYwMDAsIDExMDI1LCAxMjAwMCwgODAwMF0sXHJcblxyXG4gIFNhbXBsZXNDb2VmZmljaWVudHM6IFtcclxuICAgIC8vIE1QRUcgMi41XHJcbiAgICBbXHJcbiAgICAgIDAsIC8vIFJlc2VydmVkXHJcbiAgICAgIDcyLCAvLyBMYXllcjNcclxuICAgICAgMTQ0LCAvLyBMYXllcjJcclxuICAgICAgMTIgLy8gTGF5ZXIxXHJcbiAgICBdLFxyXG4gICAgLy8gUmVzZXJ2ZWRcclxuICAgIFtcclxuICAgICAgMCwgLy8gUmVzZXJ2ZWRcclxuICAgICAgMCwgLy8gTGF5ZXIzXHJcbiAgICAgIDAsIC8vIExheWVyMlxyXG4gICAgICAwIC8vIExheWVyMVxyXG4gICAgXSxcclxuICAgIC8vIE1QRUcgMlxyXG4gICAgW1xyXG4gICAgICAwLCAvLyBSZXNlcnZlZFxyXG4gICAgICA3MiwgLy8gTGF5ZXIzXHJcbiAgICAgIDE0NCwgLy8gTGF5ZXIyXHJcbiAgICAgIDEyIC8vIExheWVyMVxyXG4gICAgXSxcclxuICAgIC8vIE1QRUcgMVxyXG4gICAgW1xyXG4gICAgICAwLCAvLyBSZXNlcnZlZFxyXG4gICAgICAxNDQsIC8vIExheWVyM1xyXG4gICAgICAxNDQsIC8vIExheWVyMlxyXG4gICAgICAxMiAvLyBMYXllcjFcclxuICAgIF1cclxuICBdLFxyXG5cclxuICBCeXRlc0luU2xvdDogW1xyXG4gICAgMCwgLy8gUmVzZXJ2ZWRcclxuICAgIDEsIC8vIExheWVyM1xyXG4gICAgMSwgLy8gTGF5ZXIyXHJcbiAgICA0IC8vIExheWVyMVxyXG4gIF0sXHJcblxyXG4gIGFwcGVuZEZyYW1lOiBmdW5jdGlvbiAodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KSB7XHJcbiAgICAvLyBVc2luZyBodHRwOi8vd3d3LmRhdGF2b3lhZ2UuY29tL21wZ3NjcmlwdC9tcGVnaGRyLmh0bSBhcyBhIHJlZmVyZW5jZVxyXG4gICAgaWYgKG9mZnNldCArIDI0ID4gZGF0YS5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgaGVhZGVyID0gdGhpcy5wYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xyXG4gICAgaWYgKGhlYWRlciAmJiBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcclxuICAgICAgbGV0IGZyYW1lRHVyYXRpb24gPSBoZWFkZXIuc2FtcGxlc1BlckZyYW1lICogOTAwMDAgLyBoZWFkZXIuc2FtcGxlUmF0ZTtcclxuICAgICAgbGV0IHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XHJcbiAgICAgIGxldCBzYW1wbGUgPSB7IHVuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGgpLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wIH07XHJcblxyXG4gICAgICB0cmFjay5jb25maWcgPSBbXTtcclxuICAgICAgdHJhY2suY2hhbm5lbENvdW50ID0gaGVhZGVyLmNoYW5uZWxDb3VudDtcclxuICAgICAgdHJhY2suc2FtcGxlcmF0ZSA9IGhlYWRlci5zYW1wbGVSYXRlO1xyXG4gICAgICB0cmFjay5zYW1wbGVzLnB1c2goc2FtcGxlKTtcclxuXHJcbiAgICAgIHJldHVybiB7IHNhbXBsZSwgbGVuZ3RoOiBoZWFkZXIuZnJhbWVMZW5ndGggfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH0sXHJcblxyXG4gIHBhcnNlSGVhZGVyOiBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XHJcbiAgICBsZXQgaGVhZGVyQiA9IChkYXRhW29mZnNldCArIDFdID4+IDMpICYgMztcclxuICAgIGxldCBoZWFkZXJDID0gKGRhdGFbb2Zmc2V0ICsgMV0gPj4gMSkgJiAzO1xyXG4gICAgbGV0IGhlYWRlckUgPSAoZGF0YVtvZmZzZXQgKyAyXSA+PiA0KSAmIDE1O1xyXG4gICAgbGV0IGhlYWRlckYgPSAoZGF0YVtvZmZzZXQgKyAyXSA+PiAyKSAmIDM7XHJcbiAgICBsZXQgaGVhZGVyRyA9IChkYXRhW29mZnNldCArIDJdID4+IDEpICYgMTtcclxuICAgIGlmIChoZWFkZXJCICE9PSAxICYmIGhlYWRlckUgIT09IDAgJiYgaGVhZGVyRSAhPT0gMTUgJiYgaGVhZGVyRiAhPT0gMykge1xyXG4gICAgICBsZXQgY29sdW1uSW5CaXRyYXRlcyA9IGhlYWRlckIgPT09IDMgPyAoMyAtIGhlYWRlckMpIDogKGhlYWRlckMgPT09IDMgPyAzIDogNCk7XHJcbiAgICAgIGxldCBiaXRSYXRlID0gTXBlZ0F1ZGlvLkJpdHJhdGVzTWFwW2NvbHVtbkluQml0cmF0ZXMgKiAxNCArIGhlYWRlckUgLSAxXSAqIDEwMDA7XHJcbiAgICAgIGxldCBjb2x1bW5JblNhbXBsZVJhdGVzID0gaGVhZGVyQiA9PT0gMyA/IDAgOiBoZWFkZXJCID09PSAyID8gMSA6IDI7XHJcbiAgICAgIGxldCBzYW1wbGVSYXRlID0gTXBlZ0F1ZGlvLlNhbXBsaW5nUmF0ZU1hcFtjb2x1bW5JblNhbXBsZVJhdGVzICogMyArIGhlYWRlckZdO1xyXG4gICAgICBsZXQgY2hhbm5lbENvdW50ID0gZGF0YVtvZmZzZXQgKyAzXSA+PiA2ID09PSAzID8gMSA6IDI7IC8vIElmIGJpdHMgb2YgY2hhbm5lbCBtb2RlIGFyZSBgMTFgIHRoZW4gaXQgaXMgYSBzaW5nbGUgY2hhbm5lbCAoTW9ubylcclxuICAgICAgbGV0IHNhbXBsZUNvZWZmaWNpZW50ID0gTXBlZ0F1ZGlvLlNhbXBsZXNDb2VmZmljaWVudHNbaGVhZGVyQl1baGVhZGVyQ107XHJcbiAgICAgIGxldCBieXRlc0luU2xvdCA9IE1wZWdBdWRpby5CeXRlc0luU2xvdFtoZWFkZXJDXTtcclxuICAgICAgbGV0IHNhbXBsZXNQZXJGcmFtZSA9IHNhbXBsZUNvZWZmaWNpZW50ICogOCAqIGJ5dGVzSW5TbG90O1xyXG4gICAgICBsZXQgZnJhbWVMZW5ndGggPSBwYXJzZUludChzYW1wbGVDb2VmZmljaWVudCAqIGJpdFJhdGUgLyBzYW1wbGVSYXRlICsgaGVhZGVyRywgMTApICogYnl0ZXNJblNsb3Q7XHJcblxyXG4gICAgICByZXR1cm4geyBzYW1wbGVSYXRlLCBjaGFubmVsQ291bnQsIGZyYW1lTGVuZ3RoLCBzYW1wbGVzUGVyRnJhbWUgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH0sXHJcblxyXG4gIGlzSGVhZGVyUGF0dGVybjogZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xyXG4gICAgcmV0dXJuIGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZTApID09PSAweGUwICYmIChkYXRhW29mZnNldCArIDFdICYgMHgwNikgIT09IDB4MDA7XHJcbiAgfSxcclxuXHJcbiAgaXNIZWFkZXI6IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcclxuICAgIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXHJcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxyXG4gICAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcclxuICAgIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgdGhpcy5pc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuXHJcbiAgcHJvYmU6IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcclxuICAgIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBNUEVHIGZyYW1lIGZvbGxvd3MgbGFzdCBNUEVHIGZyYW1lXHJcbiAgICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXHJcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIHRoaXMuaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkpIHtcclxuICAgICAgLy8gTVBFRyBoZWFkZXIgTGVuZ3RoXHJcbiAgICAgIGxldCBoZWFkZXJMZW5ndGggPSA0O1xyXG4gICAgICAvLyBNUEVHIGZyYW1lIExlbmd0aFxyXG4gICAgICBsZXQgaGVhZGVyID0gdGhpcy5wYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xyXG4gICAgICBsZXQgZnJhbWVMZW5ndGggPSBoZWFkZXJMZW5ndGg7XHJcbiAgICAgIGlmIChoZWFkZXIgJiYgaGVhZGVyLmZyYW1lTGVuZ3RoKSB7XHJcbiAgICAgICAgZnJhbWVMZW5ndGggPSBoZWFkZXIuZnJhbWVMZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcclxuICAgICAgaWYgKG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgKG5ld09mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiB0aGlzLmlzSGVhZGVyUGF0dGVybihkYXRhLCBuZXdPZmZzZXQpKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTXBlZ0F1ZGlvO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9kZW11eC9tcGVnYXVkaW8uanMiLCIvKipcclxuICogIFRpbWVSYW5nZXMgdG8gc3RyaW5nIGhlbHBlclxyXG4gKi9cclxuXHJcbmNvbnN0IFRpbWVSYW5nZXMgPSB7XHJcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uIChyOiBUaW1lUmFuZ2VzKSB7XHJcbiAgICBsZXQgbG9nID0gJyc7XHJcbiAgICBsZXQgbGVuID0gci5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGxvZyArPSAnWycgKyByLnN0YXJ0KGkpLnRvRml4ZWQoMykgKyAnLCcgKyByLmVuZChpKS50b0ZpeGVkKDMpICsgJ10nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsb2c7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGltZVJhbmdlcztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMvdGltZS1yYW5nZXMudHMiLCJpbXBvcnQgQmluYXJ5U2VhcmNoIGZyb20gJy4vYmluYXJ5LXNlYXJjaCc7XHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpcnN0RnJhZ1dpdGhDQyAoZnJhZ21lbnRzLCBjYykge1xyXG4gIGxldCBmaXJzdEZyYWcgPSBudWxsO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgY29uc3QgY3VycmVudEZyYWcgPSBmcmFnbWVudHNbaV07XHJcbiAgICBpZiAoY3VycmVudEZyYWcgJiYgY3VycmVudEZyYWcuY2MgPT09IGNjKSB7XHJcbiAgICAgIGZpcnN0RnJhZyA9IGN1cnJlbnRGcmFnO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmaXJzdEZyYWc7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRnJhZ1dpdGhDQyAoZnJhZ21lbnRzLCBDQykge1xyXG4gIHJldHVybiBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgKGNhbmRpZGF0ZSkgPT4ge1xyXG4gICAgaWYgKGNhbmRpZGF0ZS5jYyA8IENDKSB7XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgfSBlbHNlIGlmIChjYW5kaWRhdGUuY2MgPiBDQykge1xyXG4gICAgICByZXR1cm4gLTE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMgKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpIHtcclxuICBsZXQgc2hvdWxkQWxpZ24gPSBmYWxzZTtcclxuICBpZiAobGFzdExldmVsICYmIGxhc3RMZXZlbC5kZXRhaWxzICYmIGRldGFpbHMpIHtcclxuICAgIGlmIChkZXRhaWxzLmVuZENDID4gZGV0YWlscy5zdGFydENDIHx8IChsYXN0RnJhZyAmJiBsYXN0RnJhZy5jYyA8IGRldGFpbHMuc3RhcnRDQykpIHtcclxuICAgICAgc2hvdWxkQWxpZ24gPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc2hvdWxkQWxpZ247XHJcbn1cclxuXHJcbi8vIEZpbmQgdGhlIGZpcnN0IGZyYWcgaW4gdGhlIHByZXZpb3VzIGxldmVsIHdoaWNoIG1hdGNoZXMgdGhlIENDIG9mIHRoZSBmaXJzdCBmcmFnIG9mIHRoZSBuZXcgbGV2ZWxcclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyAocHJldkRldGFpbHMsIGN1ckRldGFpbHMpIHtcclxuICBjb25zdCBwcmV2RnJhZ3MgPSBwcmV2RGV0YWlscy5mcmFnbWVudHM7XHJcbiAgY29uc3QgY3VyRnJhZ3MgPSBjdXJEZXRhaWxzLmZyYWdtZW50cztcclxuXHJcbiAgaWYgKCFjdXJGcmFncy5sZW5ndGggfHwgIXByZXZGcmFncy5sZW5ndGgpIHtcclxuICAgIGxvZ2dlci5sb2coJ05vIGZyYWdtZW50cyB0byBhbGlnbicpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcHJldlN0YXJ0RnJhZyA9IGZpbmRGaXJzdEZyYWdXaXRoQ0MocHJldkZyYWdzLCBjdXJGcmFnc1swXS5jYyk7XHJcblxyXG4gIGlmICghcHJldlN0YXJ0RnJhZyB8fCAocHJldlN0YXJ0RnJhZyAmJiAhcHJldlN0YXJ0RnJhZy5zdGFydFBUUykpIHtcclxuICAgIGxvZ2dlci5sb2coJ05vIGZyYWcgaW4gcHJldmlvdXMgbGV2ZWwgdG8gYWxpZ24gb24nKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHJldHVybiBwcmV2U3RhcnRGcmFnO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0UHRzIChzbGlkaW5nLCBkZXRhaWxzKSB7XHJcbiAgZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaCgoZnJhZykgPT4ge1xyXG4gICAgaWYgKGZyYWcpIHtcclxuICAgICAgbGV0IHN0YXJ0ID0gZnJhZy5zdGFydCArIHNsaWRpbmc7XHJcbiAgICAgIGZyYWcuc3RhcnQgPSBmcmFnLnN0YXJ0UFRTID0gc3RhcnQ7XHJcbiAgICAgIGZyYWcuZW5kUFRTID0gc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIGRldGFpbHMuUFRTS25vd24gPSB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogVXNpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGxhc3QgbGV2ZWwsIHRoaXMgZnVuY3Rpb24gY29tcHV0ZXMgUFRTJyBvZiB0aGUgbmV3IGZyYWdtZW50cyBzbyB0aGF0IHRoZXkgZm9ybSBhXHJcbiAqIGNvbnRpZ3VvdXMgc3RyZWFtIHdpdGggdGhlIGxhc3QgZnJhZ21lbnRzLlxyXG4gKiBUaGUgUFRTIG9mIGEgZnJhZ21lbnQgbGV0cyBIbHMuanMga25vdyB3aGVyZSBpdCBmaXRzIGludG8gYSBzdHJlYW0gLSBieSBrbm93aW5nIGV2ZXJ5IFBUUywgd2Uga25vdyB3aGljaCBmcmFnbWVudCB0b1xyXG4gKiBkb3dubG9hZCBhdCBhbnkgZ2l2ZW4gdGltZS4gUFRTIGlzIG5vcm1hbGx5IGNvbXB1dGVkIHdoZW4gdGhlIGZyYWdtZW50IGlzIGRlbXV4ZWQsIHNvIHRha2luZyB0aGlzIHN0ZXAgc2F2ZXMgdXMgdGltZVxyXG4gKiBhbmQgYW4gZXh0cmEgZG93bmxvYWQuXHJcbiAqIEBwYXJhbSBsYXN0RnJhZ1xyXG4gKiBAcGFyYW0gbGFzdExldmVsXHJcbiAqIEBwYXJhbSBkZXRhaWxzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWxpZ25TdHJlYW0gKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpIHtcclxuICBhbGlnbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgZGV0YWlscywgbGFzdExldmVsKTtcclxuICBpZiAoIWRldGFpbHMuUFRTS25vd24gJiYgbGFzdExldmVsKSB7XHJcbiAgICAvLyBJZiB0aGUgUFRTIHdhc24ndCBmaWd1cmVkIG91dCB2aWEgZGlzY29udGludWl0eSBzZXF1ZW5jZSB0aGF0IG1lYW5zIHRoZXJlIHdhcyBubyBDQyBpbmNyZWFzZSB3aXRoaW4gdGhlIGxldmVsLlxyXG4gICAgLy8gQWxpZ25pbmcgdmlhIFByb2dyYW0gRGF0ZSBUaW1lIHNob3VsZCB0aGVyZWZvcmUgYmUgcmVsaWFibGUsIHNpbmNlIFBEVCBzaG91bGQgYmUgdGhlIHNhbWUgd2l0aGluIHRoZSBzYW1lXHJcbiAgICAvLyBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxyXG4gICAgYWxpZ25QRFQoZGV0YWlscywgbGFzdExldmVsLmRldGFpbHMpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBQVFMgaWYgYSBuZXcgbGV2ZWwncyBmcmFnbWVudHMgdXNpbmcgdGhlIFBUUyBvZiBhIGZyYWdtZW50IGluIHRoZSBsYXN0IGxldmVsIHdoaWNoIHNoYXJlcyB0aGUgc2FtZVxyXG4gKiBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxyXG4gKiBAcGFyYW0gbGFzdExldmVsIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXHJcbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFsaWduRGlzY29udGludWl0aWVzIChsYXN0RnJhZywgZGV0YWlscywgbGFzdExldmVsKSB7XHJcbiAgaWYgKHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIGxhc3RMZXZlbCwgZGV0YWlscykpIHtcclxuICAgIGNvbnN0IHJlZmVyZW5jZUZyYWcgPSBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcobGFzdExldmVsLmRldGFpbHMsIGRldGFpbHMpO1xyXG4gICAgaWYgKHJlZmVyZW5jZUZyYWcpIHtcclxuICAgICAgbG9nZ2VyLmxvZygnQWRqdXN0aW5nIFBUUyB1c2luZyBsYXN0IGxldmVsIGR1ZSB0byBDQyBpbmNyZWFzZSB3aXRoaW4gY3VycmVudCBsZXZlbCcpO1xyXG4gICAgICBhZGp1c3RQdHMocmVmZXJlbmNlRnJhZy5zdGFydCwgZGV0YWlscyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIFBUUyBvZiBhIG5ldyBsZXZlbCdzIGZyYWdtZW50cyB1c2luZyB0aGUgZGlmZmVyZW5jZSBpbiBQcm9ncmFtIERhdGUgVGltZSBmcm9tIHRoZSBsYXN0IGxldmVsLlxyXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgbGV2ZWxcclxuICogQHBhcmFtIGxhc3REZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWxpZ25QRFQgKGRldGFpbHMsIGxhc3REZXRhaWxzKSB7XHJcbiAgaWYgKGxhc3REZXRhaWxzICYmIGxhc3REZXRhaWxzLmZyYWdtZW50cy5sZW5ndGgpIHtcclxuICAgIGlmICghZGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgfHwgIWxhc3REZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBpZiBsYXN0IGxldmVsIHNsaWRpbmcgaXMgMTAwMCBhbmQgaXRzIGZpcnN0IGZyYWcgUFJPR1JBTS1EQVRFLVRJTUUgaXMgMjAxNy0wOC0yMCAxOjEwOjAwIEFNXHJcbiAgICAvLyBhbmQgaWYgbmV3IGRldGFpbHMgZmlyc3QgZnJhZyBQUk9HUkFNIERBVEUtVElNRSBpcyAyMDE3LTA4LTIwIDE6MTA6MDggQU1cclxuICAgIC8vIHRoZW4gd2UgY2FuIGRlZHVjZSB0aGF0IHBsYXlsaXN0IEIgc2xpZGluZyBpcyAxMDAwKzggPSAxMDA4c1xyXG4gICAgbGV0IGxhc3RQRFQgPSBsYXN0RGV0YWlscy5mcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lO1xyXG4gICAgbGV0IG5ld1BEVCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZTtcclxuICAgIC8vIGRhdGUgZGlmZiBpcyBpbiBtcy4gZnJhZy5zdGFydCBpcyBpbiBzZWNvbmRzXHJcbiAgICBsZXQgc2xpZGluZyA9IChuZXdQRFQgLSBsYXN0UERUKSAvIDEwMDAgKyBsYXN0RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XHJcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHNsaWRpbmcpKSB7XHJcbiAgICAgIGxvZ2dlci5sb2coYGFkanVzdGluZyBQVFMgdXNpbmcgcHJvZ3JhbURhdGVUaW1lIGRlbHRhLCBzbGlkaW5nOiR7c2xpZGluZy50b0ZpeGVkKDMpfWApO1xyXG4gICAgICBhZGp1c3RQdHMoc2xpZGluZywgZGV0YWlscyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL2Rpc2NvbnRpbnVpdGllcy5qcyIsImltcG9ydCBCaW5hcnlTZWFyY2ggZnJvbSAnLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCc7XHJcbmltcG9ydCBGcmFnbWVudCBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgZmlyc3QgZnJhZ21lbnQgd2hvc2UgZW5kUGR0IHZhbHVlIGV4Y2VlZHMgdGhlIGdpdmVuIFBEVC5cclxuICogQHBhcmFtIHtBcnJheTxGcmFnbWVudD59IGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IFtQRFRWYWx1ZSA9IG51bGxdIC0gVGhlIFBEVCB2YWx1ZSB3aGljaCBtdXN0IGJlIGV4Y2VlZGVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xyXG4gKiBAcmV0dXJucyB7KnxudWxsfSBmcmFnbWVudCAtIFRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQRFQgKGZyYWdtZW50czogQXJyYXk8RnJhZ21lbnQ+LCBQRFRWYWx1ZTogbnVtYmVyIHwgbnVsbCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogbnVtYmVyKTogRnJhZ21lbnQgfCBudWxsIHtcclxuICBpZiAoUERUVmFsdWUgPT09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkoZnJhZ21lbnRzKSB8fCAhZnJhZ21lbnRzLmxlbmd0aCB8fCAhTnVtYmVyLmlzRmluaXRlKFBEVFZhbHVlKSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBpZiBsZXNzIHRoYW4gc3RhcnRcclxuICBjb25zdCBzdGFydFBEVCA9IGZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7XHJcbiAgaWYgKFBEVFZhbHVlIDwgKHN0YXJ0UERUIHx8IDApKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGVuZFBEVCA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kUHJvZ3JhbURhdGVUaW1lO1xyXG4gIGlmIChQRFRWYWx1ZSA+PSAoZW5kUERUIHx8IDApKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHx8IDA7XHJcbiAgZm9yIChsZXQgc2VnID0gMDsgc2VnIDwgZnJhZ21lbnRzLmxlbmd0aDsgKytzZWcpIHtcclxuICAgIGxldCBmcmFnID0gZnJhZ21lbnRzW3NlZ107XHJcbiAgICBpZiAocGR0V2l0aGluVG9sZXJhbmNlVGVzdChQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZykpIHtcclxuICAgICAgcmV0dXJuIGZyYWc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmRzIGEgZnJhZ21lbnQgYmFzZWQgb24gdGhlIFNOIG9mIHRoZSBwcmV2aW91cyBmcmFnbWVudDsgb3IgYmFzZWQgb24gdGhlIG5lZWRzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cclxuICogVGhpcyBtZXRob2QgY29tcGVuc2F0ZXMgZm9yIHNtYWxsIGJ1ZmZlciBnYXBzIGJ5IGFwcGx5aW5nIGEgdG9sZXJhbmNlIHRvIHRoZSBzdGFydCBvZiBhbnkgY2FuZGlkYXRlIGZyYWdtZW50LCB0aHVzXHJcbiAqIGJyZWFraW5nIGFueSB0cmFwcyB3aGljaCB3b3VsZCBjYXVzZSB0aGUgc2FtZSBmcmFnbWVudCB0byBiZSBjb250aW51b3VzbHkgc2VsZWN0ZWQgd2l0aGluIGEgc21hbGwgcmFuZ2UuXHJcbiAqIEBwYXJhbSB7Kn0gZnJhZ1ByZXZpb3VzIC0gVGhlIGxhc3QgZnJhZyBzdWNjZXNzZnVsbHkgYXBwZW5kZWRcclxuICogQHBhcmFtIHtBcnJheTxGcmFnbWVudD59IGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYnVmZmVyRW5kID0gMF0gLSBUaGUgZW5kIG9mIHRoZSBjb250aWd1b3VzIGJ1ZmZlcmVkIHJhbmdlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkgd2l0aGluXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xyXG4gKiBAcmV0dXJucyB7Kn0gZm91bmRGcmFnIC0gVGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBUUyAoZnJhZ1ByZXZpb3VzOiBGcmFnbWVudCwgZnJhZ21lbnRzOiBBcnJheTxGcmFnbWVudD4sIGJ1ZmZlckVuZDogbnVtYmVyID0gMCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogbnVtYmVyID0gMCk6IEZyYWdtZW50IHwgbnVsbCB7XHJcbiAgY29uc3QgZnJhZ05leHQgPSBmcmFnUHJldmlvdXMgPyBmcmFnbWVudHNbZnJhZ1ByZXZpb3VzLnNuIGFzIG51bWJlciAtIChmcmFnbWVudHNbMF0uc24gYXMgbnVtYmVyKSArIDFdIDogbnVsbDtcclxuICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXHJcbiAgaWYgKGZyYWdOZXh0ICYmICFmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnTmV4dCkpIHtcclxuICAgIHJldHVybiBmcmFnTmV4dDtcclxuICB9XHJcbiAgcmV0dXJuIEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QuYmluZChudWxsLCBidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5U24ncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXHJcbiAqIEBwYXJhbSB7Kn0gY2FuZGlkYXRlIC0gVGhlIGZyYWdtZW50IHRvIHRlc3RcclxuICogQHBhcmFtIHtudW1iZXJ9IFtidWZmZXJFbmQgPSAwXSAtIFRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyZWQgcmFuZ2UgdGhlIHBsYXloZWFkIGlzIGN1cnJlbnRseSB3aXRoaW5cclxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcclxuICogQHJldHVybnMge251bWJlcn0gLSAwIGlmIGl0IG1hdGNoZXMsIDEgaWYgdG9vIGxvdywgLTEgaWYgdG9vIGhpZ2hcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QgKGJ1ZmZlckVuZCA9IDAsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwLCBjYW5kaWRhdGU6IEZyYWdtZW50KSB7XHJcbiAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxyXG4gIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxyXG4gIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXHJcbiAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cclxuICAvLyBmcmFnWzFdIDogWzEwLDIwXVxyXG4gIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcclxuICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cclxuICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcclxuICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cclxuICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXHJcbiAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXHJcbiAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcclxuICAvLyBsb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xyXG4gIC8vIFNldCB0aGUgbG9va3VwIHRvbGVyYW5jZSB0byBiZSBzbWFsbCBlbm91Z2ggdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHNlZ21lbnQgLSBlbnN1cmVzIHdlIGRvbid0IHNraXAgb3ZlciB2ZXJ5IHNtYWxsIHNlZ21lbnRzXHJcbiAgbGV0IGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbiArIChjYW5kaWRhdGUuZGVsdGFQVFMgPyBjYW5kaWRhdGUuZGVsdGFQVFMgOiAwKSk7XHJcbiAgaWYgKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA8PSBidWZmZXJFbmQpIHtcclxuICAgIHJldHVybiAxO1xyXG4gIH0gZWxzZSBpZiAoY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCkge1xyXG4gICAgLy8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIHJldHVybiAwO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlQZHQncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXHJcbiAqIFRoaXMgZnVuY3Rpb24gdGVzdHMgdGhlIGNhbmRpZGF0ZSdzIHByb2dyYW0gZGF0ZSB0aW1lIHZhbHVlcywgYXMgcmVwcmVzZW50ZWQgaW4gVW5peCB0aW1lXHJcbiAqIEBwYXJhbSB7Kn0gY2FuZGlkYXRlIC0gVGhlIGZyYWdtZW50IHRvIHRlc3RcclxuICogQHBhcmFtIHtudW1iZXJ9IFtwZHRCdWZmZXJFbmQgPSAwXSAtIFRoZSBVbml4IHRpbWUgcmVwcmVzZW50aW5nIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyZWQgcmFuZ2VcclxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgY29udGlndW91cywgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGR0V2l0aGluVG9sZXJhbmNlVGVzdCAocGR0QnVmZmVyRW5kOiBudW1iZXIsIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IG51bWJlciwgY2FuZGlkYXRlOiBGcmFnbWVudCk6IGJvb2xlYW4ge1xyXG4gIGxldCBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpICogMTAwMDtcclxuXHJcbiAgLy8gZW5kUHJvZ3JhbURhdGVUaW1lIGNhbiBiZSBudWxsLCBkZWZhdWx0IHRvIHplcm9cclxuICBjb25zdCBlbmRQcm9ncmFtRGF0ZVRpbWUgPSBjYW5kaWRhdGUuZW5kUHJvZ3JhbURhdGVUaW1lIHx8IDA7XHJcbiAgcmV0dXJuIGVuZFByb2dyYW1EYXRlVGltZSAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IHBkdEJ1ZmZlckVuZDtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LWZpbmRlcnMudHMiLCJpbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4vZXZlbnQtaGFuZGxlcic7XHJcbmltcG9ydCBIbHMgZnJvbSAnLi9obHMnO1xyXG5cclxuLyoqXHJcbiAqIFN1Yi1jbGFzcyBzcGVjaWFsaXphdGlvbiBvZiBFdmVudEhhbmRsZXIgYmFzZSBjbGFzcy5cclxuICpcclxuICogVGFza0xvb3AgYWxsb3dzIHRvIHNjaGVkdWxlIGEgdGFzayBmdW5jdGlvbiBiZWluZyBjYWxsZWQgKG9wdGlvbm5hbHkgcmVwZWF0ZWRseSkgb24gdGhlIG1haW4gbG9vcCxcclxuICogc2NoZWR1bGVkIGFzeW5jaHJvbmVvdXNseSwgYXZvaWRpbmcgcmVjdXJzaXZlIGNhbGxzIGluIHRoZSBzYW1lIHRpY2suXHJcbiAqXHJcbiAqIFRoZSB0YXNrIGl0c2VsZiBpcyBpbXBsZW1lbnRlZCBpbiBgZG9UaWNrYC4gSXQgY2FuIGJlIHJlcXVlc3RlZCBhbmQgY2FsbGVkIGZvciBzaW5nbGUgZXhlY3V0aW9uXHJcbiAqIHVzaW5nIHRoZSBgdGlja2AgbWV0aG9kLlxyXG4gKlxyXG4gKiBJdCB3aWxsIGJlIGFzc3VyZWQgdGhhdCB0aGUgdGFzayBleGVjdXRpb24gbWV0aG9kIChgdGlja2ApIG9ubHkgZ2V0cyBjYWxsZWQgb25jZSBwZXIgbWFpbiBsb29wIFwidGlja1wiLFxyXG4gKiBubyBtYXR0ZXIgaG93IG9mdGVuIGl0IGdldHMgcmVxdWVzdGVkIGZvciBleGVjdXRpb24uIEV4ZWN1dGlvbiBpbiBmdXJ0aGVyIHRpY2tzIHdpbGwgYmUgc2NoZWR1bGVkIGFjY29yZGluZ2x5LlxyXG4gKlxyXG4gKiBJZiBmdXJ0aGVyIGV4ZWN1dGlvbiByZXF1ZXN0cyBoYXZlIGFscmVhZHkgYmVlbiBzY2hlZHVsZWQgb24gdGhlIG5leHQgdGljaywgaXQgY2FuIGJlIGNoZWNrZWQgd2l0aCBgaGFzTmV4dFRpY2tgLFxyXG4gKiBhbmQgY2FuY2VsbGVkIHdpdGggYGNsZWFyTmV4dFRpY2tgLlxyXG4gKlxyXG4gKiBUaGUgdGFzayBjYW4gYmUgc2NoZWR1bGVkIGFzIGFuIGludGVydmFsIHJlcGVhdGVkbHkgd2l0aCBhIHBlcmlvZCBhcyBwYXJhbWV0ZXIgKHNlZSBgc2V0SW50ZXJ2YWxgLCBgY2xlYXJJbnRlcnZhbGApLlxyXG4gKlxyXG4gKiBTdWItY2xhc3NlcyBuZWVkIHRvIGltcGxlbWVudCB0aGUgYGRvVGlja2AgbWV0aG9kIHdoaWNoIHdpbGwgZWZmZWN0aXZlbHkgaGF2ZSB0aGUgdGFzayBleGVjdXRpb24gcm91dGluZS5cclxuICpcclxuICogRnVydGhlciBleHBsYW5hdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBiYXNlY2xhc3MgaGFzIGEgYHRpY2tgIG1ldGhvZCB0aGF0IHdpbGwgc2NoZWR1bGUgdGhlIGRvVGljayBjYWxsLiBJdCBtYXkgYmUgY2FsbGVkIHN5bmNocm9uZW91c2x5XHJcbiAqIG9ubHkgZm9yIGEgc3RhY2stZGVwdGggb2Ygb25lLiBPbiByZS1lbnRyYW50IGNhbGxzLCBzdWItc2VxdWVudCBjYWxscyBhcmUgc2NoZWR1bGVkIGZvciBuZXh0IG1haW4gbG9vcCB0aWNrcy5cclxuICpcclxuICogV2hlbiB0aGUgdGFzayBleGVjdXRpb24gKGB0aWNrYCBtZXRob2QpIGlzIGNhbGxlZCBpbiByZS1lbnRyYW50IHdheSB0aGlzIGlzIGRldGVjdGVkIGFuZFxyXG4gKiB3ZSBhcmUgbGltaXRpbmcgdGhlIHRhc2sgZXhlY3V0aW9uIHBlciBjYWxsIHN0YWNrIHRvIGV4YWN0bHkgb25lLCBidXQgc2NoZWR1bGluZy9wb3N0LXBvbmluZyBmdXJ0aGVyXHJcbiAqIHRhc2sgcHJvY2Vzc2luZyBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIChhbHNvIGtub3duIGFzIFwibmV4dCB0aWNrXCIgaW4gdGhlIE5vZGUvSlMgcnVudGltZSBsaW5nbykuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFza0xvb3AgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2JvdW5kVGljazogKCkgPT4gdm9pZDtcclxuICBwcml2YXRlIF90aWNrVGltZXI6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgX3RpY2tJbnRlcnZhbDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBfdGlja0NhbGxDb3VudCA9IDA7XHJcblxyXG4gIGNvbnN0cnVjdG9yIChobHM6IEhscywgLi4uZXZlbnRzOiBzdHJpbmdbXSkge1xyXG4gICAgc3VwZXIoaGxzLCAuLi5ldmVudHMpO1xyXG4gICAgdGhpcy5fYm91bmRUaWNrID0gdGhpcy50aWNrLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgb25IYW5kbGVyRGVzdHJveWluZyAoKSB7XHJcbiAgICAvLyBjbGVhciBhbGwgdGltZXJzIGJlZm9yZSB1bnJlZ2lzdGVyaW5nIGZyb20gZXZlbnQgYnVzXHJcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcclxuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgcHVibGljIGhhc0ludGVydmFsICgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAhIXRoaXMuX3RpY2tJbnRlcnZhbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHB1YmxpYyBoYXNOZXh0VGljayAoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gISF0aGlzLl90aWNrVGltZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzIEludGVydmFsIHRpbWUgKG1zKVxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gaW50ZXJ2YWwgaGFzIGJlZW4gc2NoZWR1bGVkLCBmYWxzZSB3aGVuIGFscmVhZHkgc2NoZWR1bGVkIChubyBlZmZlY3QpXHJcbiAgICovXHJcbiAgcHVibGljIHNldEludGVydmFsIChtaWxsaXM6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgaWYgKCF0aGlzLl90aWNrSW50ZXJ2YWwpIHtcclxuICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLl9ib3VuZFRpY2ssIG1pbGxpcyk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiBpbnRlcnZhbCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcclxuICAgKi9cclxuICBwdWJsaWMgY2xlYXJJbnRlcnZhbCAoKTogYm9vbGVhbiB7XHJcbiAgICBpZiAodGhpcy5fdGlja0ludGVydmFsKSB7XHJcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLl90aWNrSW50ZXJ2YWwpO1xyXG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gdGltZW91dCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcclxuICAgKi9cclxuICBwdWJsaWMgY2xlYXJOZXh0VGljayAoKTogYm9vbGVhbiB7XHJcbiAgICBpZiAodGhpcy5fdGlja1RpbWVyKSB7XHJcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMuX3RpY2tUaW1lcik7XHJcbiAgICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2lsbCBjYWxsIHRoZSBzdWJjbGFzcyBkb1RpY2sgaW1wbGVtZW50YXRpb24gaW4gdGhpcyBtYWluIGxvb3AgdGlja1xyXG4gICAqIG9yIGluIHRoZSBuZXh0IG9uZSAodmlhIHNldFRpbWVvdXQoLDApKSBpbiBjYXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkXHJcbiAgICogaW4gdGhpcyB0aWNrIChpbiBjYXNlIHRoaXMgaXMgYSByZS1lbnRyYW50IGNhbGwpLlxyXG4gICAqL1xyXG4gIHB1YmxpYyB0aWNrICgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3RpY2tDYWxsQ291bnQrKztcclxuICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID09PSAxKSB7XHJcbiAgICAgIHRoaXMuZG9UaWNrKCk7XHJcbiAgICAgIC8vIHJlLWVudHJhbnQgY2FsbCB0byB0aWNrIGZyb20gcHJldmlvdXMgZG9UaWNrIGNhbGwgc3RhY2tcclxuICAgICAgLy8gLT4gc2NoZWR1bGUgYSBjYWxsIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gdG8gcHJvY2VzcyB0aGlzIHRhc2sgcHJvY2Vzc2luZyByZXF1ZXN0XHJcbiAgICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID4gMSkge1xyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBvbmx5IG9uZSB0aW1lciBleGlzdHMgYXQgYW55IHRpbWUgYXQgbWF4XHJcbiAgICAgICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XHJcbiAgICAgICAgdGhpcy5fdGlja1RpbWVyID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMuX2JvdW5kVGljaywgMCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGb3Igc3ViY2xhc3MgdG8gaW1wbGVtZW50IHRhc2sgbG9naWNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZG9UaWNrICgpOiB2b2lkIHt9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdGFzay1sb29wLnRzIiwiLyoqXHJcbiAqIFhIUiBiYXNlZCBsb2dnZXJcclxuKi9cclxuXHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcblxyXG5jb25zdCB7IHBlcmZvcm1hbmNlLCBYTUxIdHRwUmVxdWVzdCB9ID0gd2luZG93O1xyXG5cclxuY2xhc3MgWGhyTG9hZGVyIHtcclxuICBjb25zdHJ1Y3RvciAoY29uZmlnKSB7XHJcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy54aHJTZXR1cCkge1xyXG4gICAgICB0aGlzLnhoclNldHVwID0gY29uZmlnLnhoclNldHVwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVzdHJveSAoKSB7XHJcbiAgICB0aGlzLmFib3J0KCk7XHJcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBhYm9ydCAoKSB7XHJcbiAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXI7XHJcbiAgICBpZiAobG9hZGVyICYmIGxvYWRlci5yZWFkeVN0YXRlICE9PSA0KSB7XHJcbiAgICAgIHRoaXMuc3RhdHMuYWJvcnRlZCA9IHRydWU7XHJcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XHJcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gbnVsbDtcclxuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xyXG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgbG9hZCAoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xyXG4gICAgdGhpcy5zdGF0cyA9IHsgdHJlcXVlc3Q6IHBlcmZvcm1hbmNlLm5vdygpLCByZXRyeTogMCB9O1xyXG4gICAgdGhpcy5yZXRyeURlbGF5ID0gY29uZmlnLnJldHJ5RGVsYXk7XHJcbiAgICB0aGlzLmxvYWRJbnRlcm5hbCgpO1xyXG4gIH1cclxuXHJcbiAgbG9hZEludGVybmFsICgpIHtcclxuICAgIGxldCB4aHIsIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICB4aHIgPSB0aGlzLmxvYWRlciA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cclxuICAgIGxldCBzdGF0cyA9IHRoaXMuc3RhdHM7XHJcbiAgICBzdGF0cy50Zmlyc3QgPSAwO1xyXG4gICAgc3RhdHMubG9hZGVkID0gMDtcclxuICAgIGNvbnN0IHhoclNldHVwID0gdGhpcy54aHJTZXR1cDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoeGhyU2V0dXApIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgeGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgLy8gZml4IHhoclNldHVwOiAoeGhyLCB1cmwpID0+IHt4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtTGFuZ3VhZ2VcIiwgXCJ0ZXN0XCIpO31cclxuICAgICAgICAgIC8vIG5vdCB3b3JraW5nLCBhcyB4aHIuc2V0UmVxdWVzdEhlYWRlciBleHBlY3RzIHhoci5yZWFkeVN0YXRlID09PSBPUEVOXHJcbiAgICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xyXG4gICAgICAgICAgeGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcclxuICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIC8vIElFMTEgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB4aHIub3BlbiBpZiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBhbiBIVFRQIHJlc291cmNlIG92ZXIgSFRUUFNcclxuICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcih7IGNvZGU6IHhoci5zdGF0dXMsIHRleHQ6IGUubWVzc2FnZSB9LCBjb250ZXh0LCB4aHIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbnRleHQucmFuZ2VFbmQpIHtcclxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyAoY29udGV4dC5yYW5nZUVuZCAtIDEpKTtcclxuICAgIH1cclxuXHJcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5yZWFkeXN0YXRlY2hhbmdlLmJpbmQodGhpcyk7XHJcbiAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyk7XHJcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gY29udGV4dC5yZXNwb25zZVR5cGU7XHJcblxyXG4gICAgLy8gc2V0dXAgdGltZW91dCBiZWZvcmUgd2UgcGVyZm9ybSByZXF1ZXN0XHJcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZy50aW1lb3V0KTtcclxuICAgIHhoci5zZW5kKCk7XHJcbiAgfVxyXG5cclxuICByZWFkeXN0YXRlY2hhbmdlIChldmVudCkge1xyXG4gICAgbGV0IHhociA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXHJcbiAgICAgIHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZSxcclxuICAgICAgc3RhdHMgPSB0aGlzLnN0YXRzLFxyXG4gICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxyXG4gICAgICBjb25maWcgPSB0aGlzLmNvbmZpZztcclxuXHJcbiAgICAvLyBkb24ndCBwcm9jZWVkIGlmIHhociBoYXMgYmVlbiBhYm9ydGVkXHJcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPj0gSEVBREVSU19SRUNFSVZFRFxyXG4gICAgaWYgKHJlYWR5U3RhdGUgPj0gMikge1xyXG4gICAgICAvLyBjbGVhciB4aHIgdGltZW91dCBhbmQgcmVhcm0gaXQgaWYgcmVhZHlTdGF0ZSBsZXNzIHRoYW4gNFxyXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xyXG4gICAgICBpZiAoc3RhdHMudGZpcnN0ID09PSAwKSB7XHJcbiAgICAgICAgc3RhdHMudGZpcnN0ID0gTWF0aC5tYXgocGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLnRyZXF1ZXN0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDQpIHtcclxuICAgICAgICBsZXQgc3RhdHVzID0geGhyLnN0YXR1cztcclxuICAgICAgICAvLyBodHRwIHN0YXR1cyBiZXR3ZWVuIDIwMCB0byAyOTkgYXJlIGFsbCBzdWNjZXNzZnVsXHJcbiAgICAgICAgaWYgKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICBzdGF0cy50bG9hZCA9IE1hdGgubWF4KHN0YXRzLnRmaXJzdCwgcGVyZm9ybWFuY2Uubm93KCkpO1xyXG4gICAgICAgICAgbGV0IGRhdGEsIGxlbjtcclxuICAgICAgICAgIGlmIChjb250ZXh0LnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xyXG4gICAgICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlO1xyXG4gICAgICAgICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlVGV4dDtcclxuICAgICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IGxlbjtcclxuICAgICAgICAgIGxldCByZXNwb25zZSA9IHsgdXJsOiB4aHIucmVzcG9uc2VVUkwsIGRhdGE6IGRhdGEgfTtcclxuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIHhocik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGlmIG1heCBuYiBvZiByZXRyaWVzIHJlYWNoZWQgb3IgaWYgaHR0cCBzdGF0dXMgYmV0d2VlbiA0MDAgYW5kIDQ5OSAoc3VjaCBlcnJvciBjYW5ub3QgYmUgcmVjb3ZlcmVkLCByZXRyeWluZyBpcyB1c2VsZXNzKSwgcmV0dXJuIGVycm9yXHJcbiAgICAgICAgICBpZiAoc3RhdHMucmV0cnkgPj0gY29uZmlnLm1heFJldHJ5IHx8IChzdGF0dXMgPj0gNDAwICYmIHN0YXR1cyA8IDQ5OSkpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGAke3N0YXR1c30gd2hpbGUgbG9hZGluZyAke2NvbnRleHQudXJsfWApO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yKHsgY29kZTogc3RhdHVzLCB0ZXh0OiB4aHIuc3RhdHVzVGV4dCB9LCBjb250ZXh0LCB4aHIpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcmV0cnlcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYCR7c3RhdHVzfSB3aGlsZSBsb2FkaW5nICR7Y29udGV4dC51cmx9LCByZXRyeWluZyBpbiAke3RoaXMucmV0cnlEZWxheX0uLi5gKTtcclxuICAgICAgICAgICAgLy8gYWJvcnRzIGFuZCByZXNldHMgaW50ZXJuYWwgc3RhdGVcclxuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIHJldHJ5XHJcbiAgICAgICAgICAgIHRoaXMucmV0cnlUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkSW50ZXJuYWwuYmluZCh0aGlzKSwgdGhpcy5yZXRyeURlbGF5KTtcclxuICAgICAgICAgICAgLy8gc2V0IGV4cG9uZW50aWFsIGJhY2tvZmZcclxuICAgICAgICAgICAgdGhpcy5yZXRyeURlbGF5ID0gTWF0aC5taW4oMiAqIHRoaXMucmV0cnlEZWxheSwgY29uZmlnLm1heFJldHJ5RGVsYXkpO1xyXG4gICAgICAgICAgICBzdGF0cy5yZXRyeSsrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyByZWFkeVN0YXRlID49IDIgQU5EIHJlYWR5U3RhdGUgIT09NCAocmVhZHlTdGF0ZSA9IEhFQURFUlNfUkVDRUlWRUQgfHwgTE9BRElORykgcmVhcm0gdGltZW91dCBhcyB4aHIgbm90IGZpbmlzaGVkIHlldFxyXG4gICAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIGNvbmZpZy50aW1lb3V0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbG9hZHRpbWVvdXQgKCkge1xyXG4gICAgbG9nZ2VyLndhcm4oYHRpbWVvdXQgd2hpbGUgbG9hZGluZyAke3RoaXMuY29udGV4dC51cmx9YCk7XHJcbiAgICB0aGlzLmNhbGxiYWNrcy5vblRpbWVvdXQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0LCBudWxsKTtcclxuICB9XHJcblxyXG4gIGxvYWRwcm9ncmVzcyAoZXZlbnQpIHtcclxuICAgIGxldCB4aHIgPSBldmVudC5jdXJyZW50VGFyZ2V0LFxyXG4gICAgICBzdGF0cyA9IHRoaXMuc3RhdHM7XHJcblxyXG4gICAgc3RhdHMubG9hZGVkID0gZXZlbnQubG9hZGVkO1xyXG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcclxuICAgICAgc3RhdHMudG90YWwgPSBldmVudC50b3RhbDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgb25Qcm9ncmVzcyA9IHRoaXMuY2FsbGJhY2tzLm9uUHJvZ3Jlc3M7XHJcbiAgICBpZiAob25Qcm9ncmVzcykge1xyXG4gICAgICAvLyB0aGlyZCBhcmcgaXMgdG8gcHJvdmlkZSBvbiBwcm9ncmVzcyBkYXRhXHJcbiAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIHRoaXMuY29udGV4dCwgbnVsbCwgeGhyKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFhockxvYWRlcjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMveGhyLWxvYWRlci5qcyIsIi8qXHJcbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzL2Jsb2IvbWFzdGVyL2Rpc3QvdnR0LmpzI0wxNzE2XHJcbiAqL1xyXG5cclxuaW1wb3J0IFZUVEN1ZSBmcm9tICcuL3Z0dGN1ZSc7XHJcblxyXG5jb25zdCBTdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24gU3RyaW5nRGVjb2RlciAoKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGRlY29kZTogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSk7XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFZUVFBhcnNlciAoKSB7XHJcbiAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XHJcbiAgdGhpcy5zdGF0ZSA9ICdJTklUSUFMJztcclxuICB0aGlzLmJ1ZmZlciA9ICcnO1xyXG4gIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCk7XHJcbiAgdGhpcy5yZWdpb25MaXN0ID0gW107XHJcbn1cclxuXHJcbi8vIFRyeSB0byBwYXJzZSBpbnB1dCBhcyBhIHRpbWUgc3RhbXAuXHJcbmZ1bmN0aW9uIHBhcnNlVGltZVN0YW1wIChpbnB1dCkge1xyXG4gIGZ1bmN0aW9uIGNvbXB1dGVTZWNvbmRzIChoLCBtLCBzLCBmKSB7XHJcbiAgICByZXR1cm4gKGggfCAwKSAqIDM2MDAgKyAobSB8IDApICogNjAgKyAocyB8IDApICsgKGYgfCAwKSAvIDEwMDA7XHJcbiAgfVxyXG5cclxuICBsZXQgbSA9IGlucHV0Lm1hdGNoKC9eKFxcZCspOihcXGR7Mn0pKDpcXGR7Mn0pP1xcLihcXGR7M30pLyk7XHJcbiAgaWYgKCFtKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGlmIChtWzNdKSB7XHJcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc106W3NlY29uZHNdLlttaWxsaXNlY29uZHNdXHJcbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgbVszXS5yZXBsYWNlKCc6JywgJycpLCBtWzRdKTtcclxuICB9IGVsc2UgaWYgKG1bMV0gPiA1OSkge1xyXG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdLlttaWxsaXNlY29uZHNdXHJcbiAgICAvLyBGaXJzdCBwb3NpdGlvbiBpcyBob3VycyBhcyBpdCdzIG92ZXIgNTkuXHJcbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgMCwgbVs0XSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbbWludXRlc106W3NlY29uZHNdLlttaWxsaXNlY29uZHNdXHJcbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMoMCwgbVsxXSwgbVsyXSwgbVs0XSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3RcclxuLy8gYXNzaWdubWVudCB0byBhIHNwZWNpZmljIGtleS5cclxuZnVuY3Rpb24gU2V0dGluZ3MgKCkge1xyXG4gIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxufVxyXG5cclxuU2V0dGluZ3MucHJvdG90eXBlID0ge1xyXG4gIC8vIE9ubHkgYWNjZXB0IHRoZSBmaXJzdCBhc3NpZ25tZW50IHRvIGFueSBrZXkuXHJcbiAgc2V0OiBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKCF0aGlzLmdldChrKSAmJiB2ICE9PSAnJykge1xyXG4gICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XHJcbiAgICB9XHJcbiAgfSxcclxuICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciBhIGtleSwgb3IgYSBkZWZhdWx0IHZhbHVlLlxyXG4gIC8vIElmICdkZWZhdWx0S2V5JyBpcyBwYXNzZWQgdGhlbiAnZGZsdCcgaXMgYXNzdW1lZCB0byBiZSBhbiBvYmplY3Qgd2l0aFxyXG4gIC8vIGEgbnVtYmVyIG9mIHBvc3NpYmxlIGRlZmF1bHQgdmFsdWVzIGFzIHByb3BlcnRpZXMgd2hlcmUgJ2RlZmF1bHRLZXknIGlzXHJcbiAgLy8gdGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIGNob3Nlbjsgb3RoZXJ3aXNlIGl0J3MgYXNzdW1lZCB0byBiZVxyXG4gIC8vIGEgc2luZ2xlIHZhbHVlLlxyXG4gIGdldDogZnVuY3Rpb24gKGssIGRmbHQsIGRlZmF1bHRLZXkpIHtcclxuICAgIGlmIChkZWZhdWx0S2V5KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdFtkZWZhdWx0S2V5XTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHQ7XHJcbiAgfSxcclxuICAvLyBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSB2YWx1ZSBmb3IgYSBrZXkuXHJcbiAgaGFzOiBmdW5jdGlvbiAoaykge1xyXG4gICAgcmV0dXJuIGsgaW4gdGhpcy52YWx1ZXM7XHJcbiAgfSxcclxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cclxuICBhbHQ6IGZ1bmN0aW9uIChrLCB2LCBhKSB7XHJcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IGEubGVuZ3RoOyArK24pIHtcclxuICAgICAgaWYgKHYgPT09IGFbbl0pIHtcclxuICAgICAgICB0aGlzLnNldChrLCB2KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxyXG4gIGludGVnZXI6IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAoL14tP1xcZCskLy50ZXN0KHYpKSB7IC8vIGludGVnZXJcclxuICAgICAgdGhpcy5zZXQoaywgcGFyc2VJbnQodiwgMTApKTtcclxuICAgIH1cclxuICB9LFxyXG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgcGVyY2VudGFnZS5cclxuICBwZXJjZW50OiBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgbGV0IG07XHJcbiAgICBpZiAoKG0gPSB2Lm1hdGNoKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvKSkpIHtcclxuICAgICAgdiA9IHBhcnNlRmxvYXQodik7XHJcbiAgICAgIGlmICh2ID49IDAgJiYgdiA8PSAxMDApIHtcclxuICAgICAgICB0aGlzLnNldChrLCB2KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBpbnB1dCBpbnRvIGdyb3VwcyBzZXBhcmF0ZWQgYnkgJ2dyb3VwRGVsaW0nLCBhbmRcclxuLy8gaW50ZXJwcmV0ZSBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cclxuZnVuY3Rpb24gcGFyc2VPcHRpb25zIChpbnB1dCwgY2FsbGJhY2ssIGtleVZhbHVlRGVsaW0sIGdyb3VwRGVsaW0pIHtcclxuICBsZXQgZ3JvdXBzID0gZ3JvdXBEZWxpbSA/IGlucHV0LnNwbGl0KGdyb3VwRGVsaW0pIDogW2lucHV0XTtcclxuICBmb3IgKGxldCBpIGluIGdyb3Vwcykge1xyXG4gICAgaWYgKHR5cGVvZiBncm91cHNbaV0gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBrdiA9IGdyb3Vwc1tpXS5zcGxpdChrZXlWYWx1ZURlbGltKTtcclxuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGsgPSBrdlswXTtcclxuICAgIGxldCB2ID0ga3ZbMV07XHJcbiAgICBjYWxsYmFjayhrLCB2KTtcclxuICB9XHJcbn1cclxuXHJcbmxldCBkZWZhdWx0cyA9IG5ldyBWVFRDdWUoMCwgMCwgMCk7XHJcbi8vICdtaWRkbGUnIHdhcyBjaGFuZ2VkIHRvICdjZW50ZXInIGluIHRoZSBzcGVjOiBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYnZ0dC9wdWxsLzI0NFxyXG4vLyAgU2FmYXJpIGRvZXNuJ3QgeWV0IHN1cHBvcnQgdGhpcyBjaGFuZ2UsIGJ1dCBGRiBhbmQgQ2hyb21lIGRvLlxyXG5sZXQgY2VudGVyID0gZGVmYXVsdHMuYWxpZ24gPT09ICdtaWRkbGUnID8gJ21pZGRsZScgOiAnY2VudGVyJztcclxuXHJcbmZ1bmN0aW9uIHBhcnNlQ3VlIChpbnB1dCwgY3VlLCByZWdpb25MaXN0KSB7XHJcbiAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIGlucHV0IGlmIHdlIG5lZWQgdG8gdGhyb3cgYW4gZXJyb3IuXHJcbiAgbGV0IG9JbnB1dCA9IGlucHV0O1xyXG4gIC8vIDQuMSBXZWJWVFQgdGltZXN0YW1wXHJcbiAgZnVuY3Rpb24gY29uc3VtZVRpbWVTdGFtcCAoKSB7XHJcbiAgICBsZXQgdHMgPSBwYXJzZVRpbWVTdGFtcChpbnB1dCk7XHJcbiAgICBpZiAodHMgPT09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgdGltZXN0YW1wOiAnICsgb0lucHV0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgdGltZSBzdGFtcCBmcm9tIGlucHV0LlxyXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCAnJyk7XHJcbiAgICByZXR1cm4gdHM7XHJcbiAgfVxyXG5cclxuICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXHJcbiAgZnVuY3Rpb24gY29uc3VtZUN1ZVNldHRpbmdzIChpbnB1dCwgY3VlKSB7XHJcbiAgICBsZXQgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcclxuXHJcbiAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICAgIHN3aXRjaCAoaykge1xyXG4gICAgICBjYXNlICdyZWdpb24nOlxyXG4gICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgcmVnaW9uIHdlIHBhcnNlZCB3aXRoIHRoZSBzYW1lIHJlZ2lvbiBpZC5cclxuICAgICAgICBmb3IgKGxldCBpID0gcmVnaW9uTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgaWYgKHJlZ2lvbkxpc3RbaV0uaWQgPT09IHYpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3Muc2V0KGssIHJlZ2lvbkxpc3RbaV0ucmVnaW9uKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd2ZXJ0aWNhbCc6XHJcbiAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsncmwnLCAnbHInXSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2xpbmUnOlxyXG4gICAgICAgIHZhciB2YWxzID0gdi5zcGxpdCgnLCcpLFxyXG4gICAgICAgICAgdmFsczAgPSB2YWxzWzBdO1xyXG4gICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdmFsczApO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5wZXJjZW50KGssIHZhbHMwKSkge1xyXG4gICAgICAgICAgc2V0dGluZ3Muc2V0KCdzbmFwVG9MaW5lcycsIGZhbHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzMCwgWydhdXRvJ10pO1xyXG4gICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgc2V0dGluZ3MuYWx0KCdsaW5lQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJ10pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcclxuICAgICAgICB2YWxzID0gdi5zcGxpdCgnLCcpO1xyXG4gICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSk7XHJcbiAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoJ3Bvc2l0aW9uQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xpbmUtbGVmdCcsICdsaW5lLXJpZ2h0JywgJ2F1dG8nXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnc2l6ZSc6XHJcbiAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnYWxpZ24nOlxyXG4gICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xlZnQnLCAncmlnaHQnXSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH0sIC86LywgL1xccy8pO1xyXG5cclxuICAgIC8vIEFwcGx5IGRlZmF1bHQgdmFsdWVzIGZvciBhbnkgbWlzc2luZyBmaWVsZHMuXHJcbiAgICBjdWUucmVnaW9uID0gc2V0dGluZ3MuZ2V0KCdyZWdpb24nLCBudWxsKTtcclxuICAgIGN1ZS52ZXJ0aWNhbCA9IHNldHRpbmdzLmdldCgndmVydGljYWwnLCAnJyk7XHJcbiAgICBsZXQgbGluZSA9IHNldHRpbmdzLmdldCgnbGluZScsICdhdXRvJyk7XHJcbiAgICBpZiAobGluZSA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLmxpbmUgPT09IC0xKSB7XHJcbiAgICAgIC8vIHNldCBudW1lcmljIGxpbmUgbnVtYmVyIGZvciBTYWZhcmlcclxuICAgICAgbGluZSA9IC0xO1xyXG4gICAgfVxyXG4gICAgY3VlLmxpbmUgPSBsaW5lO1xyXG4gICAgY3VlLmxpbmVBbGlnbiA9IHNldHRpbmdzLmdldCgnbGluZUFsaWduJywgJ3N0YXJ0Jyk7XHJcbiAgICBjdWUuc25hcFRvTGluZXMgPSBzZXR0aW5ncy5nZXQoJ3NuYXBUb0xpbmVzJywgdHJ1ZSk7XHJcbiAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldCgnc2l6ZScsIDEwMCk7XHJcbiAgICBjdWUuYWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2FsaWduJywgY2VudGVyKTtcclxuICAgIGxldCBwb3NpdGlvbiA9IHNldHRpbmdzLmdldCgncG9zaXRpb24nLCAnYXV0bycpO1xyXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgZGVmYXVsdHMucG9zaXRpb24gPT09IDUwKSB7XHJcbiAgICAgIC8vIHNldCBudW1lcmljIHBvc2l0aW9uIGZvciBTYWZhcmlcclxuICAgICAgcG9zaXRpb24gPSBjdWUuYWxpZ24gPT09ICdzdGFydCcgfHwgY3VlLmFsaWduID09PSAnbGVmdCcgPyAwIDogY3VlLmFsaWduID09PSAnZW5kJyB8fCBjdWUuYWxpZ24gPT09ICdyaWdodCcgPyAxMDAgOiA1MDtcclxuICAgIH1cclxuICAgIGN1ZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UgKCkge1xyXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eXFxzKy8sICcnKTtcclxuICB9XHJcblxyXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHRpbWluZ3MuXHJcbiAgc2tpcFdoaXRlc3BhY2UoKTtcclxuICBjdWUuc3RhcnRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAvLyAoMSkgY29sbGVjdCBjdWUgc3RhcnQgdGltZVxyXG4gIHNraXBXaGl0ZXNwYWNlKCk7XHJcbiAgaWYgKGlucHV0LnN1YnN0cigwLCAzKSAhPT0gJy0tPicpIHsgLy8gKDMpIG5leHQgY2hhcmFjdGVycyBtdXN0IG1hdGNoICctLT4nXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCB0aW1lIHN0YW1wICh0aW1lIHN0YW1wcyBtdXN0IGJlIHNlcGFyYXRlZCBieSBcXCctLT5cXCcpOiAnICtcclxuICAgICAgb0lucHV0KTtcclxuICB9XHJcbiAgaW5wdXQgPSBpbnB1dC5zdWJzdHIoMyk7XHJcbiAgc2tpcFdoaXRlc3BhY2UoKTtcclxuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDUpIGNvbGxlY3QgY3VlIGVuZCB0aW1lXHJcblxyXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHNldHRpbmdzIGxpc3QuXHJcbiAgc2tpcFdoaXRlc3BhY2UoKTtcclxuICBjb25zdW1lQ3VlU2V0dGluZ3MoaW5wdXQsIGN1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpeExpbmVCcmVha3MgKGlucHV0KSB7XHJcbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoLzxicig/OiBcXC8pPz4vZ2ksICdcXG4nKTtcclxufVxyXG5cclxuVlRUUGFyc2VyLnByb3RvdHlwZSA9IHtcclxuICBwYXJzZTogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIGxldCBzZWxmID0gdGhpcztcclxuXHJcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBkYXRhIHRoZW4gd2Ugd29uJ3QgZGVjb2RlIGl0LCBidXQgd2lsbCBqdXN0IHRyeSB0byBwYXJzZVxyXG4gICAgLy8gd2hhdGV2ZXIgaXMgaW4gYnVmZmVyIGFscmVhZHkuIFRoaXMgbWF5IG9jY3VyIGluIGNpcmN1bXN0YW5jZXMsIGZvclxyXG4gICAgLy8gZXhhbXBsZSB3aGVuIGZsdXNoKCkgaXMgY2FsbGVkLlxyXG4gICAgaWYgKGRhdGEpIHtcclxuICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgZGF0YSB0aGF0IHdlIHJlY2VpdmVkLlxyXG4gICAgICBzZWxmLmJ1ZmZlciArPSBzZWxmLmRlY29kZXIuZGVjb2RlKGRhdGEsIHsgc3RyZWFtOiB0cnVlIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbGxlY3ROZXh0TGluZSAoKSB7XHJcbiAgICAgIGxldCBidWZmZXIgPSBzZWxmLmJ1ZmZlcjtcclxuICAgICAgbGV0IHBvcyA9IDA7XHJcblxyXG4gICAgICBidWZmZXIgPSBmaXhMaW5lQnJlYWtzKGJ1ZmZlcik7XHJcblxyXG4gICAgICB3aGlsZSAocG9zIDwgYnVmZmVyLmxlbmd0aCAmJiBidWZmZXJbcG9zXSAhPT0gJ1xccicgJiYgYnVmZmVyW3Bvc10gIT09ICdcXG4nKSB7XHJcbiAgICAgICAgKytwb3M7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBsaW5lID0gYnVmZmVyLnN1YnN0cigwLCBwb3MpO1xyXG4gICAgICAvLyBBZHZhbmNlIHRoZSBidWZmZXIgZWFybHkgaW4gY2FzZSB3ZSBmYWlsIGJlbG93LlxyXG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXHInKSB7XHJcbiAgICAgICAgKytwb3M7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xcbicpIHtcclxuICAgICAgICArK3BvcztcclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi5idWZmZXIgPSBidWZmZXIuc3Vic3RyKHBvcyk7XHJcbiAgICAgIHJldHVybiBsaW5lO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDMuMiBXZWJWVFQgbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxyXG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIgKGlucHV0KSB7XHJcbiAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgICAgICBzd2l0Y2ggKGspIHtcclxuICAgICAgICBjYXNlICdSZWdpb24nOlxyXG4gICAgICAgICAgLy8gMy4zIFdlYlZUVCByZWdpb24gbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3BhcnNlIHJlZ2lvbicsIHYpO1xyXG4gICAgICAgICAgLy8gcGFyc2VSZWdpb24odik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH0sIC86Lyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXHJcbiAgICB0cnkge1xyXG4gICAgICBsZXQgbGluZTtcclxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJykge1xyXG4gICAgICAgIC8vIFdlIGNhbid0IHN0YXJ0IHBhcnNpbmcgdW50aWwgd2UgaGF2ZSB0aGUgZmlyc3QgbGluZS5cclxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XHJcbiAgICAgICAgLy8gc3RyaXAgb2YgVVRGLTggQk9NIGlmIGFueVxyXG4gICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0J5dGVfb3JkZXJfbWFyayNVVEYtOFxyXG4gICAgICAgIGxldCBtID0gbGluZS5tYXRjaCgvXijDr8K7wr8pP1dFQlZUVChbIFxcdF0uKik/JC8pO1xyXG4gICAgICAgIGlmICghbSB8fCAhbVswXSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYuc3RhdGUgPSAnSEVBREVSJztcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XHJcbiAgICAgIHdoaWxlIChzZWxmLmJ1ZmZlcikge1xyXG4gICAgICAgIC8vIFdlIGNhbid0IHBhcnNlIGEgbGluZSB1bnRpbCB3ZSBoYXZlIHRoZSBmdWxsIGxpbmUuXHJcbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChzZWxmLmJ1ZmZlcikpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFhbHJlYWR5Q29sbGVjdGVkTGluZSkge1xyXG4gICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3dpdGNoIChzZWxmLnN0YXRlKSB7XHJcbiAgICAgICAgY2FzZSAnSEVBREVSJzpcclxuICAgICAgICAgIC8vIDEzLTE4IC0gQWxsb3cgYSBoZWFkZXIgKG1ldGFkYXRhKSB1bmRlciB0aGUgV0VCVlRUIGxpbmUuXHJcbiAgICAgICAgICBpZiAoLzovLnRlc3QobGluZSkpIHtcclxuICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCFsaW5lKSB7XHJcbiAgICAgICAgICAgIC8vIEFuIGVtcHR5IGxpbmUgdGVybWluYXRlcyB0aGUgaGVhZGVyIGFuZCBzdGFydHMgdGhlIGJvZHkgKGN1ZXMpLlxyXG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGNhc2UgJ05PVEUnOlxyXG4gICAgICAgICAgLy8gSWdub3JlIE5PVEUgYmxvY2tzLlxyXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XHJcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGNhc2UgJ0lEJzpcclxuICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgTk9URSBibG9ja3MuXHJcbiAgICAgICAgICBpZiAoL15OT1RFKCR8WyBcXHRdKS8udGVzdChsaW5lKSkge1xyXG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gJ05PVEUnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIDE5LTI5IC0gQWxsb3cgYW55IG51bWJlciBvZiBsaW5lIHRlcm1pbmF0b3JzLCB0aGVuIGluaXRpYWxpemUgbmV3IGN1ZSB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAoIWxpbmUpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc2VsZi5jdWUgPSBuZXcgVlRUQ3VlKDAsIDAsICcnKTtcclxuICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQ1VFJztcclxuICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXHJcbiAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCctLT4nKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgc2VsZi5jdWUuaWQgPSBsaW5lO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIFByb2Nlc3MgbGluZSBhcyBzdGFydCBvZiBhIGN1ZS5cclxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICBjYXNlICdDVUUnOlxyXG4gICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHBhcnNlQ3VlKGxpbmUsIHNlbGYuY3VlLCBzZWxmLnJlZ2lvbkxpc3QpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXHJcbiAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcclxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdCQURDVUUnO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQ1VFVEVYVCc7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBjYXNlICdDVUVURVhUJzpcclxuICAgICAgICAgIHZhciBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoJy0tPicpICE9PSAtMTtcclxuICAgICAgICAgIC8vIDM0IC0gSWYgd2UgaGF2ZSBhbiBlbXB0eSBsaW5lIHRoZW4gcmVwb3J0IHRoZSBjdWUuXHJcbiAgICAgICAgICAvLyAzNSAtIElmIHdlIGhhdmUgdGhlIHNwZWNpYWwgc3Vic3RyaW5nICctLT4nIHRoZW4gcmVwb3J0IHRoZSBjdWUsXHJcbiAgICAgICAgICAvLyBidXQgZG8gbm90IGNvbGxlY3QgdGhlIGxpbmUgYXMgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBjdXJyZW50XHJcbiAgICAgICAgICAvLyBvbmUgYXMgYSBuZXcgY3VlLlxyXG4gICAgICAgICAgaWYgKCFsaW5lIHx8IGhhc1N1YnN0cmluZyAmJiAoYWxyZWFkeUNvbGxlY3RlZExpbmUgPSB0cnVlKSkge1xyXG4gICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBwYXJzaW5nIHNlbGYgY3VlLlxyXG4gICAgICAgICAgICBpZiAoc2VsZi5vbmN1ZSkge1xyXG4gICAgICAgICAgICAgIHNlbGYub25jdWUoc2VsZi5jdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLmN1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChzZWxmLmN1ZS50ZXh0KSB7XHJcbiAgICAgICAgICAgIHNlbGYuY3VlLnRleHQgKz0gJ1xcbic7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc2VsZi5jdWUudGV4dCArPSBsaW5lO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgY2FzZSAnQkFEQ1VFJzogLy8gQkFEQ1VFXHJcbiAgICAgICAgICAvLyA1NC02MiAtIENvbGxlY3QgYW5kIGRpc2NhcmQgdGhlIHJlbWFpbmluZyBjdWUuXHJcbiAgICAgICAgICBpZiAoIWxpbmUpIHtcclxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGFyc2luZyBhIGN1ZSwgcmVwb3J0IHdoYXQgd2UgaGF2ZS5cclxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdDVUVURVhUJyAmJiBzZWxmLmN1ZSAmJiBzZWxmLm9uY3VlKSB7XHJcbiAgICAgICAgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYuY3VlID0gbnVsbDtcclxuICAgICAgLy8gRW50ZXIgQkFEV0VCVlRUIHN0YXRlIGlmIGhlYWRlciB3YXMgbm90IHBhcnNlZCBjb3JyZWN0bHkgb3RoZXJ3aXNlXHJcbiAgICAgIC8vIGFub3RoZXIgZXhjZXB0aW9uIG9jY3VycmVkIHNvIGVudGVyIEJBRENVRSBzdGF0ZS5cclxuICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJyA/ICdCQURXRUJWVFQnIDogJ0JBRENVRSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG4gIGZsdXNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cclxuICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZSgpO1xyXG4gICAgICAvLyBTeW50aGVzaXplIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgY3VlIG9yIHJlZ2lvbi5cclxuICAgICAgaWYgKHNlbGYuY3VlIHx8IHNlbGYuc3RhdGUgPT09ICdIRUFERVInKSB7XHJcbiAgICAgICAgc2VsZi5idWZmZXIgKz0gJ1xcblxcbic7XHJcbiAgICAgICAgc2VsZi5wYXJzZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIElmIHdlJ3ZlIGZsdXNoZWQsIHBhcnNlZCwgYW5kIHdlJ3JlIHN0aWxsIG9uIHRoZSBJTklUSUFMIHN0YXRlIHRoZW5cclxuICAgICAgLy8gdGhhdCBtZWFucyB3ZSBkb24ndCBoYXZlIGVub3VnaCBvZiB0aGUgc3RyZWFtIHRvIHBhcnNlIHRoZSBmaXJzdFxyXG4gICAgICAvLyBsaW5lLlxyXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gJ0lOSVRJQUwnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG4gICAgaWYgKHNlbGYub25mbHVzaCkge1xyXG4gICAgICBzZWxmLm9uZmx1c2goKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgeyBmaXhMaW5lQnJlYWtzIH07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBWVFRQYXJzZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3V0aWxzL3Z0dHBhcnNlci5qcyIsIi8qKlxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9OYXZpZ2F0b3IvcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXHJcbiAqL1xyXG5leHBvcnQgZW51bSBLZXlTeXN0ZW1zIHtcclxuICBXSURFVklORSA9ICdjb20ud2lkZXZpbmUuYWxwaGEnLFxyXG4gIFBMQVlSRUFEWSA9ICdjb20ubWljcm9zb2Z0LnBsYXlyZWFkeScsXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIE1lZGlhS2V5RnVuYyA9IChrZXlTeXN0ZW06IEtleVN5c3RlbXMsIHN1cHBvcnRlZENvbmZpZ3VyYXRpb25zOiBNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25bXSkgPT4gUHJvbWlzZTxNZWRpYUtleVN5c3RlbUFjY2Vzcz47XHJcbmNvbnN0IHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IChmdW5jdGlvbiAoKTogTWVkaWFLZXlGdW5jIHwgbnVsbCB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcclxuICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcy5iaW5kKHdpbmRvdy5uYXZpZ2F0b3IpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn0pKCk7XHJcblxyXG5leHBvcnQge1xyXG4gIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy91dGlscy9tZWRpYWtleXMtaGVscGVyLnRzIiwidmFyIHZqc1BsdWdpbiA9IHJlcXVpcmUoJy4vdmlkZW9qcy1obHNqcy1wbHVnaW4uanMnKTtcclxuXHJcbmlmICh3aW5kb3cudmlkZW9qcykge1xyXG4gICAgdmpzUGx1Z2luLnJlZ2lzdGVyQ29uZmlnUGx1Z2luKHdpbmRvdy52aWRlb2pzKTtcclxuICAgIHZqc1BsdWdpbi5yZWdpc3RlclNvdXJjZUhhbmRsZXIod2luZG93LnZpZGVvanMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgcmVnaXN0ZXI6IHZqc1BsdWdpbi5yZWdpc3RlclNvdXJjZUhhbmRsZXIgfTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL21haW4uanMiLCJ2YXIgSGxzanMgPSByZXF1aXJlKCdobHMuanMnKS5kZWZhdWx0O1xudmFyIFhockFlc0xvYWRlciA9IHJlcXVpcmUoJ2hscy5qcy9zcmMvdXRpbHMveGhyLWFlcy1sb2FkZXInKS5kZWZhdWx0O1xuXG52YXIgcmVnaXN0ZXJTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24gKHZpZGVvanMpIHtcbiAgICB2YXIgaG9va3MgPSB7fTtcblxuICAgIGZ1bmN0aW9uIEh0bWw1SGxzanMoc291cmNlLCB0ZWNoKSB7XG4gICAgICAgIHRlY2gubmFtZV8gPSAnU3RyZWFtcm9vdEhsc2pzJztcblxuICAgICAgICB2YXIgX3ZpZGVvID0gdGVjaC5lbCgpO1xuICAgICAgICB2YXIgX2hscztcbiAgICAgICAgdmFyIF9lcnJvckNvdW50cyA9IHt9O1xuICAgICAgICB2YXIgX2R1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgdmFyIF9kdnJjaGVjaztcbiAgICAgICAgdmFyIF9tZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHZhciBfcGxheWVyID0gdmlkZW9qcyh0ZWNoLm9wdGlvbnNfLnBsYXllcklkKTtcblxuICAgICAgICBmdW5jdGlvbiBfZXhlY3V0ZUhvb2tzRm9yKHR5cGUpIHtcbiAgICAgICAgICAgIGlmIChob29rc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFUzMgYW5kIElFIDwgOVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1t0eXBlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGhvb2tzW3R5cGVdW2ldKF9wbGF5ZXIsIF9obHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX2hhbmRsZU1lZGlhRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghX2Vycm9yQ291bnRzW0hsc2pzLkVycm9yVHlwZXMuTUVESUFfRVJST1JdIHx8IF9lcnJvckNvdW50c1tIbHNqcy5FcnJvclR5cGVzLk1FRElBX0VSUk9SXSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCd0cnlpbmcgdG8gcmVjb3ZlciBtZWRpYSBlcnJvcicpO1xuICAgICAgICAgICAgICAgIF9obHMuZGVzdHJveSgpXG4gICAgICAgICAgICAgICAgX2hscy5zdGFydExvYWQoLTEpO1xuICAgICAgICAgICAgICAgIF9obHMucmVjb3Zlck1lZGlhRXJyb3IoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2Vycm9yQ291bnRzW0hsc2pzLkVycm9yVHlwZXMuTUVESUFfRVJST1JdID09PSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCcybmQgdHJ5IHRvIHJlY292ZXIgbWVkaWEgZXJyb3IgKGJ5IHN3YXBwaW5nIGF1ZGlvIGNvZGVjJyk7XG4gICAgICAgICAgICAgICAgX2hscy5zd2FwQXVkaW9Db2RlYygpO1xuICAgICAgICAgICAgICAgIF9obHMucmVjb3Zlck1lZGlhRXJyb3IoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2Vycm9yQ291bnRzW0hsc2pzLkVycm9yVHlwZXMuTUVESUFfRVJST1JdID4gMikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnYnViYmxpbmcgbWVkaWEgZXJyb3IgdXAgdG8gVklERU9KUycpO1xuICAgICAgICAgICAgICAgIHRlY2guZXJyb3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcjsgfTtcbiAgICAgICAgICAgICAgICB0ZWNoLnRyaWdnZXIoJ2Vycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgnSExTLmpzIGVycm9yOiAnICsgZGF0YS50eXBlICsgJyAtIGZhdGFsOiAnICsgZGF0YS5mYXRhbCArICcgLSAnICsgZGF0YS5kZXRhaWxzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG5cbiAgICAgICAgICAgIC8vIGluY3JlbWVudC9zZXQgZXJyb3IgY291bnRcbiAgICAgICAgICAgIGlmIChfZXJyb3JDb3VudHNbZGF0YS50eXBlXSkge1xuICAgICAgICAgICAgICAgIF9lcnJvckNvdW50c1tkYXRhLnR5cGVdICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9lcnJvckNvdW50c1tkYXRhLnR5cGVdID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW1wbGVtZW50IHNpbXBsZSBlcnJvciBoYW5kbGluZyBiYXNlZCBvbiBobHMuanMgZG9jdW1lbnRhdGlvbiAoaHR0cHM6Ly9naXRodWIuY29tL2RhaWx5bW90aW9uL2hscy5qcy9ibG9iL21hc3Rlci9BUEkubWQjZmlmdGgtc3RlcC1lcnJvci1oYW5kbGluZylcbiAgICAgICAgICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBIbHNqcy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ2J1YmJsaW5nIG5ldHdvcmsgZXJyb3IgdXAgdG8gVklERU9KUycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWNoLmVycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3I7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWNoLnRyaWdnZXIoJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIEhsc2pzLkVycm9yVHlwZXMuTUVESUFfRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oYW5kbGVNZWRpYUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW5ub3QgcmVjb3ZlclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hscy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ2J1YmJsaW5nIGVycm9yIHVwIHRvIFZJREVPSlMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlY2guZXJyb3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcjsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlY2gudHJpZ2dlcignZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHN3aXRjaFF1YWxpdHkocXVhbGl0eUlkKSB7XG4gICAgICAgICAgICBpZiAoX2hscy5jb25maWcubGV2ZWxTd2l0Y2hTdHJhdGVneSAmJiBfaGxzLmNvbmZpZy5sZXZlbFN3aXRjaFN0cmF0ZWd5ID09PSAnaW5zdGFudCcpIHtcbiAgICAgICAgICAgICAgICBfaGxzLmN1cnJlbnRMZXZlbCA9IHF1YWxpdHlJZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2hscy5jb25maWcubGV2ZWxTd2l0Y2hTdHJhdGVneSAmJiBfaGxzLmNvbmZpZy5sZXZlbFN3aXRjaFN0cmF0ZWd5ID09PSAnc21vb3RoJykge1xuICAgICAgICAgICAgICAgIF9obHMubmV4dExldmVsID0gcXVhbGl0eUlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfaGxzLmxvYWRMZXZlbCA9IHF1YWxpdHlJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9sZXZlbExhYmVsKGxldmVsKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwuaGVpZ2h0KSByZXR1cm4gbGV2ZWwuaGVpZ2h0ICsgJ3AnO1xuICAgICAgICAgICAgZWxzZSBpZiAobGV2ZWwud2lkdGgpIHJldHVybiBNYXRoLnJvdW5kKGxldmVsLndpZHRoICogOSAvIDE2KSArICdwJztcbiAgICAgICAgICAgIGVsc2UgaWYgKGxldmVsLmJpdHJhdGUpIHJldHVybiAobGV2ZWwuYml0cmF0ZSAvIDEwMDApICsgJ2ticHMnO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfbm90aWZ5VmlkZW9RdWFsaXRpZXMoKSB7XG4gICAgICAgICAgICBpZiAoX21ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsZWFuVHJhY2tsaXN0ID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoX21ldGFkYXRhLmxldmVscy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdXRvTGV2ZWwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ2F1dG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IF9obHMubWFudWFsTGV2ZWwgPT09IC0xXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuVHJhY2tsaXN0LnB1c2goYXV0b0xldmVsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbWV0YWRhdGEubGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXVhbGl0eSA9IHt9OyAvLyBEb24ndCB3cml0ZSBpbiBsZXZlbCAoc2hhcmVkIHJlZmVyZW5jZSB3aXRoIEhscy5qcylcbiAgICAgICAgICAgICAgICAgICAgcXVhbGl0eS5pZCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBxdWFsaXR5LnNlbGVjdGVkID0gaW5kZXggPT09IF9obHMubWFudWFsTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIHF1YWxpdHkubGFiZWwgPSBfbGV2ZWxMYWJlbChsZXZlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xlYW5UcmFja2xpc3QucHVzaChxdWFsaXR5KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICBxdWFsaXR5RGF0YTogeyB2aWRlbzogY2xlYW5UcmFja2xpc3QgfSxcbiAgICAgICAgICAgICAgICAgICAgcXVhbGl0eVN3aXRjaENhbGxiYWNrOiBzd2l0Y2hRdWFsaXR5XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRlY2gudHJpZ2dlcignbG9hZGVkcXVhbGl0eWRhdGEnLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgICAgIC8vIFNlbGYtZGUtcmVnaXN0ZXIgc28gd2UgZG9uJ3QgcmFpc2UgdGhlIHBheWxvYWQgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgICAgICBfdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheWluZycsIF9ub3RpZnlWaWRlb1F1YWxpdGllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfdXBkYXRlSGxzanNBdWRpb1RyYWNrKCkge1xuICAgICAgICAgICAgdmFyIHBsYXllckF1ZGlvVHJhY2tzID0gdGVjaC5hdWRpb1RyYWNrcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwbGF5ZXJBdWRpb1RyYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChwbGF5ZXJBdWRpb1RyYWNrc1tqXS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9obHMuYXVkaW9UcmFjayA9IGo7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9vbkF1ZGlvVHJhY2tzKCkge1xuICAgICAgICAgICAgdmFyIGhsc0F1ZGlvVHJhY2tzID0gX2hscy5hdWRpb1RyYWNrcztcbiAgICAgICAgICAgIHZhciBwbGF5ZXJBdWRpb1RyYWNrcyA9IHRlY2guYXVkaW9UcmFja3MoKTtcbiAgICAgICAgICAgIGlmIChobHNBdWRpb1RyYWNrcy5sZW5ndGggPiAxICYmIHBsYXllckF1ZGlvVHJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBIbHMuanMgYXVkaW8gdHJhY2tzIGlmIG5vdCBhZGRlZCB5ZXRcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhsc0F1ZGlvVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllckF1ZGlvVHJhY2tzLmFkZFRyYWNrKG5ldyB2aWRlb2pzLkF1ZGlvVHJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiAnYWx0ZXJuYXRpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGhsc0F1ZGlvVHJhY2tzW2ldLm5hbWUgfHwgaGxzQXVkaW9UcmFja3NbaV0ubGFuZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBobHNBdWRpb1RyYWNrc1tpXS5sYW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogaSA9PT0gX2hscy5hdWRpb1RyYWNrXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYXVkaW8gdHJhY2sgY2hhbmdlIGV2ZW50XG4gICAgICAgICAgICAgICAgcGxheWVyQXVkaW9UcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgX3VwZGF0ZUhsc2pzQXVkaW9UcmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfdXBkYXRlSGxzanNUZXh0VHJhY2soKSB7XG4gICAgICAgICAgICB2YXIgcGxheWVyVGV4dFRyYWNrcyA9IF9wbGF5ZXIudGV4dFRyYWNrcygpO1xuICAgICAgICAgICAgdmFyIGFjdGl2ZVRyYWNrID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGxheWVyVGV4dFRyYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChwbGF5ZXJUZXh0VHJhY2tzW2pdLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUcmFjayA9IHBsYXllclRleHRUcmFja3Nbal07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhsc2pzVHJhY2tzID0gX3ZpZGVvLnRleHRUcmFja3M7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGhsc2pzVHJhY2tzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhsc2pzVHJhY2tzW2tdLmtpbmQgPT09ICdzdWJ0aXRsZXMnIHx8IGhsc2pzVHJhY2tzW2tdLmtpbmQgPT09ICdjYXB0aW9ucycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogbGFiZWwgaGVyZSBpcyByZWFkYWJsZSBsYWJlbCBhbmQgaXMgb3B0aW9uYWwgKHVzZWQgaW4gdGhlIFVJIHNvIGlmIGl0IGlzIHRoZXJlIGl0IGhhcyB0byBiZSBkaWZmZXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHZhciBobHNUcmFja0lkID0gaGxzanNUcmFja3Nba10ubGFiZWwgPyBobHNqc1RyYWNrc1trXS5sYWJlbCA6IGhsc2pzVHJhY2tzW2tdLmxhbmd1YWdlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmpzVHJhY2tJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVUcmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmpzVHJhY2tJZCA9IGFjdGl2ZVRyYWNrLmxhYmVsID8gYWN0aXZlVHJhY2subGFiZWwgOiBhY3RpdmVUcmFjay5sYW5ndWFnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBobHNqc1RyYWNrc1trXS5tb2RlID0gaGxzVHJhY2tJZCA9PT0gdmpzVHJhY2tJZCA/ICdzaG93aW5nJyA6ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfc3RvcExvYWRpbmdDaHVua3MoKSB7XG4gICAgICAgICAgICBfaGxzLnN0b3BMb2FkKCk7XG4gICAgICAgICAgICBpZiAoX3ZpZGVvLmlzTGl2ZSkge1xuICAgICAgICAgICAgICAgIC8vIFBMQVlFUi0xMjogb24gcGxheSB3ZSBuZWVkIHRvIGxvYWQgYmFjayBobHMgY2h1bmtzIGFuZCBtb3ZlIGZvcndhcmQgc28gd2UgZG9uJ3QgYnVmZmVyXG4gICAgICAgICAgICAgICAgX3ZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCBfbG9hZE1hbmlmZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9sb2FkTWFuaWZlc3QoKSB7XG4gICAgICAgICAgICAvLyBfaW5pdEhsc2pzKClcbiAgICAgICAgICAgIF9obHMucmVjb3Zlck1lZGlhRXJyb3IoKTtcbiAgICAgICAgICAgIF92aWRlby5wbGF5KCk7XG4gICAgICAgICAgICBfdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheScsIF9sb2FkTWFuaWZlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX3N0YXJ0TG9hZCgpIHtcbiAgICAgICAgICAgIF9obHMuc3RhcnRMb2FkKC0xKTtcbiAgICAgICAgICAgIF92aWRlby5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5JywgX3N0YXJ0TG9hZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfb25lTGV2ZWxPYmpDbG9uZShvYmopIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmpLZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtvYmpLZXlzW2ldXSA9IG9ialtvYmpLZXlzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfZmlsdGVyVGV4dFRyYWNrcyh0ZXh0VHJhY2tzKSB7XG4gICAgICAgICAgICB2YXIgZGlzcGxheWFibGVUcmFja3MgPSBbXTtcblxuICAgICAgICAgICAgLy8gRmlsdGVyIG91dCB0cmFja3MgdGhhdCBpcyBkaXNwbGF5YWJsZSAoY2FwdGlvbnMgb3Igc3VidGl0bHRlcylcbiAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHRleHRUcmFja3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0VHJhY2tzW2lkeF0ua2luZCA9PT0gJ3N1YnRpdGxlcycgfHwgdGV4dFRyYWNrc1tpZHhdLmtpbmQgPT09ICdjYXB0aW9ucycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheWFibGVUcmFja3MucHVzaCh0ZXh0VHJhY2tzW2lkeF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlhYmxlVHJhY2tzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX29uQWRkVGV4dFRyYWNrKCkge1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlhYmxlVHJhY2tzID0gX2ZpbHRlclRleHRUcmFja3MoX3ZpZGVvLnRleHRUcmFja3MpO1xuICAgICAgICAgICAgdmFyIHBsYXllclRleHRUcmFja3MgPSBfcGxheWVyLnRleHRUcmFja3MoKTtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5YWJsZVRyYWNrcy5sZW5ndGggPiAwICYmIHBsYXllclRleHRUcmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHN0dWJzIHRvIG1ha2UgdGhlIGNhcHRpb24gc3dpdGNoZXIgc2hvd3MgdXBcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBBZGRpbmcgdGhlIEhscy5qcyB0ZXh0IHRyYWNrIGluIHdpbGwgbWFrZSB1cyBoYXZlIGRvdWJsZSBjYXB0aW9uc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGRpc3BsYXlhYmxlVHJhY2tzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhsc2pzVGV4dFRyYWNrID0gZGlzcGxheWFibGVUcmFja3NbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgX3BsYXllci5hZGRSZW1vdGVUZXh0VHJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGhsc2pzVGV4dFRyYWNrLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2U6IGhsc2pzVGV4dFRyYWNrLmxhbmd1YWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjbGFuZzogaGxzanNUZXh0VHJhY2subGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBVSSBzd2l0Y2hpbmdcbiAgICAgICAgICAgICAgICBwbGF5ZXJUZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIF91cGRhdGVIbHNqc1RleHRUcmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX29uTGV2ZWxMb2FkIChldmVudCwgZGF0YSkgeyBcbiAgICAgICAgICAgIHRlY2gudHJpZ2dlcihcImhsc2xldmVsbG9hZGVkXCIsZGF0YSk7IFxuICAgICAgICAgICAgX2R1cmF0aW9uID0gZGF0YS5kZXRhaWxzLmxpdmUgPyBJbmZpbml0eSA6IGRhdGEuZGV0YWlscy50b3RhbGR1cmF0aW9uOyBcbiAgICAgICAgICAgIGlmICh0eXBlb2YgX2R2cmNoZWNrID09PSAndW5kZWZpbmVkJyAmJiBkYXRhLmRldGFpbHMubGl2ZSAmJiBfaGxzLnN0cmVhbUNvbnRyb2xsZXIubGFzdEN1cnJlbnRUaW1lID4gIChfaGxzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExvYWRQb3NpdGlvbiAtIF9obHMuc3RyZWFtQ29udHJvbGxlci5sYXN0Q3VycmVudFRpbWUpICogMTApIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGJlZm9yZSBtb3JlIHRoYW4gMTAgY2h1bmtzIC0gaXRzIERWUiAobGl2ZSBzdHJlYW0gdXN1YWxseSBoYXMgMyBjaHVuY2tzIGluIG0zdTgpXG4gICAgICAgICAgICAgICAgdGVjaC50cmlnZ2VyKCdkdnJzb3VyY2VkZXRlY3RlZCcpXG4gICAgICAgICAgICB9IGVsc2UgaWYoZGF0YS5kZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBQTEFZRVItMTI6IHdlIG5lZWQgdG8ga2VlcCB0aGUgbWluaW11bSBidWZmZXIgcG9zc2libGUgZm9yIGxpdmUgbGlrZSAzMCBzZWNvbmRzXG4gICAgICAgICAgICAgICAgX2hscy5jb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID0gMzA7XG4gICAgICAgICAgICAgICAgX3ZpZGVvLmlzTGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZHZyY2hlY2sgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX29uTWV0YURhdGEoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY291bGQgYXJyaXZlIGJlZm9yZSAnbG9hZGVkcXVhbGl0eWRhdGEnIGhhbmRsZXJzIGlzIHJlZ2lzdGVyZWQsIHJlbWVtYmVyIGl0IHNvIHdlIGNhbiByYWlzZSBpdCBsYXRlclxuICAgICAgICAgICAgX21ldGFkYXRhID0gZGF0YTtcbiAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBub3RpZnkgYWJvdXQgcXVhbGl0eWRhdGEgdHdpY2UgYmVjYXVzZSBcImxvYWRlZHF1YWxpdHlkYXRhXCIgbWVhbiB0aGF0IG1hbmlmZXN0IHdhcyBsb2FkZWQuIGl0IG11c3QgaGFwcGVuIGJlZm9yZSBwbGF5XG4gICAgICAgICAgIF9ub3RpZnlWaWRlb1F1YWxpdGllcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX2luaXRIbHNqcygpIHtcbiAgICAgICAgICAgIHZhciBobHNqc0NvbmZpZ1JlZiA9IHRlY2gub3B0aW9uc18uaGxzanNDb25maWc7XG4gICAgICAgICAgICAvLyBOT1RFOiBIbHMuanMgd2lsbCB3cml0ZSB0byB0aGUgcmVmZXJlbmNlIHRodXMgY2hhbmdlIHRoZSBvYmplY3QgZm9yIGxhdGVyIHN0cmVhbXNcbiAgICAgICAgICAgIHZhciBobHNqc0NvbmZpZyA9IGhsc2pzQ29uZmlnUmVmID8gX29uZUxldmVsT2JqQ2xvbmUoaGxzanNDb25maWdSZWYpIDoge307XG4gICAgICAgICAgICBpZiAoaGxzanNDb25maWcuYWVzU2V0dXAgJiYgaGxzanNDb25maWcuYWVzU2V0dXAua2V5ICYmIGhsc2pzQ29uZmlnLmFlc1NldHVwLml2KSB7XG4gICAgICAgICAgICAgICAgaGxzanNDb25maWcucExvYWRlciA9IFhockFlc0xvYWRlclxuICAgICAgICAgICAgICAgIGhsc2pzQ29uZmlnLmZMb2FkZXIgPSBYaHJBZXNMb2FkZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChbJycsICdhdXRvJ10uaW5kZXhPZihfdmlkZW8ucHJlbG9hZCkgPT09IC0xICYmICFfdmlkZW8uYXV0b3BsYXkgJiYgaGxzanNDb25maWcuYXV0b1N0YXJ0TG9hZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaGxzanNDb25maWcuYXV0b1N0YXJ0TG9hZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBleHBsaWNpdGVseSBzZXRzIGF1dG9TdGFydExvYWQgdG8gZmFsc2UsIHdlJ3JlIG5vdCBnb2luZyB0byBlbnRlciB0aGUgaWYgYmxvY2sgYWJvdmUsIHRoYXQncyB3aHkgd2UgaGF2ZSBhIHNlcGFyYXRlIGlmIGJsb2NrIGhlcmUgdG8gc2V0IHRoZSAncGxheScgbGlzdGVuZXJcbiAgICAgICAgICAgIGlmIChobHNqc0NvbmZpZy5hdXRvU3RhcnRMb2FkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIF92aWRlby5hZGRFdmVudExpc3RlbmVyKCdwbGF5JywgX3N0YXJ0TG9hZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiBydW5uaW5nIHRoaXMgYWZ0ZXIgZ2VuZXJhdGluZyB0ZXh0IHRyYWNrIGxpc3Qgd2lsbCByYWlzZSBhbiBlcnJvciBpbnNpZGUgSGxzLmpzICh0b28gZWFybHkgcGVyaGFwcylcbiAgICAgICAgICAgIF92aWRlby5hZGRFdmVudExpc3RlbmVyKCdwbGF5JywgX3VwZGF0ZUhsc2pzVGV4dFRyYWNrKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3RvcCBsb2FkaW5nIGNodW5rcyBvbiBwYXVzZSBcbiAgICAgICAgICAgIF92aWRlby5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIF9zdG9wTG9hZGluZ0NodW5rcyk7XG5cbiAgICAgICAgICAgIC8vIF9ub3RpZnlWaWRlb1F1YWxpdGllcyBzb21ldGltZXMgcnVucyBiZWZvcmUgdGhlIHF1YWxpdHkgcGlja2VyIGV2ZW50IGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCAtPiBubyB2aWRlbyBzd2l0Y2hlclxuICAgICAgICAgICAgX3ZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCBfbm90aWZ5VmlkZW9RdWFsaXRpZXMpO1xuXG4gICAgICAgICAgICBfaGxzID0gbmV3IEhsc2pzKGhsc2pzQ29uZmlnKTtcblxuICAgICAgICAgICAgX2V4ZWN1dGVIb29rc0ZvcignYmVmb3JlaW5pdGlhbGl6ZScpO1xuXG4gICAgICAgICAgICBfaGxzLm9uKEhsc2pzLkV2ZW50cy5FUlJPUiwgZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7IF9vbkVycm9yKGV2ZW50LCBkYXRhLCB0ZWNoLCBfZXJyb3JDb3VudHMpOyB9KTtcbiAgICAgICAgICAgIF9obHMub24oSGxzanMuRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgX29uQXVkaW9UcmFja3MpO1xuICAgICAgICAgICAgX2hscy5vbihIbHNqcy5FdmVudHMuTUFOSUZFU1RfUEFSU0VELCBfb25NZXRhRGF0YSk7XG4gICAgICAgICAgICBfaGxzLm9uKEhsc2pzLkV2ZW50cy5MRVZFTF9MT0FERUQsIF9vbkxldmVsTG9hZCk7XG4gICAgICAgICAgICBfaGxzLm9uKEhsc2pzLkV2ZW50cy5MRVZFTF9TV0lUQ0hFRCwgZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7IHRlY2gudHJpZ2dlcihcImhsc2xldmVsc3dpdGNoZWRcIixkYXRhKTt9KTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIHRleHQgdHJhY2tzXG4gICAgICAgICAgICBfaGxzLm9uKEhsc2pzLkV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIF9vbkFkZFRleHRUcmFjayk7XG5cbiAgICAgICAgICAgIF9obHMuYXR0YWNoTWVkaWEoX3ZpZGVvKTtcbiAgICAgICAgICAgIF9obHMubG9hZFNvdXJjZShzb3VyY2Uuc3JjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgICAgICAgICBfaW5pdEhsc2pzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRRdWFsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfaGxzLmxldmVsQ29udHJvbGxlci5sZXZlbHNbX2hscy5sZXZlbENvbnRyb2xsZXIubGV2ZWxdXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfZHVyYXRpb24gfHwgX3ZpZGVvLmR1cmF0aW9uIHx8IDA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKF9obHMuY29uZmlnLCBjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VlIGNvbW1lbnQgZm9yIGBpbml0aWFsaXplYCBtZXRob2QuXG4gICAgICAgIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF92aWRlby5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5JywgX3N0YXJ0TG9hZCk7XG4gICAgICAgICAgICBfdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheScsIF91cGRhdGVIbHNqc1RleHRUcmFjayk7XG4gICAgICAgICAgICBfdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheWluZycsIF9ub3RpZnlWaWRlb1F1YWxpdGllcyk7XG5cbiAgICAgICAgICAgIF9wbGF5ZXIudGV4dFRyYWNrcygpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIF91cGRhdGVIbHNqc1RleHRUcmFjayk7XG4gICAgICAgICAgICBfcGxheWVyLmF1ZGlvVHJhY2tzKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgX3VwZGF0ZUhsc2pzQXVkaW9UcmFjayk7XG5cbiAgICAgICAgICAgIF9obHMuZGVzdHJveSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF92aWRlby5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIHZhciBlcnJvclR4dCxcbiAgICAgICAgICAgICAgICBtZWRpYUVycm9yID0gZXZ0LmN1cnJlbnRUYXJnZXQuZXJyb3I7XG5cbiAgICAgICAgICAgIHN3aXRjaCAobWVkaWFFcnJvci5jb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBtZWRpYUVycm9yLk1FRElBX0VSUl9BQk9SVEVEOlxuICAgICAgICAgICAgICAgICAgICBlcnJvclR4dCA9ICdZb3UgYWJvcnRlZCB0aGUgdmlkZW8gcGxheWJhY2snO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIG1lZGlhRXJyb3IuTUVESUFfRVJSX0RFQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JUeHQgPSAnVGhlIHZpZGVvIHBsYXliYWNrIHdhcyBhYm9ydGVkIGR1ZSB0byBhIGNvcnJ1cHRpb24gcHJvYmxlbSBvciBiZWNhdXNlIHRoZSB2aWRlbyB1c2VkIGZlYXR1cmVzIHlvdXIgYnJvd3NlciBkaWQgbm90IHN1cHBvcnQnO1xuICAgICAgICAgICAgICAgICAgICBfaGFuZGxlTWVkaWFFcnJvcihtZWRpYUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBtZWRpYUVycm9yLk1FRElBX0VSUl9ORVRXT1JLOlxuICAgICAgICAgICAgICAgICAgICBlcnJvclR4dCA9ICdBIG5ldHdvcmsgZXJyb3IgY2F1c2VkIHRoZSB2aWRlbyBkb3dubG9hZCB0byBmYWlsIHBhcnQtd2F5JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBtZWRpYUVycm9yLk1FRElBX0VSUl9TUkNfTk9UX1NVUFBPUlRFRDpcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JUeHQgPSAnVGhlIHZpZGVvIGNvdWxkIG5vdCBiZSBsb2FkZWQsIGVpdGhlciBiZWNhdXNlIHRoZSBzZXJ2ZXIgb3IgbmV0d29yayBmYWlsZWQgb3IgYmVjYXVzZSB0aGUgZm9ybWF0IGlzIG5vdCBzdXBwb3J0ZWQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGVycm9yVHh0ID0gbWVkaWFFcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdNRURJQV9FUlJPUjogJywgZXJyb3JUeHQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgSHRtbDVIbHNqcy5hZGRIb29rID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tzW3R5cGVdID0gaG9va3NbdHlwZV0gfHwgW107XG4gICAgICAgIGhvb2tzW3R5cGVdLnB1c2goY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBIdG1sNUhsc2pzLnJlbW92ZUhvb2sgPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGhvb2tzW3R5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IGhvb2tzW3R5cGVdLmluZGV4T2YoY2FsbGJhY2spO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhvb2tzW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBpZiAoSGxzanMuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICB2YXIgaHRtbDU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2aWRlb2pzLmdldFRlY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGh0bWw1ID0gdmlkZW9qcy5nZXRUZWNoKCdIdG1sNScpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2aWRlb2pzLmdldENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaHRtbDUgPSB2aWRlb2pzLmdldENvbXBvbmVudCgnSHRtbDUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vdCBzdXBwb3J0ZWQgdmVyc2lvbiBpZiB2aWRlby5qcycpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWh0bWw1KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdOb3Qgc3VwcG9ydGVkIHZlcnNpb24gaWYgdmlkZW8uanMnKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaHRtbDUucmVnaXN0ZXJTb3VyY2VIYW5kbGVyKHtcbiAgICAgICAgICAgIGNhbkhhbmRsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHZhciBobHNUeXBlUkUgPSAvXmFwcGxpY2F0aW9uXFwveC1tcGVnVVJMJC9pO1xuICAgICAgICAgICAgICAgIHZhciBobHNFeHRSRSA9IC9cXC5tM3U4L2k7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGlmIChobHNUeXBlUkUudGVzdChzb3VyY2UudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJ3Byb2JhYmx5JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhsc0V4dFJFLnRlc3Qoc291cmNlLnNyYykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJ21heWJlJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgdGVjaCkge1xuICAgICAgICAgICAgICAgIGlmICh0ZWNoLmhsc1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlY2guaGxzUHJvdmlkZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRlY2guaGxzUHJvdmlkZXIgPSBuZXcgSHRtbDVIbHNqcyhzb3VyY2UsIHRlY2gpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlY2guaGxzUHJvdmlkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIHZpZGVvanMuSHRtbDVIbHNqcyA9IEh0bWw1SGxzanM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdIbHMuanMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIhJyk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gc3RyZWFtcm9vdEhsc2pzQ29uZmlnSGFuZGxlcihvcHRpb25zKSB7XG4gICAgdmFyIHBsYXllciA9IHRoaXM7XG5cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghcGxheWVyLm9wdGlvbnNfLmh0bWw1KSB7XG4gICAgICAgIHBsYXllci5vcHRpb25zXy5odG1sNSA9IHt9O1xuICAgIH1cblxuICAgIGlmICghcGxheWVyLm9wdGlvbnNfLmh0bWw1Lmhsc2pzQ29uZmlnKSB7XG4gICAgICAgIHBsYXllci5vcHRpb25zXy5odG1sNS5obHNqc0NvbmZpZyA9IG9wdGlvbnMuaGxzanNDb25maWc7XG4gICAgfVxufVxuXG52YXIgcmVnaXN0ZXJDb25maWdQbHVnaW4gPSBmdW5jdGlvbiAodmlkZW9qcykge1xuICAgIC8vIFVzZWQgaW4gQnJpZ2h0Y292ZSBzaW5jZSB3ZSBkb24ndCBwYXNzIG9wdGlvbnMgZGlyZWN0bHkgdGhlcmVcbiAgICB2YXIgcmVnaXN0ZXJWanNQbHVnaW4gPSB2aWRlb2pzLnJlZ2lzdGVyUGx1Z2luIHx8IHZpZGVvanMucGx1Z2luO1xuICAgIHJlZ2lzdGVyVmpzUGx1Z2luKCdzdHJlYW1yb290SGxzJywgc3RyZWFtcm9vdEhsc2pzQ29uZmlnSGFuZGxlcik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICByZWdpc3RlclNvdXJjZUhhbmRsZXI6IHJlZ2lzdGVyU291cmNlSGFuZGxlcixcbiAgICByZWdpc3RlckNvbmZpZ1BsdWdpbjogcmVnaXN0ZXJDb25maWdQbHVnaW5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvdmlkZW9qcy1obHNqcy1wbHVnaW4uanMiLCJpbXBvcnQgKiBhcyBVUkxUb29sa2l0IGZyb20gJ3VybC10b29sa2l0JztcclxuXHJcbmltcG9ydCB7XHJcbiAgRXJyb3JUeXBlcyxcclxuICBFcnJvckRldGFpbHNcclxufSBmcm9tICcuL2Vycm9ycyc7XHJcblxyXG5pbXBvcnQgUGxheWxpc3RMb2FkZXIgZnJvbSAnLi9sb2FkZXIvcGxheWxpc3QtbG9hZGVyJztcclxuaW1wb3J0IEZyYWdtZW50TG9hZGVyIGZyb20gJy4vbG9hZGVyL2ZyYWdtZW50LWxvYWRlcic7XHJcbmltcG9ydCBLZXlMb2FkZXIgZnJvbSAnLi9sb2FkZXIva2V5LWxvYWRlcic7XHJcblxyXG5pbXBvcnQgeyBGcmFnbWVudFRyYWNrZXIgfSBmcm9tICcuL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlcic7XHJcbmltcG9ydCBTdHJlYW1Db250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlcic7XHJcbmltcG9ydCBMZXZlbENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2xldmVsLWNvbnRyb2xsZXInO1xyXG5pbXBvcnQgSUQzVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlcic7XHJcblxyXG5pbXBvcnQgeyBpc1N1cHBvcnRlZCB9IGZyb20gJy4vaXMtc3VwcG9ydGVkJztcclxuaW1wb3J0IHsgbG9nZ2VyLCBlbmFibGVMb2dzIH0gZnJvbSAnLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgeyBobHNEZWZhdWx0Q29uZmlnLCBIbHNDb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XHJcblxyXG5pbXBvcnQgSGxzRXZlbnRzIGZyb20gJy4vZXZlbnRzJztcclxuXHJcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAnLi9vYnNlcnZlcic7XHJcblxyXG4vKipcclxuICogQG1vZHVsZSBIbHNcclxuICogQGNsYXNzXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGxzIGV4dGVuZHMgT2JzZXJ2ZXIge1xyXG4gIHB1YmxpYyBzdGF0aWMgZGVmYXVsdENvbmZpZz86IEhsc0NvbmZpZztcclxuICBwdWJsaWMgY29uZmlnOiBIbHNDb25maWc7XHJcblxyXG4gIHByaXZhdGUgX2F1dG9MZXZlbENhcHBpbmc6IG51bWJlcjtcclxuICBwcml2YXRlIGFickNvbnRyb2xsZXI6IGFueTtcclxuICBwcml2YXRlIGNhcExldmVsQ29udHJvbGxlcjogYW55O1xyXG4gIHByaXZhdGUgbGV2ZWxDb250cm9sbGVyOiBhbnk7XHJcbiAgcHJpdmF0ZSBzdHJlYW1Db250cm9sbGVyOiBhbnk7XHJcbiAgcHJpdmF0ZSBuZXR3b3JrQ29udHJvbGxlcnM6IGFueVtdO1xyXG4gIHByaXZhdGUgYXVkaW9UcmFja0NvbnRyb2xsZXI6IGFueTtcclxuICBwcml2YXRlIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyOiBhbnk7XHJcbiAgcHJpdmF0ZSBlbWVDb250cm9sbGVyOiBhbnk7XHJcbiAgcHJpdmF0ZSBjb3JlQ29tcG9uZW50czogYW55W107XHJcbiAgcHJpdmF0ZSBtZWRpYTogSFRNTE1lZGlhRWxlbWVudCB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgdXJsOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IHZlcnNpb24gKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gX19WRVJTSU9OX187XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBzdGF0aWMgaXNTdXBwb3J0ZWQgKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7SGxzRXZlbnRzfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgRXZlbnRzICgpIHtcclxuICAgIHJldHVybiBIbHNFdmVudHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7SGxzRXJyb3JUeXBlc31cclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IEVycm9yVHlwZXMgKCkge1xyXG4gICAgcmV0dXJuIEVycm9yVHlwZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7SGxzRXJyb3JEZXRhaWxzfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgRXJyb3JEZXRhaWxzICgpIHtcclxuICAgIHJldHVybiBFcnJvckRldGFpbHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7SGxzQ29uZmlnfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgRGVmYXVsdENvbmZpZyAoKTogSGxzQ29uZmlnIHtcclxuICAgIGlmICghSGxzLmRlZmF1bHRDb25maWcpIHtcclxuICAgICAgcmV0dXJuIGhsc0RlZmF1bHRDb25maWc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEhscy5kZWZhdWx0Q29uZmlnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge0hsc0NvbmZpZ31cclxuICAgKi9cclxuICBzdGF0aWMgc2V0IERlZmF1bHRDb25maWcgKGRlZmF1bHRDb25maWc6IEhsc0NvbmZpZykge1xyXG4gICAgSGxzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhbiBITFMgY2xpZW50IHRoYXQgY2FuIGF0dGFjaCB0byBleGFjdGx5IG9uZSBgSFRNTE1lZGlhRWxlbWVudGAuXHJcbiAgICpcclxuICAgKiBAY29uc3RydWN0cyBIbHNcclxuICAgKiBAcGFyYW0ge0hsc0NvbmZpZ30gY29uZmlnXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IgKHVzZXJDb25maWc6IFBhcnRpYWw8SGxzQ29uZmlnPiA9IHt9KSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSBIbHMuRGVmYXVsdENvbmZpZztcclxuXHJcbiAgICBpZiAoKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50IHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KSAmJiAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbikpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IGRvblxcJ3QgbWl4IHVwIGxpdmVTeW5jRHVyYXRpb25Db3VudC9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgYW5kIGxpdmVTeW5jRHVyYXRpb24vbGl2ZU1heExhdGVuY3lEdXJhdGlvbicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNoYWxsb3cgY2xvbmVcclxuICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAuLi5kZWZhdWx0Q29uZmlnLFxyXG4gICAgICAuLi51c2VyQ29uZmlnXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHsgY29uZmlnIH0gPSB0aGlzO1xyXG5cclxuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICE9PSB2b2lkIDAgJiYgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCA8PSBjb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudFwiIG11c3QgYmUgZ3QgXCJsaXZlU3luY0R1cmF0aW9uQ291bnRcIicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdm9pZCAwICYmIChjb25maWcubGl2ZVN5bmNEdXJhdGlvbiA9PT0gdm9pZCAwIHx8IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDw9IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBndCBcImxpdmVTeW5jRHVyYXRpb25cIicpO1xyXG4gICAgfVxyXG5cclxuICAgIGVuYWJsZUxvZ3MoY29uZmlnLmRlYnVnKTtcclxuXHJcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XHJcblxyXG4gICAgLy8gY29yZSBjb250cm9sbGVycyBhbmQgbmV0d29yayBsb2FkZXJzXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtBYnJDb250cm9sbGVyfSBhYnJDb250cm9sbGVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGFickNvbnRyb2xsZXIgPSB0aGlzLmFickNvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmFickNvbnRyb2xsZXIodGhpcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxyXG4gICAgY29uc3QgYnVmZmVyQ29udHJvbGxlciA9IG5ldyBjb25maWcuYnVmZmVyQ29udHJvbGxlcih0aGlzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXHJcbiAgICBjb25zdCBjYXBMZXZlbENvbnRyb2xsZXIgPSB0aGlzLmNhcExldmVsQ29udHJvbGxlciA9IG5ldyBjb25maWcuY2FwTGV2ZWxDb250cm9sbGVyKHRoaXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcclxuICAgIGNvbnN0IGZwc0NvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmZwc0NvbnRyb2xsZXIodGhpcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxyXG4gICAgY29uc3QgcGxheUxpc3RMb2FkZXIgPSBuZXcgUGxheWxpc3RMb2FkZXIodGhpcyk7XHJcbiAgICBjb25zdCBmcmFnbWVudExvYWRlciA9IG5ldyBGcmFnbWVudExvYWRlcih0aGlzKTtcclxuICAgIGNvbnN0IGtleUxvYWRlciA9IG5ldyBLZXlMb2FkZXIodGhpcyk7XHJcbiAgICBjb25zdCBpZDNUcmFja0NvbnRyb2xsZXIgPSBuZXcgSUQzVHJhY2tDb250cm9sbGVyKHRoaXMpO1xyXG5cclxuICAgIC8vIG5ldHdvcmsgY29udHJvbGxlcnNcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXIge0xldmVsQ29udHJvbGxlcn0gbGV2ZWxDb250cm9sbGVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGxldmVsQ29udHJvbGxlciA9IHRoaXMubGV2ZWxDb250cm9sbGVyID0gbmV3IExldmVsQ29udHJvbGxlcih0aGlzKTtcclxuXHJcbiAgICAvLyBGSVhNRTogRnJhZ21lbnRUcmFja2VyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgU3RyZWFtQ29udHJvbGxlciBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcclxuICAgIGNvbnN0IGZyYWdtZW50VHJhY2tlciA9IG5ldyBGcmFnbWVudFRyYWNrZXIodGhpcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtTdHJlYW1Db250cm9sbGVyfSBzdHJlYW1Db250cm9sbGVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBuZXcgU3RyZWFtQ29udHJvbGxlcih0aGlzLCBmcmFnbWVudFRyYWNrZXIpO1xyXG5cclxuICAgIGxldCBuZXR3b3JrQ29udHJvbGxlcnMgPSBbbGV2ZWxDb250cm9sbGVyLCBzdHJlYW1Db250cm9sbGVyXTtcclxuXHJcbiAgICAvLyBvcHRpb25hbCBhdWRpbyBzdHJlYW0gY29udHJvbGxlclxyXG4gICAgLyoqXHJcbiAgICAgKiBAdmFyIHtJQ29yZUNvbXBvbmVudCB8IENvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIGxldCBDb250cm9sbGVyID0gY29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcclxuICAgIGlmIChDb250cm9sbGVyKSB7XHJcbiAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKG5ldyBDb250cm9sbGVyKHRoaXMsIGZyYWdtZW50VHJhY2tlcikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7SU5ldHdvcmtDb250cm9sbGVyW119IG5ldHdvcmtDb250cm9sbGVyc1xyXG4gICAgICovXHJcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IG5ldHdvcmtDb250cm9sbGVycztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB2YXIge0lDb3JlQ29tcG9uZW50W119XHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGNvcmVDb21wb25lbnRzID0gW1xyXG4gICAgICBwbGF5TGlzdExvYWRlcixcclxuICAgICAgZnJhZ21lbnRMb2FkZXIsXHJcbiAgICAgIGtleUxvYWRlcixcclxuICAgICAgYWJyQ29udHJvbGxlcixcclxuICAgICAgYnVmZmVyQ29udHJvbGxlcixcclxuICAgICAgY2FwTGV2ZWxDb250cm9sbGVyLFxyXG4gICAgICBmcHNDb250cm9sbGVyLFxyXG4gICAgICBpZDNUcmFja0NvbnRyb2xsZXIsXHJcbiAgICAgIGZyYWdtZW50VHJhY2tlclxyXG4gICAgXTtcclxuXHJcbiAgICAvLyBvcHRpb25hbCBhdWRpbyB0cmFjayBhbmQgc3VidGl0bGUgY29udHJvbGxlclxyXG4gICAgQ29udHJvbGxlciA9IGNvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcclxuICAgIGlmIChDb250cm9sbGVyKSB7XHJcbiAgICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIodGhpcyk7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlciB7QXVkaW9UcmFja0NvbnRyb2xsZXJ9IGF1ZGlvVHJhY2tDb250cm9sbGVyXHJcbiAgICAgICAqL1xyXG4gICAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gYXVkaW9UcmFja0NvbnRyb2xsZXI7XHJcbiAgICAgIGNvcmVDb21wb25lbnRzLnB1c2goYXVkaW9UcmFja0NvbnRyb2xsZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIENvbnRyb2xsZXIgPSBjb25maWcuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XHJcbiAgICBpZiAoQ29udHJvbGxlcikge1xyXG4gICAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKHRoaXMpO1xyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXIge1N1YnRpdGxlVHJhY2tDb250cm9sbGVyfSBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlclxyXG4gICAgICAgKi9cclxuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xyXG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgQ29udHJvbGxlciA9IGNvbmZpZy5lbWVDb250cm9sbGVyO1xyXG4gICAgaWYgKENvbnRyb2xsZXIpIHtcclxuICAgICAgY29uc3QgZW1lQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKHRoaXMpO1xyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXIge0VNRUNvbnRyb2xsZXJ9IGVtZUNvbnRyb2xsZXJcclxuICAgICAgICovXHJcbiAgICAgIHRoaXMuZW1lQ29udHJvbGxlciA9IGVtZUNvbnRyb2xsZXI7XHJcbiAgICAgIGNvcmVDb21wb25lbnRzLnB1c2goZW1lQ29udHJvbGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gb3B0aW9uYWwgc3VidGl0bGUgY29udHJvbGxlcnNcclxuICAgIENvbnRyb2xsZXIgPSBjb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xyXG4gICAgaWYgKENvbnRyb2xsZXIpIHtcclxuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2gobmV3IENvbnRyb2xsZXIodGhpcywgZnJhZ21lbnRUcmFja2VyKSk7XHJcbiAgICB9XHJcbiAgICBDb250cm9sbGVyID0gY29uZmlnLnRpbWVsaW5lQ29udHJvbGxlcjtcclxuICAgIGlmIChDb250cm9sbGVyKSB7XHJcbiAgICAgIGNvcmVDb21wb25lbnRzLnB1c2gobmV3IENvbnRyb2xsZXIodGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7SUNvcmVDb21wb25lbnRbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IGNvcmVDb21wb25lbnRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcG9zZSBvZiB0aGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBkZXN0cm95ICgpIHtcclxuICAgIGxvZ2dlci5sb2coJ2Rlc3Ryb3knKTtcclxuICAgIHRoaXMudHJpZ2dlcihIbHNFdmVudHMuREVTVFJPWUlORyk7XHJcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XHJcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmNvbmNhdCh0aGlzLm5ldHdvcmtDb250cm9sbGVycykuZm9yRWFjaChjb21wb25lbnQgPT4ge1xyXG4gICAgICBjb21wb25lbnQuZGVzdHJveSgpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLnVybCA9IG51bGw7XHJcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoIGEgbWVkaWEgZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7SFRNTE1lZGlhRWxlbWVudH0gbWVkaWFcclxuICAgKi9cclxuICBhdHRhY2hNZWRpYSAobWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQpIHtcclxuICAgIGxvZ2dlci5sb2coJ2F0dGFjaE1lZGlhJyk7XHJcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XHJcbiAgICB0aGlzLnRyaWdnZXIoSGxzRXZlbnRzLk1FRElBX0FUVEFDSElORywgeyBtZWRpYTogbWVkaWEgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2ggZnJvbSB0aGUgbWVkaWFcclxuICAgKi9cclxuICBkZXRhY2hNZWRpYSAoKSB7XHJcbiAgICBsb2dnZXIubG9nKCdkZXRhY2hNZWRpYScpO1xyXG4gICAgdGhpcy50cmlnZ2VyKEhsc0V2ZW50cy5NRURJQV9ERVRBQ0hJTkcpO1xyXG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIHNvdXJjZSBVUkwuIENhbiBiZSByZWxhdGl2ZSBvciBhYnNvbHV0ZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXHJcbiAgICovXHJcbiAgbG9hZFNvdXJjZSAodXJsOiBzdHJpbmcpIHtcclxuICAgIHVybCA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiwgdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcclxuICAgIGxvZ2dlci5sb2coYGxvYWRTb3VyY2U6JHt1cmx9YCk7XHJcbiAgICB0aGlzLnVybCA9IHVybDtcclxuICAgIC8vIHdoZW4gYXR0YWNoaW5nIHRvIGEgc291cmNlIFVSTCwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWRcclxuICAgIHRoaXMudHJpZ2dlcihIbHNFdmVudHMuTUFOSUZFU1RfTE9BRElORywgeyB1cmw6IHVybCB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGxvYWRpbmcgZGF0YSBmcm9tIHRoZSBzdHJlYW0gc291cmNlLlxyXG4gICAqIERlcGVuZGluZyBvbiBkZWZhdWx0IGNvbmZpZywgY2xpZW50IHN0YXJ0cyBsb2FkaW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBhIHNvdXJjZSBpcyBzZXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRQb3NpdGlvbiBTZXQgdGhlIHN0YXJ0IHBvc2l0aW9uIHRvIHN0cmVhbSBmcm9tXHJcbiAgICogQGRlZmF1bHQgLTEgTm9uZSAoZnJvbSBlYXJsaWVzdCBwb2ludClcclxuICAgKi9cclxuICBzdGFydExvYWQgKHN0YXJ0UG9zaXRpb246IG51bWJlciA9IC0xKSB7XHJcbiAgICBsb2dnZXIubG9nKGBzdGFydExvYWQoJHtzdGFydFBvc2l0aW9ufSlgKTtcclxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29udHJvbGxlciA9PiB7XHJcbiAgICAgIGNvbnRyb2xsZXIuc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIGxvYWRpbmcgb2YgYW55IHN0cmVhbSBkYXRhLlxyXG4gICAqL1xyXG4gIHN0b3BMb2FkICgpIHtcclxuICAgIGxvZ2dlci5sb2coJ3N0b3BMb2FkJyk7XHJcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGNvbnRyb2xsZXIgPT4ge1xyXG4gICAgICBjb250cm9sbGVyLnN0b3BMb2FkKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN3YXAgdGhyb3VnaCBwb3NzaWJsZSBhdWRpbyBjb2RlY3MgaW4gdGhlIHN0cmVhbSAoZm9yIGV4YW1wbGUgdG8gc3dpdGNoIGZyb20gc3RlcmVvIHRvIDUuMSlcclxuICAgKi9cclxuICBzd2FwQXVkaW9Db2RlYyAoKSB7XHJcbiAgICBsb2dnZXIubG9nKCdzd2FwQXVkaW9Db2RlYycpO1xyXG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLnN3YXBBdWRpb0NvZGVjKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXaGVuIHRoZSBtZWRpYS1lbGVtZW50IGZhaWxzLCB0aGlzIGFsbG93cyB0byBkZXRhY2ggYW5kIHRoZW4gcmUtYXR0YWNoIGl0XHJcbiAgICogYXMgb25lIGNhbGwgKGNvbnZlbmllbmNlIG1ldGhvZCkuXHJcbiAgICpcclxuICAgKiBBdXRvbWF0aWMgcmVjb3Zlcnkgb2YgbWVkaWEtZXJyb3JzIGJ5IHRoaXMgcHJvY2VzcyBpcyBjb25maWd1cmFibGUuXHJcbiAgICovXHJcbiAgcmVjb3Zlck1lZGlhRXJyb3IgKCkge1xyXG4gICAgbG9nZ2VyLmxvZygncmVjb3Zlck1lZGlhRXJyb3InKTtcclxuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7UXVhbGl0eUxldmVsW119XHJcbiAgICovXHJcbiAgLy8gdG9kbyh0eXBlc2NyaXB0LWxldmVsQ29udHJvbGxlcilcclxuICBnZXQgbGV2ZWxzICgpOiBhbnlbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWxzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5kZXggb2YgcXVhbGl0eSBsZXZlbCBjdXJyZW50bHkgcGxheWVkXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgY3VycmVudExldmVsICgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50TGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBpbW1lZGlhdGVseSAuXHJcbiAgICogVGhpcyB3aWxsIGZsdXNoIHRoZSBjdXJyZW50IGJ1ZmZlciB0byByZXBsYWNlIHRoZSBxdWFsaXR5IGFzYXAuXHJcbiAgICogVGhhdCBtZWFucyBwbGF5YmFjayB3aWxsIGludGVycnVwdCBhdCBsZWFzdCBzaG9ydGx5IHRvIHJlLWJ1ZmZlciBhbmQgcmUtc3luYyBldmVudHVhbGx5LlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9IC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uXHJcbiAgICovXHJcbiAgc2V0IGN1cnJlbnRMZXZlbCAobmV3TGV2ZWw6IG51bWJlcikge1xyXG4gICAgbG9nZ2VyLmxvZyhgc2V0IGN1cnJlbnRMZXZlbDoke25ld0xldmVsfWApO1xyXG4gICAgdGhpcy5sb2FkTGV2ZWwgPSBuZXdMZXZlbDtcclxuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5kZXggb2YgbmV4dCBxdWFsaXR5IGxldmVsIGxvYWRlZCBhcyBzY2hlZHVsZWQgYnkgc3RyZWFtIGNvbnRyb2xsZXIuXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgbmV4dExldmVsICgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YS5cclxuICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSB2aWRlbyBxdWFsaXR5IGFzYXAsIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrLlxyXG4gICAqIE1heSBhYm9ydCBjdXJyZW50IGxvYWRpbmcgb2YgZGF0YSwgYW5kIGZsdXNoIHBhcnRzIG9mIGJ1ZmZlciAob3V0c2lkZSBjdXJyZW50bHkgcGxheWVkIGZyYWdtZW50IHJlZ2lvbikuXHJcbiAgICogQHR5cGUge251bWJlcn0gLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cclxuICAgKi9cclxuICBzZXQgbmV4dExldmVsIChuZXdMZXZlbDogbnVtYmVyKSB7XHJcbiAgICBsb2dnZXIubG9nKGBzZXQgbmV4dExldmVsOiR7bmV3TGV2ZWx9YCk7XHJcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xyXG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIHRoZSBjdXJyZW50bHkgb3IgbGFzdCAob2Ygbm9uZSBpcyBsb2FkZWQgY3VycmVudGx5KSBzZWdtZW50XHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgbG9hZExldmVsICgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEgaW4gYSBjb25zZXJ2YXRpdmUgd2F5LlxyXG4gICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHF1YWxpdHkgd2l0aG91dCBmbHVzaGluZywgYnV0IGludGVycnVwdCBjdXJyZW50IGxvYWRpbmcuXHJcbiAgICogVGh1cyB0aGUgbW9tZW50IHdoZW4gdGhlIHF1YWxpdHkgc3dpdGNoIHdpbGwgYXBwZWFyIGluIGVmZmVjdCB3aWxsIG9ubHkgYmUgYWZ0ZXIgdGhlIGFscmVhZHkgZXhpc3RpbmcgYnVmZmVyLlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9IG5ld0xldmVsIC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uXHJcbiAgICovXHJcbiAgc2V0IGxvYWRMZXZlbCAobmV3TGV2ZWw6IG51bWJlcikge1xyXG4gICAgbG9nZ2VyLmxvZyhgc2V0IGxvYWRMZXZlbDoke25ld0xldmVsfWApO1xyXG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGdldCBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgbmV4dExvYWRMZXZlbCAoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBsb2FkZWQgc2VnbWVudCBpbiBhIGZ1bGx5IFwibm9uLWRlc3RydWN0aXZlXCIgd2F5LlxyXG4gICAqIFNhbWUgYXMgYGxvYWRMZXZlbGAgYnV0IHdpbGwgd2FpdCBmb3IgbmV4dCBzd2l0Y2ggKHVudGlsIGN1cnJlbnQgbG9hZGluZyBpcyBkb25lKS5cclxuICAgKiBAdHlwZSB7bnVtYmVyfSBsZXZlbFxyXG4gICAqL1xyXG4gIHNldCBuZXh0TG9hZExldmVsIChsZXZlbDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsID0gbGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gXCJmaXJzdCBsZXZlbFwiOiBsaWtlIGEgZGVmYXVsdCBsZXZlbCwgaWYgbm90IHNldCxcclxuICAgKiBmYWxscyBiYWNrIHRvIGluZGV4IG9mIGZpcnN0IGxldmVsIHJlZmVyZW5jZWQgaW4gbWFuaWZlc3RcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBmaXJzdExldmVsICgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgXCJmaXJzdC1sZXZlbFwiLCBzZWUgZ2V0dGVyLlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc2V0IGZpcnN0TGV2ZWwgKG5ld0xldmVsOiBudW1iZXIpIHtcclxuICAgIGxvZ2dlci5sb2coYHNldCBmaXJzdExldmVsOiR7bmV3TGV2ZWx9YCk7XHJcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcclxuICAgKiBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcclxuICAgKiBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGhcclxuICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgc3RhcnRMZXZlbCAoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogc2V0ICBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxyXG4gICAqIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxyXG4gICAqIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aFxyXG4gICAqIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcclxuICAgKiBAdHlwZSB7bnVtYmVyfSBuZXdMZXZlbFxyXG4gICAqL1xyXG4gIHNldCBzdGFydExldmVsIChuZXdMZXZlbDogbnVtYmVyKSB7XHJcbiAgICBsb2dnZXIubG9nKGBzZXQgc3RhcnRMZXZlbDoke25ld0xldmVsfWApO1xyXG4gICAgLy8gaWYgbm90IGluIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBkZXRlY3Rpb24sIGVuc3VyZSBzdGFydExldmVsIGlzIGdyZWF0ZXIgdGhhbiBtaW5BdXRvTGV2ZWxcclxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcclxuICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1heChuZXdMZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHNldCAgZHluYW1pY2FsbHkgc2V0IGNhcExldmVsVG9QbGF5ZXJTaXplIGFnYWluc3QgKGBDYXBMZXZlbENvbnRyb2xsZXJgKVxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgc2V0IGNhcExldmVsVG9QbGF5ZXJTaXplIChzaG91bGRTdGFydENhcHBpbmc6IGJvb2xlYW4pIHtcclxuICAgIGNvbnN0IG5ld0NhcExldmVsVG9QbGF5ZXJTaXplID0gISFzaG91bGRTdGFydENhcHBpbmc7XHJcblxyXG4gICAgaWYgKG5ld0NhcExldmVsVG9QbGF5ZXJTaXplICE9PSB0aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xyXG4gICAgICBpZiAobmV3Q2FwTGV2ZWxUb1BsYXllclNpemUpIHtcclxuICAgICAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdGFydENhcHBpbmcoKTsgLy8gSWYgY2FwcGluZyBvY2N1cnMsIG5leHRMZXZlbFN3aXRjaCB3aWxsIGhhcHBlbiBiYXNlZCBvbiBzaXplLlxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyLnN0b3BDYXBwaW5nKCk7XHJcbiAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XHJcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpOyAvLyBOb3cgd2UncmUgdW5jYXBwZWQsIGdldCB0aGUgbmV4dCBsZXZlbCBhc2FwLlxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSA9IG5ld0NhcExldmVsVG9QbGF5ZXJTaXplO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAoYEFCUkNvbnRyb2xsZXJgKVxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGF1dG9MZXZlbENhcHBpbmcgKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fYXV0b0xldmVsQ2FwcGluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGdldCBiYW5kd2lkdGggZXN0aW1hdGVcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBiYW5kd2lkdGhFc3RpbWF0ZSAoKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IGJ3RXN0aW1hdG9yID0gdGhpcy5hYnJDb250cm9sbGVyLl9id0VzdGltYXRvcjtcclxuICAgIHJldHVybiBid0VzdGltYXRvciA/IGJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiBOYU47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBzZXQgYXV0b0xldmVsQ2FwcGluZyAobmV3TGV2ZWw6IG51bWJlcikge1xyXG4gICAgbG9nZ2VyLmxvZyhgc2V0IGF1dG9MZXZlbENhcHBpbmc6JHtuZXdMZXZlbH1gKTtcclxuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSBuZXdMZXZlbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRydWUgd2hlbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGVuYWJsZWRcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgYXV0b0xldmVsRW5hYmxlZCAoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID09PSAtMSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMZXZlbCBzZXQgbWFudWFsbHkgKGlmIGFueSlcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBtYW51YWxMZXZlbCAoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIG1pbiBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gY29uZmlnLm1pbkF1dG9CaXRyYXRlXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgbWluQXV0b0xldmVsICgpOiBudW1iZXIge1xyXG4gICAgY29uc3QgeyBsZXZlbHMsIGNvbmZpZzogeyBtaW5BdXRvQml0cmF0ZSB9IH0gPSB0aGlzO1xyXG4gICAgY29uc3QgbGVuID0gbGV2ZWxzID8gbGV2ZWxzLmxlbmd0aCA6IDA7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBjb25zdCBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW2ldLnJlYWxCaXRyYXRlXHJcbiAgICAgICAgPyBNYXRoLm1heChsZXZlbHNbaV0ucmVhbEJpdHJhdGUsIGxldmVsc1tpXS5iaXRyYXRlKVxyXG4gICAgICAgIDogbGV2ZWxzW2ldLmJpdHJhdGU7XHJcblxyXG4gICAgICBpZiAobGV2ZWxOZXh0Qml0cmF0ZSA+IG1pbkF1dG9CaXRyYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIG1heCBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gYXV0b0xldmVsQ2FwcGluZ1xyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IG1heEF1dG9MZXZlbCAoKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IHsgbGV2ZWxzLCBhdXRvTGV2ZWxDYXBwaW5nIH0gPSB0aGlzO1xyXG5cclxuICAgIGxldCBtYXhBdXRvTGV2ZWw7XHJcbiAgICBpZiAoYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgJiYgbGV2ZWxzICYmIGxldmVscy5sZW5ndGgpIHtcclxuICAgICAgbWF4QXV0b0xldmVsID0gbGV2ZWxzLmxlbmd0aCAtIDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtYXhBdXRvTGV2ZWwgPSBhdXRvTGV2ZWxDYXBwaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtYXhBdXRvTGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBuZXh0IGF1dG9tYXRpY2FsbHkgc2VsZWN0ZWQgcXVhbGl0eSBsZXZlbFxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IG5leHRBdXRvTGV2ZWwgKCk6IG51bWJlciB7XHJcbiAgICAvLyBlbnN1cmUgbmV4dCBhdXRvIGxldmVsIGlzIGJldHdlZW4gIG1pbiBhbmQgbWF4IGF1dG8gbGV2ZWxcclxuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpLCB0aGlzLm1heEF1dG9MZXZlbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiB0aGlzIHNldHRlciBpcyB1c2VkIHRvIGZvcmNlIG5leHQgYXV0byBsZXZlbC5cclxuICAgKiB0aGlzIGlzIHVzZWZ1bCB0byBmb3JjZSBhIHN3aXRjaCBkb3duIGluIGF1dG8gbW9kZTpcclxuICAgKiBpbiBjYXNlIG9mIGxvYWQgZXJyb3Igb24gbGV2ZWwgTiwgaGxzLmpzIGNhbiBzZXQgbmV4dEF1dG9MZXZlbCB0byBOLTEgZm9yIGV4YW1wbGUpXHJcbiAgICogZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2VzZnVsIGZyYWcgbG9hZGluZyBhdCBmb3JjZWQgbGV2ZWwsXHJcbiAgICogdGhpcyB2YWx1ZSB3aWxsIGJlIHJlc2V0dGVkIHRvIC0xIGJ5IEFCUiBjb250cm9sbGVyLlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc2V0IG5leHRBdXRvTGV2ZWwgKG5leHRMZXZlbDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCA9IE1hdGgubWF4KHRoaXMubWluQXV0b0xldmVsLCBuZXh0TGV2ZWwpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge0F1ZGlvVHJhY2tbXX1cclxuICAgKi9cclxuICAvLyB0b2RvKHR5cGVzY3JpcHQtYXVkaW9UcmFja0NvbnRyb2xsZXIpXHJcbiAgZ2V0IGF1ZGlvVHJhY2tzICgpOiBhbnlbXSB7XHJcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XHJcbiAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrcyA6IFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cylcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBhdWRpb1RyYWNrICgpOiBudW1iZXIge1xyXG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xyXG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA6IC0xO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogc2VsZWN0cyBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBzZXQgYXVkaW9UcmFjayAoYXVkaW9UcmFja0lkOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcclxuICAgIGlmIChhdWRpb1RyYWNrQ29udHJvbGxlcikge1xyXG4gICAgICBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrID0gYXVkaW9UcmFja0lkO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge1NlY29uZHN9XHJcbiAgICovXHJcbiAgZ2V0IGxpdmVTeW5jUG9zaXRpb24gKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmxpdmVTeW5jUG9zaXRpb247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3RcclxuICAgKiBAdHlwZSB7U3VidGl0bGVUcmFja1tdfVxyXG4gICAqL1xyXG4gIC8vIHRvZG8odHlwZXNjcmlwdC1zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcilcclxuICBnZXQgc3VidGl0bGVUcmFja3MgKCk6IGFueVtdIHtcclxuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcclxuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2tzIDogW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKVxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHN1YnRpdGxlVHJhY2sgKCk6IG51bWJlciB7XHJcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XHJcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrIDogLTE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBzZWxlY3QgYW4gc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0c1xyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc2V0IHN1YnRpdGxlVHJhY2sgKHN1YnRpdGxlVHJhY2tJZDogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XHJcbiAgICBpZiAoc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpIHtcclxuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA9IHN1YnRpdGxlVHJhY2tJZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBzdWJ0aXRsZURpc3BsYXkgKCk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xyXG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5IDogZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFbmFibGUvZGlzYWJsZSBzdWJ0aXRsZSBkaXNwbGF5IHJlbmRlcmluZ1xyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHNldCBzdWJ0aXRsZURpc3BsYXkgKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XHJcbiAgICBpZiAoc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpIHtcclxuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2hscy50cyIsIi8qKlxyXG4gKiBQbGF5bGlzdExvYWRlciAtIGRlbGVnYXRlIGZvciBtZWRpYSBtYW5pZmVzdC9wbGF5bGlzdCBsb2FkaW5nIHRhc2tzLiBUYWtlcyBjYXJlIG9mIHBhcnNpbmcgbWVkaWEgdG8gaW50ZXJuYWwgZGF0YS1tb2RlbHMuXHJcbiAqXHJcbiAqIE9uY2UgbG9hZGVkLCBkaXNwYXRjaGVzIGV2ZW50cyB3aXRoIHBhcnNlZCBkYXRhLW1vZGVscyBvZiBtYW5pZmVzdC9sZXZlbHMvYXVkaW8vc3VidGl0bGUgdHJhY2tzLlxyXG4gKlxyXG4gKiBVc2VzIGxvYWRlcihzKSBzZXQgaW4gY29uZmlnIHRvIGRvIGFjdHVhbCBpbnRlcm5hbCBsb2FkaW5nIG9mIHJlc291cmNlIHRhc2tzLlxyXG4gKlxyXG4gKiBAbW9kdWxlXHJcbiAqXHJcbiAqL1xyXG5cclxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XHJcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcbmltcG9ydCB7IExvYWRlciwgUGxheWxpc3RDb250ZXh0VHlwZSwgUGxheWxpc3RMb2FkZXJDb250ZXh0LCBQbGF5bGlzdExldmVsVHlwZSwgTG9hZGVyQ2FsbGJhY2tzLCBMb2FkZXJSZXNwb25zZSwgTG9hZGVyU3RhdHMsIExvYWRlckNvbmZpZ3VyYXRpb24gfSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xyXG5pbXBvcnQgTVA0RGVtdXhlciBmcm9tICcuLi9kZW11eC9tcDRkZW11eGVyJztcclxuaW1wb3J0IE0zVThQYXJzZXIgZnJvbSAnLi9tM3U4LXBhcnNlcic7XHJcbmltcG9ydCB7IEF1ZGlvR3JvdXAgfSBmcm9tICcuLi90eXBlcy9tZWRpYS1wbGF5bGlzdCc7XHJcblxyXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSB3aW5kb3c7XHJcblxyXG4vKipcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5jbGFzcyBQbGF5bGlzdExvYWRlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcbiAgcHJpdmF0ZSBsb2FkZXJzOiBQYXJ0aWFsPFJlY29yZDxQbGF5bGlzdENvbnRleHRUeXBlLCBMb2FkZXI8UGxheWxpc3RMb2FkZXJDb250ZXh0Pj4+ID0ge307XHJcblxyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RzXHJcbiAgICogQHBhcmFtIHtIbHN9IGhsc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yIChobHMpIHtcclxuICAgIHN1cGVyKGhscyxcclxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcclxuICAgICAgRXZlbnQuTEVWRUxfTE9BRElORyxcclxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfTE9BRElORyxcclxuICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BRElORyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1BsYXlsaXN0Q29udGV4dFR5cGV9IHR5cGVcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBzdGF0aWMgY2FuSGF2ZVF1YWxpdHlMZXZlbHMgKHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAodHlwZSAhPT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJlxyXG4gICAgICB0eXBlICE9PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcCBjb250ZXh0LnR5cGUgdG8gTGV2ZWxUeXBlXHJcbiAgICogQHBhcmFtIHtQbGF5bGlzdExvYWRlckNvbnRleHR9IGNvbnRleHRcclxuICAgKiBAcmV0dXJucyB7TGV2ZWxUeXBlfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBtYXBDb250ZXh0VG9MZXZlbFR5cGUgKGNvbnRleHQ6IFBsYXlsaXN0TG9hZGVyQ29udGV4dCk6IFBsYXlsaXN0TGV2ZWxUeXBlIHtcclxuICAgIGNvbnN0IHsgdHlwZSB9ID0gY29udGV4dDtcclxuXHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcclxuICAgICAgcmV0dXJuIFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPO1xyXG4gICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxyXG4gICAgICByZXR1cm4gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEU7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gUGxheWxpc3RMZXZlbFR5cGUuTUFJTjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRSZXNwb25zZVVybCAocmVzcG9uc2U6IExvYWRlclJlc3BvbnNlLCBjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHQpOiBzdHJpbmcge1xyXG4gICAgbGV0IHVybCA9IHJlc3BvbnNlLnVybDtcclxuICAgIC8vIHJlc3BvbnNlVVJMIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2VycyAoaXQgaXMgdXNlZCB0byBkZXRlY3QgVVJMIHJlZGlyZWN0aW9uKVxyXG4gICAgLy8gZGF0YS11cmkgbW9kZSBhbHNvIG5vdCBzdXBwb3J0ZWQgKGJ1dCBubyBuZWVkIHRvIGRldGVjdCByZWRpcmVjdGlvbilcclxuICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCB8fCB1cmwuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xyXG4gICAgICAvLyBmYWxsYmFjayB0byBpbml0aWFsIFVSTFxyXG4gICAgICB1cmwgPSBjb250ZXh0LnVybDtcclxuICAgIH1cclxuICAgIHJldHVybiB1cmw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGRlZmF1bHRzIG9yIGNvbmZpZ3VyZWQgbG9hZGVyLXR5cGUgb3ZlcmxvYWRzIChwTG9hZGVyIGFuZCBsb2FkZXIgY29uZmlnIHBhcmFtcylcclxuICAgKiBEZWZhdWx0IGxvYWRlciBpcyBYSFJMb2FkZXIgKHNlZSB1dGlscylcclxuICAgKiBAcGFyYW0ge1BsYXlsaXN0TG9hZGVyQ29udGV4dH0gY29udGV4dFxyXG4gICAqIEByZXR1cm5zIHtMb2FkZXJ9IG9yIG90aGVyIGNvbXBhdGlibGUgY29uZmlndXJlZCBvdmVybG9hZFxyXG4gICAqL1xyXG4gIGNyZWF0ZUludGVybmFsTG9hZGVyIChjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHQpOiBMb2FkZXI8UGxheWxpc3RMb2FkZXJDb250ZXh0PiB7XHJcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XHJcbiAgICBjb25zdCBQTG9hZGVyID0gY29uZmlnLnBMb2FkZXI7XHJcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xyXG4gICAgLy8gVE9ETyh0eXBlc2NyaXB0LWNvbmZpZyk6IFZlcmlmeSBvbmNlIGNvbmZpZyBpcyB0eXBlZCB0aGF0IEludGVybmFsTG9hZGVyIGFsd2F5cyByZXR1cm5zIGEgTG9hZGVyXHJcbiAgICBjb25zdCBJbnRlcm5hbExvYWRlciA9IFBMb2FkZXIgfHwgTG9hZGVyO1xyXG5cclxuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBJbnRlcm5hbExvYWRlcihjb25maWcpO1xyXG5cclxuICAgIC8vIFRPRE8gLSBEbyB3ZSByZWFsbHkgbmVlZCB0byBhc3NpZ24gdGhlIGluc3RhbmNlIG9yIGlmIHRoZSBkZXAgaGFzIGJlZW4gbG9zdFxyXG4gICAgY29udGV4dC5sb2FkZXIgPSBsb2FkZXI7XHJcbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IGxvYWRlcjtcclxuXHJcbiAgICByZXR1cm4gbG9hZGVyO1xyXG4gIH1cclxuXHJcbiAgZ2V0SW50ZXJuYWxMb2FkZXIgKGNvbnRleHQ6IFBsYXlsaXN0TG9hZGVyQ29udGV4dCk6IExvYWRlcjxQbGF5bGlzdExvYWRlckNvbnRleHQ+IHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXTtcclxuICB9XHJcblxyXG4gIHJlc2V0SW50ZXJuYWxMb2FkZXIgKGNvbnRleHRUeXBlOiBQbGF5bGlzdENvbnRleHRUeXBlKSB7XHJcbiAgICBpZiAodGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXSkge1xyXG4gICAgICBkZWxldGUgdGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGwgYGRlc3Ryb3lgIG9uIGFsbCBpbnRlcm5hbCBsb2FkZXIgaW5zdGFuY2VzIG1hcHBlZCAob25lIHBlciBjb250ZXh0IHR5cGUpXHJcbiAgICovXHJcbiAgZGVzdHJveUludGVybmFsTG9hZGVycyAoKSB7XHJcbiAgICBmb3IgKGxldCBjb250ZXh0VHlwZSBpbiB0aGlzLmxvYWRlcnMpIHtcclxuICAgICAgbGV0IGxvYWRlciA9IHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV07XHJcbiAgICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUgYXMgUGxheWxpc3RDb250ZXh0VHlwZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZXN0cm95ICgpIHtcclxuICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xyXG5cclxuICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICB9XHJcblxyXG4gIG9uTWFuaWZlc3RMb2FkaW5nIChkYXRhOiB7IHVybDogc3RyaW5nOyB9KSB7XHJcbiAgICB0aGlzLmxvYWQoe1xyXG4gICAgICB1cmw6IGRhdGEudXJsLFxyXG4gICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNULFxyXG4gICAgICBsZXZlbDogMCxcclxuICAgICAgaWQ6IG51bGwsXHJcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIG9uTGV2ZWxMb2FkaW5nIChkYXRhOiB7IHVybDogc3RyaW5nOyBsZXZlbDogbnVtYmVyIHwgbnVsbDsgaWQ6IG51bWJlciB8IG51bGw7IH0pIHtcclxuICAgIHRoaXMubG9hZCh7XHJcbiAgICAgIHVybDogZGF0YS51cmwsXHJcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwsXHJcbiAgICAgIGxldmVsOiBkYXRhLmxldmVsLFxyXG4gICAgICBpZDogZGF0YS5pZCxcclxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCdcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgb25BdWRpb1RyYWNrTG9hZGluZyAoZGF0YTogeyB1cmw6IHN0cmluZzsgaWQ6IG51bWJlciB8IG51bGw7IH0pIHtcclxuICAgIHRoaXMubG9hZCh7XHJcbiAgICAgIHVybDogZGF0YS51cmwsXHJcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0ssXHJcbiAgICAgIGxldmVsOiBudWxsLFxyXG4gICAgICBpZDogZGF0YS5pZCxcclxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCdcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGluZyAoZGF0YTogeyB1cmw6IHN0cmluZzsgaWQ6IG51bWJlciB8IG51bGw7IH0pIHtcclxuICAgIHRoaXMubG9hZCh7XHJcbiAgICAgIHVybDogZGF0YS51cmwsXHJcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0ssXHJcbiAgICAgIGxldmVsOiBudWxsLFxyXG4gICAgICBpZDogZGF0YS5pZCxcclxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCdcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgbG9hZCAoY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0KTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XHJcblxyXG4gICAgbG9nZ2VyLmRlYnVnKGBMb2FkaW5nIHBsYXlsaXN0IG9mIHR5cGUgJHtjb250ZXh0LnR5cGV9LCBsZXZlbDogJHtjb250ZXh0LmxldmVsfSwgaWQ6ICR7Y29udGV4dC5pZH1gKTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiBhIGxvYWRlciBmb3IgdGhpcyBjb250ZXh0IGFscmVhZHkgZXhpc3RzXHJcbiAgICBsZXQgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcclxuICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IGxvYWRlci5jb250ZXh0O1xyXG4gICAgICBpZiAobG9hZGVyQ29udGV4dCAmJiBsb2FkZXJDb250ZXh0LnVybCA9PT0gY29udGV4dC51cmwpIHsgLy8gc2FtZSBVUkwgY2FuJ3Qgb3ZlcmxhcFxyXG4gICAgICAgIGxvZ2dlci50cmFjZSgncGxheWxpc3QgcmVxdWVzdCBvbmdvaW5nJyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxvZ2dlci53YXJuKGBhYm9ydGluZyBwcmV2aW91cyBsb2FkZXIgZm9yIHR5cGU6ICR7Y29udGV4dC50eXBlfWApO1xyXG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG1heFJldHJ5OiBudW1iZXI7XHJcbiAgICBsZXQgdGltZW91dDogbnVtYmVyO1xyXG4gICAgbGV0IHJldHJ5RGVsYXk6IG51bWJlcjtcclxuICAgIGxldCBtYXhSZXRyeURlbGF5OiBudW1iZXI7XHJcblxyXG4gICAgLy8gYXBwbHkgZGlmZmVyZW50IGNvbmZpZ3MgZm9yIHJldHJpZXMgZGVwZW5kaW5nIG9uXHJcbiAgICAvLyBjb250ZXh0IChtYW5pZmVzdCwgbGV2ZWwsIGF1ZGlvL3N1YnMgcGxheWxpc3QpXHJcbiAgICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xyXG4gICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUOlxyXG4gICAgICBtYXhSZXRyeSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeTtcclxuICAgICAgdGltZW91dCA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdUaW1lT3V0O1xyXG4gICAgICByZXRyeURlbGF5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk7XHJcbiAgICAgIG1heFJldHJ5RGVsYXkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTDpcclxuICAgICAgLy8gRGlzYWJsZSBpbnRlcm5hbCBsb2FkZXIgcmV0cnkgbG9naWMsIHNpbmNlIHdlIGFyZSBtYW5hZ2luZyByZXRyaWVzIGluIExldmVsIENvbnRyb2xsZXJcclxuICAgICAgbWF4UmV0cnkgPSAwO1xyXG4gICAgICBtYXhSZXRyeURlbGF5ID0gMDtcclxuICAgICAgcmV0cnlEZWxheSA9IDA7XHJcbiAgICAgIHRpbWVvdXQgPSBjb25maWcubGV2ZWxMb2FkaW5nVGltZU91dDtcclxuICAgICAgLy8gVE9ETyBJbnRyb2R1Y2UgcmV0cnkgc2V0dGluZ3MgZm9yIGF1ZGlvLXRyYWNrIGFuZCBzdWJ0aXRsZS10cmFjaywgaXQgc2hvdWxkIG5vdCB1c2UgbGV2ZWwgcmV0cnkgY29uZmlnXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgbWF4UmV0cnkgPSBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnk7XHJcbiAgICAgIHRpbWVvdXQgPSBjb25maWcubGV2ZWxMb2FkaW5nVGltZU91dDtcclxuICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5O1xyXG4gICAgICBtYXhSZXRyeURlbGF5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZGVyID0gdGhpcy5jcmVhdGVJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcclxuXHJcbiAgICBjb25zdCBsb2FkZXJDb25maWc6IExvYWRlckNvbmZpZ3VyYXRpb24gPSB7XHJcbiAgICAgIHRpbWVvdXQsXHJcbiAgICAgIG1heFJldHJ5LFxyXG4gICAgICByZXRyeURlbGF5LFxyXG4gICAgICBtYXhSZXRyeURlbGF5XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGxvYWRlckNhbGxiYWNrczogTG9hZGVyQ2FsbGJhY2tzPFBsYXlsaXN0TG9hZGVyQ29udGV4dD4gPSB7XHJcbiAgICAgIG9uU3VjY2VzczogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLFxyXG4gICAgICBvbkVycm9yOiB0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLFxyXG4gICAgICBvblRpbWVvdXQ6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKVxyXG4gICAgfTtcclxuXHJcbiAgICBsb2dnZXIuZGVidWcoYENhbGxpbmcgaW50ZXJuYWwgbG9hZGVyIGRlbGVnYXRlIGZvciBVUkw6ICR7Y29udGV4dC51cmx9YCk7XHJcbiAgICBsb2FkZXIubG9hZChjb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBsb2Fkc3VjY2VzcyAocmVzcG9uc2U6IExvYWRlclJlc3BvbnNlLCBzdGF0czogTG9hZGVyU3RhdHMsIGNvbnRleHQ6IFBsYXlsaXN0TG9hZGVyQ29udGV4dCwgbmV0d29ya0RldGFpbHM6IHVua25vd24gPSBudWxsKSB7XHJcbiAgICBpZiAoY29udGV4dC5pc1NpZHhSZXF1ZXN0KSB7XHJcbiAgICAgIHRoaXMuX2hhbmRsZVNpZHhSZXF1ZXN0KHJlc3BvbnNlLCBjb250ZXh0KTtcclxuICAgICAgdGhpcy5faGFuZGxlUGxheWxpc3RMb2FkZWQocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcclxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuZGF0YSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCByZXNwb25zZVR5cGUgb2YgXCJ0ZXh0XCIgZm9yIFBsYXlsaXN0TG9hZGVyJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RyaW5nID0gcmVzcG9uc2UuZGF0YTtcclxuXHJcbiAgICBzdGF0cy50bG9hZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgLy8gc3RhdHMubXRpbWUgPSBuZXcgRGF0ZSh0YXJnZXQuZ2V0UmVzcG9uc2VIZWFkZXIoJ0xhc3QtTW9kaWZpZWQnKSk7XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgaWYgaXQgaXMgYW4gTTNVOCBhdCBhbGxcclxuICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVE0zVScpICE9PSAwKSB7XHJcbiAgICAgIHRoaXMuX2hhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCAnbm8gRVhUTTNVIGRlbGltaXRlcicsIG5ldHdvcmtEZXRhaWxzKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGlmIGNodW5rLWxpc3Qgb3IgbWFzdGVyLiBoYW5kbGUgZW1wdHkgY2h1bmsgbGlzdCBjYXNlIChmaXJzdCBFWFRJTkYgbm90IHNpZ25hbGVkLCBidXQgVEFSR0VURFVSQVRJT04gcHJlc2VudClcclxuICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVElORjonKSA+IDAgfHwgc3RyaW5nLmluZGV4T2YoJyNFWFQtWC1UQVJHRVREVVJBVElPTjonKSA+IDApIHtcclxuICAgICAgdGhpcy5faGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9oYW5kbGVNYXN0ZXJQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxvYWRlcnJvciAocmVzcG9uc2U6IExvYWRlclJlc3BvbnNlLCBjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHQsIG5ldHdvcmtEZXRhaWxzID0gbnVsbCkge1xyXG4gICAgdGhpcy5faGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBmYWxzZSwgcmVzcG9uc2UpO1xyXG4gIH1cclxuXHJcbiAgbG9hZHRpbWVvdXQgKHN0YXRzOiBMb2FkZXJTdGF0cywgY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0LCBuZXR3b3JrRGV0YWlscyA9IG51bGwpIHtcclxuICAgIHRoaXMuX2hhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPKHR5cGVzY3JpcHQtY29uZmlnKTogbmV0d29ya0RldGFpbHMgY2FuIGN1cnJlbnRseSBiZSBhIFhIUiBvciBGZXRjaCBpbXBsLFxyXG4gIC8vIGJ1dCB3aXRoIGN1c3RvbSBsb2FkZXJzIGl0IGNvdWxkIGJlIGdlbmVyaWMgaW52ZXN0aWdhdGUgdGhpcyBmdXJ0aGVyIHdoZW4gY29uZmlnIGlzIHR5cGVkXHJcbiAgX2hhbmRsZU1hc3RlclBsYXlsaXN0IChyZXNwb25zZTogTG9hZGVyUmVzcG9uc2UsIHN0YXRzOiBMb2FkZXJTdGF0cywgY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0LCBuZXR3b3JrRGV0YWlsczogdW5rbm93bikge1xyXG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XHJcbiAgICBjb25zdCBzdHJpbmcgPSByZXNwb25zZS5kYXRhIGFzIHN0cmluZztcclxuXHJcbiAgICBjb25zdCB1cmwgPSBQbGF5bGlzdExvYWRlci5nZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XHJcbiAgICBjb25zdCBsZXZlbHMgPSBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCB1cmwpO1xyXG4gICAgaWYgKCFsZXZlbHMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuX2hhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCAnbm8gbGV2ZWwgZm91bmQgaW4gbWFuaWZlc3QnLCBuZXR3b3JrRGV0YWlscyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBtdWx0aSBsZXZlbCBwbGF5bGlzdCwgcGFyc2UgbGV2ZWwgaW5mb1xyXG4gICAgY29uc3QgYXVkaW9Hcm91cHM6IEFycmF5PEF1ZGlvR3JvdXA+ID0gbGV2ZWxzLm1hcChsZXZlbCA9PiAoe1xyXG4gICAgICBpZDogbGV2ZWwuYXR0cnMuQVVESU8sXHJcbiAgICAgIGNvZGVjOiBsZXZlbC5hdWRpb0NvZGVjXHJcbiAgICB9KSk7XHJcblxyXG4gICAgY29uc3QgYXVkaW9UcmFja3MgPSBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgJ0FVRElPJywgYXVkaW9Hcm91cHMpO1xyXG4gICAgY29uc3Qgc3VidGl0bGVzID0gTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsICdTVUJUSVRMRVMnKTtcclxuXHJcbiAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoKSB7XHJcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgZm91bmQgYW4gYXVkaW8gdHJhY2sgZW1iZWRkZWQgaW4gbWFpbiBwbGF5bGlzdCAoYXVkaW8gdHJhY2sgd2l0aG91dCBVUkkgYXR0cmlidXRlKVxyXG4gICAgICBsZXQgZW1iZWRkZWRBdWRpb0ZvdW5kID0gZmFsc2U7XHJcbiAgICAgIGF1ZGlvVHJhY2tzLmZvckVhY2goYXVkaW9UcmFjayA9PiB7XHJcbiAgICAgICAgaWYgKCFhdWRpb1RyYWNrLnVybCkge1xyXG4gICAgICAgICAgZW1iZWRkZWRBdWRpb0ZvdW5kID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gaWYgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgYnV0IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsXHJcbiAgICAgIC8vIHdlIG5lZWQgdG8gc2lnbmFsIHRoaXMgbWFpbiBhdWRpbyB0cmFjayB0aGlzIGNvdWxkIGhhcHBlbiB3aXRoIHBsYXlsaXN0cyB3aXRoXHJcbiAgICAgIC8vIGFsdCBhdWRpbyByZW5kaXRpb24gaW4gd2hpY2ggcXVhbGl0eSBsZXZlbHMgKG1haW4pXHJcbiAgICAgIC8vIGNvbnRhaW5zIGJvdGggYXVkaW8rdmlkZW8uIGJ1dCB3aXRoIG1peGVkIGF1ZGlvIHRyYWNrIG5vdCBzaWduYWxlZFxyXG4gICAgICBpZiAoZW1iZWRkZWRBdWRpb0ZvdW5kID09PSBmYWxzZSAmJiBsZXZlbHNbMF0uYXVkaW9Db2RlYyAmJiAhbGV2ZWxzWzBdLmF0dHJzLkFVRElPKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgYnV0IG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIHNpZ25hbGVkLCBjcmVhdGUgb25lJyk7XHJcbiAgICAgICAgYXVkaW9UcmFja3MudW5zaGlmdCh7XHJcbiAgICAgICAgICB0eXBlOiAnbWFpbicsXHJcbiAgICAgICAgICBuYW1lOiAnbWFpbicsXHJcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcclxuICAgICAgICAgIGF1dG9zZWxlY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgZm9yY2VkOiBmYWxzZSxcclxuICAgICAgICAgIGlkOiAtMVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaGxzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfTE9BREVELCB7XHJcbiAgICAgIGxldmVscyxcclxuICAgICAgYXVkaW9UcmFja3MsXHJcbiAgICAgIHN1YnRpdGxlcyxcclxuICAgICAgdXJsLFxyXG4gICAgICBzdGF0cyxcclxuICAgICAgbmV0d29ya0RldGFpbHNcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX2hhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0IChyZXNwb25zZTogTG9hZGVyUmVzcG9uc2UsIHN0YXRzOiBMb2FkZXJTdGF0cywgY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0LCBuZXR3b3JrRGV0YWlsczogdW5rbm93bikge1xyXG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XHJcblxyXG4gICAgY29uc3QgeyBpZCwgbGV2ZWwsIHR5cGUgfSA9IGNvbnRleHQ7XHJcblxyXG4gICAgY29uc3QgdXJsID0gUGxheWxpc3RMb2FkZXIuZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xyXG5cclxuICAgIC8vIGlmIHRoZSB2YWx1ZXMgYXJlIG51bGwsIHRoZXkgd2lsbCByZXN1bHQgaW4gdGhlIGVsc2UgY29uZGl0aW9uYWxcclxuICAgIGNvbnN0IGxldmVsVXJsSWQgPSBOdW1iZXIuaXNGaW5pdGUoaWQgYXMgbnVtYmVyKSA/IGlkIGFzIG51bWJlciA6IDA7XHJcbiAgICBjb25zdCBsZXZlbElkID0gTnVtYmVyLmlzRmluaXRlKGxldmVsIGFzIG51bWJlcikgPyBsZXZlbCBhcyBudW1iZXIgOiBsZXZlbFVybElkO1xyXG5cclxuICAgIGNvbnN0IGxldmVsVHlwZSA9IFBsYXlsaXN0TG9hZGVyLm1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KTtcclxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IE0zVThQYXJzZXIucGFyc2VMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLmRhdGEgYXMgc3RyaW5nLCB1cmwsIGxldmVsSWQsIGxldmVsVHlwZSwgbGV2ZWxVcmxJZCk7XHJcblxyXG4gICAgLy8gc2V0IHN0YXRzIG9uIGxldmVsIHN0cnVjdHVyZVxyXG4gICAgLy8gVE9ETyhqc3RhY2tob3VzZSk6IHdoeT8gbWl4aW5nIGNvbmNlcm5zLCBpcyBpdCBqdXN0IHRyZWF0ZWQgYXMgdmFsdWUgYmFnP1xyXG4gICAgKGxldmVsRGV0YWlscyBhcyBhbnkpLnRsb2FkID0gc3RhdHMudGxvYWQ7XHJcblxyXG4gICAgLy8gV2UgaGF2ZSBkb25lIG91ciBmaXJzdCByZXF1ZXN0IChNYW5pZmVzdC10eXBlKSBhbmQgcmVjZWl2ZVxyXG4gICAgLy8gbm90IGEgbWFzdGVyIHBsYXlsaXN0IGJ1dCBhIGNodW5rLWxpc3QgKHRyYWNrL2xldmVsKVxyXG4gICAgLy8gV2UgZmlyZSB0aGUgbWFuaWZlc3QtbG9hZGVkIGV2ZW50IGFueXdheSB3aXRoIHRoZSBwYXJzZWQgbGV2ZWwtZGV0YWlsc1xyXG4gICAgLy8gYnkgY3JlYXRpbmcgYSBzaW5nbGUtbGV2ZWwgc3RydWN0dXJlIGZvciBpdC5cclxuICAgIGlmICh0eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUKSB7XHJcbiAgICAgIGNvbnN0IHNpbmdsZUxldmVsID0ge1xyXG4gICAgICAgIHVybCxcclxuICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHNcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX0xPQURFRCwge1xyXG4gICAgICAgIGxldmVsczogW3NpbmdsZUxldmVsXSxcclxuICAgICAgICBhdWRpb1RyYWNrczogW10sXHJcbiAgICAgICAgdXJsLFxyXG4gICAgICAgIHN0YXRzLFxyXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNhdmUgcGFyc2luZyB0aW1lXHJcbiAgICBzdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcblxyXG4gICAgLy8gaW4gY2FzZSB3ZSBuZWVkIFNJRFggcmFuZ2VzXHJcbiAgICAvLyByZXR1cm4gZWFybHkgYWZ0ZXIgY2FsbGluZyBsb2FkIGZvclxyXG4gICAgLy8gdGhlIFNJRFggYm94LlxyXG4gICAgaWYgKGxldmVsRGV0YWlscy5uZWVkU2lkeFJhbmdlcykge1xyXG4gICAgICBjb25zdCBzaWR4VXJsID0gbGV2ZWxEZXRhaWxzLmluaXRTZWdtZW50LnVybDtcclxuICAgICAgdGhpcy5sb2FkKHtcclxuICAgICAgICB1cmw6IHNpZHhVcmwsXHJcbiAgICAgICAgaXNTaWR4UmVxdWVzdDogdHJ1ZSxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIGxldmVsLFxyXG4gICAgICAgIGxldmVsRGV0YWlscyxcclxuICAgICAgICBpZCxcclxuICAgICAgICByYW5nZVN0YXJ0OiAwLFxyXG4gICAgICAgIHJhbmdlRW5kOiAyMDQ4LFxyXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJ1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGV4dGVuZCB0aGUgY29udGV4dCB3aXRoIHRoZSBuZXcgbGV2ZWxEZXRhaWxzIHByb3BlcnR5XHJcbiAgICBjb250ZXh0LmxldmVsRGV0YWlscyA9IGxldmVsRGV0YWlscztcclxuXHJcbiAgICB0aGlzLl9oYW5kbGVQbGF5bGlzdExvYWRlZChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKTtcclxuICB9XHJcblxyXG4gIF9oYW5kbGVTaWR4UmVxdWVzdCAocmVzcG9uc2U6IExvYWRlclJlc3BvbnNlLCBjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHQpIHtcclxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuZGF0YSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWR4IHJlcXVlc3QgbXVzdCBiZSBtYWRlIHdpdGggcmVzcG9uc2VUeXBlIG9mIGFycmF5IGJ1ZmZlcicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNpZHhJbmZvID0gTVA0RGVtdXhlci5wYXJzZVNlZ21lbnRJbmRleChuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKSk7XHJcbiAgICAvLyBpZiBwcm92aWRlZCBmcmFnbWVudCBkb2VzIG5vdCBjb250YWluIHNpZHgsIGVhcmx5IHJldHVyblxyXG4gICAgaWYgKCFzaWR4SW5mbykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBzaWR4UmVmZXJlbmNlcyA9IHNpZHhJbmZvLnJlZmVyZW5jZXM7XHJcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSBjb250ZXh0LmxldmVsRGV0YWlscztcclxuICAgIHNpZHhSZWZlcmVuY2VzLmZvckVhY2goKHNlZ21lbnRSZWYsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IHNlZ1JlZkluZm8gPSBzZWdtZW50UmVmLmluZm87XHJcbiAgICAgIGlmICghbGV2ZWxEZXRhaWxzKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGZyYWcgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2luZGV4XTtcclxuICAgICAgaWYgKGZyYWcuYnl0ZVJhbmdlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKFN0cmluZygxICsgc2VnUmVmSW5mby5lbmQgLSBzZWdSZWZJbmZvLnN0YXJ0KSArICdAJyArIFN0cmluZyhzZWdSZWZJbmZvLnN0YXJ0KSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChsZXZlbERldGFpbHMpIHtcclxuICAgICAgbGV2ZWxEZXRhaWxzLmluaXRTZWdtZW50LnNldEJ5dGVSYW5nZShTdHJpbmcoc2lkeEluZm8ubW9vdkVuZE9mZnNldCkgKyAnQDAnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvciAocmVzcG9uc2U6IExvYWRlclJlc3BvbnNlLCBjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHQsIHJlYXNvbjogc3RyaW5nLCBuZXR3b3JrRGV0YWlsczogdW5rbm93bikge1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xyXG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXHJcbiAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLFxyXG4gICAgICBmYXRhbDogdHJ1ZSxcclxuICAgICAgdXJsOiByZXNwb25zZS51cmwsXHJcbiAgICAgIHJlYXNvbixcclxuICAgICAgbmV0d29ya0RldGFpbHNcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX2hhbmRsZU5ldHdvcmtFcnJvciAoY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0LCBuZXR3b3JrRGV0YWlsczogdW5rbm93biwgdGltZW91dDogYm9vbGVhbiA9IGZhbHNlLCByZXNwb25zZTogTG9hZGVyUmVzcG9uc2UgfCBudWxsID0gbnVsbCkge1xyXG4gICAgbG9nZ2VyLmluZm8oYEEgbmV0d29yayBlcnJvciBvY2N1cmVkIHdoaWxlIGxvYWRpbmcgYSAke2NvbnRleHQudHlwZX0tdHlwZSBwbGF5bGlzdGApO1xyXG5cclxuICAgIGxldCBkZXRhaWxzO1xyXG4gICAgbGV0IGZhdGFsO1xyXG5cclxuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XHJcblxyXG4gICAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcclxuICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVDpcclxuICAgICAgZGV0YWlscyA9ICh0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX0VSUk9SKTtcclxuICAgICAgZmF0YWwgPSB0cnVlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTDpcclxuICAgICAgZGV0YWlscyA9ICh0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SKTtcclxuICAgICAgZmF0YWwgPSBmYWxzZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XHJcbiAgICAgIGRldGFpbHMgPSAodGltZW91dCA/IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUik7XHJcbiAgICAgIGZhdGFsID0gZmFsc2U7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgLy8gZGV0YWlscyA9IC4uLj9cclxuICAgICAgZmF0YWwgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xyXG4gICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPKHR5cGVzY3JpcHQtZXZlbnRzKTogd2hlbiBlcnJvciBldmVudHMgYXJlIGhhbmRsZWQsIHR5cGUgdGhpc1xyXG4gICAgbGV0IGVycm9yRGF0YTogYW55ID0ge1xyXG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXHJcbiAgICAgIGRldGFpbHMsXHJcbiAgICAgIGZhdGFsLFxyXG4gICAgICB1cmw6IGNvbnRleHQudXJsLFxyXG4gICAgICBsb2FkZXIsXHJcbiAgICAgIGNvbnRleHQsXHJcbiAgICAgIG5ldHdvcmtEZXRhaWxzXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChyZXNwb25zZSkge1xyXG4gICAgICBlcnJvckRhdGEucmVzcG9uc2UgPSByZXNwb25zZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBlcnJvckRhdGEpO1xyXG4gIH1cclxuXHJcbiAgX2hhbmRsZVBsYXlsaXN0TG9hZGVkIChyZXNwb25zZTogTG9hZGVyUmVzcG9uc2UsIHN0YXRzOiBMb2FkZXJTdGF0cywgY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0LCBuZXR3b3JrRGV0YWlsczogdW5rbm93bikge1xyXG4gICAgY29uc3QgeyB0eXBlLCBsZXZlbCwgaWQsIGxldmVsRGV0YWlscyB9ID0gY29udGV4dDtcclxuXHJcbiAgICBpZiAoIWxldmVsRGV0YWlscyB8fCAhbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSB7XHJcbiAgICAgIHRoaXMuX2hhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCAnaW52YWxpZCB0YXJnZXQgZHVyYXRpb24nLCBuZXR3b3JrRGV0YWlscyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjYW5IYXZlTGV2ZWxzID0gUGxheWxpc3RMb2FkZXIuY2FuSGF2ZVF1YWxpdHlMZXZlbHMoY29udGV4dC50eXBlKTtcclxuICAgIGlmIChjYW5IYXZlTGV2ZWxzKSB7XHJcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfTE9BREVELCB7XHJcbiAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxyXG4gICAgICAgIGxldmVsOiBsZXZlbCB8fCAwLFxyXG4gICAgICAgIGlkOiBpZCB8fCAwLFxyXG4gICAgICAgIHN0YXRzLFxyXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcclxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCwge1xyXG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxyXG4gICAgICAgICAgaWQsXHJcbiAgICAgICAgICBzdGF0cyxcclxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcclxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURFRCwge1xyXG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxyXG4gICAgICAgICAgaWQsXHJcbiAgICAgICAgICBzdGF0cyxcclxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBsYXlsaXN0TG9hZGVyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9sb2FkZXIvcGxheWxpc3QtbG9hZGVyLnRzIiwiaW1wb3J0ICogYXMgVVJMVG9vbGtpdCBmcm9tICd1cmwtdG9vbGtpdCc7XHJcblxyXG5pbXBvcnQgRnJhZ21lbnQgZnJvbSAnLi9mcmFnbWVudCc7XHJcbmltcG9ydCBMZXZlbCBmcm9tICcuL2xldmVsJztcclxuaW1wb3J0IExldmVsS2V5IGZyb20gJy4vbGV2ZWwta2V5JztcclxuXHJcbmltcG9ydCBBdHRyTGlzdCBmcm9tICcuLi91dGlscy9hdHRyLWxpc3QnO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgeyBpc0NvZGVjVHlwZSwgQ29kZWNUeXBlIH0gZnJvbSAnLi4vdXRpbHMvY29kZWNzJztcclxuaW1wb3J0IHsgTWVkaWFQbGF5bGlzdCwgQXVkaW9Hcm91cCwgTWVkaWFQbGF5bGlzdFR5cGUgfSBmcm9tICcuLi90eXBlcy9tZWRpYS1wbGF5bGlzdCc7XHJcbmltcG9ydCB7IFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcclxuXHJcbi8qKlxyXG4gKiBNM1U4IHBhcnNlclxyXG4gKiBAbW9kdWxlXHJcbiAqL1xyXG5cclxuLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20gaXMgeW91ciBmcmllbmRcclxuY29uc3QgTUFTVEVSX1BMQVlMSVNUX1JFR0VYID0gLyNFWFQtWC1TVFJFQU0tSU5GOihbXlxcblxccl0qKVtcXHJcXG5dKyhbXlxcclxcbl0rKS9nO1xyXG5jb25zdCBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVggPSAvI0VYVC1YLU1FRElBOiguKikvZztcclxuXHJcbmNvbnN0IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSBuZXcgUmVnRXhwKFtcclxuICAvI0VYVElORjpcXHMqKFxcZCooPzpcXC5cXGQrKT8pKD86LCguKilcXHMrKT8vLnNvdXJjZSwgLy8gZHVyYXRpb24gKCNFWFRJTkY6PGR1cmF0aW9uPiw8dGl0bGU+KSwgZ3JvdXAgMSA9PiBkdXJhdGlvbiwgZ3JvdXAgMiA9PiB0aXRsZVxyXG4gIC98KD8hIykoW1xcUysgP10rKS8uc291cmNlLCAvLyBzZWdtZW50IFVSSSwgZ3JvdXAgMyA9PiB0aGUgVVJJIChub3RlIG5ld2xpbmUgaXMgbm90IGVhdGVuKVxyXG4gIC98I0VYVC1YLUJZVEVSQU5HRToqKC4rKS8uc291cmNlLCAvLyBuZXh0IHNlZ21lbnQncyBieXRlcmFuZ2UsIGdyb3VwIDQgPT4gcmFuZ2Ugc3BlYyAoeEB5KVxyXG4gIC98I0VYVC1YLVBST0dSQU0tREFURS1USU1FOiguKykvLnNvdXJjZSwgLy8gbmV4dCBzZWdtZW50J3MgcHJvZ3JhbSBkYXRlL3RpbWUgZ3JvdXAgNSA9PiB0aGUgZGF0ZXRpbWUgc3BlY1xyXG4gIC98Iy4qLy5zb3VyY2UgLy8gQWxsIG90aGVyIG5vbi1zZWdtZW50IG9yaWVudGVkIHRhZ3Mgd2lsbCBtYXRjaCB3aXRoIGFsbCBncm91cHMgZW1wdHlcclxuXS5qb2luKCcnKSwgJ2cnKTtcclxuXHJcbmNvbnN0IExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cgPSAvKD86KD86IyhFWFRNM1UpKXwoPzojRVhULVgtKFBMQVlMSVNULVRZUEUpOiguKykpfCg/OiNFWFQtWC0oTUVESUEtU0VRVUVOQ0UpOiAqKFxcZCspKXwoPzojRVhULVgtKFRBUkdFVERVUkFUSU9OKTogKihcXGQrKSl8KD86I0VYVC1YLShLRVkpOiguKykpfCg/OiNFWFQtWC0oU1RBUlQpOiguKykpfCg/OiNFWFQtWC0oRU5ETElTVCkpfCg/OiNFWFQtWC0oRElTQ09OVElOVUlUWS1TRVEpVUVOQ0U6KFxcZCspKXwoPzojRVhULVgtKERJUylDT05USU5VSVRZKSl8KD86I0VYVC1YLShWRVJTSU9OKTooXFxkKykpfCg/OiNFWFQtWC0oTUFQKTooLispKXwoPzooIykoW146XSopOiguKikpfCg/OigjKSguKikpKD86LiopXFxyP1xcbj8vO1xyXG5cclxuY29uc3QgTVA0X1JFR0VYX1NVRkZJWCA9IC9cXC4obXA0fG00c3xtNHZ8bTRhKSQvaTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE0zVThQYXJzZXIge1xyXG4gIHN0YXRpYyBmaW5kR3JvdXAgKGdyb3VwczogQXJyYXk8QXVkaW9Hcm91cD4sIG1lZGlhR3JvdXBJZDogc3RyaW5nKTogQXVkaW9Hcm91cCB8IHVuZGVmaW5lZCB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcclxuICAgICAgaWYgKGdyb3VwLmlkID09PSBtZWRpYUdyb3VwSWQpIHtcclxuICAgICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBjb252ZXJ0QVZDMVRvQVZDT1RJIChjb2RlYykge1xyXG4gICAgbGV0IGF2Y2RhdGEgPSBjb2RlYy5zcGxpdCgnLicpO1xyXG4gICAgbGV0IHJlc3VsdDtcclxuICAgIGlmIChhdmNkYXRhLmxlbmd0aCA+IDIpIHtcclxuICAgICAgcmVzdWx0ID0gYXZjZGF0YS5zaGlmdCgpICsgJy4nO1xyXG4gICAgICByZXN1bHQgKz0gcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpKS50b1N0cmluZygxNik7XHJcbiAgICAgIHJlc3VsdCArPSAoJzAwMCcgKyBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc3VsdCA9IGNvZGVjO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyByZXNvbHZlICh1cmwsIGJhc2VVcmwpIHtcclxuICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwoYmFzZVVybCwgdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBwYXJzZU1hc3RlclBsYXlsaXN0IChzdHJpbmc6IHN0cmluZywgYmFzZXVybDogc3RyaW5nKSB7XHJcbiAgICAvLyBUT0RPKHR5cGVzY3JpcHQtbGV2ZWwpXHJcbiAgICBsZXQgbGV2ZWxzOiBBcnJheTxhbnk+ID0gW107XHJcbiAgICBNQVNURVJfUExBWUxJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcclxuXHJcbiAgICAvLyBUT0RPKHR5cGVzY3JpcHQtbGV2ZWwpXHJcbiAgICBmdW5jdGlvbiBzZXRDb2RlY3MgKGNvZGVjczogQXJyYXk8c3RyaW5nPiwgbGV2ZWw6IGFueSkge1xyXG4gICAgICBbJ3ZpZGVvJywgJ2F1ZGlvJ10uZm9yRWFjaCgodHlwZTogQ29kZWNUeXBlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBjb2RlY3MuZmlsdGVyKChjb2RlYykgPT4gaXNDb2RlY1R5cGUoY29kZWMsIHR5cGUpKTtcclxuICAgICAgICBpZiAoZmlsdGVyZWQubGVuZ3RoKSB7XHJcbiAgICAgICAgICBjb25zdCBwcmVmZXJyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoKGNvZGVjKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2RlYy5sYXN0SW5kZXhPZignYXZjMScsIDApID09PSAwIHx8IGNvZGVjLmxhc3RJbmRleE9mKCdtcDRhJywgMCkgPT09IDA7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGxldmVsW2Ake3R5cGV9Q29kZWNgXSA9IHByZWZlcnJlZC5sZW5ndGggPiAwID8gcHJlZmVycmVkWzBdIDogZmlsdGVyZWRbMF07XHJcblxyXG4gICAgICAgICAgLy8gcmVtb3ZlIGZyb20gbGlzdFxyXG4gICAgICAgICAgY29kZWNzID0gY29kZWNzLmZpbHRlcigoY29kZWMpID0+IGZpbHRlcmVkLmluZGV4T2YoY29kZWMpID09PSAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGxldmVsLnVua25vd25Db2RlY3MgPSBjb2RlY3M7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHJlc3VsdDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbDtcclxuICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT0gbnVsbCkge1xyXG4gICAgICAvLyBUT0RPKHR5cGVzY3JpcHQtbGV2ZWwpXHJcbiAgICAgIGNvbnN0IGxldmVsOiBhbnkgPSB7fTtcclxuXHJcbiAgICAgIGNvbnN0IGF0dHJzID0gbGV2ZWwuYXR0cnMgPSBuZXcgQXR0ckxpc3QocmVzdWx0WzFdKTtcclxuICAgICAgbGV2ZWwudXJsID0gTTNVOFBhcnNlci5yZXNvbHZlKHJlc3VsdFsyXSwgYmFzZXVybCk7XHJcblxyXG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gYXR0cnMuZGVjaW1hbFJlc29sdXRpb24oJ1JFU09MVVRJT04nKTtcclxuICAgICAgaWYgKHJlc29sdXRpb24pIHtcclxuICAgICAgICBsZXZlbC53aWR0aCA9IHJlc29sdXRpb24ud2lkdGg7XHJcbiAgICAgICAgbGV2ZWwuaGVpZ2h0ID0gcmVzb2x1dGlvbi5oZWlnaHQ7XHJcbiAgICAgIH1cclxuICAgICAgbGV2ZWwuYml0cmF0ZSA9IGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdBVkVSQUdFLUJBTkRXSURUSCcpIHx8IGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdCQU5EV0lEVEgnKTtcclxuICAgICAgbGV2ZWwubmFtZSA9IGF0dHJzLk5BTUU7XHJcblxyXG4gICAgICBzZXRDb2RlY3MoW10uY29uY2F0KChhdHRycy5DT0RFQ1MgfHwgJycpLnNwbGl0KC9bICxdKy8pKSwgbGV2ZWwpO1xyXG5cclxuICAgICAgaWYgKGxldmVsLnZpZGVvQ29kZWMgJiYgbGV2ZWwudmlkZW9Db2RlYy5pbmRleE9mKCdhdmMxJykgIT09IC0xKSB7XHJcbiAgICAgICAgbGV2ZWwudmlkZW9Db2RlYyA9IE0zVThQYXJzZXIuY29udmVydEFWQzFUb0FWQ09USShsZXZlbC52aWRlb0NvZGVjKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxldmVscztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEgKHN0cmluZzogc3RyaW5nLCBiYXNldXJsOiBzdHJpbmcsIHR5cGU6IE1lZGlhUGxheWxpc3RUeXBlLCBhdWRpb0dyb3VwczogQXJyYXk8QXVkaW9Hcm91cD4gPSBbXSk6IEFycmF5PE1lZGlhUGxheWxpc3Q+IHtcclxuICAgIGxldCByZXN1bHQ6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGw7XHJcbiAgICBsZXQgbWVkaWFzOiBBcnJheTxNZWRpYVBsYXlsaXN0PiA9IFtdO1xyXG4gICAgbGV0IGlkID0gMDtcclxuICAgIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5sYXN0SW5kZXggPSAwO1xyXG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVguZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBhdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pO1xyXG4gICAgICBpZiAoYXR0cnMuVFlQRSA9PT0gdHlwZSkge1xyXG4gICAgICAgIGNvbnN0IG1lZGlhOiBNZWRpYVBsYXlsaXN0ID0ge1xyXG4gICAgICAgICAgaWQ6IGlkKyssXHJcbiAgICAgICAgICBncm91cElkOiBhdHRyc1snR1JPVVAtSUQnXSxcclxuICAgICAgICAgIG5hbWU6IGF0dHJzLk5BTUUgfHwgYXR0cnMuTEFOR1VBR0UsXHJcbiAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgZGVmYXVsdDogKGF0dHJzLkRFRkFVTFQgPT09ICdZRVMnKSxcclxuICAgICAgICAgIGF1dG9zZWxlY3Q6IChhdHRycy5BVVRPU0VMRUNUID09PSAnWUVTJyksXHJcbiAgICAgICAgICBmb3JjZWQ6IChhdHRycy5GT1JDRUQgPT09ICdZRVMnKSxcclxuICAgICAgICAgIGxhbmc6IGF0dHJzLkxBTkdVQUdFXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKGF0dHJzLlVSSSkge1xyXG4gICAgICAgICAgbWVkaWEudXJsID0gTTNVOFBhcnNlci5yZXNvbHZlKGF0dHJzLlVSSSwgYmFzZXVybCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXVkaW9Hcm91cHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYXVkaW8gZ3JvdXBzIHNpZ25hbGxlZCBpbiB0aGUgbWFuaWZlc3QsIGxldCdzIGxvb2sgZm9yIGEgbWF0Y2hpbmcgY29kZWMgc3RyaW5nIGZvciB0aGlzIHRyYWNrXHJcbiAgICAgICAgICBjb25zdCBncm91cENvZGVjID0gTTNVOFBhcnNlci5maW5kR3JvdXAoYXVkaW9Hcm91cHMsIG1lZGlhLmdyb3VwSWQgYXMgc3RyaW5nKTtcclxuXHJcbiAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBmaW5kIHRoZSB0cmFjayBzaWduYWxsZWQsIGxldHMgdXNlIHRoZSBmaXJzdCBhdWRpbyBncm91cHMgY29kZWMgd2UgaGF2ZVxyXG4gICAgICAgICAgLy8gQWN0aW5nIGFzIGEgYmVzdCBndWVzc1xyXG4gICAgICAgICAgbWVkaWEuYXVkaW9Db2RlYyA9IGdyb3VwQ29kZWMgPyBncm91cENvZGVjLmNvZGVjIDogYXVkaW9Hcm91cHNbMF0uY29kZWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtZWRpYXM7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcGFyc2VMZXZlbFBsYXlsaXN0IChzdHJpbmc6IHN0cmluZywgYmFzZXVybDogc3RyaW5nLCBpZDogbnVtYmVyLCB0eXBlOiBQbGF5bGlzdExldmVsVHlwZSwgbGV2ZWxVcmxJZDogbnVtYmVyKSB7XHJcbiAgICBsZXQgY3VycmVudFNOID0gMDtcclxuICAgIGxldCB0b3RhbGR1cmF0aW9uID0gMDtcclxuICAgIGxldCBsZXZlbCA9IG5ldyBMZXZlbChiYXNldXJsKTtcclxuICAgIGxldCBkaXNjb250aW51aXR5Q291bnRlciA9IDA7XHJcbiAgICBsZXQgcHJldkZyYWc6IEZyYWdtZW50IHwgbnVsbCA9IG51bGw7XHJcbiAgICBsZXQgZnJhZzogRnJhZ21lbnQgfCBudWxsID0gbmV3IEZyYWdtZW50KCk7XHJcbiAgICBsZXQgcmVzdWx0OiBSZWdFeHBFeGVjQXJyYXkgfCBSZWdFeHBNYXRjaEFycmF5IHwgbnVsbDtcclxuICAgIGxldCBpOiBudW1iZXI7XHJcbiAgICBsZXQgbGV2ZWxrZXk6IExldmVsS2V5IHwgdW5kZWZpbmVkO1xyXG5cclxuICAgIGxldCBmaXJzdFBkdEluZGV4ID0gbnVsbDtcclxuXHJcbiAgICBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmxhc3RJbmRleCA9IDA7XHJcblxyXG4gICAgd2hpbGUgKChyZXN1bHQgPSBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcclxuICAgICAgY29uc3QgZHVyYXRpb24gPSByZXN1bHRbMV07XHJcbiAgICAgIGlmIChkdXJhdGlvbikgeyAvLyBJTkZcclxuICAgICAgICBmcmFnLmR1cmF0aW9uID0gcGFyc2VGbG9hdChkdXJhdGlvbik7XHJcbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxyXG4gICAgICAgIGNvbnN0IHRpdGxlID0gKCcgJyArIHJlc3VsdFsyXSkuc2xpY2UoMSk7XHJcbiAgICAgICAgZnJhZy50aXRsZSA9IHRpdGxlIHx8IG51bGw7XHJcbiAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godGl0bGUgPyBbICdJTkYnLCBkdXJhdGlvbiwgdGl0bGUgXSA6IFsgJ0lORicsIGR1cmF0aW9uIF0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFszXSkgeyAvLyB1cmxcclxuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGZyYWcuZHVyYXRpb24pKSB7XHJcbiAgICAgICAgICBjb25zdCBzbiA9IGN1cnJlbnRTTisrO1xyXG4gICAgICAgICAgZnJhZy50eXBlID0gdHlwZTtcclxuICAgICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xyXG4gICAgICAgICAgaWYgKGxldmVsa2V5KSB7XHJcbiAgICAgICAgICAgIGZyYWcubGV2ZWxrZXkgPSBsZXZlbGtleTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGZyYWcuc24gPSBzbjtcclxuICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcclxuICAgICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcclxuICAgICAgICAgIGZyYWcudXJsSWQgPSBsZXZlbFVybElkO1xyXG4gICAgICAgICAgZnJhZy5iYXNldXJsID0gYmFzZXVybDtcclxuICAgICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcclxuICAgICAgICAgIGZyYWcucmVsdXJsID0gKCcgJyArIHJlc3VsdFszXSkuc2xpY2UoMSk7XHJcbiAgICAgICAgICBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpO1xyXG5cclxuICAgICAgICAgIGxldmVsLmZyYWdtZW50cy5wdXNoKGZyYWcpO1xyXG4gICAgICAgICAgcHJldkZyYWcgPSBmcmFnO1xyXG4gICAgICAgICAgdG90YWxkdXJhdGlvbiArPSBmcmFnLmR1cmF0aW9uO1xyXG5cclxuICAgICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzRdKSB7IC8vIFgtQllURVJBTkdFXHJcbiAgICAgICAgY29uc3QgZGF0YSA9ICgnICcgKyByZXN1bHRbNF0pLnNsaWNlKDEpO1xyXG4gICAgICAgIGlmIChwcmV2RnJhZykge1xyXG4gICAgICAgICAgZnJhZy5zZXRCeXRlUmFuZ2UoZGF0YSwgcHJldkZyYWcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZShkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzVdKSB7IC8vIFBST0dSQU0tREFURS1USU1FXHJcbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxyXG4gICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gKCcgJyArIHJlc3VsdFs1XSkuc2xpY2UoMSk7XHJcbiAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydQUk9HUkFNLURBVEUtVElNRScsIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lXSk7XHJcbiAgICAgICAgaWYgKGZpcnN0UGR0SW5kZXggPT09IG51bGwpIHtcclxuICAgICAgICAgIGZpcnN0UGR0SW5kZXggPSBsZXZlbC5mcmFnbWVudHMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXN1bHQgPSByZXN1bHRbMF0ubWF0Y2goTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyk7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgIGxvZ2dlci53YXJuKCdObyBtYXRjaGVzIG9uIHNsb3cgcmVnZXggbWF0Y2ggZm9yIGxldmVsIHBsYXlsaXN0IScpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2ldICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcclxuICAgICAgICBjb25zdCB2YWx1ZTEgPSAoJyAnICsgcmVzdWx0W2kgKyAxXSkuc2xpY2UoMSk7XHJcbiAgICAgICAgY29uc3QgdmFsdWUyID0gKCcgJyArIHJlc3VsdFtpICsgMl0pLnNsaWNlKDEpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHJlc3VsdFtpXSkge1xyXG4gICAgICAgIGNhc2UgJyMnOlxyXG4gICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godmFsdWUyID8gWyB2YWx1ZTEsIHZhbHVlMiBdIDogWyB2YWx1ZTEgXSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdQTEFZTElTVC1UWVBFJzpcclxuICAgICAgICAgIGxldmVsLnR5cGUgPSB2YWx1ZTEudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ01FRElBLVNFUVVFTkNFJzpcclxuICAgICAgICAgIGN1cnJlbnRTTiA9IGxldmVsLnN0YXJ0U04gPSBwYXJzZUludCh2YWx1ZTEpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnVEFSR0VURFVSQVRJT04nOlxyXG4gICAgICAgICAgbGV2ZWwudGFyZ2V0ZHVyYXRpb24gPSBwYXJzZUZsb2F0KHZhbHVlMSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdWRVJTSU9OJzpcclxuICAgICAgICAgIGxldmVsLnZlcnNpb24gPSBwYXJzZUludCh2YWx1ZTEpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnRVhUTTNVJzpcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ0VORExJU1QnOlxyXG4gICAgICAgICAgbGV2ZWwubGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnRElTJzpcclxuICAgICAgICAgIGRpc2NvbnRpbnVpdHlDb3VudGVyKys7XHJcbiAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0RJUyddKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ0RJU0NPTlRJTlVJVFktU0VRJzpcclxuICAgICAgICAgIGRpc2NvbnRpbnVpdHlDb3VudGVyID0gcGFyc2VJbnQodmFsdWUxKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ0tFWSc6IHtcclxuICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1wYW50b3MtaHR0cC1saXZlLXN0cmVhbWluZy0wOCNzZWN0aW9uLTMuNC40XHJcbiAgICAgICAgICBjb25zdCBkZWNyeXB0cGFyYW1zID0gdmFsdWUxO1xyXG4gICAgICAgICAgY29uc3Qga2V5QXR0cnMgPSBuZXcgQXR0ckxpc3QoZGVjcnlwdHBhcmFtcyk7XHJcbiAgICAgICAgICBjb25zdCBkZWNyeXB0bWV0aG9kID0ga2V5QXR0cnMuZW51bWVyYXRlZFN0cmluZygnTUVUSE9EJyk7XHJcbiAgICAgICAgICBjb25zdCBkZWNyeXB0dXJpID0ga2V5QXR0cnMuVVJJO1xyXG4gICAgICAgICAgY29uc3QgZGVjcnlwdGl2ID0ga2V5QXR0cnMuaGV4YWRlY2ltYWxJbnRlZ2VyKCdJVicpO1xyXG5cclxuICAgICAgICAgIGlmIChkZWNyeXB0bWV0aG9kKSB7XHJcbiAgICAgICAgICAgIGxldmVsa2V5ID0gbmV3IExldmVsS2V5KGJhc2V1cmwsIGRlY3J5cHR1cmkpO1xyXG4gICAgICAgICAgICBpZiAoKGRlY3J5cHR1cmkpICYmIChbJ0FFUy0xMjgnLCAnU0FNUExFLUFFUycsICdTQU1QTEUtQUVTLUNFTkMnXS5pbmRleE9mKGRlY3J5cHRtZXRob2QpID49IDApKSB7XHJcbiAgICAgICAgICAgICAgbGV2ZWxrZXkubWV0aG9kID0gZGVjcnlwdG1ldGhvZDtcclxuICAgICAgICAgICAgICBsZXZlbGtleS5rZXkgPSBudWxsO1xyXG4gICAgICAgICAgICAgIC8vIEluaXRpYWxpemF0aW9uIFZlY3RvciAoSVYpXHJcbiAgICAgICAgICAgICAgbGV2ZWxrZXkuaXYgPSBkZWNyeXB0aXY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICdTVEFSVCc6IHtcclxuICAgICAgICAgIGNvbnN0IHN0YXJ0QXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcclxuICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1RJTUUtT0ZGU0VUJyk7XHJcbiAgICAgICAgICAvLyBUSU1FLU9GRlNFVCBjYW4gYmUgMFxyXG4gICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShzdGFydFRpbWVPZmZzZXQpKSB7XHJcbiAgICAgICAgICAgIGxldmVsLnN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0VGltZU9mZnNldDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICdNQVAnOiB7XHJcbiAgICAgICAgICBjb25zdCBtYXBBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xyXG4gICAgICAgICAgZnJhZy5yZWx1cmwgPSBtYXBBdHRycy5VUkk7XHJcbiAgICAgICAgICBpZiAobWFwQXR0cnMuQllURVJBTkdFKSB7XHJcbiAgICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKG1hcEF0dHJzLkJZVEVSQU5HRSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmcmFnLmJhc2V1cmwgPSBiYXNldXJsO1xyXG4gICAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xyXG4gICAgICAgICAgZnJhZy50eXBlID0gdHlwZTtcclxuICAgICAgICAgIGZyYWcuc24gPSAnaW5pdFNlZ21lbnQnO1xyXG4gICAgICAgICAgbGV2ZWwuaW5pdFNlZ21lbnQgPSBmcmFnO1xyXG4gICAgICAgICAgZnJhZyA9IG5ldyBGcmFnbWVudCgpO1xyXG4gICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBsZXZlbC5pbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGxvZ2dlci53YXJuKGBsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6ICR7cmVzdWx0fWApO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmcmFnID0gcHJldkZyYWc7XHJcbiAgICAvLyBsb2dnZXIubG9nKCdmb3VuZCAnICsgbGV2ZWwuZnJhZ21lbnRzLmxlbmd0aCArICcgZnJhZ21lbnRzJyk7XHJcbiAgICBpZiAoZnJhZyAmJiAhZnJhZy5yZWx1cmwpIHtcclxuICAgICAgbGV2ZWwuZnJhZ21lbnRzLnBvcCgpO1xyXG4gICAgICB0b3RhbGR1cmF0aW9uIC09IGZyYWcuZHVyYXRpb247XHJcbiAgICB9XHJcbiAgICBsZXZlbC50b3RhbGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbjtcclxuICAgIGxldmVsLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb24gLyBsZXZlbC5mcmFnbWVudHMubGVuZ3RoO1xyXG4gICAgbGV2ZWwuZW5kU04gPSBjdXJyZW50U04gLSAxO1xyXG4gICAgbGV2ZWwuc3RhcnRDQyA9IGxldmVsLmZyYWdtZW50c1swXSA/IGxldmVsLmZyYWdtZW50c1swXS5jYyA6IDA7XHJcbiAgICBsZXZlbC5lbmRDQyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xyXG5cclxuICAgIGlmICghbGV2ZWwuaW5pdFNlZ21lbnQgJiYgbGV2ZWwuZnJhZ21lbnRzLmxlbmd0aCkge1xyXG4gICAgICAvLyB0aGlzIGlzIGEgYml0IGx1cmt5IGJ1dCBITFMgcmVhbGx5IGhhcyBubyBvdGhlciB3YXkgdG8gdGVsbCB1c1xyXG4gICAgICAvLyBpZiB0aGUgZnJhZ21lbnRzIGFyZSBUUyBvciBNUDQsIGV4Y2VwdCBpZiB3ZSBkb3dubG9hZCB0aGVtIDovXHJcbiAgICAgIC8vIGJ1dCB0aGlzIGlzIHRvIGJlIGFibGUgdG8gaGFuZGxlIFNJRFguXHJcbiAgICAgIGlmIChsZXZlbC5mcmFnbWVudHMuZXZlcnkoKGZyYWcpID0+IE1QNF9SRUdFWF9TVUZGSVgudGVzdChmcmFnLnJlbHVybCkpKSB7XHJcbiAgICAgICAgbG9nZ2VyLndhcm4oJ01QNCBmcmFnbWVudHMgZm91bmQgYnV0IG5vIGluaXQgc2VnbWVudCAocHJvYmFibHkgbm8gTUFQLCBpbmNvbXBsZXRlIE0zVTgpLCB0cnlpbmcgdG8gZmV0Y2ggU0lEWCcpO1xyXG5cclxuICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KCk7XHJcbiAgICAgICAgZnJhZy5yZWx1cmwgPSBsZXZlbC5mcmFnbWVudHNbMF0ucmVsdXJsO1xyXG4gICAgICAgIGZyYWcuYmFzZXVybCA9IGJhc2V1cmw7XHJcbiAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xyXG4gICAgICAgIGZyYWcudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgZnJhZy5zbiA9ICdpbml0U2VnbWVudCc7XHJcblxyXG4gICAgICAgIGxldmVsLmluaXRTZWdtZW50ID0gZnJhZztcclxuICAgICAgICBsZXZlbC5uZWVkU2lkeFJhbmdlcyA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJhY2tmaWxsIGFueSBtaXNzaW5nIFBEVCB2YWx1ZXNcclxuICAgICAgIFwiSWYgdGhlIGZpcnN0IEVYVC1YLVBST0dSQU0tREFURS1USU1FIHRhZyBpbiBhIFBsYXlsaXN0IGFwcGVhcnMgYWZ0ZXJcclxuICAgICAgIG9uZSBvciBtb3JlIE1lZGlhIFNlZ21lbnQgVVJJcywgdGhlIGNsaWVudCBTSE9VTEQgZXh0cmFwb2xhdGVcclxuICAgICAgIGJhY2t3YXJkIGZyb20gdGhhdCB0YWcgKHVzaW5nIEVYVElORiBkdXJhdGlvbnMgYW5kL29yIG1lZGlhXHJcbiAgICAgICB0aW1lc3RhbXBzKSB0byBhc3NvY2lhdGUgZGF0ZXMgd2l0aCB0aG9zZSBzZWdtZW50cy5cIlxyXG4gICAgICogV2UgaGF2ZSBhbHJlYWR5IGV4dHJhcG9sYXRlZCBmb3J3YXJkLCBidXQgYWxsIGZyYWdtZW50cyB1cCB0byB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgUERUIGRvIG5vdCBoYXZlIHRoZWlyIFBEVHNcclxuICAgICAqIGNvbXB1dGVkLlxyXG4gICAgICovXHJcbiAgICBpZiAoZmlyc3RQZHRJbmRleCkge1xyXG4gICAgICBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMobGV2ZWwuZnJhZ21lbnRzLCBmaXJzdFBkdEluZGV4KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGV2ZWw7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMgKGZyYWdtZW50cywgc3RhcnRJbmRleCkge1xyXG4gIGxldCBmcmFnUHJldiA9IGZyYWdtZW50c1tzdGFydEluZGV4XTtcclxuICBmb3IgKGxldCBpID0gc3RhcnRJbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICBjb25zdCBmcmFnID0gZnJhZ21lbnRzW2ldO1xyXG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBmcmFnUHJldi5wcm9ncmFtRGF0ZVRpbWUgLSAoZnJhZy5kdXJhdGlvbiAqIDEwMDApO1xyXG4gICAgZnJhZ1ByZXYgPSBmcmFnO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXNzaWduUHJvZ3JhbURhdGVUaW1lIChmcmFnLCBwcmV2RnJhZykge1xyXG4gIGlmIChmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSkge1xyXG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBEYXRlLnBhcnNlKGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKTtcclxuICB9IGVsc2UgaWYgKHByZXZGcmFnICYmIHByZXZGcmFnLnByb2dyYW1EYXRlVGltZSkge1xyXG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBwcmV2RnJhZy5lbmRQcm9ncmFtRGF0ZVRpbWU7XHJcbiAgfVxyXG5cclxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFnLnByb2dyYW1EYXRlVGltZSkpIHtcclxuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcclxuICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcclxuICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvbG9hZGVyL20zdTgtcGFyc2VyLnRzIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGV2ZWwge1xyXG4gIGNvbnN0cnVjdG9yIChiYXNlVXJsKSB7XHJcbiAgICAvLyBQbGVhc2Uga2VlcCBwcm9wZXJ0aWVzIGluIGFscGhhYmV0aWNhbCBvcmRlclxyXG4gICAgdGhpcy5lbmRDQyA9IDA7XHJcbiAgICB0aGlzLmVuZFNOID0gMDtcclxuICAgIHRoaXMuZnJhZ21lbnRzID0gW107XHJcbiAgICB0aGlzLmluaXRTZWdtZW50ID0gbnVsbDtcclxuICAgIHRoaXMubGl2ZSA9IHRydWU7XHJcbiAgICB0aGlzLm5lZWRTaWR4UmFuZ2VzID0gZmFsc2U7XHJcbiAgICB0aGlzLnN0YXJ0Q0MgPSAwO1xyXG4gICAgdGhpcy5zdGFydFNOID0gMDtcclxuICAgIHRoaXMuc3RhcnRUaW1lT2Zmc2V0ID0gbnVsbDtcclxuICAgIHRoaXMudGFyZ2V0ZHVyYXRpb24gPSAwO1xyXG4gICAgdGhpcy50b3RhbGR1cmF0aW9uID0gMDtcclxuICAgIHRoaXMudHlwZSA9IG51bGw7XHJcbiAgICB0aGlzLnVybCA9IGJhc2VVcmw7XHJcbiAgICB0aGlzLnZlcnNpb24gPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGhhc1Byb2dyYW1EYXRlVGltZSAoKSB7XHJcbiAgICByZXR1cm4gISEodGhpcy5mcmFnbWVudHNbMF0gJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZSkpO1xyXG4gIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9sb2FkZXIvbGV2ZWwuanMiLCJjb25zdCBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxyXG5jb25zdCBBVFRSX0xJU1RfUkVHRVggPSAvXFxzKiguKz8pXFxzKj0oKD86XFxcIi4qP1xcXCIpfC4qPykoPzosfCQpL2c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcclxuXHJcbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20va2Fub25naWwvbm9kZS1tM3U4cGFyc2UvYmxvYi9tYXN0ZXIvYXR0cmxpc3QuanNcclxuY2xhc3MgQXR0ckxpc3Qge1xyXG4gIGNvbnN0cnVjdG9yIChhdHRycykge1xyXG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgYXR0cnMgPSBBdHRyTGlzdC5wYXJzZUF0dHJMaXN0KGF0dHJzKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBhdHRyIGluIGF0dHJzKSB7XHJcbiAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xyXG4gICAgICAgIHRoaXNbYXR0cl0gPSBhdHRyc1thdHRyXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVjaW1hbEludGVnZXIgKGF0dHJOYW1lKSB7XHJcbiAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxMCk7XHJcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xyXG4gICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGludFZhbHVlO1xyXG4gIH1cclxuXHJcbiAgaGV4YWRlY2ltYWxJbnRlZ2VyIChhdHRyTmFtZSkge1xyXG4gICAgaWYgKHRoaXNbYXR0ck5hbWVdKSB7XHJcbiAgICAgIGxldCBzdHJpbmdWYWx1ZSA9ICh0aGlzW2F0dHJOYW1lXSB8fCAnMHgnKS5zbGljZSgyKTtcclxuICAgICAgc3RyaW5nVmFsdWUgPSAoKHN0cmluZ1ZhbHVlLmxlbmd0aCAmIDEpID8gJzAnIDogJycpICsgc3RyaW5nVmFsdWU7XHJcblxyXG4gICAgICBjb25zdCB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDI7IGkrKykge1xyXG4gICAgICAgIHZhbHVlW2ldID0gcGFyc2VJbnQoc3RyaW5nVmFsdWUuc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBoZXhhZGVjaW1hbEludGVnZXJBc051bWJlciAoYXR0ck5hbWUpIHtcclxuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcclxuICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XHJcbiAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW50VmFsdWU7XHJcbiAgfVxyXG5cclxuICBkZWNpbWFsRmxvYXRpbmdQb2ludCAoYXR0ck5hbWUpIHtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXNbYXR0ck5hbWVdKTtcclxuICB9XHJcblxyXG4gIGVudW1lcmF0ZWRTdHJpbmcgKGF0dHJOYW1lKSB7XHJcbiAgICByZXR1cm4gdGhpc1thdHRyTmFtZV07XHJcbiAgfVxyXG5cclxuICBkZWNpbWFsUmVzb2x1dGlvbiAoYXR0ck5hbWUpIHtcclxuICAgIGNvbnN0IHJlcyA9IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWC5leGVjKHRoaXNbYXR0ck5hbWVdKTtcclxuICAgIGlmIChyZXMgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3aWR0aDogcGFyc2VJbnQocmVzWzFdLCAxMCksXHJcbiAgICAgIGhlaWdodDogcGFyc2VJbnQocmVzWzJdLCAxMClcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcGFyc2VBdHRyTGlzdCAoaW5wdXQpIHtcclxuICAgIGxldCBtYXRjaCwgYXR0cnMgPSB7fTtcclxuICAgIEFUVFJfTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xyXG4gICAgd2hpbGUgKChtYXRjaCA9IEFUVFJfTElTVF9SRUdFWC5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcclxuICAgICAgbGV0IHZhbHVlID0gbWF0Y2hbMl0sIHF1b3RlID0gJ1wiJztcclxuXHJcbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKHF1b3RlKSA9PT0gMCAmJlxyXG4gICAgICAgICAgdmFsdWUubGFzdEluZGV4T2YocXVvdGUpID09PSAodmFsdWUubGVuZ3RoIC0gMSkpIHtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYXR0cnNbbWF0Y2hbMV1dID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXR0cnM7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBdHRyTGlzdDtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMvYXR0ci1saXN0LmpzIiwiLypcclxuICogRnJhZ21lbnQgTG9hZGVyXHJcbiovXHJcblxyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmNsYXNzIEZyYWdtZW50TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcclxuICBjb25zdHJ1Y3RvciAoaGxzKSB7XHJcbiAgICBzdXBlcihobHMsIEV2ZW50LkZSQUdfTE9BRElORyk7XHJcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3kgKCkge1xyXG4gICAgbGV0IGxvYWRlcnMgPSB0aGlzLmxvYWRlcnM7XHJcbiAgICBmb3IgKGxldCBsb2FkZXJOYW1lIGluIGxvYWRlcnMpIHtcclxuICAgICAgbGV0IGxvYWRlciA9IGxvYWRlcnNbbG9hZGVyTmFtZV07XHJcbiAgICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcclxuXHJcbiAgICBzdXBlci5kZXN0cm95KCk7XHJcbiAgfVxyXG5cclxuICBvbkZyYWdMb2FkaW5nIChkYXRhKSB7XHJcbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnLFxyXG4gICAgICB0eXBlID0gZnJhZy50eXBlLFxyXG4gICAgICBsb2FkZXJzID0gdGhpcy5sb2FkZXJzLFxyXG4gICAgICBjb25maWcgPSB0aGlzLmhscy5jb25maWcsXHJcbiAgICAgIEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyLFxyXG4gICAgICBEZWZhdWx0SUxvYWRlciA9IGNvbmZpZy5sb2FkZXI7XHJcblxyXG4gICAgLy8gcmVzZXQgZnJhZ21lbnQgc3RhdGVcclxuICAgIGZyYWcubG9hZGVkID0gMDtcclxuXHJcbiAgICBsZXQgbG9hZGVyID0gbG9hZGVyc1t0eXBlXTtcclxuICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgbG9nZ2VyLndhcm4oYGFib3J0IHByZXZpb3VzIGZyYWdtZW50IGxvYWRlciBmb3IgdHlwZTogJHt0eXBlfWApO1xyXG4gICAgICBsb2FkZXIuYWJvcnQoKTtcclxuICAgIH1cclxuXHJcbiAgICBsb2FkZXIgPSBsb2FkZXJzW3R5cGVdID0gZnJhZy5sb2FkZXIgPVxyXG4gICAgICBjb25maWcuZkxvYWRlciA/IG5ldyBGcmFnbWVudElMb2FkZXIoY29uZmlnKSA6IG5ldyBEZWZhdWx0SUxvYWRlcihjb25maWcpO1xyXG5cclxuICAgIGxldCBsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcztcclxuXHJcbiAgICBsb2FkZXJDb250ZXh0ID0geyB1cmw6IGZyYWcudXJsLCBmcmFnOiBmcmFnLCByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsIHByb2dyZXNzRGF0YTogZmFsc2UgfTtcclxuXHJcbiAgICBsZXQgc3RhcnQgPSBmcmFnLmJ5dGVSYW5nZVN0YXJ0T2Zmc2V0LFxyXG4gICAgICBlbmQgPSBmcmFnLmJ5dGVSYW5nZUVuZE9mZnNldDtcclxuXHJcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHN0YXJ0KSAmJiBOdW1iZXIuaXNGaW5pdGUoZW5kKSkge1xyXG4gICAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBzdGFydDtcclxuICAgICAgbG9hZGVyQ29udGV4dC5yYW5nZUVuZCA9IGVuZDtcclxuICAgIH1cclxuXHJcbiAgICBsb2FkZXJDb25maWcgPSB7XHJcbiAgICAgIHRpbWVvdXQ6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsXHJcbiAgICAgIG1heFJldHJ5OiAwLFxyXG4gICAgICByZXRyeURlbGF5OiAwLFxyXG4gICAgICBtYXhSZXRyeURlbGF5OiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXRcclxuICAgIH07XHJcblxyXG4gICAgbG9hZGVyQ2FsbGJhY2tzID0ge1xyXG4gICAgICBvblN1Y2Nlc3M6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSxcclxuICAgICAgb25FcnJvcjogdGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSxcclxuICAgICAgb25UaW1lb3V0OiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksXHJcbiAgICAgIG9uUHJvZ3Jlc3M6IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcylcclxuICAgIH07XHJcblxyXG4gICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xyXG4gIH1cclxuXHJcbiAgbG9hZHN1Y2Nlc3MgKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMgPSBudWxsKSB7XHJcbiAgICBsZXQgcGF5bG9hZCA9IHJlc3BvbnNlLmRhdGEsIGZyYWcgPSBjb250ZXh0LmZyYWc7XHJcbiAgICAvLyBkZXRhY2ggZnJhZ21lbnQgbG9hZGVyIG9uIGxvYWQgc3VjY2Vzc1xyXG4gICAgZnJhZy5sb2FkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FERUQsIHsgcGF5bG9hZDogcGF5bG9hZCwgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzLCBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMgfSk7XHJcbiAgfVxyXG5cclxuICBsb2FkZXJyb3IgKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyA9IG51bGwpIHtcclxuICAgIGNvbnN0IGZyYWcgPSBjb250ZXh0LmZyYWc7XHJcbiAgICBsZXQgbG9hZGVyID0gZnJhZy5sb2FkZXI7XHJcbiAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogY29udGV4dC5mcmFnLCByZXNwb25zZTogcmVzcG9uc2UsIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyB9KTtcclxuICB9XHJcblxyXG4gIGxvYWR0aW1lb3V0IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMgPSBudWxsKSB7XHJcbiAgICBjb25zdCBmcmFnID0gY29udGV4dC5mcmFnO1xyXG4gICAgbGV0IGxvYWRlciA9IGZyYWcubG9hZGVyO1xyXG4gICAgaWYgKGxvYWRlcikge1xyXG4gICAgICBsb2FkZXIuYWJvcnQoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsIGZhdGFsOiBmYWxzZSwgZnJhZzogY29udGV4dC5mcmFnLCBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBkYXRhIHdpbGwgYmUgdXNlZCBmb3IgcHJvZ3Jlc3NpdmUgcGFyc2luZ1xyXG4gIGxvYWRwcm9ncmVzcyAoc3RhdHMsIGNvbnRleHQsIGRhdGEsIG5ldHdvcmtEZXRhaWxzID0gbnVsbCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnO1xyXG4gICAgZnJhZy5sb2FkZWQgPSBzdGF0cy5sb2FkZWQ7XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRF9QUk9HUkVTUywgeyBmcmFnOiBmcmFnLCBzdGF0czogc3RhdHMsIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZyYWdtZW50TG9hZGVyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyLmpzIiwiLypcclxuICogRGVjcnlwdCBrZXkgTG9hZGVyXHJcbiovXHJcblxyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuaW1wb3J0IEhscyBmcm9tICcuLi9obHMnO1xyXG5pbXBvcnQgRnJhZ21lbnQgZnJvbSAnLi9mcmFnbWVudCc7XHJcbmltcG9ydCB7IExvYWRlclN0YXRzLCBMb2FkZXJSZXNwb25zZSwgTG9hZGVyQ29udGV4dCwgTG9hZGVyQ29uZmlndXJhdGlvbiwgTG9hZGVyQ2FsbGJhY2tzIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcclxuXHJcbmludGVyZmFjZSBPbktleUxvYWRpbmdQYXlsb2FkIHtcclxuICBmcmFnOiBGcmFnbWVudFxyXG59XHJcblxyXG5pbnRlcmZhY2UgS2V5TG9hZGVyQ29udGV4dCBleHRlbmRzIExvYWRlckNvbnRleHQge1xyXG4gIGZyYWc6IEZyYWdtZW50XHJcbn1cclxuXHJcbmNsYXNzIEtleUxvYWRlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcbiAgcHVibGljIGxvYWRlcnMgPSB7fTtcclxuICBwdWJsaWMgZGVjcnlwdGtleTogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xyXG4gIHB1YmxpYyBkZWNyeXB0dXJsOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgY29uc3RydWN0b3IgKGhsczogSGxzKSB7XHJcbiAgICBzdXBlcihobHMsIEV2ZW50LktFWV9MT0FESU5HKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3kgKCk6IHZvaWQge1xyXG4gICAgZm9yIChjb25zdCBsb2FkZXJOYW1lIGluIHRoaXMubG9hZGVycykge1xyXG4gICAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2xvYWRlck5hbWVdO1xyXG4gICAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5sb2FkZXJzID0ge307XHJcblxyXG4gICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gIH1cclxuXHJcbiAgb25LZXlMb2FkaW5nIChkYXRhOiBPbktleUxvYWRpbmdQYXlsb2FkKSB7XHJcbiAgICBjb25zdCB7IGZyYWcgfSA9IGRhdGE7XHJcbiAgICBjb25zdCB0eXBlID0gZnJhZy50eXBlO1xyXG4gICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdO1xyXG4gICAgaWYgKCFmcmFnLmRlY3J5cHRkYXRhKSB7XHJcbiAgICAgIGxvZ2dlci53YXJuKCdNaXNzaW5nIGRlY3J5cHRpb24gZGF0YSBvbiBmcmFnbWVudCBpbiBvbktleUxvYWRpbmcnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExvYWQgdGhlIGtleSBpZiB0aGUgdXJpIGlzIGRpZmZlcmVudCBmcm9tIHByZXZpb3VzIG9uZSwgb3IgaWYgdGhlIGRlY3J5cHQga2V5IGhhcyBub3QgeWV0IGJlZW4gcmV0cmlldmVkXHJcbiAgICBjb25zdCB1cmkgPSBmcmFnLmRlY3J5cHRkYXRhLnVyaTtcclxuICAgIGlmICh1cmkgIT09IHRoaXMuZGVjcnlwdHVybCB8fCB0aGlzLmRlY3J5cHRrZXkgPT09IG51bGwpIHtcclxuICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcclxuICAgICAgaWYgKGxvYWRlcikge1xyXG4gICAgICAgIGxvZ2dlci53YXJuKGBhYm9ydCBwcmV2aW91cyBrZXkgbG9hZGVyIGZvciB0eXBlOiR7dHlwZX1gKTtcclxuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXVyaSkge1xyXG4gICAgICAgIGxvZ2dlci53YXJuKCdrZXkgdXJpIGlzIGZhbHN5Jyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmcmFnLmxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSA9IG5ldyBjb25maWcubG9hZGVyKGNvbmZpZyk7XHJcbiAgICAgIHRoaXMuZGVjcnlwdHVybCA9IHVyaTtcclxuICAgICAgdGhpcy5kZWNyeXB0a2V5ID0gbnVsbDtcclxuXHJcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQ6IEtleUxvYWRlckNvbnRleHQgPSB7XHJcbiAgICAgICAgdXJsOiB1cmksXHJcbiAgICAgICAgZnJhZzogZnJhZyxcclxuICAgICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcidcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIG1heFJldHJ5IGlzIDAgc28gdGhhdCBpbnN0ZWFkIG9mIHJldHJ5aW5nIHRoZSBzYW1lIGtleSBvbiB0aGUgc2FtZSB2YXJpYW50IG11bHRpcGxlIHRpbWVzLFxyXG4gICAgICAvLyBrZXktbG9hZGVyIHdpbGwgdHJpZ2dlciBhbiBlcnJvciBhbmQgcmVseSBvbiBzdHJlYW0tY29udHJvbGxlciB0byBoYW5kbGUgcmV0cnkgbG9naWMuXHJcbiAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIGFsaWduIHJldHJ5IGxvZ2ljIHdpdGggZnJhZ21lbnQtbG9hZGVyXHJcbiAgICAgIGNvbnN0IGxvYWRlckNvbmZpZzogTG9hZGVyQ29uZmlndXJhdGlvbiA9IHtcclxuICAgICAgICB0aW1lb3V0OiBjb25maWcuZnJhZ0xvYWRpbmdUaW1lT3V0LFxyXG4gICAgICAgIG1heFJldHJ5OiAwLFxyXG4gICAgICAgIHJldHJ5RGVsYXk6IGNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksXHJcbiAgICAgICAgbWF4UmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBsb2FkZXJDYWxsYmFja3M6IExvYWRlckNhbGxiYWNrczxLZXlMb2FkZXJDb250ZXh0PiA9IHtcclxuICAgICAgICBvblN1Y2Nlc3M6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSxcclxuICAgICAgICBvbkVycm9yOiB0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLFxyXG4gICAgICAgIG9uVGltZW91dDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBmcmFnLmxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5kZWNyeXB0a2V5KSB7XHJcbiAgICAgIC8vIFJldHVybiB0aGUga2V5IGlmIGl0J3MgYWxyZWFkeSBiZWVuIGxvYWRlZFxyXG4gICAgICBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IHRoaXMuZGVjcnlwdGtleTtcclxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5LRVlfTE9BREVELCB7IGZyYWc6IGZyYWcgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsb2Fkc3VjY2VzcyAocmVzcG9uc2U6IExvYWRlclJlc3BvbnNlLCBzdGF0czogTG9hZGVyU3RhdHMsIGNvbnRleHQ6IEtleUxvYWRlckNvbnRleHQpIHtcclxuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnO1xyXG4gICAgaWYgKCFmcmFnLmRlY3J5cHRkYXRhKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcignYWZ0ZXIga2V5IGxvYWQsIGRlY3J5cHRkYXRhIHVuc2V0Jyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuZGVjcnlwdGtleSA9IGZyYWcuZGVjcnlwdGRhdGEua2V5ID0gbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UuZGF0YSBhcyBBcnJheUJ1ZmZlcik7XHJcblxyXG4gICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcclxuICAgIGZyYWcubG9hZGVyID0gdW5kZWZpbmVkO1xyXG4gICAgZGVsZXRlIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdO1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5LRVlfTE9BREVELCB7IGZyYWc6IGZyYWcgfSk7XHJcbiAgfVxyXG5cclxuICBsb2FkZXJyb3IgKHJlc3BvbnNlOiBMb2FkZXJSZXNwb25zZSwgY29udGV4dDogS2V5TG9hZGVyQ29udGV4dCkge1xyXG4gICAgbGV0IGZyYWcgPSBjb250ZXh0LmZyYWc7XHJcbiAgICBsZXQgbG9hZGVyID0gZnJhZy5sb2FkZXI7XHJcbiAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXTtcclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZywgcmVzcG9uc2UgfSk7XHJcbiAgfVxyXG5cclxuICBsb2FkdGltZW91dCAoc3RhdHM6IExvYWRlclN0YXRzLCBjb250ZXh0OiBLZXlMb2FkZXJDb250ZXh0KSB7XHJcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZztcclxuICAgIGxldCBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcclxuICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgbG9hZGVyLmFib3J0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdO1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VULCBmYXRhbDogZmFsc2UsIGZyYWcgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBLZXlMb2FkZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2xvYWRlci9rZXktbG9hZGVyLnRzIiwiLypcclxuICogU3RyZWFtIENvbnRyb2xsZXJcclxuKi9cclxuXHJcbmltcG9ydCBCaW5hcnlTZWFyY2ggZnJvbSAnLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCc7XHJcbmltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xyXG5pbXBvcnQgRGVtdXhlciBmcm9tICcuLi9kZW11eC9kZW11eGVyJztcclxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcbmltcG9ydCB7IEZyYWdtZW50U3RhdGUgfSBmcm9tICcuL2ZyYWdtZW50LXRyYWNrZXInO1xyXG5pbXBvcnQgeyBFbGVtZW50YXJ5U3RyZWFtVHlwZXMgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xyXG5pbXBvcnQgeyBQbGF5bGlzdExldmVsVHlwZSB9IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XHJcbmltcG9ydCAqIGFzIExldmVsSGVscGVyIGZyb20gJy4vbGV2ZWwtaGVscGVyJztcclxuaW1wb3J0IFRpbWVSYW5nZXMgZnJvbSAnLi4vdXRpbHMvdGltZS1yYW5nZXMnO1xyXG5pbXBvcnQgeyBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgeyBhbGlnblN0cmVhbSB9IGZyb20gJy4uL3V0aWxzL2Rpc2NvbnRpbnVpdGllcyc7XHJcbmltcG9ydCB7IGZpbmRGcmFnbWVudEJ5UERULCBmaW5kRnJhZ21lbnRCeVBUUyB9IGZyb20gJy4vZnJhZ21lbnQtZmluZGVycyc7XHJcbmltcG9ydCBHYXBDb250cm9sbGVyIGZyb20gJy4vZ2FwLWNvbnRyb2xsZXInO1xyXG5pbXBvcnQgQmFzZVN0cmVhbUNvbnRyb2xsZXIsIHsgU3RhdGUgfSBmcm9tICcuL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXInO1xyXG5cclxuY29uc3QgVElDS19JTlRFUlZBTCA9IDEwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcclxuXHJcbmNsYXNzIFN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlciB7XHJcbiAgY29uc3RydWN0b3IgKGhscywgZnJhZ21lbnRUcmFja2VyKSB7XHJcbiAgICBzdXBlcihobHMsXHJcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxyXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXHJcbiAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURJTkcsXHJcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRCxcclxuICAgICAgRXZlbnQuTEVWRUxfTE9BREVELFxyXG4gICAgICBFdmVudC5LRVlfTE9BREVELFxyXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcclxuICAgICAgRXZlbnQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELFxyXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULFxyXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfREFUQSxcclxuICAgICAgRXZlbnQuRlJBR19QQVJTRUQsXHJcbiAgICAgIEV2ZW50LkVSUk9SLFxyXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0hJTkcsXHJcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELFxyXG4gICAgICBFdmVudC5CVUZGRVJfQ1JFQVRFRCxcclxuICAgICAgRXZlbnQuQlVGRkVSX0FQUEVOREVELFxyXG4gICAgICBFdmVudC5CVUZGRVJfRkxVU0hFRCk7XHJcblxyXG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XHJcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gZmFsc2U7XHJcbiAgICB0aGlzLl9zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XHJcbiAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG51bGw7XHJcbiAgICB0aGlzLmFsdEF1ZGlvID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBzdGFydExvYWQgKHN0YXJ0UG9zaXRpb24pIHtcclxuICAgIGlmICh0aGlzLmxldmVscykge1xyXG4gICAgICBsZXQgbGFzdEN1cnJlbnRUaW1lID0gdGhpcy5sYXN0Q3VycmVudFRpbWUsIGhscyA9IHRoaXMuaGxzO1xyXG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XHJcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XHJcbiAgICAgIHRoaXMubGV2ZWwgPSAtMTtcclxuICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcclxuICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xyXG4gICAgICAgIC8vIGRldGVybWluZSBsb2FkIGxldmVsXHJcbiAgICAgICAgbGV0IHN0YXJ0TGV2ZWwgPSBobHMuc3RhcnRMZXZlbDtcclxuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEpIHtcclxuICAgICAgICAgIC8vIC0xIDogZ3Vlc3Mgc3RhcnQgTGV2ZWwgYnkgZG9pbmcgYSBiaXRyYXRlIHRlc3QgYnkgbG9hZGluZyBmaXJzdCBmcmFnbWVudCBvZiBsb3dlc3QgcXVhbGl0eSBsZXZlbFxyXG4gICAgICAgICAgc3RhcnRMZXZlbCA9IDA7XHJcbiAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0IG5ldyBsZXZlbCB0byBwbGF5bGlzdCBsb2FkZXIgOiB0aGlzIHdpbGwgdHJpZ2dlciBzdGFydCBsZXZlbCBsb2FkXHJcbiAgICAgICAgLy8gaGxzLm5leHRMb2FkTGV2ZWwgcmVtYWlucyB1bnRpbCBpdCBpcyBzZXQgdG8gYSBuZXcgdmFsdWUgb3IgdW50aWwgYSBuZXcgZnJhZyBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkXHJcbiAgICAgICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gc3RhcnRMZXZlbDtcclxuICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgLy8gaWYgc3RhcnRQb3NpdGlvbiB1bmRlZmluZWQgYnV0IGxhc3RDdXJyZW50VGltZSBzZXQsIHNldCBzdGFydFBvc2l0aW9uIHRvIGxhc3QgY3VycmVudFRpbWVcclxuICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcclxuICAgICAgICBsb2dnZXIubG9nKGBvdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xyXG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBsYXN0Q3VycmVudFRpbWU7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcclxuICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmZvcmNlU3RhcnRMb2FkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdG9wTG9hZCAoKSB7XHJcbiAgICB0aGlzLmZvcmNlU3RhcnRMb2FkID0gZmFsc2U7XHJcbiAgICBzdXBlci5zdG9wTG9hZCgpO1xyXG4gIH1cclxuXHJcbiAgZG9UaWNrICgpIHtcclxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xyXG4gICAgY2FzZSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc6XHJcbiAgICAgIC8vIGluIGJ1ZmZlciBmbHVzaGluZyBzdGF0ZSwgcmVzZXQgZnJhZ0xvYWRFcnJvciBjb3VudGVyXHJcbiAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBTdGF0ZS5JRExFOlxyXG4gICAgICB0aGlzLl9kb1RpY2tJZGxlKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0xFVkVMOlxyXG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXTtcclxuICAgICAgLy8gY2hlY2sgaWYgcGxheWxpc3QgaXMgYWxyZWFkeSBsb2FkZWRcclxuICAgICAgaWYgKGxldmVsICYmIGxldmVsLmRldGFpbHMpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxyXG4gICAgICB2YXIgbm93ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICB2YXIgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XHJcbiAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXHJcbiAgICAgIGlmICghcmV0cnlEYXRlIHx8IChub3cgPj0gcmV0cnlEYXRlKSB8fCAodGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhLnNlZWtpbmcpKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnbWVkaWFDb250cm9sbGVyOiByZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZScpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBTdGF0ZS5FUlJPUjpcclxuICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcclxuICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxyXG4gICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxyXG4gICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XHJcbiAgICBjYXNlIFN0YXRlLkVOREVEOlxyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgYnVmZmVyXHJcbiAgICB0aGlzLl9jaGVja0J1ZmZlcigpO1xyXG4gICAgLy8gY2hlY2svdXBkYXRlIGN1cnJlbnQgZnJhZ21lbnRcclxuICAgIHRoaXMuX2NoZWNrRnJhZ21lbnRDaGFuZ2VkKCk7XHJcbiAgfVxyXG5cclxuICAvLyBJcm9uaWNhbGx5IHRoZSBcImlkbGVcIiBzdGF0ZSBpcyB0aGUgb24gd2UgZG8gdGhlIG1vc3QgbG9naWMgaW4gaXQgc2VlbXMgLi4uLlxyXG4gIC8vIE5PVEU6IE1heWJlIHdlIGNvdWxkIHJhdGhlciBzY2hlZHVsZSBhIGNoZWNrIGZvciBidWZmZXIgbGVuZ3RoIGFmdGVyIGhhbGYgb2YgdGhlIGN1cnJlbnRseVxyXG4gIC8vICAgICAgIHBsYXllZCBzZWdtZW50LCBvciBvbiBwYXVzZS9wbGF5L3NlZWsgaW5zdGVhZCBvZiBuYWl2ZWx5IGNoZWNraW5nIGV2ZXJ5IDEwMG1zP1xyXG4gIF9kb1RpY2tJZGxlICgpIHtcclxuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzLFxyXG4gICAgICBjb25maWcgPSBobHMuY29uZmlnLFxyXG4gICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XHJcblxyXG4gICAgLy8gaWYgc3RhcnQgbGV2ZWwgbm90IHBhcnNlZCB5ZXQgT1JcclxuICAgIC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkQgc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBkaXNhYmxlXHJcbiAgICAvLyBleGl0IGxvb3AsIGFzIHdlIGVpdGhlciBuZWVkIG1vcmUgaW5mbyAobGV2ZWwgbm90IHBhcnNlZCkgb3Igd2UgbmVlZCBtZWRpYSB0byBiZSBhdHRhY2hlZCB0byBsb2FkIG5ldyBmcmFnbWVudFxyXG4gICAgaWYgKHRoaXMubGV2ZWxMYXN0TG9hZGVkID09PSB1bmRlZmluZWQgfHwgKFxyXG4gICAgICAhbWVkaWEgJiYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxyXG4gICAgbGV0IHBvcztcclxuICAgIGlmICh0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XHJcbiAgICAgIHBvcyA9IG1lZGlhLmN1cnJlbnRUaW1lO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRldGVybWluZSBuZXh0IGxvYWQgbGV2ZWxcclxuICAgIGxldCBsZXZlbCA9IGhscy5uZXh0TG9hZExldmVsLFxyXG4gICAgICBsZXZlbEluZm8gPSB0aGlzLmxldmVsc1tsZXZlbF07XHJcblxyXG4gICAgaWYgKCFsZXZlbEluZm8pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBsZXZlbEJpdHJhdGUgPSBsZXZlbEluZm8uYml0cmF0ZSxcclxuICAgICAgbWF4QnVmTGVuO1xyXG5cclxuICAgIC8vIGNvbXB1dGUgbWF4IEJ1ZmZlciBMZW5ndGggdGhhdCB3ZSBjb3VsZCBnZXQgZnJvbSB0aGlzIGxvYWQgbGV2ZWwsIGJhc2VkIG9uIGxldmVsIGJpdHJhdGUuXHJcbiAgICBpZiAobGV2ZWxCaXRyYXRlKSB7XHJcbiAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWF4KDggKiBjb25maWcubWF4QnVmZmVyU2l6ZSAvIGxldmVsQml0cmF0ZSwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIG1heEJ1ZkxlbiA9IE1hdGgubWluKG1heEJ1ZkxlbiwgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCk7XHJcblxyXG4gICAgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmQgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxyXG4gICAgLy8gZW5zdXJlIHVwIHRvIGBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoYCBvZiBidWZmZXIgdXBmcm9udFxyXG5cclxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IG1lZGlhLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKSxcclxuICAgICAgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XHJcbiAgICAvLyBTdGF5IGlkbGUgaWYgd2UgYXJlIHN0aWxsIHdpdGggYnVmZmVyIG1hcmdpbnNcclxuICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnQgLi4uXHJcbiAgICBsb2dnZXIudHJhY2UoYGJ1ZmZlciBsZW5ndGggb2YgJHtidWZmZXJMZW4udG9GaXhlZCgzKX0gaXMgYmVsb3cgbWF4IG9mICR7bWF4QnVmTGVuLnRvRml4ZWQoMyl9LiBjaGVja2luZyBmb3IgbW9yZSBwYXlsb2FkIC4uLmApO1xyXG5cclxuICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXHJcbiAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcclxuXHJcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcclxuICAgIC8vIGlmIGxldmVsIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgbGV2ZWwgcmV0cmlldmFsXHJcbiAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcclxuICAgIC8vIGEgdXNlbGVzcyBhbmQgb3V0ZGF0ZWQgZnJhZ21lbnQgKHRoYXQgbWlnaHQgZXZlbiBpbnRyb2R1Y2UgbG9hZCBlcnJvciBpZiBpdCBpcyBhbHJlYWR5IG91dCBvZiB0aGUgbGl2ZSBwbGF5bGlzdClcclxuICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8IChsZXZlbERldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWwpKSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIGxldmVsRGV0YWlscykpIHtcclxuICAgICAgY29uc3QgZGF0YSA9IHt9O1xyXG4gICAgICBpZiAodGhpcy5hbHRBdWRpbykge1xyXG4gICAgICAgIGRhdGEudHlwZSA9ICd2aWRlbyc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0VPUywgZGF0YSk7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgd2UgaGF2ZSB0aGUgbGV2ZWxEZXRhaWxzIGZvciB0aGUgc2VsZWN0ZWQgdmFyaWFudCwgbGV0cyBjb250aW51ZSBlbnJpY2hlbiBvdXIgc3RyZWFtIChsb2FkIGtleXMvZnJhZ21lbnRzIG9yIHRyaWdnZXIgRU9TLCBldGMuLilcclxuICAgIHRoaXMuX2ZldGNoUGF5bG9hZE9yRW9zKHBvcywgYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKTtcclxuICB9XHJcblxyXG4gIF9mZXRjaFBheWxvYWRPckVvcyAocG9zLCBidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpIHtcclxuICAgIGNvbnN0IGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzLFxyXG4gICAgICBsZXZlbCA9IHRoaXMubGV2ZWwsXHJcbiAgICAgIGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHMsXHJcbiAgICAgIGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xyXG5cclxuICAgIC8vIGVtcHR5IHBsYXlsaXN0XHJcbiAgICBpZiAoZnJhZ0xlbiA9PT0gMCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cclxuICAgIGxldCBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydCxcclxuICAgICAgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uZHVyYXRpb24sXHJcbiAgICAgIGJ1ZmZlckVuZCA9IGJ1ZmZlckluZm8uZW5kLFxyXG4gICAgICBmcmFnO1xyXG5cclxuICAgIGlmIChsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQgJiYgIWxldmVsRGV0YWlscy5pbml0U2VnbWVudC5kYXRhKSB7XHJcbiAgICAgIGZyYWcgPSBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBpbiBjYXNlIG9mIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgbm90IGxvY2F0ZWQgYmVmb3JlIHBsYXlsaXN0IHN0YXJ0XHJcbiAgICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSkge1xyXG4gICAgICAgIGxldCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSA9IHRoaXMuY29uZmlnLmluaXRpYWxMaXZlTWFuaWZlc3RTaXplO1xyXG4gICAgICAgIGlmIChmcmFnTGVuIDwgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUpIHtcclxuICAgICAgICAgIGxvZ2dlci53YXJuKGBDYW4gbm90IHN0YXJ0IHBsYXliYWNrIG9mIGEgbGV2ZWwsIHJlYXNvbjogbm90IGVub3VnaCBmcmFnbWVudHMgJHtmcmFnTGVufSA8ICR7aW5pdGlhbExpdmVNYW5pZmVzdFNpemV9YCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmcmFnID0gdGhpcy5fZW5zdXJlRnJhZ21lbnRBdExpdmVQb2ludChsZXZlbERldGFpbHMsIGJ1ZmZlckVuZCwgc3RhcnQsIGVuZCwgZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGZyYWdMZW4pO1xyXG4gICAgICAgIC8vIGlmIGl0IGV4cGxpY2l0ZWx5IHJldHVybnMgbnVsbCBkb24ndCBsb2FkIGFueSBmcmFnbWVudCBhbmQgZXhpdCBmdW5jdGlvbiBub3dcclxuICAgICAgICBpZiAoZnJhZyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBWb0QgcGxheWxpc3Q6IGlmIGJ1ZmZlckVuZCBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcclxuICAgICAgICBpZiAoYnVmZmVyRW5kIDwgc3RhcnQpIHtcclxuICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWZyYWcpIHtcclxuICAgICAgZnJhZyA9IHRoaXMuX2ZpbmRGcmFnbWVudChzdGFydCwgZnJhZ1ByZXZpb3VzLCBmcmFnTGVuLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgZW5kLCBsZXZlbERldGFpbHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChmcmFnKSB7XHJcbiAgICAgIGlmIChmcmFnLmVuY3J5cHRlZCkge1xyXG4gICAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcga2V5IGZvciAke2ZyYWcuc259IG9mIFske2xldmVsRGV0YWlscy5zdGFydFNOfSAsJHtsZXZlbERldGFpbHMuZW5kU059XSxsZXZlbCAke2xldmVsfWApO1xyXG4gICAgICAgIHRoaXMuX2xvYWRLZXkoZnJhZyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyAke2ZyYWcuc259IG9mIFske2xldmVsRGV0YWlscy5zdGFydFNOfSAsJHtsZXZlbERldGFpbHMuZW5kU059XSxsZXZlbCAke2xldmVsfSwgY3VycmVudFRpbWU6JHtwb3MudG9GaXhlZCgzKX0sYnVmZmVyRW5kOiR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9YCk7XHJcbiAgICAgICAgdGhpcy5fbG9hZEZyYWdtZW50KGZyYWcpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfZW5zdXJlRnJhZ21lbnRBdExpdmVQb2ludCAobGV2ZWxEZXRhaWxzLCBidWZmZXJFbmQsIHN0YXJ0LCBlbmQsIGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBmcmFnTGVuKSB7XHJcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWcsIG1lZGlhID0gdGhpcy5tZWRpYTtcclxuXHJcbiAgICBsZXQgZnJhZztcclxuXHJcbiAgICAvLyBjaGVjayBpZiByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgd2l0aGluIHNlZWthYmxlIGJvdW5kYXJpZXMgOlxyXG4gICAgLy8gbG9nZ2VyLmxvZyhgc3RhcnQvcG9zL2J1ZkVuZC9zZWVraW5nOiR7c3RhcnQudG9GaXhlZCgzKX0vJHtwb3MudG9GaXhlZCgzKX0vJHtidWZmZXJFbmQudG9GaXhlZCgzKX0vJHt0aGlzLm1lZGlhLnNlZWtpbmd9YCk7XHJcbiAgICBsZXQgbWF4TGF0ZW5jeSA9IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA6IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XHJcblxyXG4gICAgaWYgKGJ1ZmZlckVuZCA8IE1hdGgubWF4KHN0YXJ0IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGVuZCAtIG1heExhdGVuY3kpKSB7XHJcbiAgICAgIGxldCBsaXZlU3luY1Bvc2l0aW9uID0gdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHN0YXJ0LCBsZXZlbERldGFpbHMpO1xyXG4gICAgICBsb2dnZXIubG9nKGBidWZmZXIgZW5kOiAke2J1ZmZlckVuZC50b0ZpeGVkKDMpfSBpcyBsb2NhdGVkIHRvbyBmYXIgZnJvbSB0aGUgZW5kIG9mIGxpdmUgc2xpZGluZyBwbGF5bGlzdCwgcmVzZXQgY3VycmVudFRpbWUgdG8gOiAke2xpdmVTeW5jUG9zaXRpb24udG9GaXhlZCgzKX1gKTtcclxuICAgICAgYnVmZmVyRW5kID0gbGl2ZVN5bmNQb3NpdGlvbjtcclxuICAgICAgaWYgKG1lZGlhICYmICFtZWRpYS5wYXVzZWQgJiYgbWVkaWEucmVhZHlTdGF0ZSAmJiBtZWRpYS5kdXJhdGlvbiA+IGxpdmVTeW5jUG9zaXRpb24pIHtcclxuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGxpdmVTeW5jUG9zaXRpb247XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGxpdmVTeW5jUG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgZW5kIG9mIGJ1ZmZlciBncmVhdGVyIHRoYW4gbGl2ZSBlZGdlLCBkb24ndCBsb2FkIGFueSBmcmFnbWVudFxyXG4gICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaWYgbGl2ZSBwbGF5bGlzdCBpbnRlcm1pdHRlbnRseSBzbGlkZXMgaW4gdGhlIHBhc3QuXHJcbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYxLDE4MjU4MDE2N11cclxuICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjIsMTgyNTgwMTY5XVxyXG4gICAgLy8gTG9hZGluZyAxODI1ODAxNjggb2YgWzE4MjU4MDE2MiAsMTgyNTgwMTY5XSxsZXZlbCAxIC4uXHJcbiAgICAvLyBMb2FkaW5nIDE4MjU4MDE2OSBvZiBbMTgyNTgwMTYyICwxODI1ODAxNjldLGxldmVsIDEgLi5cclxuICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjIsMTgyNTgwMTY4XSA8PT09PT09PT09PT09PSBoZXJlIHdlIHNob3VsZCBoYXZlIGJ1ZmZlckVuZCA+IGVuZC4gaW4gdGhhdCBjYXNlIGJyZWFrIHRvIGF2b2lkIHJlbG9hZGluZyAxODI1ODAxNjhcclxuICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjQsMTgyNTgwMTcxXVxyXG4gICAgLy9cclxuICAgIC8vIGRvbid0IHJldHVybiBudWxsIGluIGNhc2UgbWVkaWEgbm90IGxvYWRlZCB5ZXQgKHJlYWR5c3RhdGUgPT09IDApXHJcbiAgICBpZiAobGV2ZWxEZXRhaWxzLlBUU0tub3duICYmIGJ1ZmZlckVuZCA+IGVuZCAmJiBtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiAhbGV2ZWxEZXRhaWxzLlBUU0tub3duKSB7XHJcbiAgICAgIC8qIHdlIGFyZSBzd2l0Y2hpbmcgbGV2ZWwgb24gbGl2ZSBwbGF5bGlzdCwgYnV0IHdlIGRvbid0IGhhdmUgYW55IFBUUyBpbmZvIGZvciB0aGF0IHF1YWxpdHkgbGV2ZWwgLi4uXHJcbiAgICAgICAgIHRyeSB0byBsb2FkIGZyYWcgbWF0Y2hpbmcgd2l0aCBuZXh0IFNOLlxyXG4gICAgICAgICBldmVuIGlmIFNOIGFyZSBub3Qgc3luY2hyb25pemVkIGJldHdlZW4gcGxheWxpc3RzLCBsb2FkaW5nIHRoaXMgZnJhZyB3aWxsIGhlbHAgdXNcclxuICAgICAgICAgY29tcHV0ZSBwbGF5bGlzdCBzbGlkaW5nIGFuZCBmaW5kIHRoZSByaWdodCBvbmUgYWZ0ZXIgaW4gY2FzZSBpdCB3YXMgbm90IHRoZSByaWdodCBjb25zZWN1dGl2ZSBvbmUgKi9cclxuICAgICAgaWYgKGZyYWdQcmV2aW91cykge1xyXG4gICAgICAgIGlmIChsZXZlbERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XHJcbiAgICAgICAgICAvLyBSZWxpZXMgb24gUERUIGluIG9yZGVyIHRvIHN3aXRjaCBiaXRyYXRlcyAoU3VwcG9ydCBFWFQtWC1ESVNDT05USU5VSVRZIHdpdGhvdXQgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcclxuICAgICAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggc2FtZSBQRFQ6ICR7ZnJhZ1ByZXZpb3VzLnByb2dyYW1EYXRlVGltZX1gKTtcclxuICAgICAgICAgIGZyYWcgPSBmaW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5lbmRQcm9ncmFtRGF0ZVRpbWUsIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gVXNlcyBidWZmZXIgYW5kIHNlcXVlbmNlIG51bWJlciB0byBjYWxjdWxhdGUgc3dpdGNoIHNlZ21lbnQgKHJlcXVpcmVkIGlmIHVzaW5nIEVYVC1YLURJU0NPTlRJTlVJVFktU0VRVUVOQ0UpXHJcbiAgICAgICAgICBjb25zdCB0YXJnZXRTTiA9IGZyYWdQcmV2aW91cy5zbiArIDE7XHJcbiAgICAgICAgICBpZiAodGFyZ2V0U04gPj0gbGV2ZWxEZXRhaWxzLnN0YXJ0U04gJiYgdGFyZ2V0U04gPD0gbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyYWdOZXh0ID0gZnJhZ21lbnRzW3RhcmdldFNOIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xyXG4gICAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzLmNjID09PSBmcmFnTmV4dC5jYykge1xyXG4gICAgICAgICAgICAgIGZyYWcgPSBmcmFnTmV4dDtcclxuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIG5leHQgU046ICR7ZnJhZy5zbn1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gbmV4dCBmcmFnIFNOIG5vdCBhdmFpbGFibGUgKG9yIG5vdCB3aXRoIHNhbWUgY29udGludWl0eSBjb3VudGVyKVxyXG4gICAgICAgICAgLy8gbG9vayBmb3IgYSBmcmFnIHNoYXJpbmcgdGhlIHNhbWUgQ0NcclxuICAgICAgICAgIGlmICghZnJhZykge1xyXG4gICAgICAgICAgICBmcmFnID0gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZyYWdQcmV2aW91cy5jYyAtIGZyYWcuY2M7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoZnJhZykge1xyXG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggc2FtZSBDQzogJHtmcmFnLnNufWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghZnJhZykge1xyXG4gICAgICAgIC8qIHdlIGhhdmUgbm8gaWRlYSBhYm91dCB3aGljaCBmcmFnbWVudCBzaG91bGQgYmUgbG9hZGVkLlxyXG4gICAgICAgICAgIHNvIGxldCdzIGxvYWQgbWlkIGZyYWdtZW50LiBpdCB3aWxsIGhlbHAgY29tcHV0aW5nIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGZpbmQgdGhlIHJpZ2h0IG9uZVxyXG4gICAgICAgICovXHJcbiAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tNYXRoLm1pbihmcmFnTGVuIC0gMSwgTWF0aC5yb3VuZChmcmFnTGVuIC8gMikpXTtcclxuICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIHVua25vd24sIGxvYWQgbWlkZGxlIGZyYWcgOiAke2ZyYWcuc259YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnJhZztcclxuICB9XHJcblxyXG4gIF9maW5kRnJhZ21lbnQgKHN0YXJ0LCBmcmFnUHJldmlvdXNMb2FkLCBmcmFnbWVudEluZGV4UmFuZ2UsIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlscykge1xyXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xyXG4gICAgbGV0IGZyYWdOZXh0TG9hZDtcclxuXHJcbiAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XHJcbiAgICAgIGNvbnN0IGxvb2t1cFRvbGVyYW5jZSA9IChidWZmZXJFbmQgPiBlbmQgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkgPyAwIDogY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XHJcbiAgICAgIC8vIFJlbW92ZSB0aGUgdG9sZXJhbmNlIGlmIGl0IHdvdWxkIHB1dCB0aGUgYnVmZmVyRW5kIHBhc3QgdGhlIGFjdHVhbCBlbmQgb2Ygc3RyZWFtXHJcbiAgICAgIC8vIFVzZXMgYnVmZmVyIGFuZCBzZXF1ZW5jZSBudW1iZXIgdG8gY2FsY3VsYXRlIHN3aXRjaCBzZWdtZW50IChyZXF1aXJlZCBpZiB1c2luZyBFWFQtWC1ESVNDT05USU5VSVRZLVNFUVVFTkNFKVxyXG4gICAgICBmcmFnTmV4dExvYWQgPSBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXNMb2FkLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgbG9va3VwVG9sZXJhbmNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxyXG4gICAgICBmcmFnTmV4dExvYWQgPSBmcmFnbWVudHNbZnJhZ21lbnRJbmRleFJhbmdlIC0gMV07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZyYWdOZXh0TG9hZCkge1xyXG4gICAgICBjb25zdCBjdXJTTklkeCA9IGZyYWdOZXh0TG9hZC5zbiAtIGxldmVsRGV0YWlscy5zdGFydFNOO1xyXG4gICAgICBjb25zdCBzYW1lTGV2ZWwgPSBmcmFnUHJldmlvdXNMb2FkICYmIGZyYWdOZXh0TG9hZC5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzTG9hZC5sZXZlbDtcclxuICAgICAgY29uc3QgcHJldlNuRnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCAtIDFdO1xyXG4gICAgICBjb25zdCBuZXh0U25GcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4ICsgMV07XHJcblxyXG4gICAgICAvLyBsb2dnZXIubG9nKCdmaW5kIFNOIG1hdGNoaW5nIHdpdGggcG9zOicgKyAgYnVmZmVyRW5kICsgJzonICsgZnJhZy5zbik7XHJcbiAgICAgIGlmIChmcmFnUHJldmlvdXNMb2FkICYmIGZyYWdOZXh0TG9hZC5zbiA9PT0gZnJhZ1ByZXZpb3VzTG9hZC5zbikge1xyXG4gICAgICAgIGlmIChzYW1lTGV2ZWwgJiYgIWZyYWdOZXh0TG9hZC5iYWNrdHJhY2tlZCkge1xyXG4gICAgICAgICAgaWYgKGZyYWdOZXh0TG9hZC5zbiA8IGxldmVsRGV0YWlscy5lbmRTTikge1xyXG4gICAgICAgICAgICBsZXQgZGVsdGFQVFMgPSBmcmFnUHJldmlvdXNMb2FkLmRlbHRhUFRTO1xyXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNpZ25pZmljYW50IGRlbHRhIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBsYXJnZXIgdGhhbiBtYXggYWxsb3dlZCBob2xlLFxyXG4gICAgICAgICAgICAvLyBhbmQgaWYgcHJldmlvdXMgcmVtdXhlZCBmcmFnbWVudCBkaWQgbm90IHN0YXJ0IHdpdGggYSBrZXlmcmFtZS4gKGZyYWdQcmV2aW91cy5kcm9wcGVkKVxyXG4gICAgICAgICAgICAvLyBsZXQncyB0cnkgdG8gbG9hZCBwcmV2aW91cyBmcmFnbWVudCBhZ2FpbiB0byBnZXQgbGFzdCBrZXlmcmFtZVxyXG4gICAgICAgICAgICAvLyB0aGVuIHdlIHdpbGwgcmVsb2FkIGFnYWluIGN1cnJlbnQgZnJhZ21lbnQgKHRoYXQgd2F5IHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpbGwgdGhlIGJ1ZmZlciBob2xlIC4uLilcclxuICAgICAgICAgICAgaWYgKGRlbHRhUFRTICYmIGRlbHRhUFRTID4gY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgZnJhZ1ByZXZpb3VzTG9hZC5kcm9wcGVkICYmIGN1clNOSWR4KSB7XHJcbiAgICAgICAgICAgICAgZnJhZ05leHRMb2FkID0gcHJldlNuRnJhZztcclxuICAgICAgICAgICAgICBsb2dnZXIud2FybignUHJldmlvdXMgZnJhZ21lbnQgd2FzIGRyb3BwZWQgd2l0aCBsYXJnZSBQVFMgZ2FwIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLiBNYXliZSBmcmFnbWVudCBpcyBub3Qgc3RhcnRpbmcgd2l0aCBhIGtleWZyYW1lPyBMb2FkaW5nIHByZXZpb3VzIG9uZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpcycpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGZyYWdOZXh0TG9hZCA9IG5leHRTbkZyYWc7XHJcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgUmUtbG9hZGluZyBmcmFnbWVudCB3aXRoIFNOOiAke2ZyYWdOZXh0TG9hZC5zbn1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZnJhZ05leHRMb2FkID0gbnVsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGZyYWdOZXh0TG9hZC5iYWNrdHJhY2tlZCkge1xyXG4gICAgICAgICAgLy8gT25seSBiYWNrdHJhY2sgYSBtYXggb2YgMSBjb25zZWN1dGl2ZSBmcmFnbWVudCB0byBwcmV2ZW50IHNsaWRpbmcgYmFjayB0b28gZmFyIHdoZW4gbGl0dGxlIG9yIG5vIGZyYWdzIHN0YXJ0IHdpdGgga2V5ZnJhbWVzXHJcbiAgICAgICAgICBpZiAobmV4dFNuRnJhZyAmJiBuZXh0U25GcmFnLmJhY2t0cmFja2VkKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBBbHJlYWR5IGJhY2t0cmFja2VkIGZyb20gZnJhZ21lbnQgJHtuZXh0U25GcmFnLnNufSwgd2lsbCBub3QgYmFja3RyYWNrIHRvIGZyYWdtZW50ICR7ZnJhZ05leHRMb2FkLnNufS4gTG9hZGluZyBmcmFnbWVudCAke25leHRTbkZyYWcuc259YCk7XHJcbiAgICAgICAgICAgIGZyYWdOZXh0TG9hZCA9IG5leHRTbkZyYWc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiBhIGZyYWdtZW50IGhhcyBkcm9wcGVkIGZyYW1lcyBhbmQgaXQncyBpbiBhIHNhbWUgbGV2ZWwvc2VxdWVuY2UsIGxvYWQgdGhlIHByZXZpb3VzIGZyYWdtZW50IHRvIHRyeSBhbmQgZmluZCB0aGUga2V5ZnJhbWVcclxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGRyb3BwZWQgY291bnQgbm93IHNpbmNlIGl0IHdvbid0IGJlIHJlc2V0IHVudGlsIHdlIHBhcnNlIHRoZSBmcmFnbWVudCBhZ2Fpbiwgd2hpY2ggcHJldmVudHMgaW5maW5pdGUgYmFja3RyYWNraW5nIG9uIHRoZSBzYW1lIHNlZ21lbnRcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0xvYWRlZCBmcmFnbWVudCB3aXRoIGRyb3BwZWQgZnJhbWVzLCBiYWNrdHJhY2tpbmcgMSBzZWdtZW50IHRvIGZpbmQgYSBrZXlmcmFtZScpO1xyXG4gICAgICAgICAgICBmcmFnTmV4dExvYWQuZHJvcHBlZCA9IDA7XHJcbiAgICAgICAgICAgIGlmIChwcmV2U25GcmFnKSB7XHJcbiAgICAgICAgICAgICAgZnJhZ05leHRMb2FkID0gcHJldlNuRnJhZztcclxuICAgICAgICAgICAgICBmcmFnTmV4dExvYWQuYmFja3RyYWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1clNOSWR4KSB7XHJcbiAgICAgICAgICAgICAgLy8gY2FuJ3QgYmFja3RyYWNrIG9uIHZlcnkgZmlyc3QgZnJhZ21lbnRcclxuICAgICAgICAgICAgICBmcmFnTmV4dExvYWQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZyYWdOZXh0TG9hZDtcclxuICB9XHJcblxyXG4gIF9sb2FkS2V5IChmcmFnKSB7XHJcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuS0VZX0xPQURJTkc7XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FESU5HLCB7IGZyYWcgfSk7XHJcbiAgfVxyXG5cclxuICBfbG9hZEZyYWdtZW50IChmcmFnKSB7XHJcbiAgICAvLyBDaGVjayBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXHJcbiAgICBsZXQgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XHJcblxyXG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XHJcbiAgICBpZiAoZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xyXG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBEb24ndCB1cGRhdGUgbmV4dExvYWRQb3NpdGlvbiBmb3IgZnJhZ21lbnRzIHdoaWNoIGFyZSBub3QgYnVmZmVyZWRcclxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbikgJiYgIWZyYWcuYml0cmF0ZVRlc3QpIHtcclxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWxsb3cgYmFja3RyYWNrZWQgZnJhZ21lbnRzIHRvIGxvYWRcclxuICAgIGlmIChmcmFnLmJhY2t0cmFja2VkIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMKSB7XHJcbiAgICAgIGZyYWcuYXV0b0xldmVsID0gdGhpcy5obHMuYXV0b0xldmVsRW5hYmxlZDtcclxuICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IHRoaXMuYml0cmF0ZVRlc3Q7XHJcblxyXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRElORywgeyBmcmFnIH0pO1xyXG4gICAgICAvLyBsYXp5IGRlbXV4ZXIgaW5pdCwgYXMgdGhpcyBjb3VsZCB0YWtlIHNvbWUgdGltZSAuLi4gZG8gaXQgZHVyaW5nIGZyYWcgbG9hZGluZ1xyXG4gICAgICBpZiAoIXRoaXMuZGVtdXhlcikge1xyXG4gICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKHRoaXMuaGxzLCAnbWFpbicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xyXG4gICAgfSBlbHNlIGlmIChmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuQVBQRU5ESU5HKSB7XHJcbiAgICAgIC8vIExvd2VyIHRoZSBidWZmZXIgc2l6ZSBhbmQgdHJ5IGFnYWluXHJcbiAgICAgIGlmICh0aGlzLl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGgoZnJhZy5kdXJhdGlvbikpIHtcclxuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2V0IHN0YXRlIChuZXh0U3RhdGUpIHtcclxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBuZXh0U3RhdGUpIHtcclxuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xyXG4gICAgICBsb2dnZXIubG9nKGBtYWluIHN0cmVhbS1jb250cm9sbGVyOiAke3ByZXZpb3VzU3RhdGV9LT4ke25leHRTdGF0ZX1gKTtcclxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVFJFQU1fU1RBVEVfVFJBTlNJVElPTiwgeyBwcmV2aW91c1N0YXRlLCBuZXh0U3RhdGUgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgc3RhdGUgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xyXG4gIH1cclxuXHJcbiAgZ2V0QnVmZmVyZWRGcmFnIChwb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XHJcbiAgfVxyXG5cclxuICBnZXQgY3VycmVudExldmVsICgpIHtcclxuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgY29uc3QgZnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcclxuICAgICAgaWYgKGZyYWcpIHtcclxuICAgICAgICByZXR1cm4gZnJhZy5sZXZlbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG5leHRCdWZmZXJlZEZyYWcgKCkge1xyXG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcclxuICAgIGlmIChtZWRpYSkge1xyXG4gICAgICAvLyBmaXJzdCBnZXQgZW5kIHJhbmdlIG9mIGN1cnJlbnQgZnJhZ21lbnRcclxuICAgICAgcmV0dXJuIHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZvbGxvd2luZ0J1ZmZlcmVkRnJhZyAoZnJhZykge1xyXG4gICAgaWYgKGZyYWcpIHtcclxuICAgICAgLy8gdHJ5IHRvIGdldCByYW5nZSBvZiBuZXh0IGZyYWdtZW50ICg1MDBtcyBhZnRlciB0aGlzIHJhbmdlKVxyXG4gICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJlZEZyYWcoZnJhZy5lbmRQVFMgKyAwLjUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBnZXQgbmV4dExldmVsICgpIHtcclxuICAgIGNvbnN0IGZyYWcgPSB0aGlzLm5leHRCdWZmZXJlZEZyYWc7XHJcbiAgICBpZiAoZnJhZykge1xyXG4gICAgICByZXR1cm4gZnJhZy5sZXZlbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9jaGVja0ZyYWdtZW50Q2hhbmdlZCAoKSB7XHJcbiAgICBsZXQgZnJhZ1BsYXlpbmdDdXJyZW50LCBjdXJyZW50VGltZSwgdmlkZW8gPSB0aGlzLm1lZGlhO1xyXG4gICAgaWYgKHZpZGVvICYmIHZpZGVvLnJlYWR5U3RhdGUgJiYgdmlkZW8uc2Vla2luZyA9PT0gZmFsc2UpIHtcclxuICAgICAgY3VycmVudFRpbWUgPSB2aWRlby5jdXJyZW50VGltZTtcclxuICAgICAgLyogaWYgdmlkZW8gZWxlbWVudCBpcyBpbiBzZWVrZWQgc3RhdGUsIGN1cnJlbnRUaW1lIGNhbiBvbmx5IGluY3JlYXNlLlxyXG4gICAgICAgIChhc3N1bWluZyB0aGF0IHBsYXliYWNrIHJhdGUgaXMgcG9zaXRpdmUgLi4uKVxyXG4gICAgICAgIEFzIHNvbWV0aW1lcyBjdXJyZW50VGltZSBqdW1wcyBiYWNrIHRvIHplcm8gYWZ0ZXIgYVxyXG4gICAgICAgIG1lZGlhIGRlY29kZSBlcnJvciwgY2hlY2sgdGhpcywgdG8gYXZvaWQgc2Vla2luZyBiYWNrIHRvXHJcbiAgICAgICAgd3JvbmcgcG9zaXRpb24gYWZ0ZXIgYSBtZWRpYSBkZWNvZGUgZXJyb3JcclxuICAgICAgKi9cclxuICAgICAgaWYgKGN1cnJlbnRUaW1lID4gdGhpcy5sYXN0Q3VycmVudFRpbWUpIHtcclxuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lKSkge1xyXG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGN1cnJlbnRUaW1lKTtcclxuICAgICAgfSBlbHNlIGlmIChCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUgKyAwLjEpKSB7XHJcbiAgICAgICAgLyogZW5zdXJlIHRoYXQgRlJBR19DSEFOR0VEIGV2ZW50IGlzIHRyaWdnZXJlZCBhdCBzdGFydHVwLFxyXG4gICAgICAgICAgd2hlbiBmaXJzdCB2aWRlbyBmcmFtZSBpcyBkaXNwbGF5ZWQgYW5kIHBsYXliYWNrIGlzIHBhdXNlZC5cclxuICAgICAgICAgIGFkZCBhIHRvbGVyYW5jZSBvZiAxMDBtcywgaW4gY2FzZSBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCxcclxuICAgICAgICAgIGNoZWNrIGlmIGN1cnJlbnQgcG9zKzEwMG1zIGlzIGJ1ZmZlcmVkIGFuZCB1c2UgdGhhdCBidWZmZXIgcmFuZ2VcclxuICAgICAgICAgIGZvciBGUkFHX0NIQU5HRUQgZXZlbnQgcmVwb3J0aW5nICovXHJcbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcoY3VycmVudFRpbWUgKyAwLjEpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQpIHtcclxuICAgICAgICBsZXQgZnJhZ1BsYXlpbmcgPSBmcmFnUGxheWluZ0N1cnJlbnQ7XHJcbiAgICAgICAgaWYgKGZyYWdQbGF5aW5nICE9PSB0aGlzLmZyYWdQbGF5aW5nKSB7XHJcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQ0hBTkdFRCwgeyBmcmFnOiBmcmFnUGxheWluZyB9KTtcclxuICAgICAgICAgIGNvbnN0IGZyYWdQbGF5aW5nTGV2ZWwgPSBmcmFnUGxheWluZy5sZXZlbDtcclxuICAgICAgICAgIGlmICghdGhpcy5mcmFnUGxheWluZyB8fCB0aGlzLmZyYWdQbGF5aW5nLmxldmVsICE9PSBmcmFnUGxheWluZ0xldmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfU1dJVENIRUQsIHsgbGV2ZWw6IGZyYWdQbGF5aW5nTGV2ZWwgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy5mcmFnUGxheWluZyA9IGZyYWdQbGF5aW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLypcclxuICAgIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggOlxyXG4gICAgIC0gcGF1c2UgcGxheWJhY2sgaWYgcGxheWluZ1xyXG4gICAgIC0gY2FuY2VsIGFueSBwZW5kaW5nIGxvYWQgcmVxdWVzdFxyXG4gICAgIC0gYW5kIHRyaWdnZXIgYSBidWZmZXIgZmx1c2hcclxuICAqL1xyXG4gIGltbWVkaWF0ZUxldmVsU3dpdGNoICgpIHtcclxuICAgIGxvZ2dlci5sb2coJ2ltbWVkaWF0ZUxldmVsU3dpdGNoJyk7XHJcbiAgICBpZiAoIXRoaXMuaW1tZWRpYXRlU3dpdGNoKSB7XHJcbiAgICAgIHRoaXMuaW1tZWRpYXRlU3dpdGNoID0gdHJ1ZTtcclxuICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSwgcHJldmlvdXNseVBhdXNlZDtcclxuICAgICAgaWYgKG1lZGlhKSB7XHJcbiAgICAgICAgcHJldmlvdXNseVBhdXNlZCA9IG1lZGlhLnBhdXNlZDtcclxuICAgICAgICBtZWRpYS5wYXVzZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGRvbid0IHJlc3RhcnQgcGxheWJhY2sgYWZ0ZXIgaW5zdGFudCBsZXZlbCBzd2l0Y2ggaW4gY2FzZSBtZWRpYSBub3QgYXR0YWNoZWRcclxuICAgICAgICBwcmV2aW91c2x5UGF1c2VkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnByZXZpb3VzbHlQYXVzZWQgPSBwcmV2aW91c2x5UGF1c2VkO1xyXG4gICAgfVxyXG4gICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgIGlmIChmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcclxuICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XHJcbiAgICAvLyBmbHVzaCBldmVyeXRoaW5nXHJcbiAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCBlbmQsIGFmdGVyIG5ldyBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZDpcclxuICAgKiAtIG51ZGdlIHZpZGVvIGRlY29kZXIgYnkgc2xpZ2h0bHkgYWRqdXN0aW5nIHZpZGVvIGN1cnJlbnRUaW1lIChpZiBjdXJyZW50VGltZSBidWZmZXJlZClcclxuICAgKiAtIHJlc3VtZSB0aGUgcGxheWJhY2sgaWYgbmVlZGVkXHJcbiAgICovXHJcbiAgaW1tZWRpYXRlTGV2ZWxTd2l0Y2hFbmQgKCkge1xyXG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xyXG4gICAgaWYgKG1lZGlhICYmIG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLmltbWVkaWF0ZVN3aXRjaCA9IGZhbHNlO1xyXG4gICAgICBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIG1lZGlhLmN1cnJlbnRUaW1lKSkge1xyXG4gICAgICAgIC8vIG9ubHkgbnVkZ2UgaWYgY3VycmVudFRpbWUgaXMgYnVmZmVyZWRcclxuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSAtPSAwLjAwMDE7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLnByZXZpb3VzbHlQYXVzZWQpIHtcclxuICAgICAgICBtZWRpYS5wbGF5KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHRyeSB0byBzd2l0Y2ggQVNBUCB3aXRob3V0IGJyZWFraW5nIHZpZGVvIHBsYXliYWNrOlxyXG4gICAqIGluIG9yZGVyIHRvIGVuc3VyZSBzbW9vdGggYnV0IHF1aWNrIGxldmVsIHN3aXRjaGluZyxcclxuICAgKiB3ZSBuZWVkIHRvIGZpbmQgdGhlIG5leHQgZmx1c2hhYmxlIGJ1ZmZlciByYW5nZVxyXG4gICAqIHdlIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCBuZXcgc2VnbWVudCBmZXRjaCB0aW1lXHJcbiAgICovXHJcbiAgbmV4dExldmVsU3dpdGNoICgpIHtcclxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcclxuICAgIC8vIGVuc3VyZSB0aGF0IG1lZGlhIGlzIGRlZmluZWQgYW5kIHRoYXQgbWV0YWRhdGEgYXJlIGF2YWlsYWJsZSAodG8gcmV0cmlldmUgY3VycmVudFRpbWUpXHJcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSkge1xyXG4gICAgICBsZXQgZmV0Y2hkZWxheSwgZnJhZ1BsYXlpbmdDdXJyZW50LCBuZXh0QnVmZmVyZWRGcmFnO1xyXG4gICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XHJcbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQgJiYgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0UFRTID4gMSkge1xyXG4gICAgICAgIC8vIGZsdXNoIGJ1ZmZlciBwcmVjZWRpbmcgY3VycmVudCBmcmFnbWVudCAoZmx1c2ggdW50aWwgY3VycmVudCBmcmFnbWVudCBzdGFydCBvZmZzZXQpXHJcbiAgICAgICAgLy8gbWludXMgMXMgdG8gYXZvaWQgdmlkZW8gZnJlZXppbmcsIHRoYXQgY291bGQgaGFwcGVuIGlmIHdlIGZsdXNoIGtleWZyYW1lIG9mIGN1cnJlbnQgdmlkZW8gLi4uXHJcbiAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0UFRTIC0gMSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFtZWRpYS5wYXVzZWQpIHtcclxuICAgICAgICAvLyBhZGQgYSBzYWZldHkgZGVsYXkgb2YgMXNcclxuICAgICAgICBsZXQgbmV4dExldmVsSWQgPSB0aGlzLmhscy5uZXh0TG9hZExldmVsLCBuZXh0TGV2ZWwgPSB0aGlzLmxldmVsc1tuZXh0TGV2ZWxJZF0sIGZyYWdMYXN0S2JwcyA9IHRoaXMuZnJhZ0xhc3RLYnBzO1xyXG4gICAgICAgIGlmIChmcmFnTGFzdEticHMgJiYgdGhpcy5mcmFnQ3VycmVudCkge1xyXG4gICAgICAgICAgZmV0Y2hkZWxheSA9IHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gKiBuZXh0TGV2ZWwuYml0cmF0ZSAvICgxMDAwICogZnJhZ0xhc3RLYnBzKSArIDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmZXRjaGRlbGF5ID0gMDtcclxuICAgICAgfVxyXG4gICAgICAvLyBsb2dnZXIubG9nKCdmZXRjaGRlbGF5OicrZmV0Y2hkZWxheSk7XHJcbiAgICAgIC8vIGZpbmQgYnVmZmVyIHJhbmdlIHRoYXQgd2lsbCBiZSByZWFjaGVkIG9uY2UgbmV3IGZyYWdtZW50IHdpbGwgYmUgZmV0Y2hlZFxyXG4gICAgICBuZXh0QnVmZmVyZWRGcmFnID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUgKyBmZXRjaGRlbGF5KTtcclxuICAgICAgaWYgKG5leHRCdWZmZXJlZEZyYWcpIHtcclxuICAgICAgICAvLyB3ZSBjYW4gZmx1c2ggYnVmZmVyIHJhbmdlIGZvbGxvd2luZyB0aGlzIG9uZSB3aXRob3V0IHN0YWxsaW5nIHBsYXliYWNrXHJcbiAgICAgICAgbmV4dEJ1ZmZlcmVkRnJhZyA9IHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKG5leHRCdWZmZXJlZEZyYWcpO1xyXG4gICAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XHJcbiAgICAgICAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgd2UgY2FuIGFsc28gY2FuY2VsIGFueSBsb2FkaW5nL2RlbXV4aW5nIGluIHByb2dyZXNzLCBhcyB0aGV5IGFyZSB1c2VsZXNzXHJcbiAgICAgICAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xyXG4gICAgICAgICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xyXG4gICAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgIC8vIHN0YXJ0IGZsdXNoIHBvc2l0aW9uIGlzIHRoZSBzdGFydCBQVFMgb2YgbmV4dCBidWZmZXJlZCBmcmFnLlxyXG4gICAgICAgICAgLy8gd2UgdXNlIGZyYWcubmF4U3RhcnRQVFMgd2hpY2ggaXMgbWF4KGF1ZGlvIHN0YXJ0UFRTLCB2aWRlbyBzdGFydFBUUykuXHJcbiAgICAgICAgICAvLyBpbiBjYXNlIHRoZXJlIGlzIGEgc21hbGwgUFRTIERlbHRhIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCB1c2luZyBtYXhTdGFydFBUUyBhdm9pZHMgZmx1c2hpbmcgbGFzdCBzYW1wbGVzIGZyb20gY3VycmVudCBmcmFnbWVudFxyXG4gICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIobmV4dEJ1ZmZlcmVkRnJhZy5tYXhTdGFydFBUUywgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZsdXNoTWFpbkJ1ZmZlciAoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xyXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJVRkZFUl9GTFVTSElORztcclxuICAgIGxldCBmbHVzaFNjb3BlID0geyBzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsIGVuZE9mZnNldDogZW5kT2Zmc2V0IH07XHJcbiAgICAvLyBpZiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tzIGFyZSB1c2VkLCBvbmx5IGZsdXNoIHZpZGVvLCBvdGhlcndpc2UgZmx1c2ggZXZlcnl0aGluZ1xyXG4gICAgaWYgKHRoaXMuYWx0QXVkaW8pIHtcclxuICAgICAgZmx1c2hTY29wZS50eXBlID0gJ3ZpZGVvJztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhQXR0YWNoZWQgKGRhdGEpIHtcclxuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcclxuICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcclxuICAgIHRoaXMub252c2Vla2VkID0gdGhpcy5vbk1lZGlhU2Vla2VkLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKTtcclxuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xyXG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xyXG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcclxuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcclxuICAgIGlmICh0aGlzLmxldmVscyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xyXG4gICAgICB0aGlzLmhscy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG5ldyBHYXBDb250cm9sbGVyKGNvbmZpZywgbWVkaWEsIHRoaXMuZnJhZ21lbnRUcmFja2VyLCB0aGlzLmhscyk7XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcclxuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuZW5kZWQpIHtcclxuICAgICAgbG9nZ2VyLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcclxuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlc2V0IGZyYWdtZW50IGJhY2t0cmFja2VkIGZsYWdcclxuICAgIGxldCBsZXZlbHMgPSB0aGlzLmxldmVscztcclxuICAgIGlmIChsZXZlbHMpIHtcclxuICAgICAgbGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xyXG4gICAgICAgIGlmIChsZXZlbC5kZXRhaWxzKSB7XHJcbiAgICAgICAgICBsZXZlbC5kZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKGZyYWdtZW50ID0+IHtcclxuICAgICAgICAgICAgZnJhZ21lbnQuYmFja3RyYWNrZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcclxuICAgIGlmIChtZWRpYSkge1xyXG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcclxuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xyXG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xyXG4gICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9udnNlZWtlZCA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xyXG4gICAgdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xyXG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xyXG4gICAgdGhpcy5zdG9wTG9hZCgpO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYVNlZWtlZCAoKSB7XHJcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiB1bmRlZmluZWQ7XHJcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGN1cnJlbnRUaW1lKSkge1xyXG4gICAgICBsb2dnZXIubG9nKGBtZWRpYSBzZWVrZWQgdG8gJHtjdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgRlJBR01FTlRfUExBWUlORyB0cmlnZ2VyaW5nXHJcbiAgICB0aGlzLnRpY2soKTtcclxuICB9XHJcblxyXG4gIG9uTWFuaWZlc3RMb2FkaW5nICgpIHtcclxuICAgIC8vIHJlc2V0IGJ1ZmZlciBvbiBtYW5pZmVzdCBsb2FkaW5nXHJcbiAgICBsb2dnZXIubG9nKCd0cmlnZ2VyIEJVRkZFUl9SRVNFVCcpO1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfUkVTRVQpO1xyXG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XHJcbiAgICB0aGlzLnN0YWxsZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcclxuICB9XHJcblxyXG4gIG9uTWFuaWZlc3RQYXJzZWQgKGRhdGEpIHtcclxuICAgIGxldCBhYWMgPSBmYWxzZSwgaGVhYWMgPSBmYWxzZSwgY29kZWM7XHJcbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcclxuICAgICAgLy8gZGV0ZWN0IGlmIHdlIGhhdmUgZGlmZmVyZW50IGtpbmQgb2YgYXVkaW8gY29kZWNzIHVzZWQgYW1vbmdzdCBwbGF5bGlzdHNcclxuICAgICAgY29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjO1xyXG4gICAgICBpZiAoY29kZWMpIHtcclxuICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xKSB7XHJcbiAgICAgICAgICBhYWMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xyXG4gICAgICAgICAgaGVhYWMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2l0Y2ggPSAoYWFjICYmIGhlYWFjKTtcclxuICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcclxuICAgICAgbG9nZ2VyLmxvZygnYm90aCBBQUMvSEUtQUFDIGF1ZGlvIGZvdW5kIGluIGxldmVsczsgZGVjbGFyaW5nIGxldmVsIGNvZGVjIGFzIEhFLUFBQycpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYWx0QXVkaW8gPSBkYXRhLmFsdEF1ZGlvO1xyXG4gICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcclxuICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XHJcbiAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XHJcbiAgICBpZiAoY29uZmlnLmF1dG9TdGFydExvYWQgfHwgdGhpcy5mb3JjZVN0YXJ0TG9hZCkge1xyXG4gICAgICB0aGlzLmhscy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25MZXZlbExvYWRlZCAoZGF0YSkge1xyXG4gICAgY29uc3QgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscztcclxuICAgIGNvbnN0IG5ld0xldmVsSWQgPSBkYXRhLmxldmVsO1xyXG4gICAgY29uc3QgbGFzdExldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbExhc3RMb2FkZWRdO1xyXG4gICAgY29uc3QgY3VyTGV2ZWwgPSB0aGlzLmxldmVsc1tuZXdMZXZlbElkXTtcclxuICAgIGNvbnN0IGR1cmF0aW9uID0gbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uO1xyXG4gICAgbGV0IHNsaWRpbmcgPSAwO1xyXG5cclxuICAgIGxvZ2dlci5sb2coYGxldmVsICR7bmV3TGV2ZWxJZH0gbG9hZGVkIFske25ld0RldGFpbHMuc3RhcnRTTn0sJHtuZXdEZXRhaWxzLmVuZFNOfV0sZHVyYXRpb246JHtkdXJhdGlvbn1gKTtcclxuXHJcbiAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XHJcbiAgICAgIGxldCBjdXJEZXRhaWxzID0gY3VyTGV2ZWwuZGV0YWlscztcclxuICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIHdlIGFscmVhZHkgaGF2ZSBkZXRhaWxzIGZvciB0aGF0IGxldmVsLCBtZXJnZSB0aGVtXHJcbiAgICAgICAgTGV2ZWxIZWxwZXIubWVyZ2VEZXRhaWxzKGN1ckRldGFpbHMsIG5ld0RldGFpbHMpO1xyXG4gICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcclxuICAgICAgICB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgY3VyRGV0YWlscyk7XHJcbiAgICAgICAgaWYgKG5ld0RldGFpbHMuUFRTS25vd24gJiYgTnVtYmVyLmlzRmluaXRlKHNsaWRpbmcpKSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0IHNsaWRpbmc6JHtzbGlkaW5nLnRvRml4ZWQoMyl9YCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xyXG4gICAgICAgICAgYWxpZ25TdHJlYW0odGhpcy5mcmFnUHJldmlvdXMsIGxhc3RMZXZlbCwgbmV3RGV0YWlscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcclxuICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XHJcbiAgICAgICAgYWxpZ25TdHJlYW0odGhpcy5mcmFnUHJldmlvdXMsIGxhc3RMZXZlbCwgbmV3RGV0YWlscyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIG92ZXJyaWRlIGxldmVsIGluZm9cclxuICAgIGN1ckxldmVsLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xyXG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBuZXdMZXZlbElkO1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9VUERBVEVELCB7IGRldGFpbHM6IG5ld0RldGFpbHMsIGxldmVsOiBuZXdMZXZlbElkIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9PT0gZmFsc2UpIHtcclxuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgc2V0IHRvIC0xLiB1c2UgaXQgc3RyYWlnaHQgYXdheSBpZiB2YWx1ZSBpcyBkZWZpbmVkXHJcbiAgICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xIHx8IHRoaXMubGFzdEN1cnJlbnRUaW1lID09PSAtMSkge1xyXG4gICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcclxuICAgICAgICBsZXQgc3RhcnRUaW1lT2Zmc2V0ID0gbmV3RGV0YWlscy5zdGFydFRpbWVPZmZzZXQ7XHJcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShzdGFydFRpbWVPZmZzZXQpKSB7XHJcbiAgICAgICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKGBuZWdhdGl2ZSBzdGFydCB0aW1lIG9mZnNldCAke3N0YXJ0VGltZU9mZnNldH0sIGNvdW50IGZyb20gZW5kIG9mIGxhc3QgZnJhZ21lbnRgKTtcclxuICAgICAgICAgICAgc3RhcnRUaW1lT2Zmc2V0ID0gc2xpZGluZyArIGR1cmF0aW9uICsgc3RhcnRUaW1lT2Zmc2V0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgc3RhcnQgdGltZSBvZmZzZXQgZm91bmQgaW4gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvICR7c3RhcnRUaW1lT2Zmc2V0fWApO1xyXG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRUaW1lT2Zmc2V0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBzZXQgc3RhcnQgcG9zaXRpb24gdG8gYmUgZnJhZ21lbnQgTi10aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgKHVzdWFsbHkgMylcclxuICAgICAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIG5ld0RldGFpbHMpO1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKGBjb25maWd1cmUgc3RhcnRQb3NpdGlvbiB0byAke3RoaXMuc3RhcnRQb3NpdGlvbn1gKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcclxuICAgIH1cclxuICAgIC8vIG9ubHkgc3dpdGNoIGJhdGNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciBsZXZlbCB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxyXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xyXG4gICAgdGhpcy50aWNrKCk7XHJcbiAgfVxyXG5cclxuICBvbktleUxvYWRlZCAoKSB7XHJcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgIHRoaXMudGljaygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcmFnTG9hZGVkIChkYXRhKSB7XHJcbiAgICBjb25zdCB7IGZyYWdDdXJyZW50LCBobHMsIGxldmVscywgbWVkaWEgfSA9IHRoaXM7XHJcbiAgICBjb25zdCBmcmFnTG9hZGVkID0gZGF0YS5mcmFnO1xyXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyAmJlxyXG4gICAgICAgIGZyYWdDdXJyZW50ICYmXHJcbiAgICAgICAgZnJhZ0xvYWRlZC50eXBlID09PSAnbWFpbicgJiZcclxuICAgICAgICBmcmFnTG9hZGVkLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxyXG4gICAgICAgIGZyYWdMb2FkZWQuc24gPT09IGZyYWdDdXJyZW50LnNuKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRzID0gZGF0YS5zdGF0cztcclxuICAgICAgY29uc3QgY3VycmVudExldmVsID0gbGV2ZWxzW2ZyYWdDdXJyZW50LmxldmVsXTtcclxuICAgICAgY29uc3QgZGV0YWlscyA9IGN1cnJlbnRMZXZlbC5kZXRhaWxzO1xyXG4gICAgICAvLyByZXNldCBmcmFnIGJpdHJhdGUgdGVzdCBpbiBhbnkgY2FzZSBhZnRlciBmcmFnIGxvYWRlZCBldmVudFxyXG4gICAgICAvLyBpZiB0aGlzIGZyYWcgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0IEFORCBpZiBobHMubmV4dExvYWRMZXZlbCBpcyBncmVhdGVyIHRoYW4gMFxyXG4gICAgICAvLyB0aGVuIHRoaXMgbWVhbnMgdGhhdCB3ZSBzaG91bGQgYmUgYWJsZSB0byBsb2FkIGEgZnJhZ21lbnQgYXQgYSBoaWdoZXIgcXVhbGl0eSBsZXZlbFxyXG4gICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuc3RhdHMgPSBzdGF0cztcclxuXHJcbiAgICAgIGxvZ2dlci5sb2coYExvYWRlZCAke2ZyYWdDdXJyZW50LnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSxsZXZlbCAke2ZyYWdDdXJyZW50LmxldmVsfWApO1xyXG4gICAgICBpZiAoZnJhZ0xvYWRlZC5iaXRyYXRlVGVzdCAmJiBobHMubmV4dExvYWRMZXZlbCkge1xyXG4gICAgICAgIC8vIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgLi4uIHdlIGp1c3QgbG9hZGVkIGEgZnJhZ21lbnQgdG8gZGV0ZXJtaW5lIGFkZXF1YXRlIHN0YXJ0IGJpdHJhdGUgYW5kIGluaXRpYWxpemUgYXV0b3N3aXRjaCBhbGdvXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcclxuICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnQ3VycmVudCwgaWQ6ICdtYWluJyB9KTtcclxuICAgICAgICB0aGlzLnRpY2soKTtcclxuICAgICAgfSBlbHNlIGlmIChmcmFnTG9hZGVkLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgPSBkYXRhLnBheWxvYWQ7XHJcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwgeyBzdGF0czogc3RhdHMsIGZyYWc6IGZyYWdDdXJyZW50LCBpZDogJ21haW4nIH0pO1xyXG4gICAgICAgIHRoaXMudGljaygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxvZ2dlci5sb2coYFBhcnNpbmcgJHtmcmFnQ3VycmVudC5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtmcmFnQ3VycmVudC5sZXZlbH0sIGNjICR7ZnJhZ0N1cnJlbnQuY2N9YCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFwcGVuZGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIEJpdHJhdGUgdGVzdCBmcmFncyBhcmUgbm90IHVzdWFsbHkgYnVmZmVyZWQgc28gdGhlIGZyYWdtZW50IHRyYWNrZXIgaWdub3JlcyB0aGVtLiBJZiBIbHMuanMgZGVjaWRlcyB0byBidWZmZXJcclxuICAgICAgICAvLyBpdCAoYW5kIHRoZXJlZm9yZSBlbmRzIHVwIGF0IHRoaXMgbGluZSksIHRoZW4gdGhlIGZyYWdtZW50IHRyYWNrZXIgbmVlZHMgdG8gYmUgbWFudWFsbHkgaW5mb3JtZWQuXHJcbiAgICAgICAgaWYgKGZyYWdMb2FkZWQuYml0cmF0ZVRlc3QpIHtcclxuICAgICAgICAgIGZyYWdMb2FkZWQuYml0cmF0ZVRlc3QgPSBmYWxzZTtcclxuICAgICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLm9uRnJhZ0xvYWRlZCh7XHJcbiAgICAgICAgICAgIGZyYWc6IGZyYWdMb2FkZWRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpIGFuZCBpZiBtZWRpYSBpcyBub3Qgc2Vla2luZyAodGhpcyBpcyB0byBvdmVyY29tZSBwb3RlbnRpYWwgdGltZXN0YW1wIGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0cyBhbmQgZnJhZ21lbnRzKVxyXG4gICAgICAgIGNvbnN0IGFjY3VyYXRlVGltZU9mZnNldCA9ICEobWVkaWEgJiYgbWVkaWEuc2Vla2luZykgJiYgKGRldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZSk7XHJcbiAgICAgICAgY29uc3QgaW5pdFNlZ21lbnREYXRhID0gZGV0YWlscy5pbml0U2VnbWVudCA/IGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA6IFtdO1xyXG4gICAgICAgIGNvbnN0IGF1ZGlvQ29kZWMgPSB0aGlzLl9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCk7XHJcblxyXG4gICAgICAgIC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcclxuICAgICAgICBjb25zdCBkZW11eGVyID0gdGhpcy5kZW11eGVyID0gdGhpcy5kZW11eGVyIHx8IG5ldyBEZW11eGVyKHRoaXMuaGxzLCAnbWFpbicpO1xyXG4gICAgICAgIGRlbXV4ZXIucHVzaChcclxuICAgICAgICAgIGRhdGEucGF5bG9hZCxcclxuICAgICAgICAgIGluaXRTZWdtZW50RGF0YSxcclxuICAgICAgICAgIGF1ZGlvQ29kZWMsXHJcbiAgICAgICAgICBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYyxcclxuICAgICAgICAgIGZyYWdDdXJyZW50LFxyXG4gICAgICAgICAgZGV0YWlscy50b3RhbGR1cmF0aW9uLFxyXG4gICAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcclxuICB9XHJcblxyXG4gIG9uRnJhZ1BhcnNpbmdJbml0U2VnbWVudCAoZGF0YSkge1xyXG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xyXG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcclxuXHJcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcclxuICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcclxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxyXG4gICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xyXG4gICAgICBsZXQgdHJhY2tzID0gZGF0YS50cmFja3MsIHRyYWNrTmFtZSwgdHJhY2s7XHJcblxyXG4gICAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cclxuICAgICAgaWYgKHRyYWNrcy5hdWRpbyAmJiB0aGlzLmFsdEF1ZGlvKSB7XHJcbiAgICAgICAgZGVsZXRlIHRyYWNrcy5hdWRpbztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcclxuICAgICAgdHJhY2sgPSB0cmFja3MuYXVkaW87XHJcbiAgICAgIGlmICh0cmFjaykge1xyXG4gICAgICAgIGxldCBhdWRpb0NvZGVjID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0uYXVkaW9Db2RlYyxcclxuICAgICAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChhdWRpb0NvZGVjICYmIHRoaXMuYXVkaW9Db2RlY1N3YXApIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3YXBwaW5nIHBsYXlsaXN0IGF1ZGlvIGNvZGVjJyk7XHJcbiAgICAgICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbiBjYXNlIEFBQyBhbmQgSEUtQUFDIGF1ZGlvIGNvZGVjcyBhcmUgc2lnbmFsbGVkIGluIG1hbmlmZXN0XHJcbiAgICAgICAgLy8gZm9yY2UgSEUtQUFDICwgYXMgaXQgc2VlbXMgdGhhdCBtb3N0IGJyb3dzZXJzIHByZWZlcnMgdGhhdCB3YXksXHJcbiAgICAgICAgLy8gZXhjZXB0IGZvciBtb25vIHN0cmVhbXMgT1Igb24gRkZcclxuICAgICAgICAvLyB0aGVzZSBjb25kaXRpb25zIG1pZ2h0IG5lZWQgdG8gYmUgcmV2aWV3ZWQgLi4uXHJcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xyXG4gICAgICAgICAgLy8gZG9uJ3QgZm9yY2UgSEUtQUFDIGlmIG1vbm8gc3RyZWFtXHJcbiAgICAgICAgICBpZiAodHJhY2subWV0YWRhdGEuY2hhbm5lbENvdW50ICE9PSAxICYmXHJcbiAgICAgICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBmaXJlZm94XHJcbiAgICAgICAgICAgIHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBIRS1BQUMgaXMgYnJva2VuIG9uIEFuZHJvaWQsIGFsd2F5cyBzaWduYWwgYXVkaW8gY29kZWMgYXMgQUFDIGV2ZW4gaWYgdmFyaWFudCBtYW5pZmVzdCBzdGF0ZXMgb3RoZXJ3aXNlXHJcbiAgICAgICAgaWYgKHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEgJiYgdHJhY2suY29udGFpbmVyICE9PSAnYXVkaW8vbXBlZycpIHsgLy8gRXhjbHVkZSBtcGVnIGF1ZGlvXHJcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGBBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0byAke2F1ZGlvQ29kZWN9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSBhdWRpb0NvZGVjO1xyXG4gICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcclxuICAgICAgfVxyXG4gICAgICB0cmFjayA9IHRyYWNrcy52aWRlbztcclxuICAgICAgaWYgKHRyYWNrKSB7XHJcbiAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLnZpZGVvQ29kZWM7XHJcbiAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcclxuICAgICAgLy8gbG9vcCB0aHJvdWdoIHRyYWNrcyB0aGF0IGFyZSBnb2luZyB0byBiZSBwcm92aWRlZCB0byBidWZmZXJDb250cm9sbGVyXHJcbiAgICAgIGZvciAodHJhY2tOYW1lIGluIHRyYWNrcykge1xyXG4gICAgICAgIHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgbWFpbiB0cmFjazoke3RyYWNrTmFtZX0sY29udGFpbmVyOiR7dHJhY2suY29udGFpbmVyfSxjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHt0cmFjay5sZXZlbENvZGVjfS8ke3RyYWNrLmNvZGVjfV1gKTtcclxuICAgICAgICBsZXQgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcclxuICAgICAgICBpZiAoaW5pdFNlZ21lbnQpIHtcclxuICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcclxuICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XHJcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIHsgdHlwZTogdHJhY2tOYW1lLCBkYXRhOiBpbml0U2VnbWVudCwgcGFyZW50OiAnbWFpbicsIGNvbnRlbnQ6ICdpbml0U2VnbWVudCcgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcclxuICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkZyYWdQYXJzaW5nRGF0YSAoZGF0YSkge1xyXG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xyXG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcclxuICAgIGlmIChmcmFnQ3VycmVudCAmJlxyXG4gICAgICAgIGRhdGEuaWQgPT09ICdtYWluJyAmJlxyXG4gICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXHJcbiAgICAgICAgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcclxuICAgICAgICAhKGRhdGEudHlwZSA9PT0gJ2F1ZGlvJyAmJiB0aGlzLmFsdEF1ZGlvKSAmJiAvLyBmaWx0ZXIgb3V0IG1haW4gYXVkaW8gaWYgYXVkaW8gdHJhY2sgaXMgbG9hZGVkIHRocm91Z2ggYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXJcclxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XHJcbiAgICAgIGxldCBsZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLFxyXG4gICAgICAgIGZyYWcgPSBmcmFnQ3VycmVudDtcclxuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZGF0YS5lbmRQVFMpKSB7XHJcbiAgICAgICAgZGF0YS5lbmRQVFMgPSBkYXRhLnN0YXJ0UFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XHJcbiAgICAgICAgZGF0YS5lbmREVFMgPSBkYXRhLnN0YXJ0RFRTICsgZnJhZ0N1cnJlbnQuZHVyYXRpb247XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChkYXRhLmhhc0F1ZGlvID09PSB0cnVlKSB7XHJcbiAgICAgICAgZnJhZy5hZGRFbGVtZW50YXJ5U3RyZWFtKEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChkYXRhLmhhc1ZpZGVvID09PSB0cnVlKSB7XHJcbiAgICAgICAgZnJhZy5hZGRFbGVtZW50YXJ5U3RyZWFtKEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxvZ2dlci5sb2coYFBhcnNlZCAke2RhdGEudHlwZX0sUFRTOlske2RhdGEuc3RhcnRQVFMudG9GaXhlZCgzKX0sJHtkYXRhLmVuZFBUUy50b0ZpeGVkKDMpfV0sRFRTOlske2RhdGEuc3RhcnREVFMudG9GaXhlZCgzKX0vJHtkYXRhLmVuZERUUy50b0ZpeGVkKDMpfV0sbmI6JHtkYXRhLm5ifSxkcm9wcGVkOiR7ZGF0YS5kcm9wcGVkIHx8IDB9YCk7XHJcblxyXG4gICAgICAvLyBEZXRlY3QgZ2FwcyBpbiBhIGZyYWdtZW50ICBhbmQgdHJ5IHRvIGZpeCBpdCBieSBmaW5kaW5nIGEga2V5ZnJhbWUgaW4gdGhlIHByZXZpb3VzIGZyYWdtZW50IChzZWUgX2ZpbmRGcmFnbWVudHMpXHJcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICd2aWRlbycpIHtcclxuICAgICAgICBmcmFnLmRyb3BwZWQgPSBkYXRhLmRyb3BwZWQ7XHJcbiAgICAgICAgaWYgKGZyYWcuZHJvcHBlZCkge1xyXG4gICAgICAgICAgaWYgKCFmcmFnLmJhY2t0cmFja2VkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XHJcbiAgICAgICAgICAgIGlmIChsZXZlbERldGFpbHMgJiYgZnJhZy5zbiA9PT0gbGV2ZWxEZXRhaWxzLnN0YXJ0U04pIHtcclxuICAgICAgICAgICAgICBsb2dnZXIud2FybignbWlzc2luZyB2aWRlbyBmcmFtZShzKSBvbiBmaXJzdCBmcmFnLCBhcHBlbmRpbmcgd2l0aCBnYXAnLCBmcmFnLnNuKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBsb2dnZXIud2FybignbWlzc2luZyB2aWRlbyBmcmFtZShzKSwgYmFja3RyYWNraW5nIGZyYWdtZW50JywgZnJhZy5zbik7XHJcbiAgICAgICAgICAgICAgLy8gUmV0dXJuIGJhY2sgdG8gdGhlIElETEUgc3RhdGUgd2l0aG91dCBhcHBlbmRpbmcgdG8gYnVmZmVyXHJcbiAgICAgICAgICAgICAgLy8gQ2F1c2VzIGZpbmRGcmFnbWVudHMgdG8gYmFja3RyYWNrIGEgc2VnbWVudCBhbmQgZmluZCB0aGUga2V5ZnJhbWVcclxuICAgICAgICAgICAgICAvLyBBdWRpbyBmcmFnbWVudHMgYXJyaXZpbmcgYmVmb3JlIHZpZGVvIHNldHMgdGhlIG5leHRMb2FkUG9zaXRpb24sIGNhdXNpbmcgX2ZpbmRGcmFnbWVudHMgdG8gc2tpcCB0aGUgYmFja3RyYWNrZWQgZnJhZ21lbnRcclxuICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcclxuICAgICAgICAgICAgICBmcmFnLmJhY2t0cmFja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBkYXRhLnN0YXJ0UFRTO1xyXG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcclxuICAgICAgICAgICAgICB0aGlzLnRpY2soKTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdBbHJlYWR5IGJhY2t0cmFja2VkIG9uIHRoaXMgZnJhZ21lbnQsIGFwcGVuZGluZyB3aXRoIHRoZSBnYXAnLCBmcmFnLnNuKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gT25seSByZXNldCB0aGUgYmFja3RyYWNrZWQgZmxhZyBpZiB3ZSd2ZSBsb2FkZWQgdGhlIGZyYWcgd2l0aG91dCBhbnkgZHJvcHBlZCBmcmFtZXNcclxuICAgICAgICAgIGZyYWcuYmFja3RyYWNrZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBkcmlmdCA9IExldmVsSGVscGVyLnVwZGF0ZUZyYWdQVFNEVFMobGV2ZWwuZGV0YWlscywgZnJhZywgZGF0YS5zdGFydFBUUywgZGF0YS5lbmRQVFMsIGRhdGEuc3RhcnREVFMsIGRhdGEuZW5kRFRTKSxcclxuICAgICAgICBobHMgPSB0aGlzLmhscztcclxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfUFRTX1VQREFURUQsIHsgZGV0YWlsczogbGV2ZWwuZGV0YWlscywgbGV2ZWw6IHRoaXMubGV2ZWwsIGRyaWZ0OiBkcmlmdCwgdHlwZTogZGF0YS50eXBlLCBzdGFydDogZGF0YS5zdGFydFBUUywgZW5kOiBkYXRhLmVuZFBUUyB9KTtcclxuICAgICAgLy8gaGFzIHJlbXV4ZXIgZHJvcHBlZCB2aWRlbyBmcmFtZXMgbG9jYXRlZCBiZWZvcmUgZmlyc3Qga2V5ZnJhbWUgP1xyXG4gICAgICBbZGF0YS5kYXRhMSwgZGF0YS5kYXRhMl0uZm9yRWFjaChidWZmZXIgPT4ge1xyXG4gICAgICAgIC8vIG9ubHkgYXBwZW5kIGluIFBBUlNJTkcgc3RhdGUgKHJhdGlvbmFsZSBpcyB0aGF0IGFuIGFwcGVuZGluZyBlcnJvciBjb3VsZCBoYXBwZW4gc3luY2hyb25vdXNseSBvbiBmaXJzdCBzZWdtZW50IGFwcGVuZGluZylcclxuICAgICAgICAvLyBpbiB0aGF0IGNhc2UgaXQgaXMgdXNlbGVzcyB0byBhcHBlbmQgZm9sbG93aW5nIHNlZ21lbnRzXHJcbiAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcclxuICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcclxuICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XHJcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCB7IHR5cGU6IGRhdGEudHlwZSwgZGF0YTogYnVmZmVyLCBwYXJlbnQ6ICdtYWluJywgY29udGVudDogJ2RhdGEnIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcclxuICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkZyYWdQYXJzZWQgKGRhdGEpIHtcclxuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XHJcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcclxuICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcclxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxyXG4gICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xyXG4gICAgICB0aGlzLnN0YXRzLnRwYXJzZWQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XHJcbiAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uQXVkaW9UcmFja1N3aXRjaGluZyAoZGF0YSkge1xyXG4gICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xyXG4gICAgbGV0IGFsdEF1ZGlvID0gISFkYXRhLnVybCxcclxuICAgICAgdHJhY2tJZCA9IGRhdGEuaWQ7XHJcbiAgICAvLyBpZiB3ZSBzd2l0Y2ggb24gbWFpbiBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIG1lZGlhLmJ1ZmZlcmVkXHJcbiAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiB3ZSBzd2l0Y2ggdG8gYWx0IGF1ZGlvOiBhdWRpbyBzdHJlYW0gY29udHJvbGxlciBpcyBoYW5kbGluZyBpdC5cclxuICAgIC8vIHdlIHdpbGwganVzdCBoYXZlIHRvIGNoYW5nZSBidWZmZXIgc2NoZWR1bGluZyBvbiBhdWRpb1RyYWNrU3dpdGNoZWRcclxuICAgIGlmICghYWx0QXVkaW8pIHtcclxuICAgICAgaWYgKHRoaXMubWVkaWFCdWZmZXIgIT09IHRoaXMubWVkaWEpIHtcclxuICAgICAgICBsb2dnZXIubG9nKCdzd2l0Y2hpbmcgb24gbWFpbiBhdWRpbywgdXNlIG1lZGlhLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xyXG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xyXG4gICAgICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZWZpbGwgYXVkaW8gYnVmZmVyIGZyb20gbWFpbjogY2FuY2VsIGFueSBmcmFnIGxvYWRpbmcgdG8gc3BlZWQgdXAgYXVkaW8gc3dpdGNoXHJcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8gdHJhY2ssIGNhbmNlbCBtYWluIGZyYWdtZW50IGxvYWQnKTtcclxuICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XHJcbiAgICAgICAgLy8gZGVzdHJveSBkZW11eGVyIHRvIGZvcmNlIGluaXQgc2VnbWVudCBnZW5lcmF0aW9uIChmb2xsb3dpbmcgYXVkaW8gc3dpdGNoKVxyXG4gICAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcclxuICAgICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBobHMgPSB0aGlzLmhscztcclxuICAgICAgLy8gc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHsgc3RhcnRPZmZzZXQ6IDAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlOiAnYXVkaW8nIH0pO1xyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwgeyBpZDogdHJhY2tJZCB9KTtcclxuICAgICAgdGhpcy5hbHRBdWRpbyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25BdWRpb1RyYWNrU3dpdGNoZWQgKGRhdGEpIHtcclxuICAgIGxldCB0cmFja0lkID0gZGF0YS5pZCxcclxuICAgICAgYWx0QXVkaW8gPSAhIXRoaXMuaGxzLmF1ZGlvVHJhY2tzW3RyYWNrSWRdLnVybDtcclxuICAgIGlmIChhbHRBdWRpbykge1xyXG4gICAgICBsZXQgdmlkZW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyO1xyXG4gICAgICAvLyBpZiB3ZSBzd2l0Y2hlZCBvbiBhbHRlcm5hdGUgYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCB2aWRlbyBzb3VyY2VidWZmZXIgYnVmZmVyZWRcclxuICAgICAgaWYgKHZpZGVvQnVmZmVyICYmIHRoaXMubWVkaWFCdWZmZXIgIT09IHZpZGVvQnVmZmVyKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIG9uIGFsdGVybmF0ZSBhdWRpbywgdXNlIHZpZGVvLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xyXG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB2aWRlb0J1ZmZlcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5hbHRBdWRpbyA9IGFsdEF1ZGlvO1xyXG4gICAgdGhpcy50aWNrKCk7XHJcbiAgfVxyXG5cclxuICBvbkJ1ZmZlckNyZWF0ZWQgKGRhdGEpIHtcclxuICAgIGxldCB0cmFja3MgPSBkYXRhLnRyYWNrcywgbWVkaWFUcmFjaywgbmFtZSwgYWx0ZXJuYXRlID0gZmFsc2U7XHJcbiAgICBmb3IgKGxldCB0eXBlIGluIHRyYWNrcykge1xyXG4gICAgICBsZXQgdHJhY2sgPSB0cmFja3NbdHlwZV07XHJcbiAgICAgIGlmICh0cmFjay5pZCA9PT0gJ21haW4nKSB7XHJcbiAgICAgICAgbmFtZSA9IHR5cGU7XHJcbiAgICAgICAgbWVkaWFUcmFjayA9IHRyYWNrO1xyXG4gICAgICAgIC8vIGtlZXAgdmlkZW8gc291cmNlIGJ1ZmZlciByZWZlcmVuY2VcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xyXG4gICAgICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHRyYWNrc1t0eXBlXS5idWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFsdGVybmF0ZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhbHRlcm5hdGUgJiYgbWVkaWFUcmFjaykge1xyXG4gICAgICBsb2dnZXIubG9nKGBhbHRlcm5hdGUgdHJhY2sgZm91bmQsIHVzZSAke25hbWV9LmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ2ApO1xyXG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gbWVkaWFUcmFjay5idWZmZXI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uQnVmZmVyQXBwZW5kZWQgKGRhdGEpIHtcclxuICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ21haW4nKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8IHN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcclxuICAgICAgICAvLyBjaGVjayBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gYXBwZW5kZWRcclxuICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSAoZGF0YS5wZW5kaW5nID4gMCk7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfY2hlY2tBcHBlbmRlZFBhcnNlZCAoKSB7XHJcbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XHJcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEICYmICghdGhpcy5hcHBlbmRlZCB8fCAhdGhpcy5wZW5kaW5nQnVmZmVyaW5nKSkge1xyXG4gICAgICBjb25zdCBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgICAgaWYgKGZyYWcpIHtcclxuICAgICAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcclxuICAgICAgICBsb2dnZXIubG9nKGBtYWluIGJ1ZmZlcmVkIDogJHtUaW1lUmFuZ2VzLnRvU3RyaW5nKG1lZGlhLmJ1ZmZlcmVkKX1gKTtcclxuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XHJcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB0aGlzLnN0YXRzO1xyXG4gICAgICAgIHN0YXRzLnRidWZmZXJlZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAvLyB3ZSBzaG91bGQgZ2V0IHJpZCBvZiB0aGlzLmZyYWdMYXN0S2Jwc1xyXG4gICAgICAgIHRoaXMuZnJhZ0xhc3RLYnBzID0gTWF0aC5yb3VuZCg4ICogc3RhdHMudG90YWwgLyAoc3RhdHMudGJ1ZmZlcmVkIC0gc3RhdHMudGZpcnN0KSk7XHJcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZywgaWQ6ICdtYWluJyB9KTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnRpY2soKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRXJyb3IgKGRhdGEpIHtcclxuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnIHx8wqB0aGlzLmZyYWdDdXJyZW50O1xyXG4gICAgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gbWFpbiBmcmFnbWVudFxyXG4gICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnbWFpbicpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxyXG4gICAgbGV0IG1lZGlhQnVmZmVyZWQgPSAhIXRoaXMubWVkaWEgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodGhpcy5tZWRpYSwgdGhpcy5tZWRpYS5jdXJyZW50VGltZSkgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodGhpcy5tZWRpYSwgdGhpcy5tZWRpYS5jdXJyZW50VGltZSArIDAuNSk7XHJcblxyXG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcclxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcclxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxyXG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XHJcbiAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxyXG4gICAgICBpZiAoIWRhdGEuZmF0YWwpIHtcclxuICAgICAgICAvLyBrZWVwIHJldHJ5aW5nIHVudGlsIHRoZSBsaW1pdCB3aWxsIGJlIHJlYWNoZWRcclxuICAgICAgICBpZiAoKHRoaXMuZnJhZ0xvYWRFcnJvciArIDEpIDw9IHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnkpIHtcclxuICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxyXG4gICAgICAgICAgbGV0IGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMiwgdGhpcy5mcmFnTG9hZEVycm9yKSAqIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSwgdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG1lZGlhQ29udHJvbGxlcjogZnJhZyBsb2FkaW5nIGZhaWxlZCwgcmV0cnkgaW4gJHtkZWxheX0gbXNgKTtcclxuICAgICAgICAgIHRoaXMucmV0cnlEYXRlID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XHJcbiAgICAgICAgICAvLyByZXRyeSBsb2FkaW5nIHN0YXRlXHJcbiAgICAgICAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xyXG4gICAgICAgICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xyXG4gICAgICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvcisrO1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYG1lZGlhQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9IHJlYWNoZXMgbWF4IHJldHJ5LCByZWRpc3BhdGNoIGFzIGZhdGFsIC4uLmApO1xyXG4gICAgICAgICAgLy8gc3dpdGNoIGVycm9yIHRvIGZhdGFsXHJcbiAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxyXG4gICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxyXG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuRVJST1IpIHtcclxuICAgICAgICBpZiAoZGF0YS5mYXRhbCkge1xyXG4gICAgICAgICAgLy8gaWYgZmF0YWwgZXJyb3IsIHN0b3AgcHJvY2Vzc2luZ1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYHN0cmVhbUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSxzd2l0Y2ggdG8gJHt0aGlzLnN0YXRlfSBzdGF0ZSAuLi5gKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gaW4gY2FzZSBvZiBub24gZmF0YWwgZXJyb3Igd2hpbGUgbG9hZGluZyBsZXZlbCwgaWYgbGV2ZWwgY29udHJvbGxlciBpcyBub3QgcmV0cnlpbmcgdG8gbG9hZCBsZXZlbCAsIHN3aXRjaCBiYWNrIHRvIElETEVcclxuICAgICAgICAgIGlmICghZGF0YS5sZXZlbFJldHJ5ICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XHJcbiAgICAgIC8vIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxyXG4gICAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdtYWluJyAmJiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fMKgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSkge1xyXG4gICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXHJcbiAgICAgICAgaWYgKG1lZGlhQnVmZmVyZWQpIHtcclxuICAgICAgICAgIHRoaXMuX3JlZHVjZU1heEJ1ZmZlckxlbmd0aCh0aGlzLmNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpO1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLCBidXQgYnJvd3NlciBpcyBzdGlsbCBjb21wbGFpbmluZyBhYm91dCBidWZmZXIgZnVsbCBlcnJvclxyXG4gICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNzA4XHJcbiAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGJ1ZmZlciB0byByZWNvdmVyXHJcbiAgICAgICAgICBsb2dnZXIud2FybignYnVmZmVyIGZ1bGwgZXJyb3IgYWxzbyBtZWRpYS5jdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGZsdXNoIGV2ZXJ5dGhpbmcnKTtcclxuICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgLy8gZmx1c2ggZXZlcnl0aGluZ1xyXG4gICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9yZWR1Y2VNYXhCdWZmZXJMZW5ndGggKG1pbkxlbmd0aCkge1xyXG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xyXG4gICAgaWYgKGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggPj0gbWluTGVuZ3RoKSB7XHJcbiAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxyXG4gICAgICBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoIC89IDI7XHJcbiAgICAgIGxvZ2dlci53YXJuKGBtYWluOnJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byAke2NvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGh9c2ApO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyB0aGUgaGVhbHRoIG9mIHRoZSBidWZmZXIgYW5kIGF0dGVtcHRzIHRvIHJlc29sdmUgcGxheWJhY2sgc3RhbGxzLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2NoZWNrQnVmZmVyICgpIHtcclxuICAgIGNvbnN0IHsgbWVkaWEgfSA9IHRoaXM7XHJcbiAgICBpZiAoIW1lZGlhIHx8IG1lZGlhLnJlYWR5U3RhdGUgPT09IDApIHtcclxuICAgICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBkb24ndCBoYXZlIG1lZGlhIG9yIGlmIHRoZSBtZWRpYSBoYXNuJ3QgYnVmZmVyZCBhbnl0aGluZyB5ZXQgKHJlYWR5U3RhdGUgMClcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiBtZWRpYTtcclxuICAgIGNvbnN0IGJ1ZmZlcmVkID0gbWVkaWFCdWZmZXIuYnVmZmVyZWQ7XHJcblxyXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGJ1ZmZlcmVkLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcclxuICAgICAgdGhpcy5fc2Vla1RvU3RhcnRQb3MoKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5pbW1lZGlhdGVTd2l0Y2gpIHtcclxuICAgICAgdGhpcy5pbW1lZGlhdGVMZXZlbFN3aXRjaEVuZCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5nYXBDb250cm9sbGVyLnBvbGwodGhpcy5sYXN0Q3VycmVudFRpbWUsIGJ1ZmZlcmVkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkICgpIHtcclxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcclxuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcclxuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xyXG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XHJcbiAgICB9XHJcbiAgICB0aGlzLnRpY2soKTtcclxuICB9XHJcblxyXG4gIG9uQnVmZmVyRmx1c2hlZCAoKSB7XHJcbiAgICAvKiBhZnRlciBzdWNjZXNzZnVsIGJ1ZmZlciBmbHVzaGluZywgZmlsdGVyIGZsdXNoZWQgZnJhZ21lbnRzIGZyb20gYnVmZmVyZWRGcmFnc1xyXG4gICAgICB1c2UgbWVkaWFCdWZmZXJlZCBpbnN0ZWFkIG9mIG1lZGlhIChzbyB0aGF0IHdlIHdpbGwgY2hlY2sgYWdhaW5zdCB2aWRlby5idWZmZXJlZCByYW5nZXMgaW4gY2FzZSBvZiBhbHQgYXVkaW8gdHJhY2spXHJcbiAgICAqL1xyXG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgLy8gZmlsdGVyIGZyYWdtZW50cyBwb3RlbnRpYWxseSBldmljdGVkIGZyb20gYnVmZmVyLiB0aGlzIGlzIHRvIGF2b2lkIG1lbWxlYWsgb24gbGl2ZSBzdHJlYW1zXHJcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPLCBtZWRpYS5idWZmZXJlZCk7XHJcbiAgICB9XHJcbiAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xyXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gZnJhZ1xyXG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgc3dhcEF1ZGlvQ29kZWMgKCkge1xyXG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9ICF0aGlzLmF1ZGlvQ29kZWNTd2FwO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTZWVrcyB0byB0aGUgc2V0IHN0YXJ0UG9zaXRpb24gaWYgbm90IGVxdWFsIHRvIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfc2Vla1RvU3RhcnRQb3MgKCkge1xyXG4gICAgY29uc3QgeyBtZWRpYSB9ID0gdGhpcztcclxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XHJcbiAgICAvLyBvbmx5IGFkanVzdCBjdXJyZW50VGltZSBpZiBkaWZmZXJlbnQgZnJvbSBzdGFydFBvc2l0aW9uIG9yIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkXHJcbiAgICAvLyBhdCB0aGF0IHN0YWdlLCB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgYnVmZmVyZWQgcmFuZ2UsIGFzIHdlIHJlYWNoIHRoYXQgY29kZSBhZnRlciBmaXJzdCBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZFxyXG4gICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IG1lZGlhLnNlZWtpbmcgPyBjdXJyZW50VGltZSA6IHRoaXMuc3RhcnRQb3NpdGlvbjtcclxuICAgIC8vIGlmIGN1cnJlbnRUaW1lIG5vdCBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIHN0YXJ0UG9zaXRpb24gb3Igc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWQgYnV0IGNsb3NlIHRvIGZpcnN0IGJ1ZmZlcmVkXHJcbiAgICBpZiAoY3VycmVudFRpbWUgIT09IHN0YXJ0UG9zaXRpb24gJiYgc3RhcnRQb3NpdGlvbiA+PSAwKSB7XHJcbiAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkLCBsZXQncyBzZWVrIHRvIGJ1ZmZlcmVkLnN0YXJ0KDApXHJcbiAgICAgIGxvZ2dlci5sb2coYHRhcmdldCBzdGFydCBwb3NpdGlvbiBub3QgYnVmZmVyZWQsIHNlZWsgdG8gYnVmZmVyZWQuc3RhcnQoMCkgJHtzdGFydFBvc2l0aW9ufSBmcm9tIGN1cnJlbnQgdGltZSAke2N1cnJlbnRUaW1lfSBgKTtcclxuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2dldEF1ZGlvQ29kZWMgKGN1cnJlbnRMZXZlbCkge1xyXG4gICAgbGV0IGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcclxuICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2FwKSB7XHJcbiAgICAgIGxvZ2dlci5sb2coJ3N3YXBwaW5nIHBsYXlsaXN0IGF1ZGlvIGNvZGVjJyk7XHJcbiAgICAgIGlmIChhdWRpb0NvZGVjKSB7XHJcbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XHJcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXVkaW9Db2RlYztcclxuICB9XHJcblxyXG4gIGdldCBsaXZlU3luY1Bvc2l0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9saXZlU3luY1Bvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgc2V0IGxpdmVTeW5jUG9zaXRpb24gKHZhbHVlKSB7XHJcbiAgICB0aGlzLl9saXZlU3luY1Bvc2l0aW9uID0gdmFsdWU7XHJcbiAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IFN0cmVhbUNvbnRyb2xsZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJmdW5jdGlvbiB3ZWJwYWNrQm9vdHN0cmFwRnVuYyAobW9kdWxlcykge1xuLyoqKioqKi8gIC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovICB2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyAgLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovICBmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovICAgIC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gICAgaWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyAgICAgIHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyAgICAvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gICAgdmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gICAgICBpOiBtb2R1bGVJZCxcbi8qKioqKiovICAgICAgbDogZmFsc2UsXG4vKioqKioqLyAgICAgIGV4cG9ydHM6IHt9XG4vKioqKioqLyAgICB9O1xuXG4vKioqKioqLyAgICAvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovICAgIG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyAgICAvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyAgICBtb2R1bGUubCA9IHRydWU7XG5cbi8qKioqKiovICAgIC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyAgfVxuXG4vKioqKioqLyAgLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyAgLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyAgLy8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuLyoqKioqKi8gIC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gICAgaWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovICAgICAgICBnZXQ6IGdldHRlclxuLyoqKioqKi8gICAgICB9KTtcbi8qKioqKiovICAgIH1cbi8qKioqKiovICB9O1xuXG4vKioqKioqLyAgLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyAgfTtcblxuLyoqKioqKi8gIC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyAgICB2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovICAgICAgZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovICAgIF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovICAgIHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyAgfTtcblxuLyoqKioqKi8gIC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuLyoqKioqKi8gIC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cbi8qKioqKiovICAvLyBvbiBlcnJvciBmdW5jdGlvbiBmb3IgYXN5bmMgbG9hZGluZ1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ub2UgPSBmdW5jdGlvbihlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB0aHJvdyBlcnI7IH07XG5cbiAgdmFyIGYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IEVOVFJZX01PRFVMRSlcbiAgcmV0dXJuIGYuZGVmYXVsdCB8fCBmIC8vIHRyeSB0byBjYWxsIGRlZmF1bHQgaWYgZGVmaW5lZCB0byBhbHNvIHN1cHBvcnQgYmFiZWwgZXNtb2R1bGUgZXhwb3J0c1xufVxuXG52YXIgbW9kdWxlTmFtZVJlcUV4cCA9ICdbXFxcXC58XFxcXC18XFxcXCt8XFxcXHd8XFwvfEBdKydcbnZhciBkZXBlbmRlbmN5UmVnRXhwID0gJ1xcXFwoXFxcXHMqKFxcL1xcXFwqLio/XFxcXCpcXC8pP1xcXFxzKi4qPygnICsgbW9kdWxlTmFtZVJlcUV4cCArICcpLio/XFxcXCknIC8vIGFkZGl0aW9uYWwgY2hhcnMgd2hlbiBvdXRwdXQucGF0aGluZm8gaXMgdHJ1ZVxuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNTkzNjYxLzEzMDQ0MlxuZnVuY3Rpb24gcXVvdGVSZWdFeHAgKHN0cikge1xuICByZXR1cm4gKHN0ciArICcnKS5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csICdcXFxcJCYnKVxufVxuXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gIWlzTmFOKDEgKiBuKTsgLy8gMSAqIG4gY29udmVydHMgaW50ZWdlcnMsIGludGVnZXJzIGFzIHN0cmluZyAoXCIxMjNcIiksIDFlMyBhbmQgXCIxZTNcIiB0byBpbnRlZ2VycyBhbmQgc3RyaW5ncyB0byBOYU5cbn1cblxuZnVuY3Rpb24gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzIChzb3VyY2VzLCBtb2R1bGUsIHF1ZXVlTmFtZSkge1xuICB2YXIgcmV0dmFsID0ge31cbiAgcmV0dmFsW3F1ZXVlTmFtZV0gPSBbXVxuXG4gIHZhciBmblN0cmluZyA9IG1vZHVsZS50b1N0cmluZygpXG4gIHZhciB3cmFwcGVyU2lnbmF0dXJlID0gZm5TdHJpbmcubWF0Y2goL15mdW5jdGlvblxccz9cXHcqXFwoXFx3KyxcXHMqXFx3KyxcXHMqKFxcdyspXFwpLylcbiAgaWYgKCF3cmFwcGVyU2lnbmF0dXJlKSByZXR1cm4gcmV0dmFsXG4gIHZhciB3ZWJwYWNrUmVxdWlyZU5hbWUgPSB3cmFwcGVyU2lnbmF0dXJlWzFdXG5cbiAgLy8gbWFpbiBidW5kbGUgZGVwc1xuICB2YXIgcmUgPSBuZXcgUmVnRXhwKCcoXFxcXFxcXFxufFxcXFxXKScgKyBxdW90ZVJlZ0V4cCh3ZWJwYWNrUmVxdWlyZU5hbWUpICsgZGVwZW5kZW5jeVJlZ0V4cCwgJ2cnKVxuICB2YXIgbWF0Y2hcbiAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoZm5TdHJpbmcpKSkge1xuICAgIGlmIChtYXRjaFszXSA9PT0gJ2RsbC1yZWZlcmVuY2UnKSBjb250aW51ZVxuICAgIHJldHZhbFtxdWV1ZU5hbWVdLnB1c2gobWF0Y2hbM10pXG4gIH1cblxuICAvLyBkbGwgZGVwc1xuICByZSA9IG5ldyBSZWdFeHAoJ1xcXFwoJyArIHF1b3RlUmVnRXhwKHdlYnBhY2tSZXF1aXJlTmFtZSkgKyAnXFxcXChcIihkbGwtcmVmZXJlbmNlXFxcXHMoJyArIG1vZHVsZU5hbWVSZXFFeHAgKyAnKSlcIlxcXFwpXFxcXCknICsgZGVwZW5kZW5jeVJlZ0V4cCwgJ2cnKVxuICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhmblN0cmluZykpKSB7XG4gICAgaWYgKCFzb3VyY2VzW21hdGNoWzJdXSkge1xuICAgICAgcmV0dmFsW3F1ZXVlTmFtZV0ucHVzaChtYXRjaFsxXSlcbiAgICAgIHNvdXJjZXNbbWF0Y2hbMl1dID0gX193ZWJwYWNrX3JlcXVpcmVfXyhtYXRjaFsxXSkubVxuICAgIH1cbiAgICByZXR2YWxbbWF0Y2hbMl1dID0gcmV0dmFsW21hdGNoWzJdXSB8fCBbXVxuICAgIHJldHZhbFttYXRjaFsyXV0ucHVzaChtYXRjaFs0XSlcbiAgfVxuXG4gIC8vIGNvbnZlcnQgMWUzIGJhY2sgdG8gMTAwMCAtIHRoaXMgY2FuIGJlIGltcG9ydGFudCBhZnRlciB1Z2xpZnktanMgY29udmVydGVkIDEwMDAgdG8gMWUzXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmV0dmFsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXR2YWxba2V5c1tpXV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChpc051bWVyaWMocmV0dmFsW2tleXNbaV1dW2pdKSkge1xuICAgICAgICByZXR2YWxba2V5c1tpXV1bal0gPSAxICogcmV0dmFsW2tleXNbaV1dW2pdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR2YWxcbn1cblxuZnVuY3Rpb24gaGFzVmFsdWVzSW5RdWV1ZXMgKHF1ZXVlcykge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHF1ZXVlcylcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNWYWx1ZXMsIGtleSkge1xuICAgIHJldHVybiBoYXNWYWx1ZXMgfHwgcXVldWVzW2tleV0ubGVuZ3RoID4gMFxuICB9LCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gZ2V0UmVxdWlyZWRNb2R1bGVzIChzb3VyY2VzLCBtb2R1bGVJZCkge1xuICB2YXIgbW9kdWxlc1F1ZXVlID0ge1xuICAgIG1haW46IFttb2R1bGVJZF1cbiAgfVxuICB2YXIgcmVxdWlyZWRNb2R1bGVzID0ge1xuICAgIG1haW46IFtdXG4gIH1cbiAgdmFyIHNlZW5Nb2R1bGVzID0ge1xuICAgIG1haW46IHt9XG4gIH1cblxuICB3aGlsZSAoaGFzVmFsdWVzSW5RdWV1ZXMobW9kdWxlc1F1ZXVlKSkge1xuICAgIHZhciBxdWV1ZXMgPSBPYmplY3Qua2V5cyhtb2R1bGVzUXVldWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWV1ZU5hbWUgPSBxdWV1ZXNbaV1cbiAgICAgIHZhciBxdWV1ZSA9IG1vZHVsZXNRdWV1ZVtxdWV1ZU5hbWVdXG4gICAgICB2YXIgbW9kdWxlVG9DaGVjayA9IHF1ZXVlLnBvcCgpXG4gICAgICBzZWVuTW9kdWxlc1txdWV1ZU5hbWVdID0gc2Vlbk1vZHVsZXNbcXVldWVOYW1lXSB8fCB7fVxuICAgICAgaWYgKHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10gfHwgIXNvdXJjZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSkgY29udGludWVcbiAgICAgIHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10gPSB0cnVlXG4gICAgICByZXF1aXJlZE1vZHVsZXNbcXVldWVOYW1lXSA9IHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdIHx8IFtdXG4gICAgICByZXF1aXJlZE1vZHVsZXNbcXVldWVOYW1lXS5wdXNoKG1vZHVsZVRvQ2hlY2spXG4gICAgICB2YXIgbmV3TW9kdWxlcyA9IGdldE1vZHVsZURlcGVuZGVuY2llcyhzb3VyY2VzLCBzb3VyY2VzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10sIHF1ZXVlTmFtZSlcbiAgICAgIHZhciBuZXdNb2R1bGVzS2V5cyA9IE9iamVjdC5rZXlzKG5ld01vZHVsZXMpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5ld01vZHVsZXNLZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gPSBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dIHx8IFtdXG4gICAgICAgIG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gPSBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dLmNvbmNhdChuZXdNb2R1bGVzW25ld01vZHVsZXNLZXlzW2pdXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZWRNb2R1bGVzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1vZHVsZUlkLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBzb3VyY2VzID0ge1xuICAgIG1haW46IF9fd2VicGFja19tb2R1bGVzX19cbiAgfVxuXG4gIHZhciByZXF1aXJlZE1vZHVsZXMgPSBvcHRpb25zLmFsbCA/IHsgbWFpbjogT2JqZWN0LmtleXMoc291cmNlcy5tYWluKSB9IDogZ2V0UmVxdWlyZWRNb2R1bGVzKHNvdXJjZXMsIG1vZHVsZUlkKVxuXG4gIHZhciBzcmMgPSAnJ1xuXG4gIE9iamVjdC5rZXlzKHJlcXVpcmVkTW9kdWxlcykuZmlsdGVyKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtICE9PSAnbWFpbicgfSkuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgdmFyIGVudHJ5TW9kdWxlID0gMFxuICAgIHdoaWxlIChyZXF1aXJlZE1vZHVsZXNbbW9kdWxlXVtlbnRyeU1vZHVsZV0pIHtcbiAgICAgIGVudHJ5TW9kdWxlKytcbiAgICB9XG4gICAgcmVxdWlyZWRNb2R1bGVzW21vZHVsZV0ucHVzaChlbnRyeU1vZHVsZSlcbiAgICBzb3VyY2VzW21vZHVsZV1bZW50cnlNb2R1bGVdID0gJyhmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fOyB9KSdcbiAgICBzcmMgPSBzcmMgKyAndmFyICcgKyBtb2R1bGUgKyAnID0gKCcgKyB3ZWJwYWNrQm9vdHN0cmFwRnVuYy50b1N0cmluZygpLnJlcGxhY2UoJ0VOVFJZX01PRFVMRScsIEpTT04uc3RyaW5naWZ5KGVudHJ5TW9kdWxlKSkgKyAnKSh7JyArIHJlcXVpcmVkTW9kdWxlc1ttb2R1bGVdLm1hcChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuICcnICsgSlNPTi5zdHJpbmdpZnkoaWQpICsgJzogJyArIHNvdXJjZXNbbW9kdWxlXVtpZF0udG9TdHJpbmcoKSB9KS5qb2luKCcsJykgKyAnfSk7XFxuJ1xuICB9KVxuXG4gIHNyYyA9IHNyYyArICduZXcgKCgnICsgd2VicGFja0Jvb3RzdHJhcEZ1bmMudG9TdHJpbmcoKS5yZXBsYWNlKCdFTlRSWV9NT0RVTEUnLCBKU09OLnN0cmluZ2lmeShtb2R1bGVJZCkpICsgJykoeycgKyByZXF1aXJlZE1vZHVsZXMubWFpbi5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiAnJyArIEpTT04uc3RyaW5naWZ5KGlkKSArICc6ICcgKyBzb3VyY2VzLm1haW5baWRdLnRvU3RyaW5nKCkgfSkuam9pbignLCcpICsgJ30pKShzZWxmKTsnXG5cbiAgdmFyIGJsb2IgPSBuZXcgd2luZG93LkJsb2IoW3NyY10sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSlcbiAgaWYgKG9wdGlvbnMuYmFyZSkgeyByZXR1cm4gYmxvYiB9XG5cbiAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMIHx8IHdpbmRvdy5tc1VSTFxuXG4gIHZhciB3b3JrZXJVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gIHZhciB3b3JrZXIgPSBuZXcgd2luZG93Lldvcmtlcih3b3JrZXJVcmwpXG4gIHdvcmtlci5vYmplY3RVUkwgPSB3b3JrZXJVcmxcblxuICByZXR1cm4gd29ya2VyXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUVTQ3J5cHRvIHtcclxuICBjb25zdHJ1Y3RvciAoc3VidGxlLCBpdikge1xyXG4gICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XHJcbiAgICB0aGlzLmFlc0lWID0gaXY7XHJcbiAgfVxyXG5cclxuICBkZWNyeXB0IChkYXRhLCBrZXkpIHtcclxuICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHsgbmFtZTogJ0FFUy1DQkMnLCBpdjogdGhpcy5hZXNJViB9LCBrZXksIGRhdGEpO1xyXG4gIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jcnlwdC9hZXMtY3J5cHRvLmpzIiwiY2xhc3MgRmFzdEFFU0tleSB7XHJcbiAgY29uc3RydWN0b3IgKHN1YnRsZSwga2V5KSB7XHJcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcclxuICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gIH1cclxuXHJcbiAgZXhwYW5kS2V5ICgpIHtcclxuICAgIHJldHVybiB0aGlzLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHRoaXMua2V5LCB7IG5hbWU6ICdBRVMtQ0JDJyB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGYXN0QUVTS2V5O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jcnlwdC9mYXN0LWFlcy1rZXkuanMiLCIvLyBQS0NTN1xyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUGFkZGluZyAoYnVmZmVyKSB7XHJcbiAgY29uc3Qgb3V0cHV0Qnl0ZXMgPSBidWZmZXIuYnl0ZUxlbmd0aDtcclxuICBjb25zdCBwYWRkaW5nQnl0ZXMgPSBvdXRwdXRCeXRlcyAmJiAobmV3IERhdGFWaWV3KGJ1ZmZlcikpLmdldFVpbnQ4KG91dHB1dEJ5dGVzIC0gMSk7XHJcbiAgaWYgKHBhZGRpbmdCeXRlcykge1xyXG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRCeXRlcyAtIHBhZGRpbmdCeXRlcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBidWZmZXI7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBBRVNEZWNyeXB0b3Ige1xyXG4gIGNvbnN0cnVjdG9yICgpIHtcclxuICAgIC8vIFN0YXRpYyBhZnRlciBydW5uaW5nIGluaXRUYWJsZVxyXG4gICAgdGhpcy5yY29uID0gWzB4MCwgMHgxLCAweDIsIDB4NCwgMHg4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcclxuICAgIHRoaXMuc3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcclxuICAgIHRoaXMuaW52U3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcclxuICAgIHRoaXMuc0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xyXG4gICAgdGhpcy5pbnZTQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XHJcblxyXG4gICAgLy8gQ2hhbmdlcyBkdXJpbmcgcnVudGltZVxyXG4gICAgdGhpcy5rZXkgPSBuZXcgVWludDMyQXJyYXkoMCk7XHJcblxyXG4gICAgdGhpcy5pbml0VGFibGUoKTtcclxuICB9XHJcblxyXG4gIC8vIFVzaW5nIHZpZXcuZ2V0VWludDMyKCkgYWxzbyBzd2FwcyB0aGUgYnl0ZSBvcmRlci5cclxuICB1aW50OEFycmF5VG9VaW50MzJBcnJheV8gKGFycmF5QnVmZmVyKSB7XHJcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XHJcbiAgICBsZXQgbmV3QXJyYXkgPSBuZXcgVWludDMyQXJyYXkoNCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICBuZXdBcnJheVtpXSA9IHZpZXcuZ2V0VWludDMyKGkgKiA0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3QXJyYXk7XHJcbiAgfVxyXG5cclxuICBpbml0VGFibGUgKCkge1xyXG4gICAgbGV0IHNCb3ggPSB0aGlzLnNCb3g7XHJcbiAgICBsZXQgaW52U0JveCA9IHRoaXMuaW52U0JveDtcclxuICAgIGxldCBzdWJNaXggPSB0aGlzLnN1Yk1peDtcclxuICAgIGxldCBzdWJNaXgwID0gc3ViTWl4WzBdO1xyXG4gICAgbGV0IHN1Yk1peDEgPSBzdWJNaXhbMV07XHJcbiAgICBsZXQgc3ViTWl4MiA9IHN1Yk1peFsyXTtcclxuICAgIGxldCBzdWJNaXgzID0gc3ViTWl4WzNdO1xyXG4gICAgbGV0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xyXG4gICAgbGV0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XHJcbiAgICBsZXQgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcclxuICAgIGxldCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xyXG4gICAgbGV0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XHJcblxyXG4gICAgbGV0IGQgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcclxuICAgIGxldCB4ID0gMDtcclxuICAgIGxldCB4aSA9IDA7XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuICAgICAgaWYgKGkgPCAxMjgpIHtcclxuICAgICAgICBkW2ldID0gaSA8PCAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRbaV0gPSAoaSA8PCAxKSBeIDB4MTFiO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XHJcbiAgICAgIGxldCBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xyXG4gICAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjM7XHJcbiAgICAgIHNCb3hbeF0gPSBzeDtcclxuICAgICAgaW52U0JveFtzeF0gPSB4O1xyXG5cclxuICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxyXG4gICAgICBsZXQgeDIgPSBkW3hdO1xyXG4gICAgICBsZXQgeDQgPSBkW3gyXTtcclxuICAgICAgbGV0IHg4ID0gZFt4NF07XHJcblxyXG4gICAgICAvLyBDb21wdXRlIHN1Yi9pbnZTdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xyXG4gICAgICBsZXQgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XHJcbiAgICAgIHN1Yk1peDBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XHJcbiAgICAgIHN1Yk1peDFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xyXG4gICAgICBzdWJNaXgyW3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xyXG4gICAgICBzdWJNaXgzW3hdID0gdDtcclxuXHJcbiAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xyXG4gICAgICB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApO1xyXG4gICAgICBpbnZTdWJNaXgwW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcclxuICAgICAgaW52U3ViTWl4MVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xyXG4gICAgICBpbnZTdWJNaXgyW3N4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcclxuICAgICAgaW52U3ViTWl4M1tzeF0gPSB0O1xyXG5cclxuICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcclxuICAgICAgaWYgKCF4KSB7XHJcbiAgICAgICAgeCA9IHhpID0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xyXG4gICAgICAgIHhpIF49IGRbZFt4aV1dO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBhbmRLZXkgKGtleUJ1ZmZlcikge1xyXG4gICAgLy8gY29udmVydCBrZXlCdWZmZXIgdG8gVWludDMyQXJyYXlcclxuICAgIGxldCBrZXkgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhrZXlCdWZmZXIpO1xyXG4gICAgbGV0IHNhbWVLZXkgPSB0cnVlO1xyXG4gICAgbGV0IG9mZnNldCA9IDA7XHJcblxyXG4gICAgd2hpbGUgKG9mZnNldCA8IGtleS5sZW5ndGggJiYgc2FtZUtleSkge1xyXG4gICAgICBzYW1lS2V5ID0gKGtleVtvZmZzZXRdID09PSB0aGlzLmtleVtvZmZzZXRdKTtcclxuICAgICAgb2Zmc2V0Kys7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNhbWVLZXkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgbGV0IGtleVNpemUgPSB0aGlzLmtleVNpemUgPSBrZXkubGVuZ3RoO1xyXG5cclxuICAgIGlmIChrZXlTaXplICE9PSA0ICYmIGtleVNpemUgIT09IDYgJiYga2V5U2l6ZSAhPT0gOCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWVzIGtleSBzaXplPScgKyBrZXlTaXplKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQga3NSb3dzID0gdGhpcy5rc1Jvd3MgPSAoa2V5U2l6ZSArIDYgKyAxKSAqIDQ7XHJcbiAgICBsZXQga3NSb3c7XHJcbiAgICBsZXQgaW52S3NSb3c7XHJcblxyXG4gICAgbGV0IGtleVNjaGVkdWxlID0gdGhpcy5rZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xyXG4gICAgbGV0IGludktleVNjaGVkdWxlID0gdGhpcy5pbnZLZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xyXG4gICAgbGV0IHNib3ggPSB0aGlzLnNCb3g7XHJcbiAgICBsZXQgcmNvbiA9IHRoaXMucmNvbjtcclxuXHJcbiAgICBsZXQgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XHJcbiAgICBsZXQgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcclxuICAgIGxldCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xyXG4gICAgbGV0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XHJcbiAgICBsZXQgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcclxuXHJcbiAgICBsZXQgcHJldjtcclxuICAgIGxldCB0O1xyXG5cclxuICAgIGZvciAoa3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xyXG4gICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XHJcbiAgICAgICAgcHJldiA9IGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVtrc1Jvd107XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgdCA9IHByZXY7XHJcblxyXG4gICAgICBpZiAoa3NSb3cgJSBrZXlTaXplID09PSAwKSB7XHJcbiAgICAgICAgLy8gUm90IHdvcmRcclxuICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xyXG5cclxuICAgICAgICAvLyBTdWIgd29yZFxyXG4gICAgICAgIHQgPSAoc2JveFt0ID4+PiAyNF0gPDwgMjQpIHwgKHNib3hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgc2JveFt0ICYgMHhmZl07XHJcblxyXG4gICAgICAgIC8vIE1peCBSY29uXHJcbiAgICAgICAgdCBePSByY29uWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSB7XHJcbiAgICAgICAgLy8gU3ViIHdvcmRcclxuICAgICAgICB0ID0gKHNib3hbdCA+Pj4gMjRdIDw8IDI0KSB8IChzYm94Wyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoc2JveFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IHNib3hbdCAmIDB4ZmZdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBwcmV2ID0gKGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0KSA+Pj4gMDtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcclxuICAgICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcclxuICAgICAgaWYgKGludktzUm93ICYgMykge1xyXG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xyXG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52U3ViTWl4MFtzYm94W3QgPj4+IDI0XV0gXiBpbnZTdWJNaXgxW3Nib3hbKHQgPj4+IDE2KSAmIDB4ZmZdXSBeIGludlN1Yk1peDJbc2JveFsodCA+Pj4gOCkgJiAweGZmXV0gXiBpbnZTdWJNaXgzW3Nib3hbdCAmIDB4ZmZdXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID4+PiAwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkaW5nIHRoaXMgYXMgYSBtZXRob2QgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZS5cclxuICBuZXR3b3JrVG9Ib3N0T3JkZXJTd2FwICh3b3JkKSB7XHJcbiAgICByZXR1cm4gKHdvcmQgPDwgMjQpIHwgKCh3b3JkICYgMHhmZjAwKSA8PCA4KSB8ICgod29yZCAmIDB4ZmYwMDAwKSA+PiA4KSB8ICh3b3JkID4+PiAyNCk7XHJcbiAgfVxyXG5cclxuICBkZWNyeXB0IChpbnB1dEFycmF5QnVmZmVyLCBvZmZzZXQsIGFlc0lWLCByZW1vdmVQS0NTN1BhZGRpbmcpIHtcclxuICAgIGxldCBuUm91bmRzID0gdGhpcy5rZXlTaXplICsgNjtcclxuICAgIGxldCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGU7XHJcbiAgICBsZXQgaW52U0JPWCA9IHRoaXMuaW52U0JveDtcclxuXHJcbiAgICBsZXQgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XHJcbiAgICBsZXQgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcclxuICAgIGxldCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xyXG4gICAgbGV0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XHJcbiAgICBsZXQgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcclxuXHJcbiAgICBsZXQgaW5pdFZlY3RvciA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGFlc0lWKTtcclxuICAgIGxldCBpbml0VmVjdG9yMCA9IGluaXRWZWN0b3JbMF07XHJcbiAgICBsZXQgaW5pdFZlY3RvcjEgPSBpbml0VmVjdG9yWzFdO1xyXG4gICAgbGV0IGluaXRWZWN0b3IyID0gaW5pdFZlY3RvclsyXTtcclxuICAgIGxldCBpbml0VmVjdG9yMyA9IGluaXRWZWN0b3JbM107XHJcblxyXG4gICAgbGV0IGlucHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEFycmF5QnVmZmVyKTtcclxuICAgIGxldCBvdXRwdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0SW50MzIubGVuZ3RoKTtcclxuXHJcbiAgICBsZXQgdDAsIHQxLCB0MiwgdDM7XHJcbiAgICBsZXQgczAsIHMxLCBzMiwgczM7XHJcbiAgICBsZXQgaW5wdXRXb3JkczAsIGlucHV0V29yZHMxLCBpbnB1dFdvcmRzMiwgaW5wdXRXb3JkczM7XHJcblxyXG4gICAgbGV0IGtzUm93LCBpO1xyXG4gICAgbGV0IHN3YXBXb3JkID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwO1xyXG5cclxuICAgIHdoaWxlIChvZmZzZXQgPCBpbnB1dEludDMyLmxlbmd0aCkge1xyXG4gICAgICBpbnB1dFdvcmRzMCA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0XSk7XHJcbiAgICAgIGlucHV0V29yZHMxID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAxXSk7XHJcbiAgICAgIGlucHV0V29yZHMyID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAyXSk7XHJcbiAgICAgIGlucHV0V29yZHMzID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAzXSk7XHJcblxyXG4gICAgICBzMCA9IGlucHV0V29yZHMwIF4gaW52S2V5U2NoZWR1bGVbMF07XHJcbiAgICAgIHMxID0gaW5wdXRXb3JkczMgXiBpbnZLZXlTY2hlZHVsZVsxXTtcclxuICAgICAgczIgPSBpbnB1dFdvcmRzMiBeIGludktleVNjaGVkdWxlWzJdO1xyXG4gICAgICBzMyA9IGlucHV0V29yZHMxIF4gaW52S2V5U2NoZWR1bGVbM107XHJcblxyXG4gICAgICBrc1JvdyA9IDQ7XHJcblxyXG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJvdW5kcyBvZiBkZWNyeXB0aW9uXHJcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuUm91bmRzOyBpKyspIHtcclxuICAgICAgICB0MCA9IGludlN1Yk1peDBbczAgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMxID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczIgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczMgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcclxuICAgICAgICB0MSA9IGludlN1Yk1peDBbczEgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMyID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczMgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczAgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XHJcbiAgICAgICAgdDIgPSBpbnZTdWJNaXgwW3MyID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMyA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMwID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MxICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xyXG4gICAgICAgIHQzID0gaW52U3ViTWl4MFtzMyA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczAgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMSA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMiAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcclxuICAgICAgICAvLyBVcGRhdGUgc3RhdGVcclxuICAgICAgICBzMCA9IHQwO1xyXG4gICAgICAgIHMxID0gdDE7XHJcbiAgICAgICAgczIgPSB0MjtcclxuICAgICAgICBzMyA9IHQzO1xyXG5cclxuICAgICAgICBrc1JvdyA9IGtzUm93ICsgNDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XHJcbiAgICAgIHQwID0gKChpbnZTQk9YW3MwID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMxID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMiA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMyAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcclxuICAgICAgdDEgPSAoKGludlNCT1hbczEgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczIgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMzID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MwICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcclxuICAgICAgdDIgPSAoKGludlNCT1hbczIgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczMgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMwID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MxICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcclxuICAgICAgdDMgPSAoKGludlNCT1hbczMgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczAgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMxID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MyICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcclxuICAgICAga3NSb3cgPSBrc1JvdyArIDM7XHJcblxyXG4gICAgICAvLyBXcml0ZVxyXG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXRdID0gc3dhcFdvcmQodDAgXiBpbml0VmVjdG9yMCk7XHJcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gc3dhcFdvcmQodDMgXiBpbml0VmVjdG9yMSk7XHJcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDJdID0gc3dhcFdvcmQodDIgXiBpbml0VmVjdG9yMik7XHJcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDNdID0gc3dhcFdvcmQodDEgXiBpbml0VmVjdG9yMyk7XHJcblxyXG4gICAgICAvLyByZXNldCBpbml0VmVjdG9yIHRvIGxhc3QgNCB1bnNpZ25lZCBpbnRcclxuICAgICAgaW5pdFZlY3RvcjAgPSBpbnB1dFdvcmRzMDtcclxuICAgICAgaW5pdFZlY3RvcjEgPSBpbnB1dFdvcmRzMTtcclxuICAgICAgaW5pdFZlY3RvcjIgPSBpbnB1dFdvcmRzMjtcclxuICAgICAgaW5pdFZlY3RvcjMgPSBpbnB1dFdvcmRzMztcclxuXHJcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIDQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlbW92ZVBLQ1M3UGFkZGluZyA/IHJlbW92ZVBhZGRpbmcob3V0cHV0SW50MzIuYnVmZmVyKSA6IG91dHB1dEludDMyLmJ1ZmZlcjtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3kgKCkge1xyXG4gICAgdGhpcy5rZXkgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmtleVNpemUgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmtzUm93cyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICB0aGlzLnNCb3ggPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmludlNCb3ggPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnN1Yk1peCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuaW52U3ViTWl4ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5rZXlTY2hlZHVsZSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuaW52S2V5U2NoZWR1bGUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgdGhpcy5yY29uID0gdW5kZWZpbmVkO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQUVTRGVjcnlwdG9yO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jcnlwdC9hZXMtZGVjcnlwdG9yLmpzIiwiLyoqXHJcbiAqIEFBQyBkZW11eGVyXHJcbiAqL1xyXG5pbXBvcnQgKiBhcyBBRFRTIGZyb20gJy4vYWR0cyc7XHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcbmltcG9ydCBJRDMgZnJvbSAnLi4vZGVtdXgvaWQzJztcclxuXHJcbmNsYXNzIEFBQ0RlbXV4ZXIge1xyXG4gIGNvbnN0cnVjdG9yIChvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnKSB7XHJcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XHJcbiAgfVxyXG5cclxuICByZXNldEluaXRTZWdtZW50IChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcclxuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7IGNvbnRhaW5lcjogJ2F1ZGlvL2FkdHMnLCB0eXBlOiAnYXVkaW8nLCBpZDogMCwgc2VxdWVuY2VOdW1iZXI6IDAsIGlzQUFDOiB0cnVlLCBzYW1wbGVzOiBbXSwgbGVuOiAwLCBtYW5pZmVzdENvZGVjOiBhdWRpb0NvZGVjLCBkdXJhdGlvbjogZHVyYXRpb24sIGlucHV0VGltZVNjYWxlOiA5MDAwMCB9O1xyXG4gIH1cclxuXHJcbiAgcmVzZXRUaW1lU3RhbXAgKCkge1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHByb2JlIChkYXRhKSB7XHJcbiAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGZvciB0aGUgQURUUyBzeW5jIHdvcmRcclxuICAgIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxyXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXHJcbiAgICAvLyBNb3JlIGluZm8gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcclxuICAgIGNvbnN0IGlkM0RhdGEgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCAwKSB8fCBbXTtcclxuICAgIGxldCBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xyXG4gICAgICBpZiAoQURUUy5wcm9iZShkYXRhLCBvZmZzZXQpKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnQURUUyBzeW5jIHdvcmQgZm91bmQgIScpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXHJcbiAgYXBwZW5kIChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcclxuICAgIGxldCB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XHJcbiAgICBsZXQgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIDApIHx8IFtdO1xyXG4gICAgbGV0IHRpbWVzdGFtcCA9IElEMy5nZXRUaW1lU3RhbXAoaWQzRGF0YSk7XHJcbiAgICBsZXQgcHRzID0gTnVtYmVyLmlzRmluaXRlKHRpbWVzdGFtcCkgPyB0aW1lc3RhbXAgKiA5MCA6IHRpbWVPZmZzZXQgKiA5MDAwMDtcclxuICAgIGxldCBmcmFtZUluZGV4ID0gMDtcclxuICAgIGxldCBzdGFtcCA9IHB0cztcclxuICAgIGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcclxuICAgIGxldCBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcclxuXHJcbiAgICBsZXQgaWQzU2FtcGxlcyA9IFt7IHB0czogc3RhbXAsIGR0czogc3RhbXAsIGRhdGE6IGlkM0RhdGEgfV07XHJcblxyXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCAtIDEpIHtcclxuICAgICAgaWYgKEFEVFMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSAmJiAob2Zmc2V0ICsgNSkgPCBsZW5ndGgpIHtcclxuICAgICAgICBBRFRTLmluaXRUcmFja0NvbmZpZyh0cmFjaywgdGhpcy5vYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCB0cmFjay5tYW5pZmVzdENvZGVjKTtcclxuICAgICAgICBsZXQgZnJhbWUgPSBBRFRTLmFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XHJcbiAgICAgICAgaWYgKGZyYW1lKSB7XHJcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xyXG4gICAgICAgICAgc3RhbXAgPSBmcmFtZS5zYW1wbGUucHRzO1xyXG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgQUFDIGZyYW1lJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoSUQzLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcclxuICAgICAgICBpZDNEYXRhID0gSUQzLmdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KTtcclxuICAgICAgICBpZDNTYW1wbGVzLnB1c2goeyBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wLCBkYXRhOiBpZDNEYXRhIH0pO1xyXG4gICAgICAgIG9mZnNldCArPSBpZDNEYXRhLmxlbmd0aDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBub3RoaW5nIGZvdW5kLCBrZWVwIGxvb2tpbmdcclxuICAgICAgICBvZmZzZXQrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucmVtdXhlci5yZW11eCh0cmFjayxcclxuICAgICAgeyBzYW1wbGVzOiBbXSB9LFxyXG4gICAgICB7IHNhbXBsZXM6IGlkM1NhbXBsZXMsIGlucHV0VGltZVNjYWxlOiA5MDAwMCB9LFxyXG4gICAgICB7IHNhbXBsZXM6IFtdIH0sXHJcbiAgICAgIHRpbWVPZmZzZXQsXHJcbiAgICAgIGNvbnRpZ3VvdXMsXHJcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCk7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95ICgpIHtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFBQ0RlbXV4ZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2RlbXV4L2FhY2RlbXV4ZXIuanMiLCIvKipcclxuICogaGlnaGx5IG9wdGltaXplZCBUUyBkZW11eGVyOlxyXG4gKiBwYXJzZSBQQVQsIFBNVFxyXG4gKiBleHRyYWN0IFBFUyBwYWNrZXQgZnJvbSBhdWRpbyBhbmQgdmlkZW8gUElEc1xyXG4gKiBleHRyYWN0IEFWQy9IMjY0IE5BTCB1bml0cyBhbmQgQUFDL0FEVFMgc2FtcGxlcyBmcm9tIFBFUyBwYWNrZXRcclxuICogdHJpZ2dlciB0aGUgcmVtdXhlciB1cG9uIHBhcnNpbmcgY29tcGxldGlvblxyXG4gKiBpdCBhbHNvIHRyaWVzIHRvIHdvcmthcm91bmQgYXMgYmVzdCBhcyBpdCBjYW4gYXVkaW8gY29kZWMgc3dpdGNoIChIRS1BQUMgdG8gQUFDIGFuZCB2aWNlIHZlcnNhKSwgd2l0aG91dCBoYXZpbmcgdG8gcmVzdGFydCB0aGUgTWVkaWFTb3VyY2UuXHJcbiAqIGl0IGFsc28gY29udHJvbHMgdGhlIHJlbXV4aW5nIHByb2Nlc3MgOlxyXG4gKiB1cG9uIGRpc2NvbnRpbnVpdHkgb3IgbGV2ZWwgc3dpdGNoIGRldGVjdGlvbiwgaXQgd2lsbCBhbHNvIG5vdGlmaWVzIHRoZSByZW11eGVyIHNvIHRoYXQgaXQgY2FuIHJlc2V0IGl0cyBzdGF0ZS5cclxuKi9cclxuXHJcbmltcG9ydCAqIGFzIEFEVFMgZnJvbSAnLi9hZHRzJztcclxuaW1wb3J0IE1wZWdBdWRpbyBmcm9tICcuL21wZWdhdWRpbyc7XHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXhwR29sb21iIGZyb20gJy4vZXhwLWdvbG9tYic7XHJcbmltcG9ydCBTYW1wbGVBZXNEZWNyeXB0ZXIgZnJvbSAnLi9zYW1wbGUtYWVzJztcclxuLy8gaW1wb3J0IEhleCBmcm9tICcuLi91dGlscy9oZXgnO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5pbXBvcnQgeyB1dGY4QXJyYXlUb1N0ciB9IGZyb20gJy4vaWQzJztcclxuXHJcbi8vIFdlIGFyZSB1c2luZyBmaXhlZCB0cmFjayBJRHMgZm9yIGRyaXZpbmcgdGhlIE1QNCByZW11eGVyXHJcbi8vIGluc3RlYWQgb2YgZm9sbG93aW5nIHRoZSBUUyBQSURzLlxyXG4vLyBUaGVyZSBpcyBubyByZWFzb24gbm90IHRvIGRvIHRoaXMgYW5kIHNvbWUgYnJvd3NlcnMvU291cmNlQnVmZmVyLWRlbXV4ZXJzXHJcbi8vIG1heSBub3QgbGlrZSBpZiB0aGVyZSBhcmUgVHJhY2tJRCBcInN3aXRjaGVzXCJcclxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8xMzMxXHJcbi8vIEhlcmUgd2UgYXJlIG1hcHBpbmcgb3VyIGludGVybmFsIHRyYWNrIHR5cGVzIHRvIGNvbnN0YW50IE1QNCB0cmFjayBJRHNcclxuLy8gV2l0aCBNU0UgY3VycmVudGx5IG9uZSBjYW4gb25seSBoYXZlIG9uZSB0cmFjayBvZiBlYWNoLCBhbmQgd2UgYXJlIG11eGluZ1xyXG4vLyB3aGF0ZXZlciB2aWRlby9hdWRpbyByZW5kaXRpb24gaW4gdGhlbS5cclxuY29uc3QgUmVtdXhlclRyYWNrSWRDb25maWcgPSB7XHJcbiAgdmlkZW86IDEsXHJcbiAgYXVkaW86IDIsXHJcbiAgaWQzOiAzLFxyXG4gIHRleHQ6IDRcclxufTtcclxuXHJcbmNsYXNzIFRTRGVtdXhlciB7XHJcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyLCByZW11eGVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpIHtcclxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcclxuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XHJcbiAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBzZXREZWNyeXB0RGF0YSAoZGVjcnlwdGRhdGEpIHtcclxuICAgIGlmICgoZGVjcnlwdGRhdGEgIT0gbnVsbCkgJiYgKGRlY3J5cHRkYXRhLmtleSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEubWV0aG9kID09PSAnU0FNUExFLUFFUycpKSB7XHJcbiAgICAgIHRoaXMuc2FtcGxlQWVzID0gbmV3IFNhbXBsZUFlc0RlY3J5cHRlcih0aGlzLm9ic2VydmVyLCB0aGlzLmNvbmZpZywgZGVjcnlwdGRhdGEsIHRoaXMuZGlzY2FyZEVQQik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcHJvYmUgKGRhdGEpIHtcclxuICAgIGNvbnN0IHN5bmNPZmZzZXQgPSBUU0RlbXV4ZXIuX3N5bmNPZmZzZXQoZGF0YSk7XHJcbiAgICBpZiAoc3luY09mZnNldCA8IDApIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHN5bmNPZmZzZXQpIHtcclxuICAgICAgICBsb2dnZXIud2FybihgTVBFRzItVFMgZGV0ZWN0ZWQgYnV0IGZpcnN0IHN5bmMgd29yZCBmb3VuZCBAIG9mZnNldCAke3N5bmNPZmZzZXR9LCBqdW5rIGFoZWFkID9gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgX3N5bmNPZmZzZXQgKGRhdGEpIHtcclxuICAgIC8vIHNjYW4gMTAwMCBmaXJzdCBieXRlc1xyXG4gICAgY29uc3Qgc2NhbndpbmRvdyA9IE1hdGgubWluKDEwMDAsIGRhdGEubGVuZ3RoIC0gMyAqIDE4OCk7XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IHNjYW53aW5kb3cpIHtcclxuICAgICAgLy8gYSBUUyBmcmFnbWVudCBzaG91bGQgY29udGFpbiBhdCBsZWFzdCAzIFRTIHBhY2tldHMsIGEgUEFULCBhIFBNVCwgYW5kIG9uZSBQSUQsIGVhY2ggc3RhcnRpbmcgd2l0aCAweDQ3XHJcbiAgICAgIGlmIChkYXRhW2ldID09PSAweDQ3ICYmIGRhdGFbaSArIDE4OF0gPT09IDB4NDcgJiYgZGF0YVtpICsgMiAqIDE4OF0gPT09IDB4NDcpIHtcclxuICAgICAgICByZXR1cm4gaTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpKys7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSB0cmFjayBtb2RlbCBpbnRlcm5hbCB0byBkZW11eGVyIHVzZWQgdG8gZHJpdmUgcmVtdXhpbmcgaW5wdXRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICdhdWRpbycgfCAndmlkZW8nIHwgJ2lkMycgfCAndGV4dCdcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRTRGVtdXhlcidzIGludGVybmFsIHRyYWNrIG1vZGVsXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZVRyYWNrICh0eXBlLCBkdXJhdGlvbikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29udGFpbmVyOiB0eXBlID09PSAndmlkZW8nIHx8IHR5cGUgPT09ICdhdWRpbycgPyAndmlkZW8vbXAydCcgOiB1bmRlZmluZWQsXHJcbiAgICAgIHR5cGUsXHJcbiAgICAgIGlkOiBSZW11eGVyVHJhY2tJZENvbmZpZ1t0eXBlXSxcclxuICAgICAgcGlkOiAtMSxcclxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxyXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcclxuICAgICAgc2FtcGxlczogW10sXHJcbiAgICAgIGRyb3BwZWQ6IHR5cGUgPT09ICd2aWRlbycgPyAwIDogdW5kZWZpbmVkLFxyXG4gICAgICBpc0FBQzogdHlwZSA9PT0gJ2F1ZGlvJyA/IHRydWUgOiB1bmRlZmluZWQsXHJcbiAgICAgIGR1cmF0aW9uOiB0eXBlID09PSAnYXVkaW8nID8gZHVyYXRpb24gOiB1bmRlZmluZWRcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbml0IHNlZ21lbnQgb24gdGhlIGRlbXV4ZXIvcmVtdXhlciBpbnRlcmZhY2UuIE5lZWRlZCBmb3IgZGlzY29udGludWl0aWVzL3RyYWNrLXN3aXRjaGVzIChvciBhdCBzdHJlYW0gc3RhcnQpXHJcbiAgICogUmVzZXRzIGFsbCBpbnRlcm5hbCB0cmFjayBpbnN0YW5jZXMgb2YgdGhlIGRlbXV4ZXIuXHJcbiAgICpcclxuICAgKiBAb3ZlcnJpZGUgSW1wbGVtZW50cyBnZW5lcmljIGRlbXV4aW5nL3JlbXV4aW5nIGludGVyZmFjZSAoc2VlIERlbXV4ZXJJbmxpbmUpXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGluaXRTZWdtZW50XHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF1ZGlvQ29kZWNcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlkZW9Db2RlY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiAoaW4gVFMgdGltZXNjYWxlID0gOTBrSHopXHJcbiAgICovXHJcbiAgcmVzZXRJbml0U2VnbWVudCAoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XHJcbiAgICB0aGlzLnBtdFBhcnNlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fcG10SWQgPSAtMTtcclxuXHJcbiAgICB0aGlzLl9hdmNUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygndmlkZW8nLCBkdXJhdGlvbik7XHJcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCdhdWRpbycsIGR1cmF0aW9uKTtcclxuICAgIHRoaXMuX2lkM1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCdpZDMnLCBkdXJhdGlvbik7XHJcbiAgICB0aGlzLl90eHRUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygndGV4dCcsIGR1cmF0aW9uKTtcclxuXHJcbiAgICAvLyBmbHVzaCBhbnkgcGFydGlhbCBjb250ZW50XHJcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcclxuICAgIHRoaXMuYWFjTGFzdFBUUyA9IG51bGw7XHJcbiAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XHJcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xyXG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcclxuICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xyXG4gIHJlc2V0VGltZVN0YW1wICgpIHt9XHJcblxyXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcclxuICBhcHBlbmQgKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xyXG4gICAgbGV0IHN0YXJ0LCBsZW4gPSBkYXRhLmxlbmd0aCwgc3R0LCBwaWQsIGF0Ziwgb2Zmc2V0LCBwZXMsXHJcbiAgICAgIHVua25vd25QSURzID0gZmFsc2U7XHJcbiAgICB0aGlzLmNvbnRpZ3VvdXMgPSBjb250aWd1b3VzO1xyXG4gICAgbGV0IHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkLFxyXG4gICAgICBhdmNUcmFjayA9IHRoaXMuX2F2Y1RyYWNrLFxyXG4gICAgICBhdWRpb1RyYWNrID0gdGhpcy5fYXVkaW9UcmFjayxcclxuICAgICAgaWQzVHJhY2sgPSB0aGlzLl9pZDNUcmFjayxcclxuICAgICAgYXZjSWQgPSBhdmNUcmFjay5waWQsXHJcbiAgICAgIGF1ZGlvSWQgPSBhdWRpb1RyYWNrLnBpZCxcclxuICAgICAgaWQzSWQgPSBpZDNUcmFjay5waWQsXHJcbiAgICAgIHBtdElkID0gdGhpcy5fcG10SWQsXHJcbiAgICAgIGF2Y0RhdGEgPSBhdmNUcmFjay5wZXNEYXRhLFxyXG4gICAgICBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGEsXHJcbiAgICAgIGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhLFxyXG4gICAgICBwYXJzZVBBVCA9IHRoaXMuX3BhcnNlUEFULFxyXG4gICAgICBwYXJzZVBNVCA9IHRoaXMuX3BhcnNlUE1ULFxyXG4gICAgICBwYXJzZVBFUyA9IHRoaXMuX3BhcnNlUEVTLFxyXG4gICAgICBwYXJzZUFWQ1BFUyA9IHRoaXMuX3BhcnNlQVZDUEVTLmJpbmQodGhpcyksXHJcbiAgICAgIHBhcnNlQUFDUEVTID0gdGhpcy5fcGFyc2VBQUNQRVMuYmluZCh0aGlzKSxcclxuICAgICAgcGFyc2VNUEVHUEVTID0gdGhpcy5fcGFyc2VNUEVHUEVTLmJpbmQodGhpcyksXHJcbiAgICAgIHBhcnNlSUQzUEVTID0gdGhpcy5fcGFyc2VJRDNQRVMuYmluZCh0aGlzKTtcclxuXHJcbiAgICBjb25zdCBzeW5jT2Zmc2V0ID0gVFNEZW11eGVyLl9zeW5jT2Zmc2V0KGRhdGEpO1xyXG5cclxuICAgIC8vIGRvbid0IHBhcnNlIGxhc3QgVFMgcGFja2V0IGlmIGluY29tcGxldGVcclxuICAgIGxlbiAtPSAobGVuICsgc3luY09mZnNldCkgJSAxODg7XHJcblxyXG4gICAgLy8gbG9vcCB0aHJvdWdoIFRTIHBhY2tldHNcclxuICAgIGZvciAoc3RhcnQgPSBzeW5jT2Zmc2V0OyBzdGFydCA8IGxlbjsgc3RhcnQgKz0gMTg4KSB7XHJcbiAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xyXG4gICAgICAgIHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xyXG4gICAgICAgIC8vIHBpZCBpcyBhIDEzLWJpdCBmaWVsZCBzdGFydGluZyBhdCB0aGUgbGFzdCBiaXQgb2YgVFNbMV1cclxuICAgICAgICBwaWQgPSAoKGRhdGFbc3RhcnQgKyAxXSAmIDB4MWYpIDw8IDgpICsgZGF0YVtzdGFydCArIDJdO1xyXG4gICAgICAgIGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0O1xyXG4gICAgICAgIC8vIGlmIGFuIGFkYXB0aW9uIGZpZWxkIGlzIHByZXNlbnQsIGl0cyBsZW5ndGggaXMgc3BlY2lmaWVkIGJ5IHRoZSBmaWZ0aCBieXRlIG9mIHRoZSBUUyBwYWNrZXQgaGVhZGVyLlxyXG4gICAgICAgIGlmIChhdGYgPiAxKSB7XHJcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDUgKyBkYXRhW3N0YXJ0ICsgNF07XHJcbiAgICAgICAgICAvLyBjb250aW51ZSBpZiB0aGVyZSBpcyBvbmx5IGFkYXB0YXRpb24gZmllbGRcclxuICAgICAgICAgIGlmIChvZmZzZXQgPT09IChzdGFydCArIDE4OCkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChwaWQpIHtcclxuICAgICAgICBjYXNlIGF2Y0lkOlxyXG4gICAgICAgICAgaWYgKHN0dCkge1xyXG4gICAgICAgICAgICBpZiAoYXZjRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXZjRGF0YSkpKSB7XHJcbiAgICAgICAgICAgICAgcGFyc2VBVkNQRVMocGVzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGF2Y0RhdGEgPSB7IGRhdGE6IFtdLCBzaXplOiAwIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoYXZjRGF0YSkge1xyXG4gICAgICAgICAgICBhdmNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcclxuICAgICAgICAgICAgYXZjRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBhdWRpb0lkOlxyXG4gICAgICAgICAgaWYgKHN0dCkge1xyXG4gICAgICAgICAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSkge1xyXG4gICAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrLmlzQUFDKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZUFBQ1BFUyhwZXMpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZU1QRUdQRVMocGVzKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXVkaW9EYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xyXG4gICAgICAgICAgICBhdWRpb0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xyXG4gICAgICAgICAgICBhdWRpb0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgaWQzSWQ6XHJcbiAgICAgICAgICBpZiAoc3R0KSB7XHJcbiAgICAgICAgICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcclxuICAgICAgICAgICAgICBwYXJzZUlEM1BFUyhwZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZDNEYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGlkM0RhdGEpIHtcclxuICAgICAgICAgICAgaWQzRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XHJcbiAgICAgICAgICAgIGlkM0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgIGlmIChzdHQpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCA9IHBhcnNlUEFUKGRhdGEsIG9mZnNldCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIHBtdElkOlxyXG4gICAgICAgICAgaWYgKHN0dCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBsZXQgcGFyc2VkUElEcyA9IHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWcgPT09IHRydWUgfHwgdGhpcy50eXBlU3VwcG9ydGVkLm1wMyA9PT0gdHJ1ZSwgdGhpcy5zYW1wbGVBZXMgIT0gbnVsbCk7XHJcblxyXG4gICAgICAgICAgLy8gb25seSB1cGRhdGUgdHJhY2sgaWQgaWYgdHJhY2sgUElEIGZvdW5kIHdoaWxlIHBhcnNpbmcgUE1UXHJcbiAgICAgICAgICAvLyB0aGlzIGlzIHRvIGF2b2lkIHJlc2V0dGluZyB0aGUgUElEIHRvIC0xIGluIGNhc2VcclxuICAgICAgICAgIC8vIHRyYWNrIFBJRCB0cmFuc2llbnRseSBkaXNhcHBlYXJzIGZyb20gdGhlIHN0cmVhbVxyXG4gICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaW4gY2FzZSBvZiB0cmFuc2llbnQgbWlzc2luZyBhdWRpbyBzYW1wbGVzIGZvciBleGFtcGxlXHJcbiAgICAgICAgICAvLyBOT1RFIHRoaXMgaXMgb25seSB0aGUgUElEIG9mIHRoZSB0cmFjayBhcyBmb3VuZCBpbiBUUyxcclxuICAgICAgICAgIC8vIGJ1dCB3ZSBhcmUgbm90IHVzaW5nIHRoaXMgZm9yIE1QNCB0cmFjayBJRHMuXHJcbiAgICAgICAgICBhdmNJZCA9IHBhcnNlZFBJRHMuYXZjO1xyXG4gICAgICAgICAgaWYgKGF2Y0lkID4gMCkge1xyXG4gICAgICAgICAgICBhdmNUcmFjay5waWQgPSBhdmNJZDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBhdWRpb0lkID0gcGFyc2VkUElEcy5hdWRpbztcclxuICAgICAgICAgIGlmIChhdWRpb0lkID4gMCkge1xyXG4gICAgICAgICAgICBhdWRpb1RyYWNrLnBpZCA9IGF1ZGlvSWQ7XHJcbiAgICAgICAgICAgIGF1ZGlvVHJhY2suaXNBQUMgPSBwYXJzZWRQSURzLmlzQUFDO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWQzSWQgPSBwYXJzZWRQSURzLmlkMztcclxuICAgICAgICAgIGlmIChpZDNJZCA+IDApIHtcclxuICAgICAgICAgICAgaWQzVHJhY2sucGlkID0gaWQzSWQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHVua25vd25QSURzICYmICFwbXRQYXJzZWQpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZygncmVwYXJzZSBmcm9tIGJlZ2lubmluZycpO1xyXG4gICAgICAgICAgICB1bmtub3duUElEcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyB3ZSBzZXQgaXQgdG8gLTE4OCwgdGhlICs9IDE4OCBpbiB0aGUgZm9yIGxvb3Agd2lsbCByZXNldCBzdGFydCB0byAwXHJcbiAgICAgICAgICAgIHN0YXJ0ID0gc3luY09mZnNldCAtIDE4ODtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTc6XHJcbiAgICAgICAgY2FzZSAweDFmZmY6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdW5rbm93blBJRHMgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogZmFsc2UsIHJlYXNvbjogJ1RTIHBhY2tldCBkaWQgbm90IHN0YXJ0IHdpdGggMHg0NycgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHRyeSB0byBwYXJzZSBsYXN0IFBFUyBwYWNrZXRzXHJcbiAgICBpZiAoYXZjRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXZjRGF0YSkpKSB7XHJcbiAgICAgIHBhcnNlQVZDUEVTKHBlcywgdHJ1ZSk7XHJcbiAgICAgIGF2Y1RyYWNrLnBlc0RhdGEgPSBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZWl0aGVyIGF2Y0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xyXG4gICAgICBhdmNUcmFjay5wZXNEYXRhID0gYXZjRGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSkge1xyXG4gICAgICBpZiAoYXVkaW9UcmFjay5pc0FBQykge1xyXG4gICAgICAgIHBhcnNlQUFDUEVTKHBlcyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGFyc2VNUEVHUEVTKHBlcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoYXVkaW9EYXRhICYmIGF1ZGlvRGF0YS5zaXplKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnbGFzdCBBQUMgUEVTIHBhY2tldCB0cnVuY2F0ZWQsbWlnaHQgb3ZlcmxhcCBiZXR3ZWVuIGZyYWdtZW50cycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBlaXRoZXIgYXVkaW9EYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcclxuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gYXVkaW9EYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcclxuICAgICAgcGFyc2VJRDNQRVMocGVzKTtcclxuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBlaXRoZXIgaWQzRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXHJcbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBpZDNEYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnNhbXBsZUFlcyA9PSBudWxsKSB7XHJcbiAgICAgIHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCBhdmNUcmFjaywgaWQzVHJhY2ssIHRoaXMuX3R4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5kZWNyeXB0QW5kUmVtdXgoYXVkaW9UcmFjaywgYXZjVHJhY2ssIGlkM1RyYWNrLCB0aGlzLl90eHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlY3J5cHRBbmRSZW11eCAoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XHJcbiAgICBpZiAoYXVkaW9UcmFjay5zYW1wbGVzICYmIGF1ZGlvVHJhY2suaXNBQUMpIHtcclxuICAgICAgbGV0IGxvY2FsdGhpcyA9IHRoaXM7XHJcbiAgICAgIHRoaXMuc2FtcGxlQWVzLmRlY3J5cHRBYWNTYW1wbGVzKGF1ZGlvVHJhY2suc2FtcGxlcywgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxvY2FsdGhpcy5kZWNyeXB0QW5kUmVtdXhBdmMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmRlY3J5cHRBbmRSZW11eEF2YyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVjcnlwdEFuZFJlbXV4QXZjIChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcclxuICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMpIHtcclxuICAgICAgbGV0IGxvY2FsdGhpcyA9IHRoaXM7XHJcbiAgICAgIHRoaXMuc2FtcGxlQWVzLmRlY3J5cHRBdmNTYW1wbGVzKHZpZGVvVHJhY2suc2FtcGxlcywgMCwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxvY2FsdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZXN0cm95ICgpIHtcclxuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fZHVyYXRpb24gPSAwO1xyXG4gIH1cclxuXHJcbiAgX3BhcnNlUEFUIChkYXRhLCBvZmZzZXQpIHtcclxuICAgIC8vIHNraXAgdGhlIFBTSSBoZWFkZXIgYW5kIHBhcnNlIHRoZSBmaXJzdCBQTVQgZW50cnlcclxuICAgIHJldHVybiAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDFGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XHJcbiAgICAvLyBsb2dnZXIubG9nKCdQTVQgUElEOicgICsgdGhpcy5fcG10SWQpO1xyXG4gIH1cclxuXHJcbiAgX3BhcnNlUE1UIChkYXRhLCBvZmZzZXQsIG1wZWdTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzKSB7XHJcbiAgICBsZXQgc2VjdGlvbkxlbmd0aCwgdGFibGVFbmQsIHByb2dyYW1JbmZvTGVuZ3RoLCBwaWQsIHJlc3VsdCA9IHsgYXVkaW86IC0xLCBhdmM6IC0xLCBpZDM6IC0xLCBpc0FBQzogdHJ1ZSB9O1xyXG4gICAgc2VjdGlvbkxlbmd0aCA9IChkYXRhW29mZnNldCArIDFdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XHJcbiAgICB0YWJsZUVuZCA9IG9mZnNldCArIDMgKyBzZWN0aW9uTGVuZ3RoIC0gNDtcclxuICAgIC8vIHRvIGRldGVybWluZSB3aGVyZSB0aGUgdGFibGUgaXMsIHdlIGhhdmUgdG8gZmlndXJlIG91dCBob3dcclxuICAgIC8vIGxvbmcgdGhlIHByb2dyYW0gaW5mbyBkZXNjcmlwdG9ycyBhcmVcclxuICAgIHByb2dyYW1JbmZvTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xyXG4gICAgLy8gYWR2YW5jZSB0aGUgb2Zmc2V0IHRvIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgbWFwcGluZyB0YWJsZVxyXG4gICAgb2Zmc2V0ICs9IDEyICsgcHJvZ3JhbUluZm9MZW5ndGg7XHJcbiAgICB3aGlsZSAob2Zmc2V0IDwgdGFibGVFbmQpIHtcclxuICAgICAgcGlkID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcclxuICAgICAgc3dpdGNoIChkYXRhW29mZnNldF0pIHtcclxuICAgICAgY2FzZSAweGNmOiAvLyBTQU1QTEUtQUVTIEFBQ1xyXG4gICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coJ3Vua25vd24gc3RyZWFtIHR5cGU6JyArIGRhdGFbb2Zmc2V0XSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG5cclxuICAgICAgICAvLyBJU08vSUVDIDEzODE4LTcgQURUUyBBQUMgKE1QRUctMiBsb3dlciBiaXQtcmF0ZSBhdWRpbylcclxuICAgICAgY2FzZSAweDBmOlxyXG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0FBQyBQSUQ6JyAgKyBwaWQpO1xyXG4gICAgICAgIGlmIChyZXN1bHQuYXVkaW8gPT09IC0xKSB7XHJcbiAgICAgICAgICByZXN1bHQuYXVkaW8gPSBwaWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLy8gUGFja2V0aXplZCBtZXRhZGF0YSAoSUQzKVxyXG4gICAgICBjYXNlIDB4MTU6XHJcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnSUQzIFBJRDonICArIHBpZCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5pZDMgPT09IC0xKSB7XHJcbiAgICAgICAgICByZXN1bHQuaWQzID0gcGlkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIDB4ZGI6IC8vIFNBTVBMRS1BRVMgQVZDXHJcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZygndW5rbm93biBzdHJlYW0gdHlwZTonICsgZGF0YVtvZmZzZXRdKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcblxyXG4gICAgICAgIC8vIElUVS1UIFJlYy4gSC4yNjQgYW5kIElTTy9JRUMgMTQ0OTYtMTAgKGxvd2VyIGJpdC1yYXRlIHZpZGVvKVxyXG4gICAgICBjYXNlIDB4MWI6XHJcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnQVZDIFBJRDonICArIHBpZCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5hdmMgPT09IC0xKSB7XHJcbiAgICAgICAgICByZXN1bHQuYXZjID0gcGlkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIC8vIElTTy9JRUMgMTExNzItMyAoTVBFRy0xIGF1ZGlvKVxyXG4gICAgICAgIC8vIG9yIElTTy9JRUMgMTM4MTgtMyAoTVBFRy0yIGhhbHZlZCBzYW1wbGUgcmF0ZSBhdWRpbylcclxuICAgICAgY2FzZSAweDAzOlxyXG4gICAgICBjYXNlIDB4MDQ6XHJcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnTVBFRyBQSUQ6JyAgKyBwaWQpO1xyXG4gICAgICAgIGlmICghbXBlZ1N1cHBvcnRlZCkge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZygnTVBFRyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIgZm9yIG5vdycpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmF1ZGlvID09PSAtMSkge1xyXG4gICAgICAgICAgcmVzdWx0LmF1ZGlvID0gcGlkO1xyXG4gICAgICAgICAgcmVzdWx0LmlzQUFDID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAweDI0OlxyXG4gICAgICAgIGxvZ2dlci53YXJuKCdIRVZDIHN0cmVhbSB0eXBlIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGZvciBub3cnKTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgbG9nZ2VyLmxvZygndW5rbm93biBzdHJlYW0gdHlwZTonICsgZGF0YVtvZmZzZXRdKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICAvLyBtb3ZlIHRvIHRoZSBuZXh0IHRhYmxlIGVudHJ5XHJcbiAgICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcclxuICAgICAgb2Zmc2V0ICs9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MEYpIDw8IDggfCBkYXRhW29mZnNldCArIDRdKSArIDU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgX3BhcnNlUEVTIChzdHJlYW0pIHtcclxuICAgIGxldCBpID0gMCwgZnJhZywgcGVzRmxhZ3MsIHBlc1ByZWZpeCwgcGVzTGVuLCBwZXNIZHJMZW4sIHBlc0RhdGEsIHBlc1B0cywgcGVzRHRzLCBwYXlsb2FkU3RhcnRPZmZzZXQsIGRhdGEgPSBzdHJlYW0uZGF0YTtcclxuICAgIC8vIHNhZmV0eSBjaGVja1xyXG4gICAgaWYgKCFzdHJlYW0gfHwgc3RyZWFtLnNpemUgPT09IDApIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2UgbWlnaHQgbmVlZCB1cCB0byAxOSBieXRlcyB0byByZWFkIFBFUyBoZWFkZXJcclxuICAgIC8vIGlmIGZpcnN0IGNodW5rIG9mIGRhdGEgaXMgbGVzcyB0aGFuIDE5IGJ5dGVzLCBsZXQncyBtZXJnZSBpdCB3aXRoIGZvbGxvd2luZyBvbmVzIHVudGlsIHdlIGdldCAxOSBieXRlc1xyXG4gICAgLy8gdXN1YWxseSBvbmx5IG9uZSBtZXJnZSBpcyBuZWVkZWQgKGFuZCB0aGlzIGlzIHJhcmUgLi4uKVxyXG4gICAgd2hpbGUgKGRhdGFbMF0ubGVuZ3RoIDwgMTkgJiYgZGF0YS5sZW5ndGggPiAxKSB7XHJcbiAgICAgIGxldCBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YVswXS5sZW5ndGggKyBkYXRhWzFdLmxlbmd0aCk7XHJcbiAgICAgIG5ld0RhdGEuc2V0KGRhdGFbMF0pO1xyXG4gICAgICBuZXdEYXRhLnNldChkYXRhWzFdLCBkYXRhWzBdLmxlbmd0aCk7XHJcbiAgICAgIGRhdGFbMF0gPSBuZXdEYXRhO1xyXG4gICAgICBkYXRhLnNwbGljZSgxLCAxKTtcclxuICAgIH1cclxuICAgIC8vIHJldHJpZXZlIFBUUy9EVFMgZnJvbSBmaXJzdCBmcmFnbWVudFxyXG4gICAgZnJhZyA9IGRhdGFbMF07XHJcbiAgICBwZXNQcmVmaXggPSAoZnJhZ1swXSA8PCAxNikgKyAoZnJhZ1sxXSA8PCA4KSArIGZyYWdbMl07XHJcbiAgICBpZiAocGVzUHJlZml4ID09PSAxKSB7XHJcbiAgICAgIHBlc0xlbiA9IChmcmFnWzRdIDw8IDgpICsgZnJhZ1s1XTtcclxuICAgICAgLy8gaWYgUEVTIHBhcnNlZCBsZW5ndGggaXMgbm90IHplcm8gYW5kIGdyZWF0ZXIgdGhhbiB0b3RhbCByZWNlaXZlZCBsZW5ndGgsIHN0b3AgcGFyc2luZy4gUEVTIG1pZ2h0IGJlIHRydW5jYXRlZFxyXG4gICAgICAvLyBtaW51cyA2IDogUEVTIGhlYWRlciBzaXplXHJcbiAgICAgIGlmIChwZXNMZW4gJiYgcGVzTGVuID4gc3RyZWFtLnNpemUgLSA2KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBlc0ZsYWdzID0gZnJhZ1s3XTtcclxuICAgICAgaWYgKHBlc0ZsYWdzICYgMHhDMCkge1xyXG4gICAgICAgIC8qIFBFUyBoZWFkZXIgZGVzY3JpYmVkIGhlcmUgOiBodHRwOi8vZHZkLnNvdXJjZWZvcmdlLm5ldC9kdmRpbmZvL3Blcy1oZHIuaHRtbFxyXG4gICAgICAgICAgICBhcyBQVFMgLyBEVFMgaXMgMzMgYml0IHdlIGNhbm5vdCB1c2UgYml0d2lzZSBvcGVyYXRvciBpbiBKUyxcclxuICAgICAgICAgICAgYXMgQml0d2lzZSBvcGVyYXRvcnMgdHJlYXQgdGhlaXIgb3BlcmFuZHMgYXMgYSBzZXF1ZW5jZSBvZiAzMiBiaXRzICovXHJcbiAgICAgICAgcGVzUHRzID0gKGZyYWdbOV0gJiAweDBFKSAqIDUzNjg3MDkxMiArLy8gMSA8PCAyOVxyXG4gICAgICAgICAgKGZyYWdbMTBdICYgMHhGRikgKiA0MTk0MzA0ICsvLyAxIDw8IDIyXHJcbiAgICAgICAgICAoZnJhZ1sxMV0gJiAweEZFKSAqIDE2Mzg0ICsvLyAxIDw8IDE0XHJcbiAgICAgICAgICAoZnJhZ1sxMl0gJiAweEZGKSAqIDEyOCArLy8gMSA8PCA3XHJcbiAgICAgICAgICAoZnJhZ1sxM10gJiAweEZFKSAvIDI7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgZ3JlYXRlciB0aGFuIDJeMzIgLTFcclxuICAgICAgICBpZiAocGVzUHRzID4gNDI5NDk2NzI5NSkge1xyXG4gICAgICAgICAgLy8gZGVjcmVtZW50IDJeMzNcclxuICAgICAgICAgIHBlc1B0cyAtPSA4NTg5OTM0NTkyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGVzRmxhZ3MgJiAweDQwKSB7XHJcbiAgICAgICAgICBwZXNEdHMgPSAoZnJhZ1sxNF0gJiAweDBFKSAqIDUzNjg3MDkxMiArLy8gMSA8PCAyOVxyXG4gICAgICAgICAgICAoZnJhZ1sxNV0gJiAweEZGKSAqIDQxOTQzMDQgKy8vIDEgPDwgMjJcclxuICAgICAgICAgICAgKGZyYWdbMTZdICYgMHhGRSkgKiAxNjM4NCArLy8gMSA8PCAxNFxyXG4gICAgICAgICAgICAoZnJhZ1sxN10gJiAweEZGKSAqIDEyOCArLy8gMSA8PCA3XHJcbiAgICAgICAgICAgIChmcmFnWzE4XSAmIDB4RkUpIC8gMjtcclxuICAgICAgICAgIC8vIGNoZWNrIGlmIGdyZWF0ZXIgdGhhbiAyXjMyIC0xXHJcbiAgICAgICAgICBpZiAocGVzRHRzID4gNDI5NDk2NzI5NSkge1xyXG4gICAgICAgICAgICAvLyBkZWNyZW1lbnQgMl4zM1xyXG4gICAgICAgICAgICBwZXNEdHMgLT0gODU4OTkzNDU5MjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChwZXNQdHMgLSBwZXNEdHMgPiA2MCAqIDkwMDAwKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGAke01hdGgucm91bmQoKHBlc1B0cyAtIHBlc0R0cykgLyA5MDAwMCl9cyBkZWx0YSBiZXR3ZWVuIFBUUyBhbmQgRFRTLCBhbGlnbiB0aGVtYCk7XHJcbiAgICAgICAgICAgIHBlc1B0cyA9IHBlc0R0cztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcGVzRHRzID0gcGVzUHRzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwZXNIZHJMZW4gPSBmcmFnWzhdO1xyXG4gICAgICAvLyA5IGJ5dGVzIDogNiBieXRlcyBmb3IgUEVTIGhlYWRlciArIDMgYnl0ZXMgZm9yIFBFUyBleHRlbnNpb25cclxuICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gcGVzSGRyTGVuICsgOTtcclxuXHJcbiAgICAgIGlmIChzdHJlYW0uc2l6ZSA8PSBwYXlsb2FkU3RhcnRPZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBzdHJlYW0uc2l6ZSAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XHJcbiAgICAgIC8vIHJlYXNzZW1ibGUgUEVTIHBhY2tldFxyXG4gICAgICBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xyXG4gICAgICBmb3IgKGxldCBqID0gMCwgZGF0YUxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgZGF0YUxlbjsgaisrKSB7XHJcbiAgICAgICAgZnJhZyA9IGRhdGFbal07XHJcbiAgICAgICAgbGV0IGxlbiA9IGZyYWcuYnl0ZUxlbmd0aDtcclxuICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XHJcbiAgICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0ID4gbGVuKSB7XHJcbiAgICAgICAgICAgIC8vIHRyaW0gZnVsbCBmcmFnIGlmIFBFUyBoZWFkZXIgYmlnZ2VyIHRoYW4gZnJhZ1xyXG4gICAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgLT0gbGVuO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRyaW0gcGFydGlhbCBmcmFnIGlmIFBFUyBoZWFkZXIgc21hbGxlciB0aGFuIGZyYWdcclxuICAgICAgICAgICAgZnJhZyA9IGZyYWcuc3ViYXJyYXkocGF5bG9hZFN0YXJ0T2Zmc2V0KTtcclxuICAgICAgICAgICAgbGVuIC09IHBheWxvYWRTdGFydE9mZnNldDtcclxuICAgICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcGVzRGF0YS5zZXQoZnJhZywgaSk7XHJcbiAgICAgICAgaSArPSBsZW47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBlc0xlbikge1xyXG4gICAgICAgIC8vIHBheWxvYWQgc2l6ZSA6IHJlbW92ZSBQRVMgaGVhZGVyICsgUEVTIGV4dGVuc2lvblxyXG4gICAgICAgIHBlc0xlbiAtPSBwZXNIZHJMZW4gKyAzO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7IGRhdGE6IHBlc0RhdGEsIHB0czogcGVzUHRzLCBkdHM6IHBlc0R0cywgbGVuOiBwZXNMZW4gfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVzaEFjY2VzVW5pdCAoYXZjU2FtcGxlLCBhdmNUcmFjaykge1xyXG4gICAgaWYgKGF2Y1NhbXBsZS51bml0cy5sZW5ndGggJiYgYXZjU2FtcGxlLmZyYW1lKSB7XHJcbiAgICAgIGNvbnN0IHNhbXBsZXMgPSBhdmNUcmFjay5zYW1wbGVzO1xyXG4gICAgICBjb25zdCBuYlNhbXBsZXMgPSBzYW1wbGVzLmxlbmd0aDtcclxuICAgICAgLy8gaWYgc2FtcGxlIGRvZXMgbm90IGhhdmUgUFRTL0RUUywgcGF0Y2ggd2l0aCBsYXN0IHNhbXBsZSBQVFMvRFRTXHJcbiAgICAgIGlmIChpc05hTihhdmNTYW1wbGUucHRzKSkge1xyXG4gICAgICAgIGlmIChuYlNhbXBsZXMpIHtcclxuICAgICAgICAgIGNvbnN0IGxhc3RTYW1wbGUgPSBzYW1wbGVzW25iU2FtcGxlcyAtIDFdO1xyXG4gICAgICAgICAgYXZjU2FtcGxlLnB0cyA9IGxhc3RTYW1wbGUucHRzO1xyXG4gICAgICAgICAgYXZjU2FtcGxlLmR0cyA9IGxhc3RTYW1wbGUuZHRzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBkcm9wcGluZyBzYW1wbGVzLCBubyB0aW1lc3RhbXAgZm91bmRcclxuICAgICAgICAgIGF2Y1RyYWNrLmRyb3BwZWQrKztcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gb25seSBwdXNoIEFWQyBzYW1wbGUgaWYgc3RhcnRpbmcgd2l0aCBhIGtleWZyYW1lIGlzIG5vdCBtYW5kYXRvcnkgT1JcclxuICAgICAgLy8gICAgaWYga2V5ZnJhbWUgYWxyZWFkeSBmb3VuZCBpbiB0aGlzIGZyYWdtZW50IE9SXHJcbiAgICAgIC8vICAgICAgIGtleWZyYW1lIGZvdW5kIGluIGxhc3QgZnJhZ21lbnQgKHRyYWNrLnNwcykgQU5EXHJcbiAgICAgIC8vICAgICAgICAgIHNhbXBsZXMgYWxyZWFkeSBhcHBlbmRlZCAod2UgYWxyZWFkeSBmb3VuZCBhIGtleWZyYW1lIGluIHRoaXMgZnJhZ21lbnQpIE9SIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXNcclxuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5mb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5IHx8XHJcbiAgICAgICAgICBhdmNTYW1wbGUua2V5ID09PSB0cnVlIHx8XHJcbiAgICAgICAgICAoYXZjVHJhY2suc3BzICYmIChuYlNhbXBsZXMgfHwgdGhpcy5jb250aWd1b3VzKSkpIHtcclxuICAgICAgICBhdmNTYW1wbGUuaWQgPSBuYlNhbXBsZXM7XHJcbiAgICAgICAgc2FtcGxlcy5wdXNoKGF2Y1NhbXBsZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZHJvcHBlZCBzYW1wbGVzLCB0cmFjayBpdFxyXG4gICAgICAgIGF2Y1RyYWNrLmRyb3BwZWQrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGF2Y1NhbXBsZS5kZWJ1Zy5sZW5ndGgpIHtcclxuICAgICAgbG9nZ2VyLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICc6JyArIGF2Y1NhbXBsZS5kZWJ1Zyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfcGFyc2VBVkNQRVMgKHBlcywgbGFzdCkge1xyXG4gICAgLy8gbG9nZ2VyLmxvZygncGFyc2UgbmV3IFBFUycpO1xyXG4gICAgbGV0IHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssXHJcbiAgICAgIHVuaXRzID0gdGhpcy5fcGFyc2VBVkNOQUx1KHBlcy5kYXRhKSxcclxuICAgICAgZGVidWcgPSBmYWxzZSxcclxuICAgICAgZXhwR29sb21iRGVjb2RlcixcclxuICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUsXHJcbiAgICAgIHB1c2gsXHJcbiAgICAgIHNwc2ZvdW5kID0gZmFsc2UsXHJcbiAgICAgIGksXHJcbiAgICAgIHB1c2hBY2Nlc1VuaXQgPSB0aGlzLnB1c2hBY2Nlc1VuaXQuYmluZCh0aGlzKSxcclxuICAgICAgY3JlYXRlQVZDU2FtcGxlID0gZnVuY3Rpb24gKGtleSwgcHRzLCBkdHMsIGRlYnVnKSB7XHJcbiAgICAgICAgcmV0dXJuIHsga2V5OiBrZXksIHB0czogcHRzLCBkdHM6IGR0cywgdW5pdHM6IFtdLCBkZWJ1ZzogZGVidWcgfTtcclxuICAgICAgfTtcclxuICAgIC8vIGZyZWUgcGVzLmRhdGEgdG8gc2F2ZSB1cCBzb21lIG1lbW9yeVxyXG4gICAgcGVzLmRhdGEgPSBudWxsO1xyXG5cclxuICAgIC8vIGlmIG5ldyBOQUwgdW5pdHMgZm91bmQgYW5kIGxhc3Qgc2FtcGxlIHN0aWxsIHRoZXJlLCBsZXQncyBwdXNoIC4uLlxyXG4gICAgLy8gdGhpcyBoZWxwcyBwYXJzaW5nIHN0cmVhbXMgd2l0aCBtaXNzaW5nIEFVRCAob25seSBkbyB0aGlzIGlmIEFVRCBuZXZlciBmb3VuZClcclxuICAgIGlmIChhdmNTYW1wbGUgJiYgdW5pdHMubGVuZ3RoICYmICF0cmFjay5hdWRGb3VuZCkge1xyXG4gICAgICBwdXNoQWNjZXNVbml0KGF2Y1NhbXBsZSwgdHJhY2spO1xyXG4gICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZShmYWxzZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIHVuaXRzLmZvckVhY2godW5pdCA9PiB7XHJcbiAgICAgIHN3aXRjaCAodW5pdC50eXBlKSB7XHJcbiAgICAgIC8vIE5EUlxyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgcHVzaCA9IHRydWU7XHJcbiAgICAgICAgaWYgKCFhdmNTYW1wbGUpIHtcclxuICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZWJ1Zykge1xyXG4gICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdORFIgJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XHJcbiAgICAgICAgbGV0IGRhdGEgPSB1bml0LmRhdGE7XHJcbiAgICAgICAgLy8gb25seSBjaGVjayBzbGljZSB0eXBlIHRvIGRldGVjdCBLRiBpbiBjYXNlIFNQUyBmb3VuZCBpbiBzYW1lIHBhY2tldCAoYW55IGtleWZyYW1lIGlzIHByZWNlZGVkIGJ5IFNQUyAuLi4pXHJcbiAgICAgICAgaWYgKHNwc2ZvdW5kICYmIGRhdGEubGVuZ3RoID4gNCkge1xyXG4gICAgICAgICAgLy8gcmV0cmlldmUgc2xpY2UgdHlwZSBieSBwYXJzaW5nIGJlZ2lubmluZyBvZiBOQUwgdW5pdCAoZm9sbG93IEgyNjQgc3BlYywgc2xpY2VfaGVhZGVyIGRlZmluaXRpb24pIHRvIGRldGVjdCBrZXlmcmFtZSBlbWJlZGRlZCBpbiBORFJcclxuICAgICAgICAgIGxldCBzbGljZVR5cGUgPSBuZXcgRXhwR29sb21iKGRhdGEpLnJlYWRTbGljZVR5cGUoKTtcclxuICAgICAgICAgIC8vIDIgOiBJIHNsaWNlLCA0IDogU0kgc2xpY2UsIDcgOiBJIHNsaWNlLCA5OiBTSSBzbGljZVxyXG4gICAgICAgICAgLy8gU0kgc2xpY2UgOiBBIHNsaWNlIHRoYXQgaXMgY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5IGFuZCB1c2luZyBxdWFudGlzYXRpb24gb2YgdGhlIHByZWRpY3Rpb24gc2FtcGxlcy5cclxuICAgICAgICAgIC8vIEFuIFNJIHNsaWNlIGNhbiBiZSBjb2RlZCBzdWNoIHRoYXQgaXRzIGRlY29kZWQgc2FtcGxlcyBjYW4gYmUgY29uc3RydWN0ZWQgaWRlbnRpY2FsbHkgdG8gYW4gU1Agc2xpY2UuXHJcbiAgICAgICAgICAvLyBJIHNsaWNlOiBBIHNsaWNlIHRoYXQgaXMgbm90IGFuIFNJIHNsaWNlIHRoYXQgaXMgZGVjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkuXHJcbiAgICAgICAgICAvLyBpZiAoc2xpY2VUeXBlID09PSAyIHx8IHNsaWNlVHlwZSA9PT0gNykge1xyXG4gICAgICAgICAgaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDQgfHwgc2xpY2VUeXBlID09PSA3IHx8IHNsaWNlVHlwZSA9PT0gOSkge1xyXG4gICAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gSURSXHJcbiAgICAgIGNhc2UgNTpcclxuICAgICAgICBwdXNoID0gdHJ1ZTtcclxuICAgICAgICAvLyBoYW5kbGUgUEVTIG5vdCBzdGFydGluZyB3aXRoIEFVRFxyXG4gICAgICAgIGlmICghYXZjU2FtcGxlKSB7XHJcbiAgICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGVidWcpIHtcclxuICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnSURSICc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcclxuICAgICAgICBhdmNTYW1wbGUuZnJhbWUgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIFNFSVxyXG4gICAgICBjYXNlIDY6XHJcbiAgICAgICAgcHVzaCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xyXG4gICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdTRUkgJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cEdvbG9tYkRlY29kZXIgPSBuZXcgRXhwR29sb21iKHRoaXMuZGlzY2FyZEVQQih1bml0LmRhdGEpKTtcclxuXHJcbiAgICAgICAgLy8gc2tpcCBmcmFtZVR5cGVcclxuICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xyXG5cclxuICAgICAgICB2YXIgcGF5bG9hZFR5cGUgPSAwO1xyXG4gICAgICAgIHZhciBwYXlsb2FkU2l6ZSA9IDA7XHJcbiAgICAgICAgdmFyIGVuZE9mQ2FwdGlvbnMgPSBmYWxzZTtcclxuICAgICAgICB2YXIgYiA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICghZW5kT2ZDYXB0aW9ucyAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlID4gMSkge1xyXG4gICAgICAgICAgcGF5bG9hZFR5cGUgPSAwO1xyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBiID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcclxuICAgICAgICAgICAgcGF5bG9hZFR5cGUgKz0gYjtcclxuICAgICAgICAgIH0gd2hpbGUgKGIgPT09IDB4RkYpO1xyXG5cclxuICAgICAgICAgIC8vIFBhcnNlIHBheWxvYWQgc2l6ZS5cclxuICAgICAgICAgIHBheWxvYWRTaXplID0gMDtcclxuICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgYiA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XHJcbiAgICAgICAgICAgIHBheWxvYWRTaXplICs9IGI7XHJcbiAgICAgICAgICB9IHdoaWxlIChiID09PSAweEZGKTtcclxuXHJcbiAgICAgICAgICAvLyBUT0RPOiB0aGVyZSBjYW4gYmUgbW9yZSB0aGFuIG9uZSBwYXlsb2FkIGluIGFuIFNFSSBwYWNrZXQuLi5cclxuICAgICAgICAgIC8vIFRPRE86IG5lZWQgdG8gcmVhZCB0eXBlIGFuZCBzaXplIGluIGEgd2hpbGUgbG9vcCB0byBnZXQgdGhlbSBhbGxcclxuICAgICAgICAgIGlmIChwYXlsb2FkVHlwZSA9PT0gNCAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGVuZE9mQ2FwdGlvbnMgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgbGV0IGNvdW50cnlDb2RlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb3VudHJ5Q29kZSA9PT0gMTgxKSB7XHJcbiAgICAgICAgICAgICAgbGV0IHByb3ZpZGVyQ29kZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVTaG9ydCgpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAocHJvdmlkZXJDb2RlID09PSA0OSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHVzZXJTdHJ1Y3R1cmUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVSW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcclxuICAgICAgICAgICAgICAgICAgbGV0IHVzZXJEYXRhVHlwZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBSYXcgQ0VBLTYwOCBieXRlcyB3cmFwcGVkIGluIENFQS03MDggcGFja2V0XHJcbiAgICAgICAgICAgICAgICAgIGlmICh1c2VyRGF0YVR5cGUgPT09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3RCeXRlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2Vjb25kQnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbENDcyA9IDMxICYgZmlyc3RCeXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBieXRlQXJyYXkgPSBbZmlyc3RCeXRlLCBzZWNvbmRCeXRlXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ0NzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIDMgYnl0ZXMgcGVyIENDXHJcbiAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnNlcnRTYW1wbGVJbk9yZGVyKHRoaXMuX3R4dFRyYWNrLnNhbXBsZXMsIHsgdHlwZTogMywgcHRzOiBwZXMucHRzLCBieXRlczogYnl0ZUFycmF5IH0pO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWRUeXBlID09PSA1ICYmIGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUgIT09IDApIHtcclxuICAgICAgICAgICAgZW5kT2ZDYXB0aW9ucyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAocGF5bG9hZFNpemUgPiAxNikge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHV1aWRTdHJBcnJheSA9IFtdO1xyXG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB1dWlkU3RyQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpLnRvU3RyaW5nKDE2KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDMgfHwgaSA9PT0gNSB8fCBpID09PSA3IHx8IGkgPT09IDkpIHtcclxuICAgICAgICAgICAgICAgICAgdXVpZFN0ckFycmF5LnB1c2goJy0nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGF5bG9hZFNpemUgLSAxNjtcclxuICAgICAgICAgICAgICBjb25zdCB1c2VyRGF0YVBheWxvYWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB1c2VyRGF0YVBheWxvYWRCeXRlc1tpXSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICB0aGlzLl9pbnNlcnRTYW1wbGVJbk9yZGVyKHRoaXMuX3R4dFRyYWNrLnNhbXBsZXMsIHtcclxuICAgICAgICAgICAgICAgIHB0czogcGVzLnB0cyxcclxuICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlOiBwYXlsb2FkVHlwZSxcclxuICAgICAgICAgICAgICAgIHV1aWQ6IHV1aWRTdHJBcnJheS5qb2luKCcnKSxcclxuICAgICAgICAgICAgICAgIHVzZXJEYXRhQnl0ZXM6IHVzZXJEYXRhUGF5bG9hZEJ5dGVzLFxyXG4gICAgICAgICAgICAgICAgdXNlckRhdGE6IHV0ZjhBcnJheVRvU3RyKHVzZXJEYXRhUGF5bG9hZEJ5dGVzLmJ1ZmZlcilcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkU2l6ZSA8IGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBheWxvYWRTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIFNQU1xyXG4gICAgICBjYXNlIDc6XHJcbiAgICAgICAgcHVzaCA9IHRydWU7XHJcbiAgICAgICAgc3BzZm91bmQgPSB0cnVlO1xyXG4gICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcclxuICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU1BTICc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRyYWNrLnNwcykge1xyXG4gICAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBFeHBHb2xvbWIodW5pdC5kYXRhKTtcclxuICAgICAgICAgIGxldCBjb25maWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRTUFMoKTtcclxuICAgICAgICAgIHRyYWNrLndpZHRoID0gY29uZmlnLndpZHRoO1xyXG4gICAgICAgICAgdHJhY2suaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcclxuICAgICAgICAgIHRyYWNrLnBpeGVsUmF0aW8gPSBjb25maWcucGl4ZWxSYXRpbztcclxuICAgICAgICAgIHRyYWNrLnNwcyA9IFt1bml0LmRhdGFdO1xyXG4gICAgICAgICAgdHJhY2suZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcclxuICAgICAgICAgIGxldCBjb2RlY2FycmF5ID0gdW5pdC5kYXRhLnN1YmFycmF5KDEsIDQpO1xyXG4gICAgICAgICAgbGV0IGNvZGVjc3RyaW5nID0gJ2F2YzEuJztcclxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGggPSBjb2RlY2FycmF5W2ldLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xyXG4gICAgICAgICAgICAgIGggPSAnMCcgKyBoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb2RlY3N0cmluZyArPSBoO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdHJhY2suY29kZWMgPSBjb2RlY3N0cmluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gUFBTXHJcbiAgICAgIGNhc2UgODpcclxuICAgICAgICBwdXNoID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZGVidWcgJiYgYXZjU2FtcGxlKSB7XHJcbiAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1BQUyAnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcclxuICAgICAgICAgIHRyYWNrLnBwcyA9IFt1bml0LmRhdGFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gQVVEXHJcbiAgICAgIGNhc2UgOTpcclxuICAgICAgICBwdXNoID0gZmFsc2U7XHJcbiAgICAgICAgdHJhY2suYXVkRm91bmQgPSB0cnVlO1xyXG4gICAgICAgIGlmIChhdmNTYW1wbGUpIHtcclxuICAgICAgICAgIHB1c2hBY2Nlc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZShmYWxzZSwgcGVzLnB0cywgcGVzLmR0cywgZGVidWcgPyAnQVVEICcgOiAnJyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gRmlsbGVyIERhdGFcclxuICAgICAgY2FzZSAxMjpcclxuICAgICAgICBwdXNoID0gZmFsc2U7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcHVzaCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChhdmNTYW1wbGUpIHtcclxuICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAndW5rbm93biBOQUwgJyArIHVuaXQudHlwZSArICcgJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhdmNTYW1wbGUgJiYgcHVzaCkge1xyXG4gICAgICAgIGxldCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcclxuICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIGlmIGxhc3QgUEVTIHBhY2tldCwgcHVzaCBzYW1wbGVzXHJcbiAgICBpZiAobGFzdCAmJiBhdmNTYW1wbGUpIHtcclxuICAgICAgcHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcclxuICAgICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2luc2VydFNhbXBsZUluT3JkZXIgKGFyciwgZGF0YSkge1xyXG4gICAgbGV0IGxlbiA9IGFyci5sZW5ndGg7XHJcbiAgICBpZiAobGVuID4gMCkge1xyXG4gICAgICBpZiAoZGF0YS5wdHMgPj0gYXJyW2xlbiAtIDFdLnB0cykge1xyXG4gICAgICAgIGFyci5wdXNoKGRhdGEpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAobGV0IHBvcyA9IGxlbiAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xyXG4gICAgICAgICAgaWYgKGRhdGEucHRzIDwgYXJyW3Bvc10ucHRzKSB7XHJcbiAgICAgICAgICAgIGFyci5zcGxpY2UocG9zLCAwLCBkYXRhKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhcnIucHVzaChkYXRhKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9nZXRMYXN0TmFsVW5pdCAoKSB7XHJcbiAgICBsZXQgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUsIGxhc3RVbml0O1xyXG4gICAgLy8gdHJ5IHRvIGZhbGxiYWNrIHRvIHByZXZpb3VzIHNhbXBsZSBpZiBjdXJyZW50IG9uZSBpcyBlbXB0eVxyXG4gICAgaWYgKCFhdmNTYW1wbGUgfHwgYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBsZXQgdHJhY2sgPSB0aGlzLl9hdmNUcmFjaywgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XHJcbiAgICAgIGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICAgIGlmIChhdmNTYW1wbGUpIHtcclxuICAgICAgbGV0IHVuaXRzID0gYXZjU2FtcGxlLnVuaXRzO1xyXG4gICAgICBsYXN0VW5pdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxhc3RVbml0O1xyXG4gIH1cclxuXHJcbiAgX3BhcnNlQVZDTkFMdSAoYXJyYXkpIHtcclxuICAgIGxldCBpID0gMCwgbGVuID0gYXJyYXkuYnl0ZUxlbmd0aCwgdmFsdWUsIG92ZXJmbG93LCB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLCBzdGF0ZSA9IHRyYWNrLm5hbHVTdGF0ZSB8fCAwLCBsYXN0U3RhdGUgPSBzdGF0ZTtcclxuICAgIGxldCB1bml0cyA9IFtdLCB1bml0LCB1bml0VHlwZSwgbGFzdFVuaXRTdGFydCA9IC0xLCBsYXN0VW5pdFR5cGU7XHJcbiAgICAvLyBsb2dnZXIubG9nKCdQRVM6JyArIEhleC5oZXhEdW1wKGFycmF5KSk7XHJcblxyXG4gICAgaWYgKHN0YXRlID09PSAtMSkge1xyXG4gICAgLy8gc3BlY2lhbCB1c2UgY2FzZSB3aGVyZSB3ZSBmb3VuZCAzIG9yIDQtYnl0ZSBzdGFydCBjb2RlcyBleGFjdGx5IGF0IHRoZSBlbmQgb2YgcHJldmlvdXMgUEVTIHBhY2tldFxyXG4gICAgICBsYXN0VW5pdFN0YXJ0ID0gMDtcclxuICAgICAgLy8gTkFMdSB0eXBlIGlzIHZhbHVlIHJlYWQgZnJvbSBvZmZzZXQgMFxyXG4gICAgICBsYXN0VW5pdFR5cGUgPSBhcnJheVswXSAmIDB4MWY7XHJcbiAgICAgIHN0YXRlID0gMDtcclxuICAgICAgaSA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgdmFsdWUgPSBhcnJheVtpKytdO1xyXG4gICAgICAvLyBvcHRpbWl6YXRpb24uIHN0YXRlIDAgYW5kIDEgYXJlIHRoZSBwcmVkb21pbmFudCBjYXNlLiBsZXQncyBoYW5kbGUgdGhlbSBvdXRzaWRlIG9mIHRoZSBzd2l0Y2gvY2FzZVxyXG4gICAgICBpZiAoIXN0YXRlKSB7XHJcbiAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAxO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdGF0ZSA9PT0gMSkge1xyXG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMjtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICAvLyBoZXJlIHdlIGhhdmUgc3RhdGUgZWl0aGVyIGVxdWFsIHRvIDIgb3IgM1xyXG4gICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgc3RhdGUgPSAzO1xyXG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAxKSB7XHJcbiAgICAgICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCkge1xyXG4gICAgICAgICAgdW5pdCA9IHsgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgaSAtIHN0YXRlIC0gMSksIHR5cGU6IGxhc3RVbml0VHlwZSB9O1xyXG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGxhc3RVbml0U3RhcnQgaXMgdW5kZWZpbmVkID0+IHRoaXMgaXMgdGhlIGZpcnN0IHN0YXJ0IGNvZGUgZm91bmQgaW4gdGhpcyBQRVMgcGFja2V0XHJcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiBzdGFydCBjb2RlIGRlbGltaXRlciBpcyBvdmVybGFwcGluZyBiZXR3ZWVuIDIgUEVTIHBhY2tldHMsXHJcbiAgICAgICAgICAvLyBpZSBpdCBzdGFydGVkIGluIGxhc3QgcGFja2V0IChsYXN0U3RhdGUgbm90IHplcm8pXHJcbiAgICAgICAgICAvLyBhbmQgZW5kZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIFBFUyBwYWNrZXQgKGkgPD0gNCAtIGxhc3RTdGF0ZSlcclxuICAgICAgICAgIGxldCBsYXN0VW5pdCA9IHRoaXMuX2dldExhc3ROYWxVbml0KCk7XHJcbiAgICAgICAgICBpZiAobGFzdFVuaXQpIHtcclxuICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZSAmJiAoaSA8PSA0IC0gbGFzdFN0YXRlKSkge1xyXG4gICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXHJcbiAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XHJcbiAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbGFzdFVuaXQgaGFkIGEgc3RhdGUgZGlmZmVyZW50IGZyb20gemVyb1xyXG4gICAgICAgICAgICAgIGlmIChsYXN0VW5pdC5zdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlc1xyXG4gICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IGxhc3RVbml0LmRhdGEuc3ViYXJyYXkoMCwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoIC0gbGFzdFN0YXRlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgTkFMIHVuaXRzIGFyZSBub3Qgc3RhcnRpbmcgcmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBhY2tldCwgcHVzaCBwcmVjZWRpbmcgZGF0YSBpbnRvIHByZXZpb3VzIE5BTCB1bml0LlxyXG4gICAgICAgICAgICBvdmVyZmxvdyA9IGkgLSBzdGF0ZSAtIDE7XHJcbiAgICAgICAgICAgIGlmIChvdmVyZmxvdyA+IDApIHtcclxuICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaXJzdCBOQUxVIGZvdW5kIHdpdGggb3ZlcmZsb3c6JyArIG92ZXJmbG93KTtcclxuICAgICAgICAgICAgICBsZXQgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgb3ZlcmZsb3cpO1xyXG4gICAgICAgICAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XHJcbiAgICAgICAgICAgICAgdG1wLnNldChhcnJheS5zdWJhcnJheSgwLCBvdmVyZmxvdyksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gcmVhZCB1bml0IHR5cGVcclxuICAgICAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICAgICAgdW5pdFR5cGUgPSBhcnJheVtpXSAmIDB4MWY7XHJcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaW5kIE5BTFUgQCBvZmZzZXQ6JyArIGkgKyAnLHR5cGU6JyArIHVuaXRUeXBlKTtcclxuICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSBpO1xyXG4gICAgICAgICAgbGFzdFVuaXRUeXBlID0gdW5pdFR5cGU7XHJcbiAgICAgICAgICBzdGF0ZSA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIG5vdCBlbm91Z2ggYnl0ZSB0byByZWFkIHVuaXQgdHlwZS4gbGV0J3MgcmVhZCBpdCBvbiBuZXh0IFBFUyBwYXJzaW5nXHJcbiAgICAgICAgICBzdGF0ZSA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdGF0ZSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49IDAgJiYgc3RhdGUgPj0gMCkge1xyXG4gICAgICB1bml0ID0geyBkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBsZW4pLCB0eXBlOiBsYXN0VW5pdFR5cGUsIHN0YXRlOiBzdGF0ZSB9O1xyXG4gICAgICB1bml0cy5wdXNoKHVuaXQpO1xyXG4gICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZS9zdGF0ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGggKyAnLycgKyBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICAvLyBubyBOQUx1IGZvdW5kXHJcbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIC8vIGFwcGVuZCBwZXMuZGF0YSB0byBwcmV2aW91cyBOQUwgdW5pdFxyXG4gICAgICBsZXQgbGFzdFVuaXQgPSB0aGlzLl9nZXRMYXN0TmFsVW5pdCgpO1xyXG4gICAgICBpZiAobGFzdFVuaXQpIHtcclxuICAgICAgICBsZXQgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgYXJyYXkuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgdG1wLnNldChsYXN0VW5pdC5kYXRhLCAwKTtcclxuICAgICAgICB0bXAuc2V0KGFycmF5LCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIGxhc3RVbml0LmRhdGEgPSB0bXA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRyYWNrLm5hbHVTdGF0ZSA9IHN0YXRlO1xyXG4gICAgcmV0dXJuIHVuaXRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogcmVtb3ZlIEVtdWxhdGlvbiBQcmV2ZW50aW9uIGJ5dGVzIGZyb20gYSBSQlNQXHJcbiAgICovXHJcbiAgZGlzY2FyZEVQQiAoZGF0YSkge1xyXG4gICAgbGV0IGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCxcclxuICAgICAgRVBCUG9zaXRpb25zID0gW10sXHJcbiAgICAgIGkgPSAxLFxyXG4gICAgICBuZXdMZW5ndGgsIG5ld0RhdGE7XHJcblxyXG4gICAgLy8gRmluZCBhbGwgYEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzYFxyXG4gICAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XHJcbiAgICAgIGlmIChkYXRhW2ldID09PSAwICYmXHJcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9PT0gMCAmJlxyXG4gICAgICAgICAgZGF0YVtpICsgMl0gPT09IDB4MDMpIHtcclxuICAgICAgICBFUEJQb3NpdGlvbnMucHVzaChpICsgMik7XHJcbiAgICAgICAgaSArPSAyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXHJcbiAgICAvLyBhcnJheVxyXG4gICAgaWYgKEVQQlBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcclxuICAgIG5ld0xlbmd0aCA9IGxlbmd0aCAtIEVQQlBvc2l0aW9ucy5sZW5ndGg7XHJcbiAgICBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcclxuICAgIGxldCBzb3VyY2VJbmRleCA9IDA7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IG5ld0xlbmd0aDsgc291cmNlSW5kZXgrKywgaSsrKSB7XHJcbiAgICAgIGlmIChzb3VyY2VJbmRleCA9PT0gRVBCUG9zaXRpb25zWzBdKSB7XHJcbiAgICAgICAgLy8gU2tpcCB0aGlzIGJ5dGVcclxuICAgICAgICBzb3VyY2VJbmRleCsrO1xyXG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIHBvc2l0aW9uIGluZGV4XHJcbiAgICAgICAgRVBCUG9zaXRpb25zLnNoaWZ0KCk7XHJcbiAgICAgIH1cclxuICAgICAgbmV3RGF0YVtpXSA9IGRhdGFbc291cmNlSW5kZXhdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld0RhdGE7XHJcbiAgfVxyXG5cclxuICBfcGFyc2VBQUNQRVMgKHBlcykge1xyXG4gICAgbGV0IHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjayxcclxuICAgICAgZGF0YSA9IHBlcy5kYXRhLFxyXG4gICAgICBwdHMgPSBwZXMucHRzLFxyXG4gICAgICBzdGFydE9mZnNldCA9IDAsXHJcbiAgICAgIGFhY092ZXJGbG93ID0gdGhpcy5hYWNPdmVyRmxvdyxcclxuICAgICAgYWFjTGFzdFBUUyA9IHRoaXMuYWFjTGFzdFBUUyxcclxuICAgICAgZnJhbWVEdXJhdGlvbiwgZnJhbWVJbmRleCwgb2Zmc2V0LCBzdGFtcCwgbGVuO1xyXG4gICAgaWYgKGFhY092ZXJGbG93KSB7XHJcbiAgICAgIGxldCB0bXAgPSBuZXcgVWludDhBcnJheShhYWNPdmVyRmxvdy5ieXRlTGVuZ3RoICsgZGF0YS5ieXRlTGVuZ3RoKTtcclxuICAgICAgdG1wLnNldChhYWNPdmVyRmxvdywgMCk7XHJcbiAgICAgIHRtcC5zZXQoZGF0YSwgYWFjT3ZlckZsb3cuYnl0ZUxlbmd0aCk7XHJcbiAgICAgIC8vIGxvZ2dlci5sb2coYEFBQzogYXBwZW5kIG92ZXJmbG93aW5nICR7YWFjT3ZlckZsb3cuYnl0ZUxlbmd0aH0gYnl0ZXMgdG8gYmVnaW5uaW5nIG9mIG5ldyBQRVNgKTtcclxuICAgICAgZGF0YSA9IHRtcDtcclxuICAgIH1cclxuICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXHJcbiAgICBmb3IgKG9mZnNldCA9IHN0YXJ0T2Zmc2V0LCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcclxuICAgICAgaWYgKEFEVFMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBpZiBBRFRTIGhlYWRlciBkb2VzIG5vdCBzdGFydCBzdHJhaWdodCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYXlsb2FkLCByYWlzZSBhbiBlcnJvclxyXG4gICAgaWYgKG9mZnNldCkge1xyXG4gICAgICBsZXQgcmVhc29uLCBmYXRhbDtcclxuICAgICAgaWYgKG9mZnNldCA8IGxlbiAtIDEpIHtcclxuICAgICAgICByZWFzb24gPSBgQUFDIFBFUyBkaWQgbm90IHN0YXJ0IHdpdGggQURUUyBoZWFkZXIsb2Zmc2V0OiR7b2Zmc2V0fWA7XHJcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWFzb24gPSAnbm8gQURUUyBoZWFkZXIgZm91bmQgaW4gQUFDIFBFUyc7XHJcbiAgICAgICAgZmF0YWwgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGxvZ2dlci53YXJuKGBwYXJzaW5nIGVycm9yOiR7cmVhc29ufWApO1xyXG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhdGFsLCByZWFzb246IHJlYXNvbiB9KTtcclxuICAgICAgaWYgKGZhdGFsKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQURUUy5pbml0VHJhY2tDb25maWcodHJhY2ssIHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdGhpcy5hdWRpb0NvZGVjKTtcclxuICAgIGZyYW1lSW5kZXggPSAwO1xyXG4gICAgZnJhbWVEdXJhdGlvbiA9IEFEVFMuZ2V0RnJhbWVEdXJhdGlvbih0cmFjay5zYW1wbGVyYXRlKTtcclxuXHJcbiAgICAvLyBpZiBsYXN0IEFBQyBmcmFtZSBpcyBvdmVyZmxvd2luZywgd2Ugc2hvdWxkIGVuc3VyZSB0aW1lc3RhbXBzIGFyZSBjb250aWd1b3VzOlxyXG4gICAgLy8gZmlyc3Qgc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZnJhbWVEdXJhdGlvblxyXG4gICAgaWYgKGFhY092ZXJGbG93ICYmIGFhY0xhc3RQVFMpIHtcclxuICAgICAgbGV0IG5ld1BUUyA9IGFhY0xhc3RQVFMgKyBmcmFtZUR1cmF0aW9uO1xyXG4gICAgICBpZiAoTWF0aC5hYnMobmV3UFRTIC0gcHRzKSA+IDEpIHtcclxuICAgICAgICBsb2dnZXIubG9nKGBBQUM6IGFsaWduIFBUUyBmb3Igb3ZlcmxhcHBpbmcgZnJhbWVzIGJ5ICR7TWF0aC5yb3VuZCgobmV3UFRTIC0gcHRzKSAvIDkwKX1gKTtcclxuICAgICAgICBwdHMgPSBuZXdQVFM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBzY2FuIGZvciBhYWMgc2FtcGxlc1xyXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbikge1xyXG4gICAgICBpZiAoQURUUy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpICYmIChvZmZzZXQgKyA1KSA8IGxlbikge1xyXG4gICAgICAgIGxldCBmcmFtZSA9IEFEVFMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcclxuICAgICAgICBpZiAoZnJhbWUpIHtcclxuICAgICAgICAgIC8vIGxvZ2dlci5sb2coYCR7TWF0aC5yb3VuZChmcmFtZS5zYW1wbGUucHRzKX0gOiBBQUNgKTtcclxuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XHJcbiAgICAgICAgICBzdGFtcCA9IGZyYW1lLnNhbXBsZS5wdHM7XHJcbiAgICAgICAgICBmcmFtZUluZGV4Kys7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBBQUMgZnJhbWUnKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBub3RoaW5nIGZvdW5kLCBrZWVwIGxvb2tpbmdcclxuICAgICAgICBvZmZzZXQrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcclxuICAgICAgYWFjT3ZlckZsb3cgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgbGVuKTtcclxuICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDOiBvdmVyZmxvdyBkZXRlY3RlZDoke2xlbi1vZmZzZXR9YCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhYWNPdmVyRmxvdyA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hYWNPdmVyRmxvdyA9IGFhY092ZXJGbG93O1xyXG4gICAgdGhpcy5hYWNMYXN0UFRTID0gc3RhbXA7XHJcbiAgfVxyXG5cclxuICBfcGFyc2VNUEVHUEVTIChwZXMpIHtcclxuICAgIGxldCBkYXRhID0gcGVzLmRhdGE7XHJcbiAgICBsZXQgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcbiAgICBsZXQgZnJhbWVJbmRleCA9IDA7XHJcbiAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgIGxldCBwdHMgPSBwZXMucHRzO1xyXG5cclxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcclxuICAgICAgaWYgKE1wZWdBdWRpby5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XHJcbiAgICAgICAgbGV0IGZyYW1lID0gTXBlZ0F1ZGlvLmFwcGVuZEZyYW1lKHRoaXMuX2F1ZGlvVHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcclxuICAgICAgICBpZiAoZnJhbWUpIHtcclxuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XHJcbiAgICAgICAgICBmcmFtZUluZGV4Kys7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBNcGVnIGF1ZGlvIGZyYW1lJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXHJcbiAgICAgICAgb2Zmc2V0Kys7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9wYXJzZUlEM1BFUyAocGVzKSB7XHJcbiAgICB0aGlzLl9pZDNUcmFjay5zYW1wbGVzLnB1c2gocGVzKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRTRGVtdXhlcjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvZGVtdXgvdHNkZW11eGVyLmpzIiwiLyoqXHJcbiAqIFBhcnNlciBmb3IgZXhwb25lbnRpYWwgR29sb21iIGNvZGVzLCBhIHZhcmlhYmxlLWJpdHdpZHRoIG51bWJlciBlbmNvZGluZyBzY2hlbWUgdXNlZCBieSBoMjY0LlxyXG4qL1xyXG5cclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmNsYXNzIEV4cEdvbG9tYiB7XHJcbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGlzLmRhdGFcclxuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSBkYXRhLmJ5dGVMZW5ndGg7XHJcbiAgICAvLyB0aGUgY3VycmVudCB3b3JkIGJlaW5nIGV4YW1pbmVkXHJcbiAgICB0aGlzLndvcmQgPSAwOyAvLyA6dWludFxyXG4gICAgLy8gdGhlIG51bWJlciBvZiBiaXRzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGUgY3VycmVudCB3b3JkXHJcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSAwOyAvLyA6dWludFxyXG4gIH1cclxuXHJcbiAgLy8gKCk6dm9pZFxyXG4gIGxvYWRXb3JkICgpIHtcclxuICAgIGxldFxyXG4gICAgICBkYXRhID0gdGhpcy5kYXRhLFxyXG4gICAgICBieXRlc0F2YWlsYWJsZSA9IHRoaXMuYnl0ZXNBdmFpbGFibGUsXHJcbiAgICAgIHBvc2l0aW9uID0gZGF0YS5ieXRlTGVuZ3RoIC0gYnl0ZXNBdmFpbGFibGUsXHJcbiAgICAgIHdvcmtpbmdCeXRlcyA9IG5ldyBVaW50OEFycmF5KDQpLFxyXG4gICAgICBhdmFpbGFibGVCeXRlcyA9IE1hdGgubWluKDQsIGJ5dGVzQXZhaWxhYmxlKTtcclxuICAgIGlmIChhdmFpbGFibGVCeXRlcyA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xyXG4gICAgfVxyXG5cclxuICAgIHdvcmtpbmdCeXRlcy5zZXQoZGF0YS5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBhdmFpbGFibGVCeXRlcykpO1xyXG4gICAgdGhpcy53b3JkID0gbmV3IERhdGFWaWV3KHdvcmtpbmdCeXRlcy5idWZmZXIpLmdldFVpbnQzMigwKTtcclxuICAgIC8vIHRyYWNrIHRoZSBhbW91bnQgb2YgdGhpcy5kYXRhIHRoYXQgaGFzIGJlZW4gcHJvY2Vzc2VkXHJcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSBhdmFpbGFibGVCeXRlcyAqIDg7XHJcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IGF2YWlsYWJsZUJ5dGVzO1xyXG4gIH1cclxuXHJcbiAgLy8gKGNvdW50OmludCk6dm9pZFxyXG4gIHNraXBCaXRzIChjb3VudCkge1xyXG4gICAgbGV0IHNraXBCeXRlczsgLy8gOmludFxyXG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IGNvdW50KSB7XHJcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XHJcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvdW50IC09IHRoaXMuYml0c0F2YWlsYWJsZTtcclxuICAgICAgc2tpcEJ5dGVzID0gY291bnQgPj4gMztcclxuICAgICAgY291bnQgLT0gKHNraXBCeXRlcyA+PiAzKTtcclxuICAgICAgdGhpcy5ieXRlc0F2YWlsYWJsZSAtPSBza2lwQnl0ZXM7XHJcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcclxuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcclxuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gKHNpemU6aW50KTp1aW50XHJcbiAgcmVhZEJpdHMgKHNpemUpIHtcclxuICAgIGxldFxyXG4gICAgICBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKSwgLy8gOnVpbnRcclxuICAgICAgdmFsdSA9IHRoaXMud29yZCA+Pj4gKDMyIC0gYml0cyk7IC8vIDp1aW50XHJcbiAgICBpZiAoc2l6ZSA+IDMyKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcignQ2Fubm90IHJlYWQgbW9yZSB0aGFuIDMyIGJpdHMgYXQgYSB0aW1lJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGJpdHM7XHJcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gMCkge1xyXG4gICAgICB0aGlzLndvcmQgPDw9IGJpdHM7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNBdmFpbGFibGUgPiAwKSB7XHJcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcclxuICAgIH1cclxuXHJcbiAgICBiaXRzID0gc2l6ZSAtIGJpdHM7XHJcbiAgICBpZiAoYml0cyA+IDAgJiYgdGhpcy5iaXRzQXZhaWxhYmxlKSB7XHJcbiAgICAgIHJldHVybiB2YWx1IDw8IGJpdHMgfCB0aGlzLnJlYWRCaXRzKGJpdHMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHZhbHU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyAoKTp1aW50XHJcbiAgc2tpcExaICgpIHtcclxuICAgIGxldCBsZWFkaW5nWmVyb0NvdW50OyAvLyA6dWludFxyXG4gICAgZm9yIChsZWFkaW5nWmVyb0NvdW50ID0gMDsgbGVhZGluZ1plcm9Db3VudCA8IHRoaXMuYml0c0F2YWlsYWJsZTsgKytsZWFkaW5nWmVyb0NvdW50KSB7XHJcbiAgICAgIGlmICgodGhpcy53b3JkICYgKDB4ODAwMDAwMDAgPj4+IGxlYWRpbmdaZXJvQ291bnQpKSAhPT0gMCkge1xyXG4gICAgICAgIC8vIHRoZSBmaXJzdCBiaXQgb2Ygd29ya2luZyB3b3JkIGlzIDFcclxuICAgICAgICB0aGlzLndvcmQgPDw9IGxlYWRpbmdaZXJvQ291bnQ7XHJcbiAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGxlYWRpbmdaZXJvQ291bnQ7XHJcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHdlIGV4aGF1c3RlZCB3b3JkIGFuZCBzdGlsbCBoYXZlIG5vdCBmb3VuZCBhIDFcclxuICAgIHRoaXMubG9hZFdvcmQoKTtcclxuICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50ICsgdGhpcy5za2lwTFooKTtcclxuICB9XHJcblxyXG4gIC8vICgpOnZvaWRcclxuICBza2lwVUVHICgpIHtcclxuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xyXG4gIH1cclxuXHJcbiAgLy8gKCk6dm9pZFxyXG4gIHNraXBFRyAoKSB7XHJcbiAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMWigpKTtcclxuICB9XHJcblxyXG4gIC8vICgpOnVpbnRcclxuICByZWFkVUVHICgpIHtcclxuICAgIGxldCBjbHogPSB0aGlzLnNraXBMWigpOyAvLyA6dWludFxyXG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoY2x6ICsgMSkgLSAxO1xyXG4gIH1cclxuXHJcbiAgLy8gKCk6aW50XHJcbiAgcmVhZEVHICgpIHtcclxuICAgIGxldCB2YWx1ID0gdGhpcy5yZWFkVUVHKCk7IC8vIDppbnRcclxuICAgIGlmICgweDAxICYgdmFsdSkge1xyXG4gICAgICAvLyB0aGUgbnVtYmVyIGlzIG9kZCBpZiB0aGUgbG93IG9yZGVyIGJpdCBpcyBzZXRcclxuICAgICAgcmV0dXJuICgxICsgdmFsdSkgPj4+IDE7IC8vIGFkZCAxIHRvIG1ha2UgaXQgZXZlbiwgYW5kIGRpdmlkZSBieSAyXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gLTEgKiAodmFsdSA+Pj4gMSk7IC8vIGRpdmlkZSBieSB0d28gdGhlbiBtYWtlIGl0IG5lZ2F0aXZlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xyXG4gIC8vIDpCb29sZWFuXHJcbiAgcmVhZEJvb2xlYW4gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMSkgPT09IDE7XHJcbiAgfVxyXG5cclxuICAvLyAoKTppbnRcclxuICByZWFkVUJ5dGUgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoOCk7XHJcbiAgfVxyXG5cclxuICAvLyAoKTppbnRcclxuICByZWFkVVNob3J0ICgpIHtcclxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDE2KTtcclxuICB9XHJcbiAgLy8gKCk6aW50XHJcbiAgcmVhZFVJbnQgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMzIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWR2YW5jZSB0aGUgRXhwR29sb21iIGRlY29kZXIgcGFzdCBhIHNjYWxpbmcgbGlzdC4gVGhlIHNjYWxpbmdcclxuICAgKiBsaXN0IGlzIG9wdGlvbmFsbHkgdHJhbnNtaXR0ZWQgYXMgcGFydCBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlclxyXG4gICAqIHNldCBhbmQgaXMgbm90IHJlbGV2YW50IHRvIHRyYW5zbXV4aW5nLlxyXG4gICAqIEBwYXJhbSBjb3VudCB7bnVtYmVyfSB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhpcyBzY2FsaW5nIGxpc3RcclxuICAgKiBAc2VlIFJlY29tbWVuZGF0aW9uIElUVS1UIEguMjY0LCBTZWN0aW9uIDcuMy4yLjEuMS4xXHJcbiAgICovXHJcbiAgc2tpcFNjYWxpbmdMaXN0IChjb3VudCkge1xyXG4gICAgbGV0XHJcbiAgICAgIGxhc3RTY2FsZSA9IDgsXHJcbiAgICAgIG5leHRTY2FsZSA9IDgsXHJcbiAgICAgIGosXHJcbiAgICAgIGRlbHRhU2NhbGU7XHJcbiAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xyXG4gICAgICBpZiAobmV4dFNjYWxlICE9PSAwKSB7XHJcbiAgICAgICAgZGVsdGFTY2FsZSA9IHRoaXMucmVhZEVHKCk7XHJcbiAgICAgICAgbmV4dFNjYWxlID0gKGxhc3RTY2FsZSArIGRlbHRhU2NhbGUgKyAyNTYpICUgMjU2O1xyXG4gICAgICB9XHJcbiAgICAgIGxhc3RTY2FsZSA9IChuZXh0U2NhbGUgPT09IDApID8gbGFzdFNjYWxlIDogbmV4dFNjYWxlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXHJcbiAgICogcHJvcGVydGllcy4gQSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGlzIHRoZSBIMjY0IG1ldGFkYXRhIHRoYXRcclxuICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxyXG4gICAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0XHJcbiAgICogQHJldHVybiB7b2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxyXG4gICAqIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQsIGluY2x1ZGluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcclxuICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cclxuICAgKi9cclxuICByZWFkU1BTICgpIHtcclxuICAgIGxldFxyXG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gMCxcclxuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSAwLFxyXG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSAwLFxyXG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSAwLFxyXG4gICAgICBwcm9maWxlSWRjLCBwcm9maWxlQ29tcGF0LCBsZXZlbElkYyxcclxuICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlLCBwaWNXaWR0aEluTWJzTWludXMxLFxyXG4gICAgICBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxLFxyXG4gICAgICBmcmFtZU1ic09ubHlGbGFnLFxyXG4gICAgICBzY2FsaW5nTGlzdENvdW50LFxyXG4gICAgICBpLFxyXG4gICAgICByZWFkVUJ5dGUgPSB0aGlzLnJlYWRVQnl0ZS5iaW5kKHRoaXMpLFxyXG4gICAgICByZWFkQml0cyA9IHRoaXMucmVhZEJpdHMuYmluZCh0aGlzKSxcclxuICAgICAgcmVhZFVFRyA9IHRoaXMucmVhZFVFRy5iaW5kKHRoaXMpLFxyXG4gICAgICByZWFkQm9vbGVhbiA9IHRoaXMucmVhZEJvb2xlYW4uYmluZCh0aGlzKSxcclxuICAgICAgc2tpcEJpdHMgPSB0aGlzLnNraXBCaXRzLmJpbmQodGhpcyksXHJcbiAgICAgIHNraXBFRyA9IHRoaXMuc2tpcEVHLmJpbmQodGhpcyksXHJcbiAgICAgIHNraXBVRUcgPSB0aGlzLnNraXBVRUcuYmluZCh0aGlzKSxcclxuICAgICAgc2tpcFNjYWxpbmdMaXN0ID0gdGhpcy5za2lwU2NhbGluZ0xpc3QuYmluZCh0aGlzKTtcclxuXHJcbiAgICByZWFkVUJ5dGUoKTtcclxuICAgIHByb2ZpbGVJZGMgPSByZWFkVUJ5dGUoKTsgLy8gcHJvZmlsZV9pZGNcclxuICAgIHByb2ZpbGVDb21wYXQgPSByZWFkQml0cyg1KTsgLy8gY29uc3RyYWludF9zZXRbMC00XV9mbGFnLCB1KDUpXHJcbiAgICBza2lwQml0cygzKTsgLy8gcmVzZXJ2ZWRfemVyb18zYml0cyB1KDMpLFxyXG4gICAgbGV2ZWxJZGMgPSByZWFkVUJ5dGUoKTsgLy8gbGV2ZWxfaWRjIHUoOClcclxuICAgIHNraXBVRUcoKTsgLy8gc2VxX3BhcmFtZXRlcl9zZXRfaWRcclxuICAgIC8vIHNvbWUgcHJvZmlsZXMgaGF2ZSBtb3JlIG9wdGlvbmFsIGRhdGEgd2UgZG9uJ3QgbmVlZFxyXG4gICAgaWYgKHByb2ZpbGVJZGMgPT09IDEwMCB8fFxyXG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDExMCB8fFxyXG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDEyMiB8fFxyXG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDI0NCB8fFxyXG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDQ0IHx8XHJcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gODMgfHxcclxuICAgICAgICBwcm9maWxlSWRjID09PSA4NiB8fFxyXG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDExOCB8fFxyXG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDEyOCkge1xyXG4gICAgICBsZXQgY2hyb21hRm9ybWF0SWRjID0gcmVhZFVFRygpO1xyXG4gICAgICBpZiAoY2hyb21hRm9ybWF0SWRjID09PSAzKSB7XHJcbiAgICAgICAgc2tpcEJpdHMoMSk7XHJcbiAgICAgIH0gLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcclxuXHJcbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2x1bWFfbWludXM4XHJcbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2Nocm9tYV9taW51czhcclxuICAgICAgc2tpcEJpdHMoMSk7IC8vIHFwcHJpbWVfeV96ZXJvX3RyYW5zZm9ybV9ieXBhc3NfZmxhZ1xyXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkgeyAvLyBzZXFfc2NhbGluZ19tYXRyaXhfcHJlc2VudF9mbGFnXHJcbiAgICAgICAgc2NhbGluZ0xpc3RDb3VudCA9IChjaHJvbWFGb3JtYXRJZGMgIT09IDMpID8gOCA6IDEyO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FsaW5nTGlzdENvdW50OyBpKyspIHtcclxuICAgICAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7IC8vIHNlcV9zY2FsaW5nX2xpc3RfcHJlc2VudF9mbGFnWyBpIF1cclxuICAgICAgICAgICAgaWYgKGkgPCA2KSB7XHJcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDE2KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoNjQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBza2lwVUVHKCk7IC8vIGxvZzJfbWF4X2ZyYW1lX251bV9taW51czRcclxuICAgIGxldCBwaWNPcmRlckNudFR5cGUgPSByZWFkVUVHKCk7XHJcbiAgICBpZiAocGljT3JkZXJDbnRUeXBlID09PSAwKSB7XHJcbiAgICAgIHJlYWRVRUcoKTsgLy8gbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0XHJcbiAgICB9IGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xyXG4gICAgICBza2lwQml0cygxKTsgLy8gZGVsdGFfcGljX29yZGVyX2Fsd2F5c196ZXJvX2ZsYWdcclxuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3Jfbm9uX3JlZl9waWNcclxuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZFxyXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUgPSByZWFkVUVHKCk7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGU7IGkrKykge1xyXG4gICAgICAgIHNraXBFRygpO1xyXG4gICAgICB9IC8vIG9mZnNldF9mb3JfcmVmX2ZyYW1lWyBpIF1cclxuICAgIH1cclxuICAgIHNraXBVRUcoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXHJcbiAgICBza2lwQml0cygxKTsgLy8gZ2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnXHJcbiAgICBwaWNXaWR0aEluTWJzTWludXMxID0gcmVhZFVFRygpO1xyXG4gICAgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSA9IHJlYWRVRUcoKTtcclxuICAgIGZyYW1lTWJzT25seUZsYWcgPSByZWFkQml0cygxKTtcclxuICAgIGlmIChmcmFtZU1ic09ubHlGbGFnID09PSAwKSB7XHJcbiAgICAgIHNraXBCaXRzKDEpO1xyXG4gICAgfSAvLyBtYl9hZGFwdGl2ZV9mcmFtZV9maWVsZF9mbGFnXHJcblxyXG4gICAgc2tpcEJpdHMoMSk7IC8vIGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWdcclxuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7IC8vIGZyYW1lX2Nyb3BwaW5nX2ZsYWdcclxuICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCA9IHJlYWRVRUcoKTtcclxuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSByZWFkVUVHKCk7XHJcbiAgICAgIGZyYW1lQ3JvcFRvcE9mZnNldCA9IHJlYWRVRUcoKTtcclxuICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gcmVhZFVFRygpO1xyXG4gICAgfVxyXG4gICAgbGV0IHBpeGVsUmF0aW8gPSBbMSwgMV07XHJcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xyXG4gICAgICAvLyB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWdcclxuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcclxuICAgICAgICAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcclxuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xyXG4gICAgICAgIHN3aXRjaCAoYXNwZWN0UmF0aW9JZGMpIHtcclxuICAgICAgICBjYXNlIDE6IHBpeGVsUmF0aW8gPSBbMSwgMV07IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjogcGl4ZWxSYXRpbyA9IFsxMiwgMTFdOyBicmVhaztcclxuICAgICAgICBjYXNlIDM6IHBpeGVsUmF0aW8gPSBbMTAsIDExXTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA0OiBwaXhlbFJhdGlvID0gWzE2LCAxMV07IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNTogcGl4ZWxSYXRpbyA9IFs0MCwgMzNdOyBicmVhaztcclxuICAgICAgICBjYXNlIDY6IHBpeGVsUmF0aW8gPSBbMjQsIDExXTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA3OiBwaXhlbFJhdGlvID0gWzIwLCAxMV07IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgODogcGl4ZWxSYXRpbyA9IFszMiwgMTFdOyBicmVhaztcclxuICAgICAgICBjYXNlIDk6IHBpeGVsUmF0aW8gPSBbODAsIDMzXTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxMDogcGl4ZWxSYXRpbyA9IFsxOCwgMTFdOyBicmVhaztcclxuICAgICAgICBjYXNlIDExOiBwaXhlbFJhdGlvID0gWzE1LCAxMV07IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTI6IHBpeGVsUmF0aW8gPSBbNjQsIDMzXTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxMzogcGl4ZWxSYXRpbyA9IFsxNjAsIDk5XTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxNDogcGl4ZWxSYXRpbyA9IFs0LCAzXTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxNTogcGl4ZWxSYXRpbyA9IFszLCAyXTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxNjogcGl4ZWxSYXRpbyA9IFsyLCAxXTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyNTU6IHtcclxuICAgICAgICAgIHBpeGVsUmF0aW8gPSBbcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpLCByZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCldO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGg6IE1hdGguY2VpbCgoKChwaWNXaWR0aEluTWJzTWludXMxICsgMSkgKiAxNikgLSBmcmFtZUNyb3BMZWZ0T2Zmc2V0ICogMiAtIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ICogMikpLFxyXG4gICAgICBoZWlnaHQ6ICgoMiAtIGZyYW1lTWJzT25seUZsYWcpICogKHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgKyAxKSAqIDE2KSAtICgoZnJhbWVNYnNPbmx5RmxhZyA/IDIgOiA0KSAqIChmcmFtZUNyb3BUb3BPZmZzZXQgKyBmcmFtZUNyb3BCb3R0b21PZmZzZXQpKSxcclxuICAgICAgcGl4ZWxSYXRpbzogcGl4ZWxSYXRpb1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJlYWRTbGljZVR5cGUgKCkge1xyXG4gICAgLy8gc2tpcCBOQUx1IHR5cGVcclxuICAgIHRoaXMucmVhZFVCeXRlKCk7XHJcbiAgICAvLyBkaXNjYXJkIGZpcnN0X21iX2luX3NsaWNlXHJcbiAgICB0aGlzLnJlYWRVRUcoKTtcclxuICAgIC8vIHJldHVybiBzbGljZV90eXBlXHJcbiAgICByZXR1cm4gdGhpcy5yZWFkVUVHKCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFeHBHb2xvbWI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2RlbXV4L2V4cC1nb2xvbWIuanMiLCIvKipcclxuICogU0FNUExFLUFFUyBkZWNyeXB0ZXJcclxuKi9cclxuXHJcbmltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcclxuXHJcbmNsYXNzIFNhbXBsZUFlc0RlY3J5cHRlciB7XHJcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyLCBjb25maWcsIGRlY3J5cHRkYXRhLCBkaXNjYXJkRVBCKSB7XHJcbiAgICB0aGlzLmRlY3J5cHRkYXRhID0gZGVjcnlwdGRhdGE7XHJcbiAgICB0aGlzLmRpc2NhcmRFUEIgPSBkaXNjYXJkRVBCO1xyXG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKG9ic2VydmVyLCBjb25maWcsIHsgcmVtb3ZlUEtDUzdQYWRkaW5nOiBmYWxzZSB9KTtcclxuICB9XHJcblxyXG4gIGRlY3J5cHRCdWZmZXIgKGVuY3J5cHRlZERhdGEsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGVuY3J5cHRlZERhdGEsIHRoaXMuZGVjcnlwdGRhdGEua2V5LmJ1ZmZlciwgdGhpcy5kZWNyeXB0ZGF0YS5pdi5idWZmZXIsIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIC8vIEFBQyAtIGVuY3J5cHQgYWxsIGZ1bGwgMTYgYnl0ZXMgYmxvY2tzIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDE2XHJcbiAgZGVjcnlwdEFhY1NhbXBsZSAoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrLCBzeW5jKSB7XHJcbiAgICBsZXQgY3VyVW5pdCA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQ7XHJcbiAgICBsZXQgZW5jcnlwdGVkRGF0YSA9IGN1clVuaXQuc3ViYXJyYXkoMTYsIGN1clVuaXQubGVuZ3RoIC0gY3VyVW5pdC5sZW5ndGggJSAxNik7XHJcbiAgICBsZXQgZW5jcnlwdGVkQnVmZmVyID0gZW5jcnlwdGVkRGF0YS5idWZmZXIuc2xpY2UoXHJcbiAgICAgIGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCxcclxuICAgICAgZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0ICsgZW5jcnlwdGVkRGF0YS5sZW5ndGgpO1xyXG5cclxuICAgIGxldCBsb2NhbHRoaXMgPSB0aGlzO1xyXG4gICAgdGhpcy5kZWNyeXB0QnVmZmVyKGVuY3J5cHRlZEJ1ZmZlciwgZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcclxuICAgICAgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xyXG4gICAgICBjdXJVbml0LnNldChkZWNyeXB0ZWREYXRhLCAxNik7XHJcblxyXG4gICAgICBpZiAoIXN5bmMpIHtcclxuICAgICAgICBsb2NhbHRoaXMuZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXggKyAxLCBjYWxsYmFjayk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZGVjcnlwdEFhY1NhbXBsZXMgKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaykge1xyXG4gICAgZm9yICg7OyBzYW1wbGVJbmRleCsrKSB7XHJcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdC5sZW5ndGggPCAzMikge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgc3luYyA9IHRoaXMuZGVjcnlwdGVyLmlzU3luYygpO1xyXG5cclxuICAgICAgdGhpcy5kZWNyeXB0QWFjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaywgc3luYyk7XHJcblxyXG4gICAgICBpZiAoIXN5bmMpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFWQyAtIGVuY3J5cHQgb25lIDE2IGJ5dGVzIGJsb2NrIG91dCBvZiB0ZW4sIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDMyXHJcbiAgZ2V0QXZjRW5jcnlwdGVkRGF0YSAoZGVjb2RlZERhdGEpIHtcclxuICAgIGxldCBlbmNyeXB0ZWREYXRhTGVuID0gTWF0aC5mbG9vcigoZGVjb2RlZERhdGEubGVuZ3RoIC0gNDgpIC8gMTYwKSAqIDE2ICsgMTY7XHJcbiAgICBsZXQgZW5jcnlwdGVkRGF0YSA9IG5ldyBJbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUxlbik7XHJcbiAgICBsZXQgb3V0cHV0UG9zID0gMDtcclxuICAgIGZvciAobGV0IGlucHV0UG9zID0gMzI7IGlucHV0UG9zIDw9IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBpbnB1dFBvcyArPSAxNjAsIG91dHB1dFBvcyArPSAxNikge1xyXG4gICAgICBlbmNyeXB0ZWREYXRhLnNldChkZWNvZGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVuY3J5cHRlZERhdGE7XHJcbiAgfVxyXG5cclxuICBnZXRBdmNEZWNyeXB0ZWRVbml0IChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkRGF0YSkge1xyXG4gICAgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xyXG4gICAgbGV0IGlucHV0UG9zID0gMDtcclxuICAgIGZvciAobGV0IG91dHB1dFBvcyA9IDMyOyBvdXRwdXRQb3MgPD0gZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IG91dHB1dFBvcyArPSAxNjAsIGlucHV0UG9zICs9IDE2KSB7XHJcbiAgICAgIGRlY29kZWREYXRhLnNldChkZWNyeXB0ZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGVjb2RlZERhdGE7XHJcbiAgfVxyXG5cclxuICBkZWNyeXB0QXZjU2FtcGxlIChzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCwgc3luYykge1xyXG4gICAgbGV0IGRlY29kZWREYXRhID0gdGhpcy5kaXNjYXJkRVBCKGN1clVuaXQuZGF0YSk7XHJcbiAgICBsZXQgZW5jcnlwdGVkRGF0YSA9IHRoaXMuZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YSk7XHJcbiAgICBsZXQgbG9jYWx0aGlzID0gdGhpcztcclxuXHJcbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YS5idWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XHJcbiAgICAgIGN1clVuaXQuZGF0YSA9IGxvY2FsdGhpcy5nZXRBdmNEZWNyeXB0ZWRVbml0KGRlY29kZWREYXRhLCBkZWNyeXB0ZWREYXRhKTtcclxuXHJcbiAgICAgIGlmICghc3luYykge1xyXG4gICAgICAgIGxvY2FsdGhpcy5kZWNyeXB0QXZjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4ICsgMSwgY2FsbGJhY2spO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGRlY3J5cHRBdmNTYW1wbGVzIChzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaykge1xyXG4gICAgZm9yICg7OyBzYW1wbGVJbmRleCsrLCB1bml0SW5kZXggPSAwKSB7XHJcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgY3VyVW5pdHMgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0cztcclxuICAgICAgZm9yICg7OyB1bml0SW5kZXgrKykge1xyXG4gICAgICAgIGlmICh1bml0SW5kZXggPj0gY3VyVW5pdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjdXJVbml0ID0gY3VyVW5pdHNbdW5pdEluZGV4XTtcclxuICAgICAgICBpZiAoY3VyVW5pdC5sZW5ndGggPD0gNDggfHwgKGN1clVuaXQudHlwZSAhPT0gMSAmJiBjdXJVbml0LnR5cGUgIT09IDUpKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzeW5jID0gdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZGVjcnlwdEF2Y1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCwgc3luYyk7XHJcblxyXG4gICAgICAgIGlmICghc3luYykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2FtcGxlQWVzRGVjcnlwdGVyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9kZW11eC9zYW1wbGUtYWVzLmpzIiwiLyoqXHJcbiAqIE1QMyBkZW11eGVyXHJcbiAqL1xyXG5pbXBvcnQgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcbmltcG9ydCBNcGVnQXVkaW8gZnJvbSAnLi9tcGVnYXVkaW8nO1xyXG5cclxuY2xhc3MgTVAzRGVtdXhlciB7XHJcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyLCByZW11eGVyLCBjb25maWcpIHtcclxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgdGhpcy5yZW11eGVyID0gcmVtdXhlcjtcclxuICB9XHJcblxyXG4gIHJlc2V0SW5pdFNlZ21lbnQgKGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xyXG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHsgY29udGFpbmVyOiAnYXVkaW8vbXBlZycsIHR5cGU6ICdhdWRpbycsIGlkOiAtMSwgc2VxdWVuY2VOdW1iZXI6IDAsIGlzQUFDOiBmYWxzZSwgc2FtcGxlczogW10sIGxlbjogMCwgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYywgZHVyYXRpb246IGR1cmF0aW9uLCBpbnB1dFRpbWVTY2FsZTogOTAwMDAgfTtcclxuICB9XHJcblxyXG4gIHJlc2V0VGltZVN0YW1wICgpIHtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBwcm9iZSAoZGF0YSkge1xyXG4gICAgLy8gY2hlY2sgaWYgZGF0YSBjb250YWlucyBJRDMgdGltZXN0YW1wIGFuZCBNUEVHIHN5bmMgd29yZFxyXG4gICAgbGV0IG9mZnNldCwgbGVuZ3RoO1xyXG4gICAgbGV0IGlkM0RhdGEgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCAwKTtcclxuICAgIGlmIChpZDNEYXRhICYmIElEMy5nZXRUaW1lU3RhbXAoaWQzRGF0YSkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxyXG4gICAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxyXG4gICAgICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxyXG4gICAgICBmb3IgKG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoLCBsZW5ndGggPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIDEsIG9mZnNldCArIDEwMCk7IG9mZnNldCA8IGxlbmd0aDsgb2Zmc2V0KyspIHtcclxuICAgICAgICBpZiAoTXBlZ0F1ZGlvLnByb2JlKGRhdGEsIG9mZnNldCkpIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coJ01QRUcgQXVkaW8gc3luYyB3b3JkIGZvdW5kICEnKTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxyXG4gIGFwcGVuZCAoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XHJcbiAgICBsZXQgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIDApO1xyXG4gICAgbGV0IHRpbWVzdGFtcCA9IElEMy5nZXRUaW1lU3RhbXAoaWQzRGF0YSk7XHJcbiAgICBsZXQgcHRzID0gdGltZXN0YW1wID8gOTAgKiB0aW1lc3RhbXAgOiB0aW1lT2Zmc2V0ICogOTAwMDA7XHJcbiAgICBsZXQgb2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGg7XHJcbiAgICBsZXQgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcbiAgICBsZXQgZnJhbWVJbmRleCA9IDAsIHN0YW1wID0gMDtcclxuICAgIGxldCB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XHJcblxyXG4gICAgbGV0IGlkM1NhbXBsZXMgPSBbeyBwdHM6IHB0cywgZHRzOiBwdHMsIGRhdGE6IGlkM0RhdGEgfV07XHJcblxyXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xyXG4gICAgICBpZiAoTXBlZ0F1ZGlvLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcclxuICAgICAgICBsZXQgZnJhbWUgPSBNcGVnQXVkaW8uYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcclxuICAgICAgICBpZiAoZnJhbWUpIHtcclxuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XHJcbiAgICAgICAgICBzdGFtcCA9IGZyYW1lLnNhbXBsZS5wdHM7XHJcbiAgICAgICAgICBmcmFtZUluZGV4Kys7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBNcGVnIGF1ZGlvIGZyYW1lJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoSUQzLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcclxuICAgICAgICBpZDNEYXRhID0gSUQzLmdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KTtcclxuICAgICAgICBpZDNTYW1wbGVzLnB1c2goeyBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wLCBkYXRhOiBpZDNEYXRhIH0pO1xyXG4gICAgICAgIG9mZnNldCArPSBpZDNEYXRhLmxlbmd0aDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBub3RoaW5nIGZvdW5kLCBrZWVwIGxvb2tpbmdcclxuICAgICAgICBvZmZzZXQrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucmVtdXhlci5yZW11eCh0cmFjayxcclxuICAgICAgeyBzYW1wbGVzOiBbXSB9LFxyXG4gICAgICB7IHNhbXBsZXM6IGlkM1NhbXBsZXMsIGlucHV0VGltZVNjYWxlOiA5MDAwMCB9LFxyXG4gICAgICB7IHNhbXBsZXM6IFtdIH0sXHJcbiAgICAgIHRpbWVPZmZzZXQsXHJcbiAgICAgIGNvbnRpZ3VvdXMsXHJcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCk7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95ICgpIHtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1QM0RlbXV4ZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2RlbXV4L21wM2RlbXV4ZXIuanMiLCIvKipcclxuICogZk1QNCByZW11eGVyXHJcbiovXHJcblxyXG5pbXBvcnQgQUFDIGZyb20gJy4vYWFjLWhlbHBlcic7XHJcbmltcG9ydCBNUDQgZnJvbSAnLi9tcDQtZ2VuZXJhdG9yJztcclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5cclxuaW1wb3J0IHsgdG9Nc0Zyb21NcGVnVHNDbG9jaywgdG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGUsIHRvVGltZXNjYWxlRnJvbVNjYWxlIH0gZnJvbSAnLi4vdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24nO1xyXG5cclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmNvbnN0IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT05fOTBLSFogPSB0b01wZWdUc0Nsb2NrRnJvbVRpbWVzY2FsZSgxMCk7XHJcbmNvbnN0IFBUU19EVFNfU0hJRlRfVE9MRVJBTkNFXzkwS0haID0gdG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGUoMC4yKTtcclxuXHJcbmNsYXNzIE1QNFJlbXV4ZXIge1xyXG4gIGNvbnN0cnVjdG9yIChvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB2ZW5kb3IpIHtcclxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcclxuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XHJcbiAgICB0aGlzLmlzU2FmYXJpID0gdmVuZG9yICYmIHZlbmRvci5pbmRleE9mKCdBcHBsZScpID4gLTEgJiYgdXNlckFnZW50ICYmICF1c2VyQWdlbnQubWF0Y2goJ0NyaU9TJyk7XHJcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95ICgpIHtcclxuICB9XHJcblxyXG4gIHJlc2V0VGltZVN0YW1wIChkZWZhdWx0VGltZVN0YW1wKSB7XHJcbiAgICB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IGRlZmF1bHRUaW1lU3RhbXA7XHJcbiAgfVxyXG5cclxuICByZXNldEluaXRTZWdtZW50ICgpIHtcclxuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJlbXV4IChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcclxuICAgIC8vIGdlbmVyYXRlIEluaXQgU2VnbWVudCBpZiBuZWVkZWRcclxuICAgIGlmICghdGhpcy5JU0dlbmVyYXRlZCkge1xyXG4gICAgICB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcclxuICAgICAgY29uc3QgbmJBdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoO1xyXG4gICAgICBjb25zdCBuYlZpZGVvU2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGg7XHJcbiAgICAgIGxldCBhdWRpb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xyXG4gICAgICBsZXQgdmlkZW9UaW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcclxuICAgICAgaWYgKG5iQXVkaW9TYW1wbGVzICYmIG5iVmlkZW9TYW1wbGVzKSB7XHJcbiAgICAgICAgLy8gdGltZU9mZnNldCBpcyBleHBlY3RlZCB0byBiZSB0aGUgb2Zmc2V0IG9mIHRoZSBmaXJzdCB0aW1lc3RhbXAgb2YgdGhpcyBmcmFnbWVudCAoZmlyc3QgRFRTKVxyXG4gICAgICAgIC8vIGlmIGZpcnN0IGF1ZGlvIERUUyBpcyBub3QgYWxpZ25lZCB3aXRoIGZpcnN0IHZpZGVvIERUUyB0aGVuIHdlIG5lZWQgdG8gdGFrZSB0aGF0IGludG8gYWNjb3VudFxyXG4gICAgICAgIC8vIHdoZW4gcHJvdmlkaW5nIHRpbWVPZmZzZXQgdG8gcmVtdXhBdWRpbyAvIHJlbXV4VmlkZW8uIGlmIHdlIGRvbid0IGRvIHRoYXQsIHRoZXJlIG1pZ2h0IGJlIGEgcGVybWFuZW50IC8gc21hbGxcclxuICAgICAgICAvLyBkcmlmdCBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW1zXHJcbiAgICAgICAgbGV0IGF1ZGlvdmlkZW9EZWx0YUR0cyA9IChhdWRpb1RyYWNrLnNhbXBsZXNbMF0ucHRzIC0gdmlkZW9UcmFjay5zYW1wbGVzWzBdLnB0cykgLyB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xyXG4gICAgICAgIGF1ZGlvVGltZU9mZnNldCArPSBNYXRoLm1heCgwLCBhdWRpb3ZpZGVvRGVsdGFEdHMpO1xyXG4gICAgICAgIHZpZGVvVGltZU9mZnNldCArPSBNYXRoLm1heCgwLCAtYXVkaW92aWRlb0RlbHRhRHRzKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBQdXJwb3NlZnVsbHkgcmVtdXhpbmcgYXVkaW8gYmVmb3JlIHZpZGVvLCBzbyB0aGF0IHJlbXV4VmlkZW8gY2FuIHVzZSBuZXh0QXVkaW9QdHMsIHdoaWNoIGlzXHJcbiAgICAgIC8vIGNhbGN1bGF0ZWQgaW4gcmVtdXhBdWRpby5cclxuICAgICAgLy8gbG9nZ2VyLmxvZygnbmIgQUFDIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xyXG4gICAgICBpZiAobmJBdWRpb1NhbXBsZXMpIHtcclxuICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxyXG4gICAgICAgIGlmICghYXVkaW9UcmFjay50aW1lc2NhbGUpIHtcclxuICAgICAgICAgIGxvZ2dlci53YXJuKCdyZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIGF1ZGlvIGRldGVjdGVkJyk7XHJcbiAgICAgICAgICB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBhdWRpb0RhdGEgPSB0aGlzLnJlbXV4QXVkaW8oYXVkaW9UcmFjaywgYXVkaW9UaW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xyXG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ25iIEFWQyBzYW1wbGVzOicgKyB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcclxuICAgICAgICBpZiAobmJWaWRlb1NhbXBsZXMpIHtcclxuICAgICAgICAgIGxldCBhdWRpb1RyYWNrTGVuZ3RoO1xyXG4gICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xyXG4gICAgICAgICAgICBhdWRpb1RyYWNrTGVuZ3RoID0gYXVkaW9EYXRhLmVuZFBUUyAtIGF1ZGlvRGF0YS5zdGFydFBUUztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxyXG4gICAgICAgICAgaWYgKCF2aWRlb1RyYWNrLnRpbWVzY2FsZSkge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybigncmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyB2aWRlbyBkZXRlY3RlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdmlkZW9UaW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBsb2dnZXIubG9nKCduYiBBVkMgc2FtcGxlczonICsgdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XHJcbiAgICAgICAgaWYgKG5iVmlkZW9TYW1wbGVzKSB7XHJcbiAgICAgICAgICBsZXQgdmlkZW9EYXRhID0gdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssIHZpZGVvVGltZU9mZnNldCwgY29udGlndW91cywgMCwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcclxuICAgICAgICAgIGlmICh2aWRlb0RhdGEgJiYgYXVkaW9UcmFjay5jb2RlYykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbXV4RW1wdHlBdWRpbyhhdWRpb1RyYWNrLCBhdWRpb1RpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIHZpZGVvRGF0YSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBsb2dnZXIubG9nKCduYiBJRDMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XHJcbiAgICBpZiAoaWQzVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5yZW11eElEMyhpZDNUcmFjaywgdGltZU9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbG9nZ2VyLmxvZygnbmIgSUQzIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xyXG4gICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLnJlbXV4VGV4dCh0ZXh0VHJhY2ssIHRpbWVPZmZzZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG5vdGlmeSBlbmQgb2YgcGFyc2luZ1xyXG4gICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0VEKTtcclxuICB9XHJcblxyXG4gIGdlbmVyYXRlSVMgKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpIHtcclxuICAgIGxldCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIsXHJcbiAgICAgIGF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcyxcclxuICAgICAgdmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLFxyXG4gICAgICB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkLFxyXG4gICAgICBjb250YWluZXIgPSAnYXVkaW8vbXA0JyxcclxuICAgICAgdHJhY2tzID0ge30sXHJcbiAgICAgIGRhdGEgPSB7IHRyYWNrczogdHJhY2tzIH0sXHJcbiAgICAgIGNvbXB1dGVQVFNEVFMgPSAodGhpcy5faW5pdFBUUyA9PT0gdW5kZWZpbmVkKSxcclxuICAgICAgaW5pdFBUUywgaW5pdERUUztcclxuXHJcbiAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xyXG4gICAgICBpbml0UFRTID0gaW5pdERUUyA9IEluZmluaXR5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhdWRpb1RyYWNrLmNvbmZpZyAmJiBhdWRpb1NhbXBsZXMubGVuZ3RoKSB7XHJcbiAgICAgIC8vIGxldCdzIHVzZSBhdWRpbyBzYW1wbGluZyByYXRlIGFzIE1QNCB0aW1lIHNjYWxlLlxyXG4gICAgICAvLyByYXRpb25hbGUgaXMgdGhhdCB0aGVyZSBpcyBhIGludGVnZXIgbmIgb2YgYXVkaW8gZnJhbWVzIHBlciBhdWRpbyBzYW1wbGUgKDEwMjQgZm9yIEFBQylcclxuICAgICAgLy8gdXNpbmcgYXVkaW8gc2FtcGxpbmcgcmF0ZSBoZXJlIGhlbHBzIGhhdmluZyBhbiBpbnRlZ2VyIE1QNCBmcmFtZSBkdXJhdGlvblxyXG4gICAgICAvLyB0aGlzIGF2b2lkcyBwb3RlbnRpYWwgcm91bmRpbmcgaXNzdWUgYW5kIEFWIHN5bmMgaXNzdWVcclxuICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSBhdWRpb1RyYWNrLnNhbXBsZXJhdGU7XHJcbiAgICAgIGxvZ2dlci5sb2coYGF1ZGlvIHNhbXBsaW5nIHJhdGUgOiAke2F1ZGlvVHJhY2suc2FtcGxlcmF0ZX1gKTtcclxuICAgICAgaWYgKCFhdWRpb1RyYWNrLmlzQUFDKSB7XHJcbiAgICAgICAgaWYgKHR5cGVTdXBwb3J0ZWQubXBlZykgeyAvLyBDaHJvbWUgYW5kIFNhZmFyaVxyXG4gICAgICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wZWcnO1xyXG4gICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICcnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZVN1cHBvcnRlZC5tcDMpIHsgLy8gRmlyZWZveFxyXG4gICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICdtcDMnO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0cmFja3MuYXVkaW8gPSB7XHJcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgICAgY29kZWM6IGF1ZGlvVHJhY2suY29kZWMsXHJcbiAgICAgICAgaW5pdFNlZ21lbnQ6ICFhdWRpb1RyYWNrLmlzQUFDICYmIHR5cGVTdXBwb3J0ZWQubXBlZyA/IG5ldyBVaW50OEFycmF5KCkgOiBNUDQuaW5pdFNlZ21lbnQoW2F1ZGlvVHJhY2tdKSxcclxuICAgICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgICAgY2hhbm5lbENvdW50OiBhdWRpb1RyYWNrLmNoYW5uZWxDb3VudFxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcclxuICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2YgdGhpcyBkZW11eGluZyBjb250ZXh0LiBmb3IgYXVkaW8sIFBUUyA9IERUU1xyXG4gICAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gYXVkaW9TYW1wbGVzWzBdLnB0cyAtIGF1ZGlvVHJhY2suaW5wdXRUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZpZGVvVHJhY2suc3BzICYmIHZpZGVvVHJhY2sucHBzICYmIHZpZGVvU2FtcGxlcy5sZW5ndGgpIHtcclxuICAgICAgLy8gbGV0J3MgdXNlIGlucHV0IHRpbWUgc2NhbGUgYXMgTVA0IHZpZGVvIHRpbWVzY2FsZVxyXG4gICAgICAvLyB3ZSB1c2UgaW5wdXQgdGltZSBzY2FsZSBzdHJhaWdodCBhd2F5IHRvIGF2b2lkIHJvdW5kaW5nIGlzc3VlcyBvbiBmcmFtZSBkdXJhdGlvbiAvIGN0cyBjb21wdXRhdGlvblxyXG4gICAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XHJcbiAgICAgIHZpZGVvVHJhY2sudGltZXNjYWxlID0gaW5wdXRUaW1lU2NhbGU7XHJcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcclxuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxyXG4gICAgICAgIGNvZGVjOiB2aWRlb1RyYWNrLmNvZGVjLFxyXG4gICAgICAgIGluaXRTZWdtZW50OiBNUDQuaW5pdFNlZ21lbnQoW3ZpZGVvVHJhY2tdKSxcclxuICAgICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgICAgd2lkdGg6IHZpZGVvVHJhY2sud2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IHZpZGVvVHJhY2suaGVpZ2h0XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xyXG4gICAgICAgIGluaXRQVFMgPSBNYXRoLm1pbihpbml0UFRTLCB2aWRlb1NhbXBsZXNbMF0ucHRzIC0gaW5wdXRUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0KTtcclxuICAgICAgICBpbml0RFRTID0gTWF0aC5taW4oaW5pdERUUywgdmlkZW9TYW1wbGVzWzBdLmR0cyAtIGlucHV0VGltZVNjYWxlICogdGltZU9mZnNldCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCB7IGluaXRQVFM6IGluaXRQVFMgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoT2JqZWN0LmtleXModHJhY2tzKS5sZW5ndGgpIHtcclxuICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBkYXRhKTtcclxuICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IHRydWU7XHJcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IGluaXRQVFM7XHJcbiAgICAgICAgdGhpcy5faW5pdERUUyA9IGluaXREVFM7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdubyBhdWRpby92aWRlbyBzYW1wbGVzIGZvdW5kJyB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJlbXV4VmlkZW8gKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcclxuICAgIGxldCBvZmZzZXQgPSA4O1xyXG4gICAgbGV0IG1wNFNhbXBsZUR1cmF0aW9uO1xyXG4gICAgbGV0IG1kYXQ7XHJcbiAgICBsZXQgbW9vZjtcclxuICAgIGxldCBmaXJzdFBUUztcclxuICAgIGxldCBmaXJzdERUUztcclxuICAgIGxldCBsYXN0UFRTO1xyXG4gICAgbGV0IGxhc3REVFM7XHJcbiAgICBjb25zdCB0aW1lU2NhbGUgPSB0cmFjay50aW1lc2NhbGU7XHJcbiAgICBjb25zdCBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xyXG4gICAgY29uc3Qgb3V0cHV0U2FtcGxlcyA9IFtdO1xyXG4gICAgY29uc3QgbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDtcclxuICAgIGNvbnN0IHB0c05vcm1hbGl6ZSA9IHRoaXMuX1BUU05vcm1hbGl6ZTtcclxuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xyXG5cclxuICAgIC8vIGlmIHBhcnNlZCBmcmFnbWVudCBpcyBjb250aWd1b3VzIHdpdGggbGFzdCBvbmUsIGxldCdzIHVzZSBsYXN0IERUUyB2YWx1ZSBhcyByZWZlcmVuY2VcclxuICAgIGxldCBuZXh0QXZjRHRzID0gdGhpcy5uZXh0QXZjRHRzO1xyXG5cclxuICAgIGNvbnN0IGlzU2FmYXJpID0gdGhpcy5pc1NhZmFyaTtcclxuXHJcbiAgICBpZiAobmJTYW1wbGVzID09PSAwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTYWZhcmkgZG9lcyBub3QgbGlrZSBvdmVybGFwcGluZyBEVFMgb24gY29uc2VjdXRpdmUgZnJhZ21lbnRzLiBsZXQncyB1c2UgbmV4dEF2Y0R0cyB0byBvdmVyY29tZSB0aGlzIGlmIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmVcclxuICAgIGlmIChpc1NhZmFyaSkge1xyXG4gICAgICAvLyBhbHNvIGNvbnNpZGVyIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcyBiZWluZyBjb250aWd1b3VzIChldmVuIGlmIGEgbGV2ZWwgc3dpdGNoIG9jY3VycyksXHJcbiAgICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XHJcbiAgICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aFxyXG4gICAgICAvLyAgLSBsZXNzIHRoYW4gMTAwbXMgZ2FwcyBiZXR3ZWVuIG5ldyB0aW1lIG9mZnNldCAoaWYgYWNjdXJhdGUpIGFuZCBuZXh0IGV4cGVjdGVkIFBUUyBPUlxyXG4gICAgICAvLyAgLSBsZXNzIHRoYW4gMjAwIG1zIFBUUyBnYXBzICh0aW1lU2NhbGUvNSlcclxuICAgICAgY29udGlndW91cyB8PSAoaW5wdXRTYW1wbGVzLmxlbmd0aCAmJiBuZXh0QXZjRHRzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICgoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmIE1hdGguYWJzKHRpbWVPZmZzZXQgLSBuZXh0QXZjRHRzIC8gdGltZVNjYWxlKSA8IDAuMSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKChpbnB1dFNhbXBsZXNbMF0ucHRzIC0gbmV4dEF2Y0R0cyAtIGluaXRQVFMpKSA8IHRpbWVTY2FsZSAvIDUpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb250aWd1b3VzKSB7XHJcbiAgICAgIC8vIGlmIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGFyZ2V0IHRpbWVPZmZzZXRcclxuICAgICAgbmV4dEF2Y0R0cyA9IHRpbWVPZmZzZXQgKiB0aW1lU2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUFRTIGlzIGNvZGVkIG9uIDMzYml0cywgYW5kIGNhbiBsb29wIGZyb20gLTJeMzIgdG8gMl4zMlxyXG4gICAgLy8gcHRzTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxyXG4gICAgaW5wdXRTYW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKHNhbXBsZSkge1xyXG4gICAgICBzYW1wbGUucHRzID0gcHRzTm9ybWFsaXplKHNhbXBsZS5wdHMgLSBpbml0UFRTLCBuZXh0QXZjRHRzKTtcclxuICAgICAgc2FtcGxlLmR0cyA9IHB0c05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gaW5pdFBUUywgbmV4dEF2Y0R0cyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBzb3J0IHZpZGVvIHNhbXBsZXMgYnkgRFRTIHRoZW4gUFRTIHRoZW4gZGVtdXggaWQgb3JkZXJcclxuICAgIGlucHV0U2FtcGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIGNvbnN0IGRlbHRhZHRzID0gYS5kdHMgLSBiLmR0cztcclxuICAgICAgY29uc3QgZGVsdGFwdHMgPSBhLnB0cyAtIGIucHRzO1xyXG4gICAgICByZXR1cm4gZGVsdGFkdHMgfHwgKGRlbHRhcHRzIHx8IChhLmlkIC0gYi5pZCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gaGFuZGxlIGJyb2tlbiBzdHJlYW1zIHdpdGggUFRTIDwgRFRTLCB0b2xlcmFuY2UgdXAgMC4yIHNlY29uZHNcclxuICAgIGxldCBQVFNEVFNzaGlmdCA9IGlucHV0U2FtcGxlcy5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IE1hdGgubWF4KE1hdGgubWluKHByZXYsIGN1cnIucHRzIC0gY3Vyci5kdHMpLCAtMSAqIFBUU19EVFNfU0hJRlRfVE9MRVJBTkNFXzkwS0haKSwgMCk7XHJcbiAgICBpZiAoUFRTRFRTc2hpZnQgPCAwKSB7XHJcbiAgICAgIGxvZ2dlci53YXJuKGBQVFMgPCBEVFMgZGV0ZWN0ZWQgaW4gdmlkZW8gc2FtcGxlcywgc2hpZnRpbmcgRFRTIGJ5ICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhQVFNEVFNzaGlmdCwgdHJ1ZSl9IG1zIHRvIG92ZXJjb21lIHRoaXMgaXNzdWVgKTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpbnB1dFNhbXBsZXNbaV0uZHRzICs9IFBUU0RUU3NoaWZ0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29tcHV0ZSBmaXJzdCBEVFMgYW5kIGxhc3QgRFRTLCBub3JtYWxpemUgdGhlbSBhZ2FpbnN0IHJlZmVyZW5jZSB2YWx1ZVxyXG4gICAgbGV0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1swXTtcclxuICAgIGZpcnN0RFRTID0gTWF0aC5tYXgoc2FtcGxlLmR0cywgMCk7XHJcbiAgICBmaXJzdFBUUyA9IE1hdGgubWF4KHNhbXBsZS5wdHMsIDApO1xyXG5cclxuICAgIC8vIGNoZWNrIHRpbWVzdGFtcCBjb250aW51aXR5IGFjY3Jvc3MgY29uc2VjdXRpdmUgZnJhZ21lbnRzICh0aGlzIGlzIHRvIHJlbW92ZSBpbnRlci1mcmFnbWVudCBnYXAvaG9sZSlcclxuICAgIGxldCBkZWx0YSA9IGZpcnN0RFRTIC0gbmV4dEF2Y0R0cztcclxuICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xyXG4gICAgaWYgKGNvbnRpZ3VvdXMpIHtcclxuICAgICAgaWYgKGRlbHRhKSB7XHJcbiAgICAgICAgaWYgKGRlbHRhID4gMSkge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgQVZDOiAke3RvTXNGcm9tTXBlZ1RzQ2xvY2soZGVsdGEsIHRydWUpfSBtcyBob2xlIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkLGZpbGxpbmcgaXRgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRlbHRhIDwgLTEpIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coYEFWQzogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKC1kZWx0YSwgdHJ1ZSl9IG1zIG92ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZW1vdmUgaG9sZS9nYXAgOiBzZXQgRFRTIHRvIG5leHQgZXhwZWN0ZWQgRFRTXHJcbiAgICAgICAgZmlyc3REVFMgPSBuZXh0QXZjRHRzO1xyXG4gICAgICAgIGlucHV0U2FtcGxlc1swXS5kdHMgPSBmaXJzdERUUztcclxuICAgICAgICAvLyBvZmZzZXQgUFRTIGFzIHdlbGwsIGVuc3VyZSB0aGF0IFBUUyBpcyBzbWFsbGVyIG9yIGVxdWFsIHRoYW4gbmV3IERUU1xyXG4gICAgICAgIGZpcnN0UFRTID0gTWF0aC5tYXgoZmlyc3RQVFMgLSBkZWx0YSwgbmV4dEF2Y0R0cyk7XHJcbiAgICAgICAgaW5wdXRTYW1wbGVzWzBdLnB0cyA9IGZpcnN0UFRTO1xyXG4gICAgICAgIGxvZ2dlci5sb2coYFZpZGVvOiBQVFMvRFRTIGFkanVzdGVkOiAke3RvTXNGcm9tTXBlZ1RzQ2xvY2soZmlyc3RQVFMsIHRydWUpfS8ke3RvTXNGcm9tTXBlZ1RzQ2xvY2soZmlyc3REVFMsIHRydWUpfSwgZGVsdGE6ICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhkZWx0YSwgdHJ1ZSl9IG1zYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBjb21wdXRlIGxhc3RQVFMvbGFzdERUU1xyXG4gICAgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2lucHV0U2FtcGxlcy5sZW5ndGggLSAxXTtcclxuICAgIGxhc3REVFMgPSBNYXRoLm1heChzYW1wbGUuZHRzLCAwKTtcclxuICAgIGxhc3RQVFMgPSBNYXRoLm1heChzYW1wbGUucHRzLCAwLCBsYXN0RFRTKTtcclxuXHJcbiAgICAvLyBvbiBTYWZhcmkgbGV0J3Mgc2lnbmFsIHRoZSBzYW1lIHNhbXBsZSBkdXJhdGlvbiBmb3IgYWxsIHNhbXBsZXNcclxuICAgIC8vIHNhbXBsZSBkdXJhdGlvbiAoYXMgZXhwZWN0ZWQgYnkgdHJ1biBNUDQgYm94ZXMpLCBzaG91bGQgYmUgdGhlIGRlbHRhIGJldHdlZW4gc2FtcGxlIERUU1xyXG4gICAgLy8gc2V0IHRoaXMgY29uc3RhbnQgZHVyYXRpb24gYXMgYmVpbmcgdGhlIGF2ZyBkZWx0YSBiZXR3ZWVuIGNvbnNlY3V0aXZlIERUUy5cclxuICAgIGlmIChpc1NhZmFyaSkge1xyXG4gICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IE1hdGgucm91bmQoKGxhc3REVFMgLSBmaXJzdERUUykgLyAoaW5wdXRTYW1wbGVzLmxlbmd0aCAtIDEpKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbmJOYWx1ID0gMCwgbmFsdUxlbiA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XHJcbiAgICAgIC8vIGNvbXB1dGUgdG90YWwvYXZjIHNhbXBsZSBsZW5ndGggYW5kIG5iIG9mIE5BTCB1bml0c1xyXG4gICAgICBsZXQgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldLCB1bml0cyA9IHNhbXBsZS51bml0cywgbmJVbml0cyA9IHVuaXRzLmxlbmd0aCwgc2FtcGxlTGVuID0gMDtcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuYlVuaXRzOyBqKyspIHtcclxuICAgICAgICBzYW1wbGVMZW4gKz0gdW5pdHNbal0uZGF0YS5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5hbHVMZW4gKz0gc2FtcGxlTGVuO1xyXG4gICAgICBuYk5hbHUgKz0gbmJVbml0cztcclxuICAgICAgc2FtcGxlLmxlbmd0aCA9IHNhbXBsZUxlbjtcclxuXHJcbiAgICAgIC8vIG5vcm1hbGl6ZSBQVFMvRFRTXHJcbiAgICAgIGlmIChpc1NhZmFyaSkge1xyXG4gICAgICAgIC8vIHNhbXBsZSBEVFMgaXMgY29tcHV0ZWQgdXNpbmcgYSBjb25zdGFudCBkZWNvZGluZyBvZmZzZXQgKG1wNFNhbXBsZUR1cmF0aW9uKSBiZXR3ZWVuIHNhbXBsZXNcclxuICAgICAgICBzYW1wbGUuZHRzID0gZmlyc3REVFMgKyBpICogbXA0U2FtcGxlRHVyYXRpb247XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZW5zdXJlIHNhbXBsZSBtb25vdG9uaWMgRFRTXHJcbiAgICAgICAgc2FtcGxlLmR0cyA9IE1hdGgubWF4KHNhbXBsZS5kdHMsIGZpcnN0RFRTKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBlbnN1cmUgdGhhdCBjb21wdXRlZCB2YWx1ZSBpcyBncmVhdGVyIG9yIGVxdWFsIHRoYW4gc2FtcGxlIERUU1xyXG4gICAgICBzYW1wbGUucHRzID0gTWF0aC5tYXgoc2FtcGxlLnB0cywgc2FtcGxlLmR0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyogY29uY2F0ZW5hdGUgdGhlIHZpZGVvIGRhdGEgYW5kIGNvbnN0cnVjdCB0aGUgbWRhdCBpbiBwbGFjZVxyXG4gICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1wZGF0IHR5cGUpICovXHJcbiAgICBsZXQgbWRhdFNpemUgPSBuYWx1TGVuICsgKDQgKiBuYk5hbHUpICsgODtcclxuICAgIHRyeSB7XHJcbiAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTVVYX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnl0ZXM6IG1kYXRTaXplLCByZWFzb246IGBmYWlsIGFsbG9jYXRpbmcgdmlkZW8gbWRhdCAke21kYXRTaXplfWAgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcclxuICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcclxuICAgIG1kYXQuc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XHJcbiAgICAgIGxldCBhdmNTYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV0sXHJcbiAgICAgICAgYXZjU2FtcGxlVW5pdHMgPSBhdmNTYW1wbGUudW5pdHMsXHJcbiAgICAgICAgbXA0U2FtcGxlTGVuZ3RoID0gMCxcclxuICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQ7XHJcbiAgICAgIC8vIGNvbnZlcnQgTkFMVSBiaXRzdHJlYW0gdG8gTVA0IGZvcm1hdCAocHJlcGVuZCBOQUxVIHdpdGggc2l6ZSBmaWVsZClcclxuICAgICAgZm9yIChsZXQgaiA9IDAsIG5iVW5pdHMgPSBhdmNTYW1wbGVVbml0cy5sZW5ndGg7IGogPCBuYlVuaXRzOyBqKyspIHtcclxuICAgICAgICBsZXQgdW5pdCA9IGF2Y1NhbXBsZVVuaXRzW2pdLFxyXG4gICAgICAgICAgdW5pdERhdGEgPSB1bml0LmRhdGEsXHJcbiAgICAgICAgICB1bml0RGF0YUxlbiA9IHVuaXQuZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgdW5pdERhdGFMZW4pO1xyXG4gICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgIG1kYXQuc2V0KHVuaXREYXRhLCBvZmZzZXQpO1xyXG4gICAgICAgIG9mZnNldCArPSB1bml0RGF0YUxlbjtcclxuICAgICAgICBtcDRTYW1wbGVMZW5ndGggKz0gNCArIHVuaXREYXRhTGVuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWlzU2FmYXJpKSB7XHJcbiAgICAgICAgLy8gZXhwZWN0ZWQgc2FtcGxlIGR1cmF0aW9uIGlzIHRoZSBEZWNvZGluZyBUaW1lc3RhbXAgZGlmZiBvZiBjb25zZWN1dGl2ZSBzYW1wbGVzXHJcbiAgICAgICAgaWYgKGkgPCBuYlNhbXBsZXMgLSAxKSB7XHJcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGlucHV0U2FtcGxlc1tpICsgMV0uZHRzIC0gYXZjU2FtcGxlLmR0cztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnLFxyXG4gICAgICAgICAgICBsYXN0RnJhbWVEdXJhdGlvbiA9IGF2Y1NhbXBsZS5kdHMgLSBpbnB1dFNhbXBsZXNbaSA+IDAgPyBpIC0gMSA6IGldLmR0cztcclxuICAgICAgICAgIGlmIChjb25maWcuc3RyZXRjaFNob3J0VmlkZW9UcmFjaykge1xyXG4gICAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cclxuICAgICAgICAgICAgLy8gU2luY2Ugd2UndmUgYWxyZWFkeSByZW11eGVkIGF1ZGlvLCBhbmQgd2Uga25vdyBob3cgbG9uZyB0aGUgYXVkaW8gdHJhY2sgaXMsIHdlIGxvb2sgdG9cclxuICAgICAgICAgICAgLy8gc2VlIGlmIHRoZSBkZWx0YSB0byB0aGUgbmV4dCBzZWdtZW50IGlzIGxvbmdlciB0aGFuIG1heEJ1ZmZlckhvbGUuXHJcbiAgICAgICAgICAgIC8vIElmIHNvLCBwbGF5YmFjayB3b3VsZCBwb3RlbnRpYWxseSBnZXQgc3R1Y2ssIHNvIHdlIGFydGlmaWNpYWxseSBpbmZsYXRlXHJcbiAgICAgICAgICAgIC8vIHRoZSBkdXJhdGlvbiBvZiB0aGUgbGFzdCBmcmFtZSB0byBtaW5pbWl6ZSBhbnkgcG90ZW50aWFsIGdhcCBiZXR3ZWVuIHNlZ21lbnRzLlxyXG4gICAgICAgICAgICBsZXQgbWF4QnVmZmVySG9sZSA9IGNvbmZpZy5tYXhCdWZmZXJIb2xlLFxyXG4gICAgICAgICAgICAgIGdhcFRvbGVyYW5jZSA9IE1hdGguZmxvb3IobWF4QnVmZmVySG9sZSAqIHRpbWVTY2FsZSksXHJcbiAgICAgICAgICAgICAgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBmaXJzdFBUUyArIGF1ZGlvVHJhY2tMZW5ndGggKiB0aW1lU2NhbGUgOiB0aGlzLm5leHRBdWRpb1B0cykgLSBhdmNTYW1wbGUucHRzO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XHJcbiAgICAgICAgICAgICAgLy8gV2Ugc3VidHJhY3QgbGFzdEZyYW1lRHVyYXRpb24gZnJvbSBkZWx0YVRvRnJhbWVFbmQgdG8gdHJ5IHRvIHByZXZlbnQgYW55IHZpZGVvXHJcbiAgICAgICAgICAgICAgLy8gZnJhbWUgb3ZlcmxhcC4gbWF4QnVmZmVySG9sZSBzaG91bGQgYmUgPj4gbGFzdEZyYW1lRHVyYXRpb24gYW55d2F5LlxyXG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XHJcbiAgICAgICAgICAgICAgaWYgKG1wNFNhbXBsZUR1cmF0aW9uIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYEl0IGlzIGFwcHJveGltYXRlbHkgJHt0b01zRnJvbU1wZWdUc0Nsb2NrKGRlbHRhVG9GcmFtZUVuZCwgZmFsc2UpfSBtcyB0byB0aGUgbmV4dCBzZWdtZW50OyB1c2luZyBkdXJhdGlvbiAke3RvTXNGcm9tTXBlZ1RzQ2xvY2sobXA0U2FtcGxlRHVyYXRpb24sIGZhbHNlKX0gbXMgZm9yIHRoZSBsYXN0IHZpZGVvIGZyYW1lLmApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgucm91bmQoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgubWF4KDAsIG1wNFNhbXBsZUR1cmF0aW9uICogTWF0aC5yb3VuZCgoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpIC8gbXA0U2FtcGxlRHVyYXRpb24pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY29uc29sZS5sb2coJ1BUUy9EVFMvaW5pdERUUy9ub3JtUFRTL25vcm1EVFMvcmVsYXRpdmUgUFRTIDogJHthdmNTYW1wbGUucHRzfS8ke2F2Y1NhbXBsZS5kdHN9LyR7aW5pdERUU30vJHtwdHNub3JtfS8ke2R0c25vcm19LyR7KGF2Y1NhbXBsZS5wdHMvNDI5NDk2NzI5NikudG9GaXhlZCgzKX0nKTtcclxuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKHtcclxuICAgICAgICBzaXplOiBtcDRTYW1wbGVMZW5ndGgsXHJcbiAgICAgICAgLy8gY29uc3RhbnQgZHVyYXRpb25cclxuICAgICAgICBkdXJhdGlvbjogbXA0U2FtcGxlRHVyYXRpb24sXHJcbiAgICAgICAgY3RzOiBjb21wb3NpdGlvblRpbWVPZmZzZXQsXHJcbiAgICAgICAgZmxhZ3M6IHtcclxuICAgICAgICAgIGlzTGVhZGluZzogMCxcclxuICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcclxuICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXHJcbiAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxyXG4gICAgICAgICAgZGVwZW5kc09uOiBhdmNTYW1wbGUua2V5ID8gMiA6IDEsXHJcbiAgICAgICAgICBpc05vblN5bmM6IGF2Y1NhbXBsZS5rZXkgPyAwIDogMVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBuZXh0IEFWQyBzYW1wbGUgRFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBEVFMgKyBsYXN0IHNhbXBsZSBkdXJhdGlvbiAoaW4gUEVTIHRpbWVzY2FsZSlcclxuICAgIHRoaXMubmV4dEF2Y0R0cyA9IGxhc3REVFMgKyBtcDRTYW1wbGVEdXJhdGlvbjtcclxuICAgIGxldCBkcm9wcGVkID0gdHJhY2suZHJvcHBlZDtcclxuICAgIHRyYWNrLm5iTmFsdSA9IDA7XHJcbiAgICB0cmFjay5kcm9wcGVkID0gMDtcclxuICAgIGlmIChvdXRwdXRTYW1wbGVzLmxlbmd0aCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2hyb21lJykgPiAtMSkge1xyXG4gICAgICBsZXQgZmxhZ3MgPSBvdXRwdXRTYW1wbGVzWzBdLmZsYWdzO1xyXG4gICAgICAvLyBjaHJvbWUgd29ya2Fyb3VuZCwgbWFyayBmaXJzdCBzYW1wbGUgYXMgYmVpbmcgYSBSYW5kb20gQWNjZXNzIFBvaW50IHRvIGF2b2lkIHNvdXJjZWJ1ZmZlciBhcHBlbmQgaXNzdWVcclxuICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTQxMlxyXG4gICAgICBmbGFncy5kZXBlbmRzT24gPSAyO1xyXG4gICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xyXG4gICAgfVxyXG4gICAgdHJhY2suc2FtcGxlcyA9IG91dHB1dFNhbXBsZXM7XHJcbiAgICBtb29mID0gTVA0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3REVFMsIHRyYWNrKTtcclxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcclxuXHJcbiAgICBsZXQgZGF0YSA9IHtcclxuICAgICAgZGF0YTE6IG1vb2YsXHJcbiAgICAgIGRhdGEyOiBtZGF0LFxyXG4gICAgICBzdGFydFBUUzogZmlyc3RQVFMgLyB0aW1lU2NhbGUsXHJcbiAgICAgIGVuZFBUUzogKGxhc3RQVFMgKyBtcDRTYW1wbGVEdXJhdGlvbikgLyB0aW1lU2NhbGUsXHJcbiAgICAgIHN0YXJ0RFRTOiBmaXJzdERUUyAvIHRpbWVTY2FsZSxcclxuICAgICAgZW5kRFRTOiB0aGlzLm5leHRBdmNEdHMgLyB0aW1lU2NhbGUsXHJcbiAgICAgIHR5cGU6ICd2aWRlbycsXHJcbiAgICAgIGhhc0F1ZGlvOiBmYWxzZSxcclxuICAgICAgaGFzVmlkZW86IHRydWUsXHJcbiAgICAgIG5iOiBvdXRwdXRTYW1wbGVzLmxlbmd0aCxcclxuICAgICAgZHJvcHBlZDogZHJvcHBlZFxyXG4gICAgfTtcclxuICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwgZGF0YSk7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcblxyXG4gIHJlbXV4QXVkaW8gKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcclxuICAgIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XHJcbiAgICBjb25zdCBtcDR0aW1lU2NhbGUgPSB0cmFjay50aW1lc2NhbGU7XHJcbiAgICBjb25zdCBzY2FsZUZhY3RvciA9IGlucHV0VGltZVNjYWxlIC8gbXA0dGltZVNjYWxlO1xyXG4gICAgY29uc3QgbXA0U2FtcGxlRHVyYXRpb24gPSB0cmFjay5pc0FBQyA/IDEwMjQgOiAxMTUyO1xyXG4gICAgY29uc3QgaW5wdXRTYW1wbGVEdXJhdGlvbiA9IG1wNFNhbXBsZUR1cmF0aW9uICogc2NhbGVGYWN0b3I7XHJcbiAgICBjb25zdCBwdHNOb3JtYWxpemUgPSB0aGlzLl9QVFNOb3JtYWxpemU7XHJcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcclxuICAgIGNvbnN0IHJhd01QRUcgPSAhdHJhY2suaXNBQUMgJiYgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWc7XHJcblxyXG4gICAgbGV0IG1wNFNhbXBsZTtcclxuICAgIGxldCBmaWxsRnJhbWU7XHJcbiAgICBsZXQgbWRhdDtcclxuICAgIGxldCBtb29mO1xyXG4gICAgbGV0IGZpcnN0UFRTO1xyXG4gICAgbGV0IGxhc3RQVFM7XHJcbiAgICBsZXQgb2Zmc2V0ID0gKHJhd01QRUcgPyAwIDogOCk7XHJcbiAgICBsZXQgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcztcclxuICAgIGxldCBvdXRwdXRTYW1wbGVzID0gW107XHJcbiAgICBsZXQgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHM7XHJcblxyXG4gICAgLy8gZm9yIGF1ZGlvIHNhbXBsZXMsIGFsc28gY29uc2lkZXIgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFzIGJlaW5nIGNvbnRpZ3VvdXMgKGV2ZW4gaWYgYSBsZXZlbCBzd2l0Y2ggb2NjdXJzKSxcclxuICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XHJcbiAgICAvLyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXJlIGZyYWdzIHdpdGhcclxuICAgIC8vICAtIGxlc3MgdGhhbiAxMDBtcyBnYXBzIGJldHdlZW4gbmV3IHRpbWUgb2Zmc2V0IChpZiBhY2N1cmF0ZSkgYW5kIG5leHQgZXhwZWN0ZWQgUFRTIE9SXHJcbiAgICAvLyAgLSBsZXNzIHRoYW4gMjAgYXVkaW8gZnJhbWVzIGRpc3RhbmNlXHJcbiAgICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxyXG4gICAgLy8gdGhpcyBoZWxwcyBlbnN1cmluZyBhdWRpbyBjb250aW51aXR5XHJcbiAgICAvLyBhbmQgdGhpcyBhbHNvIGF2b2lkcyBhdWRpbyBnbGl0Y2hlcy9jdXQgd2hlbiBzd2l0Y2hpbmcgcXVhbGl0eSwgb3IgcmVwb3J0aW5nIHdyb25nIGR1cmF0aW9uIG9uIGZpcnN0IGF1ZGlvIGZyYW1lXHJcbiAgICBjb250aWd1b3VzIHw9IChpbnB1dFNhbXBsZXMubGVuZ3RoICYmIG5leHRBdWRpb1B0cyAmJlxyXG4gICAgICAgICAgICAgICAgICAgKChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgTWF0aC5hYnModGltZU9mZnNldCAtIG5leHRBdWRpb1B0cyAvIGlucHV0VGltZVNjYWxlKSA8IDAuMSkgfHxcclxuICAgICAgICAgICAgICAgICAgICBNYXRoLmFicygoaW5wdXRTYW1wbGVzWzBdLnB0cyAtIG5leHRBdWRpb1B0cyAtIGluaXRQVFMpKSA8IDIwICogaW5wdXRTYW1wbGVEdXJhdGlvbilcclxuICAgICk7XHJcblxyXG4gICAgLy8gY29tcHV0ZSBub3JtYWxpemVkIFBUU1xyXG4gICAgaW5wdXRTYW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKHNhbXBsZSkge1xyXG4gICAgICBzYW1wbGUucHRzID0gc2FtcGxlLmR0cyA9IHB0c05vcm1hbGl6ZShzYW1wbGUucHRzIC0gaW5pdFBUUywgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGZpbHRlciBvdXQgc2FtcGxlIHdpdGggbmVnYXRpdmUgUFRTIHRoYXQgYXJlIG5vdCBwbGF5YWJsZSBhbnl3YXlcclxuICAgIC8vIGlmIHdlIGRvbid0IHJlbW92ZSB0aGVzZSBuZWdhdGl2ZSBzYW1wbGVzLCB0aGV5IHdpbGwgc2hpZnQgYWxsIGF1ZGlvIHNhbXBsZXMgZm9yd2FyZC5cclxuICAgIC8vIGxlYWRpbmcgdG8gYXVkaW8gb3ZlcmxhcCBiZXR3ZWVuIGN1cnJlbnQgLyBuZXh0IGZyYWdtZW50XHJcbiAgICBpbnB1dFNhbXBsZXMgPSBpbnB1dFNhbXBsZXMuZmlsdGVyKGZ1bmN0aW9uIChzYW1wbGUpIHtcclxuICAgICAgcmV0dXJuIHNhbXBsZS5wdHMgPj0gMDtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGluIGNhc2UgYWxsIHNhbXBsZXMgaGF2ZSBuZWdhdGl2ZSBQVFMsIGFuZCBoYXZlIGJlZW4gZmlsdGVyZWQgb3V0LCByZXR1cm4gbm93XHJcbiAgICBpZiAoaW5wdXRTYW1wbGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb250aWd1b3VzKSB7XHJcbiAgICAgIGlmICghYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XHJcbiAgICAgICAgLy8gaWYgZnJhZyBhcmUgbW90IGNvbnRpZ3VvdXMgYW5kIGlmIHdlIGNhbnQgdHJ1c3QgdGltZSBvZmZzZXQsIGxldCdzIHVzZSBmaXJzdCBzYW1wbGUgUFRTIGFzIG5leHQgYXVkaW8gUFRTXHJcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gaW5wdXRTYW1wbGVzWzBdLnB0cztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBpZiB0aW1lT2Zmc2V0IGlzIGFjY3VyYXRlLCBsZXQncyB1c2UgaXQgYXMgcHJlZGljdGVkIG5leHQgYXVkaW8gUFRTXHJcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIGF1ZGlvIHRyYWNrIGlzIG1pc3Npbmcgc2FtcGxlcywgdGhlIGZyYW1lcyBzZWVtIHRvIGdldCBcImxlZnQtc2hpZnRlZFwiIHdpdGhpbiB0aGVcclxuICAgIC8vIHJlc3VsdGluZyBtcDQgc2VnbWVudCwgY2F1c2luZyBzeW5jIGlzc3VlcyBhbmQgbGVhdmluZyBnYXBzIGF0IHRoZSBlbmQgb2YgdGhlIGF1ZGlvIHNlZ21lbnQuXHJcbiAgICAvLyBJbiBhbiBlZmZvcnQgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nLCB3ZSBpbmplY3QgZnJhbWVzIGhlcmUgd2hlcmUgdGhlcmUgYXJlIGdhcHMuXHJcbiAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBpbmplY3QgYSBzaWxlbnQgZnJhbWU7IHdoZW4gdGhhdCdzIG5vdCBwb3NzaWJsZSwgd2UgZHVwbGljYXRlIHRoZSBsYXN0XHJcbiAgICAvLyBmcmFtZS5cclxuXHJcbiAgICBpZiAodHJhY2suaXNBQUMpIHtcclxuICAgICAgY29uc3QgbWF4QXVkaW9GcmFtZXNEcmlmdCA9IHRoaXMuY29uZmlnLm1heEF1ZGlvRnJhbWVzRHJpZnQ7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwLCBuZXh0UHRzID0gbmV4dEF1ZGlvUHRzOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDspIHtcclxuICAgICAgICAvLyBGaXJzdCwgbGV0J3Mgc2VlIGhvdyBmYXIgb2ZmIHRoaXMgZnJhbWUgaXMgZnJvbSB3aGVyZSB3ZSBleHBlY3QgaXQgdG8gYmVcclxuICAgICAgICB2YXIgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldLCBkZWx0YTtcclxuICAgICAgICBsZXQgcHRzID0gc2FtcGxlLnB0cztcclxuICAgICAgICBkZWx0YSA9IHB0cyAtIG5leHRQdHM7XHJcblxyXG4gICAgICAgIC8vIElmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBhIGR1cmF0aW9uLCBkcm9wIHRoaXMgc2FtcGxlXHJcbiAgICAgICAgaWYgKGRlbHRhIDw9IC1tYXhBdWRpb0ZyYW1lc0RyaWZ0ICogaW5wdXRTYW1wbGVEdXJhdGlvbikge1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYERyb3BwaW5nIDEgYXVkaW8gZnJhbWUgQCAke3RvTXNGcm9tTXBlZ1RzQ2xvY2sobmV4dFB0cywgdHJ1ZSl9IG1zIGR1ZSB0byAke3RvTXNGcm9tTXBlZ1RzQ2xvY2soZGVsdGEsIHRydWUpfSBtcyBvdmVybGFwLmApO1xyXG4gICAgICAgICAgaW5wdXRTYW1wbGVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgIC8vIERvbid0IHRvdWNoIG5leHRQdHNOb3JtIG9yIGlcclxuICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcclxuXHJcbiAgICAgICAgLy8gSW5zZXJ0IG1pc3NpbmcgZnJhbWVzIGlmOlxyXG4gICAgICAgIC8vIDE6IFdlJ3JlIG1vcmUgdGhhbiBtYXhBdWRpb0ZyYW1lc0RyaWZ0IGZyYW1lIGF3YXlcclxuICAgICAgICAvLyAyOiBOb3QgbW9yZSB0aGFuIE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gYXdheVxyXG4gICAgICAgIC8vIDM6IGN1cnJlbnRUaW1lIChha2EgbmV4dFB0c05vcm0pIGlzIG5vdCAwXHJcbiAgICAgICAgZWxzZSBpZiAoZGVsdGEgPj0gbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiYgZGVsdGEgPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OXzkwS0haICYmIG5leHRQdHMpIHtcclxuICAgICAgICAgIGxldCBtaXNzaW5nID0gTWF0aC5yb3VuZChkZWx0YSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEluamVjdGluZyAke21pc3Npbmd9IGF1ZGlvIGZyYW1lcyBAICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhuZXh0UHRzLCB0cnVlKX0gbXMgZHVlIHRvICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhuZXh0UHRzLCB0cnVlKX0gbXMgZ2FwLmApO1xyXG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcclxuICAgICAgICAgICAgbGV0IG5ld1N0YW1wID0gTWF0aC5tYXgobmV4dFB0cywgMCk7XHJcbiAgICAgICAgICAgIGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xyXG4gICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xyXG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgbGFzdCBmcmFtZSBpbnN0ZWFkLicpO1xyXG4gICAgICAgICAgICAgIGZpbGxGcmFtZSA9IHNhbXBsZS51bml0LnN1YmFycmF5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5wdXRTYW1wbGVzLnNwbGljZShpLCAwLCB7IHVuaXQ6IGZpbGxGcmFtZSwgcHRzOiBuZXdTdGFtcCwgZHRzOiBuZXdTdGFtcCB9KTtcclxuICAgICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQWRqdXN0IHNhbXBsZSB0byBuZXh0IGV4cGVjdGVkIHB0c1xyXG4gICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBuZXh0UHRzO1xyXG4gICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xyXG4gICAgICAgICAgaSsrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGp1c3QgYWRqdXN0IHB0c1xyXG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+ICgwLjEgKiBpbnB1dFNhbXBsZUR1cmF0aW9uKSkge1xyXG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKGBJbnZhbGlkIGZyYW1lIGRlbHRhICR7TWF0aC5yb3VuZChkZWx0YSArIGlucHV0U2FtcGxlRHVyYXRpb24pfSBhdCBQVFMgJHtNYXRoLnJvdW5kKHB0cyAvIDkwKX0gKHNob3VsZCBiZSAke01hdGgucm91bmQoaW5wdXRTYW1wbGVEdXJhdGlvbil9KS5gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gbmV4dFB0cztcclxuICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcclxuICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBjb21wdXRlIG1kYXQgc2l6ZSwgYXMgd2UgZXZlbnR1YWxseSBmaWx0ZXJlZC9hZGRlZCBzb21lIHNhbXBsZXNcclxuICAgIGxldCBuYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoO1xyXG4gICAgbGV0IG1kYXRTaXplID0gMDtcclxuICAgIHdoaWxlIChuYlNhbXBsZXMtLSkge1xyXG4gICAgICBtZGF0U2l6ZSArPSBpbnB1dFNhbXBsZXNbbmJTYW1wbGVzXS51bml0LmJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaiA9IDAsIG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7IGogPCBuYlNhbXBsZXM7IGorKykge1xyXG4gICAgICBsZXQgYXVkaW9TYW1wbGUgPSBpbnB1dFNhbXBsZXNbal07XHJcbiAgICAgIGxldCB1bml0ID0gYXVkaW9TYW1wbGUudW5pdDtcclxuICAgICAgbGV0IHB0cyA9IGF1ZGlvU2FtcGxlLnB0cztcclxuXHJcbiAgICAgIC8vIGxvZ2dlci5sb2coYEF1ZGlvL1BUUzoke3RvTXNGcm9tTXBlZ1RzQ2xvY2socHRzLCB0cnVlKX1gKTtcclxuICAgICAgLy8gaWYgbm90IGZpcnN0IHNhbXBsZVxyXG5cclxuICAgICAgaWYgKGxhc3RQVFMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG1wNFNhbXBsZS5kdXJhdGlvbiA9IE1hdGgucm91bmQoKHB0cyAtIGxhc3RQVFMpIC8gc2NhbGVGYWN0b3IpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCBkZWx0YSA9IHB0cyAtIG5leHRBdWRpb1B0cztcclxuICAgICAgICBsZXQgbnVtTWlzc2luZ0ZyYW1lcyA9IDA7XHJcblxyXG4gICAgICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xyXG4gICAgICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXHJcbiAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgdHJhY2suaXNBQUMpIHtcclxuICAgICAgICAgIC8vIGxvZyBkZWx0YVxyXG4gICAgICAgICAgaWYgKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDAgJiYgZGVsdGEgPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OXzkwS0haKSB7XHJcbiAgICAgICAgICAgICAgLy8gUTogd2h5IGRvIHdlIGhhdmUgdG8gcm91bmQgaGVyZSwgc2hvdWxkbid0IHRoaXMgYWx3YXlzIHJlc3VsdCBpbiBhbiBpbnRlZ2VyIGlmIHRpbWVzdGFtcHMgYXJlIGNvcnJlY3QsXHJcbiAgICAgICAgICAgICAgLy8gYW5kIGlmIG5vdCwgc2hvdWxkbid0IHdlIGFjdHVhbGx5IE1hdGguY2VpbCgpIGluc3RlYWQ/XHJcbiAgICAgICAgICAgICAgbnVtTWlzc2luZ0ZyYW1lcyA9IE1hdGgucm91bmQoKHB0cyAtIG5leHRBdWRpb1B0cykgLyBpbnB1dFNhbXBsZUR1cmF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgJHt0b01zRnJvbU1wZWdUc0Nsb2NrKGRlbHRhLCB0cnVlKX0gbXMgaG9sZSBiZXR3ZWVuIEFBQyBzYW1wbGVzIGRldGVjdGVkLGZpbGxpbmcgaXRgKTtcclxuICAgICAgICAgICAgICBpZiAobnVtTWlzc2luZ0ZyYW1lcyA+IDApIHtcclxuICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcclxuICAgICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gdW5pdC5zdWJhcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG1kYXRTaXplICs9IG51bU1pc3NpbmdGcmFtZXMgKiBmaWxsRnJhbWUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGZyYW1lIG92ZXJsYXAsIG92ZXJsYXBwaW5nIGZvciBtb3JlIHRoYW4gaGFsZiBhIGZyYW1lIGR1cmFpb25cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA8IC0xMikge1xyXG4gICAgICAgICAgICAgIC8vIGRyb3Agb3ZlcmxhcHBpbmcgYXVkaW8gZnJhbWVzLi4uIGJyb3dzZXIgd2lsbCBkZWFsIHdpdGggaXRcclxuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBkcm9wIG92ZXJsYXBwaW5nIEFBQyBzYW1wbGUsIGV4cGVjdGVkL3BhcnNlZC9kZWx0YTogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKG5leHRBdWRpb1B0cywgdHJ1ZSl9IG1zIC8gJHt0b01zRnJvbU1wZWdUc0Nsb2NrKHB0cywgdHJ1ZSl9IG1zIC8gJHt0b01zRnJvbU1wZWdUc0Nsb2NrKC1kZWx0YSwgdHJ1ZSl9IG1zYCk7XHJcbiAgICAgICAgICAgICAgbWRhdFNpemUgLT0gdW5pdC5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNldCBQVFMvRFRTIHRvIGV4cGVjdGVkIFBUUy9EVFNcclxuICAgICAgICAgICAgcHRzID0gbmV4dEF1ZGlvUHRzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2Ygb3VyIGF1ZGlvU2FtcGxlc1xyXG4gICAgICAgIGZpcnN0UFRTID0gcHRzO1xyXG4gICAgICAgIGlmIChtZGF0U2l6ZSA+IDApIHtcclxuICAgICAgICAgIG1kYXRTaXplICs9IG9mZnNldDtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTVVYX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnl0ZXM6IG1kYXRTaXplLCByZWFzb246IGBmYWlsIGFsbG9jYXRpbmcgYXVkaW8gbWRhdCAke21kYXRTaXplfWAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghcmF3TVBFRykge1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcclxuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xyXG4gICAgICAgICAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIG5vIGF1ZGlvIHNhbXBsZXNcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1NaXNzaW5nRnJhbWVzOyBpKyspIHtcclxuICAgICAgICAgIGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xyXG4gICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyB0aGlzIGZyYW1lIGluc3RlYWQuJyk7XHJcbiAgICAgICAgICAgIGZpbGxGcmFtZSA9IHVuaXQuc3ViYXJyYXkoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG1kYXQuc2V0KGZpbGxGcmFtZSwgb2Zmc2V0KTtcclxuICAgICAgICAgIG9mZnNldCArPSBmaWxsRnJhbWUuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgIG1wNFNhbXBsZSA9IHtcclxuICAgICAgICAgICAgc2l6ZTogZmlsbEZyYW1lLmJ5dGVMZW5ndGgsXHJcbiAgICAgICAgICAgIGN0czogMCxcclxuICAgICAgICAgICAgZHVyYXRpb246IDEwMjQsXHJcbiAgICAgICAgICAgIGZsYWdzOiB7XHJcbiAgICAgICAgICAgICAgaXNMZWFkaW5nOiAwLFxyXG4gICAgICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcclxuICAgICAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxyXG4gICAgICAgICAgICAgIGRlZ3JhZFByaW86IDAsXHJcbiAgICAgICAgICAgICAgZGVwZW5kc09uOiAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobXA0U2FtcGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbWRhdC5zZXQodW5pdCwgb2Zmc2V0KTtcclxuICAgICAgbGV0IHVuaXRMZW4gPSB1bml0LmJ5dGVMZW5ndGg7XHJcbiAgICAgIG9mZnNldCArPSB1bml0TGVuO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZygnUFRTL0RUUy9pbml0RFRTL25vcm1QVFMvbm9ybURUUy9yZWxhdGl2ZSBQVFMgOiAke2F1ZGlvU2FtcGxlLnB0c30vJHthdWRpb1NhbXBsZS5kdHN9LyR7aW5pdERUU30vJHtwdHNub3JtfS8ke2R0c25vcm19LyR7KGF1ZGlvU2FtcGxlLnB0cy80Mjk0OTY3Mjk2KS50b0ZpeGVkKDMpfScpO1xyXG4gICAgICBtcDRTYW1wbGUgPSB7XHJcbiAgICAgICAgc2l6ZTogdW5pdExlbixcclxuICAgICAgICBjdHM6IDAsXHJcbiAgICAgICAgZHVyYXRpb246IDAsXHJcbiAgICAgICAgZmxhZ3M6IHtcclxuICAgICAgICAgIGlzTGVhZGluZzogMCxcclxuICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcclxuICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXHJcbiAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxyXG4gICAgICAgICAgZGVwZW5kc09uOiAxXHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobXA0U2FtcGxlKTtcclxuICAgICAgbGFzdFBUUyA9IHB0cztcclxuICAgIH1cclxuICAgIGxldCBsYXN0U2FtcGxlRHVyYXRpb24gPSAwO1xyXG4gICAgbmJTYW1wbGVzID0gb3V0cHV0U2FtcGxlcy5sZW5ndGg7XHJcbiAgICAvLyBzZXQgbGFzdCBzYW1wbGUgZHVyYXRpb24gYXMgYmVpbmcgaWRlbnRpY2FsIHRvIHByZXZpb3VzIHNhbXBsZVxyXG4gICAgaWYgKG5iU2FtcGxlcyA+PSAyKSB7XHJcbiAgICAgIGxhc3RTYW1wbGVEdXJhdGlvbiA9IG91dHB1dFNhbXBsZXNbbmJTYW1wbGVzIC0gMl0uZHVyYXRpb247XHJcbiAgICAgIG1wNFNhbXBsZS5kdXJhdGlvbiA9IGxhc3RTYW1wbGVEdXJhdGlvbjtcclxuICAgIH1cclxuICAgIGlmIChuYlNhbXBsZXMpIHtcclxuICAgICAgLy8gbmV4dCBhdWRpbyBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBkdXJhdGlvblxyXG4gICAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IGxhc3RQVFMgKyBzY2FsZUZhY3RvciAqIGxhc3RTYW1wbGVEdXJhdGlvbjtcclxuICAgICAgLy8gbG9nZ2VyLmxvZygnQXVkaW8vUFRTL1BUU2VuZDonICsgYXVkaW9TYW1wbGUucHRzLnRvRml4ZWQoMCkgKyAnLycgKyB0aGlzLm5leHRBYWNEdHMudG9GaXhlZCgwKSk7XHJcbiAgICAgIHRyYWNrLnNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzO1xyXG4gICAgICBpZiAocmF3TVBFRykge1xyXG4gICAgICAgIG1vb2YgPSBuZXcgVWludDhBcnJheSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1vb2YgPSBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdFBUUyAvIHNjYWxlRmFjdG9yLCB0cmFjayk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcclxuICAgICAgY29uc3Qgc3RhcnQgPSBmaXJzdFBUUyAvIGlucHV0VGltZVNjYWxlO1xyXG4gICAgICBjb25zdCBlbmQgPSBuZXh0QXVkaW9QdHMgLyBpbnB1dFRpbWVTY2FsZTtcclxuICAgICAgY29uc3QgYXVkaW9EYXRhID0ge1xyXG4gICAgICAgIGRhdGExOiBtb29mLFxyXG4gICAgICAgIGRhdGEyOiBtZGF0LFxyXG4gICAgICAgIHN0YXJ0UFRTOiBzdGFydCxcclxuICAgICAgICBlbmRQVFM6IGVuZCxcclxuICAgICAgICBzdGFydERUUzogc3RhcnQsXHJcbiAgICAgICAgZW5kRFRTOiBlbmQsXHJcbiAgICAgICAgdHlwZTogJ2F1ZGlvJyxcclxuICAgICAgICBoYXNBdWRpbzogdHJ1ZSxcclxuICAgICAgICBoYXNWaWRlbzogZmFsc2UsXHJcbiAgICAgICAgbmI6IG5iU2FtcGxlc1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGF1ZGlvRGF0YSk7XHJcbiAgICAgIHJldHVybiBhdWRpb0RhdGE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHJlbXV4RW1wdHlBdWRpbyAodHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIHZpZGVvRGF0YSkge1xyXG4gICAgbGV0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XHJcbiAgICBsZXQgbXA0dGltZVNjYWxlID0gdHJhY2suc2FtcGxlcmF0ZSA/IHRyYWNrLnNhbXBsZXJhdGUgOiBpbnB1dFRpbWVTY2FsZTtcclxuICAgIGxldCBzY2FsZUZhY3RvciA9IGlucHV0VGltZVNjYWxlIC8gbXA0dGltZVNjYWxlO1xyXG4gICAgbGV0IG5leHRBdWRpb1B0cyA9IHRoaXMubmV4dEF1ZGlvUHRzO1xyXG5cclxuICAgIC8vIHN5bmMgd2l0aCB2aWRlbydzIHRpbWVzdGFtcFxyXG4gICAgbGV0IHN0YXJ0RFRTID0gKG5leHRBdWRpb1B0cyAhPT0gdW5kZWZpbmVkID8gbmV4dEF1ZGlvUHRzIDogdmlkZW9EYXRhLnN0YXJ0RFRTICogaW5wdXRUaW1lU2NhbGUpICsgdGhpcy5faW5pdERUUztcclxuICAgIGxldCBlbmREVFMgPSB2aWRlb0RhdGEuZW5kRFRTICogaW5wdXRUaW1lU2NhbGUgKyB0aGlzLl9pbml0RFRTO1xyXG4gICAgLy8gb25lIHNhbXBsZSdzIGR1cmF0aW9uIHZhbHVlXHJcbiAgICBsZXQgc2FtcGxlRHVyYXRpb24gPSAxMDI0O1xyXG4gICAgbGV0IGZyYW1lRHVyYXRpb24gPSBzY2FsZUZhY3RvciAqIHNhbXBsZUR1cmF0aW9uO1xyXG5cclxuICAgIC8vIHNhbXBsZXMgY291bnQgb2YgdGhpcyBzZWdtZW50J3MgZHVyYXRpb25cclxuICAgIGxldCBuYlNhbXBsZXMgPSBNYXRoLmNlaWwoKGVuZERUUyAtIHN0YXJ0RFRTKSAvIGZyYW1lRHVyYXRpb24pO1xyXG5cclxuICAgIC8vIHNpbGVudCBmcmFtZVxyXG4gICAgbGV0IHNpbGVudEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XHJcblxyXG4gICAgbG9nZ2VyLndhcm4oJ3JlbXV4IGVtcHR5IEF1ZGlvJyk7XHJcbiAgICAvLyBDYW4ndCByZW11eCBpZiB3ZSBjYW4ndCBnZW5lcmF0ZSBhIHNpbGVudCBmcmFtZS4uLlxyXG4gICAgaWYgKCFzaWxlbnRGcmFtZSkge1xyXG4gICAgICBsb2dnZXIudHJhY2UoJ1VuYWJsZSB0byByZW11eEVtcHR5QXVkaW8gc2luY2Ugd2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGEgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYyEnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBzYW1wbGVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XHJcbiAgICAgIGxldCBzdGFtcCA9IHN0YXJ0RFRTICsgaSAqIGZyYW1lRHVyYXRpb247XHJcbiAgICAgIHNhbXBsZXMucHVzaCh7IHVuaXQ6IHNpbGVudEZyYW1lLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wIH0pO1xyXG4gICAgfVxyXG4gICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XHJcblxyXG4gICAgdGhpcy5yZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzKTtcclxuICB9XHJcblxyXG4gIHJlbXV4SUQzICh0cmFjaykge1xyXG4gICAgbGV0IGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoLCBzYW1wbGU7XHJcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xyXG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XHJcbiAgICBjb25zdCBpbml0RFRTID0gdGhpcy5faW5pdERUUztcclxuICAgIC8vIGNvbnN1bWUgc2FtcGxlc1xyXG4gICAgaWYgKGxlbmd0aCkge1xyXG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XHJcbiAgICAgICAgLy8gc2V0dGluZyBpZDMgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxyXG4gICAgICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcclxuICAgICAgICBzYW1wbGUucHRzID0gKChzYW1wbGUucHRzIC0gaW5pdFBUUykgLyBpbnB1dFRpbWVTY2FsZSk7XHJcbiAgICAgICAgc2FtcGxlLmR0cyA9ICgoc2FtcGxlLmR0cyAtIGluaXREVFMpIC8gaW5wdXRUaW1lU2NhbGUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHtcclxuICAgICAgICBzYW1wbGVzOiB0cmFjay5zYW1wbGVzXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcclxuICB9XHJcblxyXG4gIHJlbXV4VGV4dCAodHJhY2spIHtcclxuICAgIHRyYWNrLnNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICByZXR1cm4gKGEucHRzIC0gYi5wdHMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoLCBzYW1wbGU7XHJcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xyXG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XHJcbiAgICAvLyBjb25zdW1lIHNhbXBsZXNcclxuICAgIGlmIChsZW5ndGgpIHtcclxuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xyXG4gICAgICAgIC8vIHNldHRpbmcgdGV4dCBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXHJcbiAgICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxyXG4gICAgICAgIHNhbXBsZS5wdHMgPSAoKHNhbXBsZS5wdHMgLSBpbml0UFRTKSAvIGlucHV0VGltZVNjYWxlKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCB7XHJcbiAgICAgICAgc2FtcGxlczogdHJhY2suc2FtcGxlc1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0cmFjay5zYW1wbGVzID0gW107XHJcbiAgfVxyXG5cclxuICBfUFRTTm9ybWFsaXplICh2YWx1ZSwgcmVmZXJlbmNlKSB7XHJcbiAgICBsZXQgb2Zmc2V0O1xyXG4gICAgaWYgKHJlZmVyZW5jZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcclxuICAgICAgLy8gLSAyXjMzXHJcbiAgICAgIG9mZnNldCA9IC04NTg5OTM0NTkyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gKyAyXjMzXHJcbiAgICAgIG9mZnNldCA9IDg1ODk5MzQ1OTI7XHJcbiAgICB9XHJcbiAgICAvKiBQVFMgaXMgMzNiaXQgKGZyb20gMCB0byAyXjMzIC0xKVxyXG4gICAgICBpZiBkaWZmIGJldHdlZW4gdmFsdWUgYW5kIHJlZmVyZW5jZSBpcyBiaWdnZXIgdGhhbiBoYWxmIG9mIHRoZSBhbXBsaXR1ZGUgKDJeMzIpIHRoZW4gaXQgbWVhbnMgdGhhdFxyXG4gICAgICBQVFMgbG9vcGluZyBvY2N1cmVkLiBmaWxsIHRoZSBnYXAgKi9cclxuICAgIHdoaWxlIChNYXRoLmFicyh2YWx1ZSAtIHJlZmVyZW5jZSkgPiA0Mjk0OTY3Mjk2KSB7XHJcbiAgICAgIHZhbHVlICs9IG9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNUDRSZW11eGVyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9yZW11eC9tcDQtcmVtdXhlci5qcyIsIi8qKlxyXG4gKiAgQUFDIGhlbHBlclxyXG4gKi9cclxuXHJcbmNsYXNzIEFBQyB7XHJcbiAgc3RhdGljIGdldFNpbGVudEZyYW1lIChjb2RlYywgY2hhbm5lbENvdW50KSB7XHJcbiAgICBzd2l0Y2ggKGNvZGVjKSB7XHJcbiAgICBjYXNlICdtcDRhLjQwLjInOlxyXG4gICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIzLCAweDgwXSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDIxLCAweDAwLCAweDQ5LCAweDkwLCAweDAyLCAweDE5LCAweDAwLCAweDIzLCAweDgwXSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDhlXSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgwLCAweDJjLCAweDgwLCAweDA4LCAweDAyLCAweDM4XSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDM4XSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA2KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLCAweDAwLCAweDIwLCAweDA4LCAweGUwXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgLy8gaGFuZGxlIEhFLUFBQyBiZWxvdyAobXA0YS40MC41IC8gbXA0YS40MC4yOSlcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcclxuICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZSAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDRlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MWMsIDB4NiwgMHhmMSwgMHhjMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XHJcbiAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHg5NSwgMHgwLCAweDYsIDB4ZjEsIDB4YTEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xyXG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xyXG4gICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHg5NSwgMHgwLCAweDYsIDB4ZjEsIDB4YTEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBQUM7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL3JlbXV4L2FhYy1oZWxwZXIuanMiLCIvKipcclxuICogR2VuZXJhdGUgTVA0IEJveFxyXG4qL1xyXG5cclxuY29uc3QgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XHJcblxyXG5jbGFzcyBNUDQge1xyXG4gIHN0YXRpYyBpbml0ICgpIHtcclxuICAgIE1QNC50eXBlcyA9IHtcclxuICAgICAgYXZjMTogW10sIC8vIGNvZGluZ25hbWVcclxuICAgICAgYXZjQzogW10sXHJcbiAgICAgIGJ0cnQ6IFtdLFxyXG4gICAgICBkaW5mOiBbXSxcclxuICAgICAgZHJlZjogW10sXHJcbiAgICAgIGVzZHM6IFtdLFxyXG4gICAgICBmdHlwOiBbXSxcclxuICAgICAgaGRscjogW10sXHJcbiAgICAgIG1kYXQ6IFtdLFxyXG4gICAgICBtZGhkOiBbXSxcclxuICAgICAgbWRpYTogW10sXHJcbiAgICAgIG1maGQ6IFtdLFxyXG4gICAgICBtaW5mOiBbXSxcclxuICAgICAgbW9vZjogW10sXHJcbiAgICAgIG1vb3Y6IFtdLFxyXG4gICAgICBtcDRhOiBbXSxcclxuICAgICAgJy5tcDMnOiBbXSxcclxuICAgICAgbXZleDogW10sXHJcbiAgICAgIG12aGQ6IFtdLFxyXG4gICAgICBwYXNwOiBbXSxcclxuICAgICAgc2R0cDogW10sXHJcbiAgICAgIHN0Ymw6IFtdLFxyXG4gICAgICBzdGNvOiBbXSxcclxuICAgICAgc3RzYzogW10sXHJcbiAgICAgIHN0c2Q6IFtdLFxyXG4gICAgICBzdHN6OiBbXSxcclxuICAgICAgc3R0czogW10sXHJcbiAgICAgIHRmZHQ6IFtdLFxyXG4gICAgICB0ZmhkOiBbXSxcclxuICAgICAgdHJhZjogW10sXHJcbiAgICAgIHRyYWs6IFtdLFxyXG4gICAgICB0cnVuOiBbXSxcclxuICAgICAgdHJleDogW10sXHJcbiAgICAgIHRraGQ6IFtdLFxyXG4gICAgICB2bWhkOiBbXSxcclxuICAgICAgc21oZDogW11cclxuICAgIH07XHJcblxyXG4gICAgbGV0IGk7XHJcbiAgICBmb3IgKGkgaW4gTVA0LnR5cGVzKSB7XHJcbiAgICAgIGlmIChNUDQudHlwZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICBNUDQudHlwZXNbaV0gPSBbXHJcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMCksXHJcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMSksXHJcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMiksXHJcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMylcclxuICAgICAgICBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHZpZGVvSGRsciA9IG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXHJcbiAgICAgIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsIC8vIGhhbmRsZXJfdHlwZTogJ3ZpZGUnXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4NTYsIDB4NjksIDB4NjQsIDB4NjUsXHJcbiAgICAgIDB4NmYsIDB4NDgsIDB4NjEsIDB4NmUsXHJcbiAgICAgIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1ZpZGVvSGFuZGxlcidcclxuICAgIF0pO1xyXG5cclxuICAgIGxldCBhdWRpb0hkbHIgPSBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxyXG4gICAgICAweDczLCAweDZmLCAweDc1LCAweDZlLCAvLyBoYW5kbGVyX3R5cGU6ICdzb3VuJ1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDUzLCAweDZmLCAweDc1LCAweDZlLFxyXG4gICAgICAweDY0LCAweDQ4LCAweDYxLCAweDZlLFxyXG4gICAgICAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdTb3VuZEhhbmRsZXInXHJcbiAgICBdKTtcclxuXHJcbiAgICBNUDQuSERMUl9UWVBFUyA9IHtcclxuICAgICAgJ3ZpZGVvJzogdmlkZW9IZGxyLFxyXG4gICAgICAnYXVkaW8nOiBhdWRpb0hkbHJcclxuICAgIH07XHJcblxyXG4gICAgbGV0IGRyZWYgPSBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBlbnRyeV9jb3VudFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDBjLCAvLyBlbnRyeV9zaXplXHJcbiAgICAgIDB4NzUsIDB4NzIsIDB4NmMsIDB4MjAsIC8vICd1cmwnIHR5cGVcclxuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDEgLy8gZW50cnlfZmxhZ3NcclxuICAgIF0pO1xyXG5cclxuICAgIGxldCBzdGNvID0gbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcclxuICAgIF0pO1xyXG5cclxuICAgIE1QNC5TVFRTID0gTVA0LlNUU0MgPSBNUDQuU1RDTyA9IHN0Y287XHJcblxyXG4gICAgTVA0LlNUU1ogPSBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gc2FtcGxlX3NpemVcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBzYW1wbGVfY291bnRcclxuICAgIF0pO1xyXG4gICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZmxhZ3NcclxuICAgICAgMHgwMCwgMHgwMCwgLy8gZ3JhcGhpY3Ntb2RlXHJcbiAgICAgIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDAgLy8gb3Bjb2xvclxyXG4gICAgXSk7XHJcbiAgICBNUDQuU01IRCA9IG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCwgLy8gdmVyc2lvblxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG4gICAgICAweDAwLCAweDAwLCAvLyBiYWxhbmNlXHJcbiAgICAgIDB4MDAsIDB4MDAgLy8gcmVzZXJ2ZWRcclxuICAgIF0pO1xyXG5cclxuICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pOy8vIGVudHJ5X2NvdW50XHJcblxyXG4gICAgbGV0IG1ham9yQnJhbmQgPSBuZXcgVWludDhBcnJheShbMTA1LCAxMTUsIDExMSwgMTA5XSk7IC8vIGlzb21cclxuICAgIGxldCBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsIDExOCwgOTksIDQ5XSk7IC8vIGF2YzFcclxuICAgIGxldCBtaW5vclZlcnNpb24gPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMV0pO1xyXG5cclxuICAgIE1QNC5GVFlQID0gTVA0LmJveChNUDQudHlwZXMuZnR5cCwgbWFqb3JCcmFuZCwgbWlub3JWZXJzaW9uLCBtYWpvckJyYW5kLCBhdmMxQnJhbmQpO1xyXG4gICAgTVA0LkRJTkYgPSBNUDQuYm94KE1QNC50eXBlcy5kaW5mLCBNUDQuYm94KE1QNC50eXBlcy5kcmVmLCBkcmVmKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYm94ICh0eXBlKSB7XHJcbiAgICBsZXRcclxuICAgICAgcGF5bG9hZCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcbiAgICAgIHNpemUgPSA4LFxyXG4gICAgICBpID0gcGF5bG9hZC5sZW5ndGgsXHJcbiAgICAgIGxlbiA9IGksXHJcbiAgICAgIHJlc3VsdDtcclxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgdG90YWwgc2l6ZSB3ZSBuZWVkIHRvIGFsbG9jYXRlXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xyXG4gICAgcmVzdWx0WzBdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcclxuICAgIHJlc3VsdFsxXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XHJcbiAgICByZXN1bHRbMl0gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XHJcbiAgICByZXN1bHRbM10gPSBzaXplICYgMHhmZjtcclxuICAgIHJlc3VsdC5zZXQodHlwZSwgNCk7XHJcbiAgICAvLyBjb3B5IHRoZSBwYXlsb2FkIGludG8gdGhlIHJlc3VsdFxyXG4gICAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAvLyBjb3B5IHBheWxvYWRbaV0gYXJyYXkgQCBvZmZzZXQgc2l6ZVxyXG4gICAgICByZXN1bHQuc2V0KHBheWxvYWRbaV0sIHNpemUpO1xyXG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgaGRsciAodHlwZSkge1xyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmhkbHIsIE1QNC5IRExSX1RZUEVTW3R5cGVdKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBtZGF0IChkYXRhKSB7XHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRhdCwgZGF0YSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgbWRoZCAodGltZXNjYWxlLCBkdXJhdGlvbikge1xyXG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xyXG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XHJcbiAgICBjb25zdCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGhkLCBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXHJcbiAgICAgICh0aW1lc2NhbGUgPj4gMjQpICYgMHhGRixcclxuICAgICAgKHRpbWVzY2FsZSA+PiAxNikgJiAweEZGLFxyXG4gICAgICAodGltZXNjYWxlID4+IDgpICYgMHhGRixcclxuICAgICAgdGltZXNjYWxlICYgMHhGRiwgLy8gdGltZXNjYWxlXHJcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAyNCksXHJcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxyXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxyXG4gICAgICB1cHBlcldvcmREdXJhdGlvbiAmIDB4RkYsXHJcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAyNCksXHJcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxyXG4gICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxyXG4gICAgICBsb3dlcldvcmREdXJhdGlvbiAmIDB4RkYsXHJcbiAgICAgIDB4NTUsIDB4YzQsIC8vICd1bmQnIGxhbmd1YWdlICh1bmRldGVybWluZWQpXHJcbiAgICAgIDB4MDAsIDB4MDBcclxuICAgIF0pKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBtZGlhICh0cmFjaykge1xyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaWEsIE1QNC5tZGhkKHRyYWNrLnRpbWVzY2FsZSwgdHJhY2suZHVyYXRpb24pLCBNUDQuaGRscih0cmFjay50eXBlKSwgTVA0Lm1pbmYodHJhY2spKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBtZmhkIChzZXF1ZW5jZU51bWJlcikge1xyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1maGQsIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcclxuICAgICAgKHNlcXVlbmNlTnVtYmVyID4+IDI0KSxcclxuICAgICAgKHNlcXVlbmNlTnVtYmVyID4+IDE2KSAmIDB4RkYsXHJcbiAgICAgIChzZXF1ZW5jZU51bWJlciA+PiA4KSAmIDB4RkYsXHJcbiAgICAgIHNlcXVlbmNlTnVtYmVyICYgMHhGRiAvLyBzZXF1ZW5jZV9udW1iZXJcclxuICAgIF0pKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBtaW5mICh0cmFjaykge1xyXG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcclxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnNtaGQsIE1QNC5TTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMudm1oZCwgTVA0LlZNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBtb29mIChzbiwgYmFzZU1lZGlhRGVjb2RlVGltZSwgdHJhY2spIHtcclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tb29mLCBNUDQubWZoZChzbiksIE1QNC50cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gKiBAcGFyYW0gdHJhY2tzLi4uIChvcHRpb25hbCkge2FycmF5fSB0aGUgdHJhY2tzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1vdmllXHJcbiAqL1xyXG4gIHN0YXRpYyBtb292ICh0cmFja3MpIHtcclxuICAgIGxldFxyXG4gICAgICBpID0gdHJhY2tzLmxlbmd0aCxcclxuICAgICAgYm94ZXMgPSBbXTtcclxuXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyYWsodHJhY2tzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm1vb3YsIE1QNC5tdmhkKHRyYWNrc1swXS50aW1lc2NhbGUsIHRyYWNrc1swXS5kdXJhdGlvbildLmNvbmNhdChib3hlcykuY29uY2F0KE1QNC5tdmV4KHRyYWNrcykpKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBtdmV4ICh0cmFja3MpIHtcclxuICAgIGxldFxyXG4gICAgICBpID0gdHJhY2tzLmxlbmd0aCxcclxuICAgICAgYm94ZXMgPSBbXTtcclxuXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyZXgodHJhY2tzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm12ZXhdLmNvbmNhdChib3hlcykpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIG12aGQgKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcclxuICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcclxuICAgIGNvbnN0IHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xyXG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XHJcbiAgICBsZXRcclxuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbXHJcbiAgICAgICAgMHgwMSwgLy8gdmVyc2lvbiAxXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcclxuICAgICAgICAodGltZXNjYWxlID4+IDI0KSAmIDB4RkYsXHJcbiAgICAgICAgKHRpbWVzY2FsZSA+PiAxNikgJiAweEZGLFxyXG4gICAgICAgICh0aW1lc2NhbGUgPj4gOCkgJiAweEZGLFxyXG4gICAgICAgIHRpbWVzY2FsZSAmIDB4RkYsIC8vIHRpbWVzY2FsZVxyXG4gICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAyNCksXHJcbiAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXHJcbiAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDgpICYgMHhGRixcclxuICAgICAgICB1cHBlcldvcmREdXJhdGlvbiAmIDB4RkYsXHJcbiAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDI0KSxcclxuICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcclxuICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxyXG4gICAgICAgIGxvd2VyV29yZER1cmF0aW9uICYgMHhGRixcclxuICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAvLyAxLjAgcmF0ZVxyXG4gICAgICAgIDB4MDEsIDB4MDAsIC8vIDEuMCB2b2x1bWVcclxuICAgICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxyXG4gICAgICAgIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYgLy8gbmV4dF90cmFja19JRFxyXG4gICAgICBdKTtcclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmhkLCBieXRlcyk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgc2R0cCAodHJhY2spIHtcclxuICAgIGxldFxyXG4gICAgICBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXSxcclxuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpLFxyXG4gICAgICBmbGFncyxcclxuICAgICAgaTtcclxuICAgIC8vIGxlYXZlIHRoZSBmdWxsIGJveCBoZWFkZXIgKDQgYnl0ZXMpIGFsbCB6ZXJvXHJcbiAgICAvLyB3cml0ZSB0aGUgc2FtcGxlIHRhYmxlXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XHJcbiAgICAgIGJ5dGVzW2kgKyA0XSA9IChmbGFncy5kZXBlbmRzT24gPDwgNCkgfFxyXG4gICAgICAgIChmbGFncy5pc0RlcGVuZGVkT24gPDwgMikgfFxyXG4gICAgICAgIChmbGFncy5oYXNSZWR1bmRhbmN5KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc2R0cCwgYnl0ZXMpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHN0YmwgKHRyYWNrKSB7XHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RibCwgTVA0LnN0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuU1RUUyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c2MsIE1QNC5TVFNDKSwgTVA0LmJveChNUDQudHlwZXMuc3RzeiwgTVA0LlNUU1opLCBNUDQuYm94KE1QNC50eXBlcy5zdGNvLCBNUDQuU1RDTykpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGF2YzEgKHRyYWNrKSB7XHJcbiAgICBsZXQgc3BzID0gW10sIHBwcyA9IFtdLCBpLCBkYXRhLCBsZW47XHJcbiAgICAvLyBhc3NlbWJsZSB0aGUgU1BTc1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5zcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgZGF0YSA9IHRyYWNrLnNwc1tpXTtcclxuICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgICBzcHMucHVzaCgobGVuID4+PiA4KSAmIDB4RkYpO1xyXG4gICAgICBzcHMucHVzaCgobGVuICYgMHhGRikpO1xyXG5cclxuICAgICAgLy8gU1BTXHJcbiAgICAgIHNwcyA9IHNwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFzc2VtYmxlIHRoZSBQUFNzXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2sucHBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGRhdGEgPSB0cmFjay5wcHNbaV07XHJcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcclxuICAgICAgcHBzLnB1c2goKGxlbiA+Pj4gOCkgJiAweEZGKTtcclxuICAgICAgcHBzLnB1c2goKGxlbiAmIDB4RkYpKTtcclxuXHJcbiAgICAgIHBwcyA9IHBwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBhdmNjID0gTVA0LmJveChNUDQudHlwZXMuYXZjQywgbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAgIDB4MDEsIC8vIHZlcnNpb25cclxuICAgICAgICBzcHNbM10sIC8vIHByb2ZpbGVcclxuICAgICAgICBzcHNbNF0sIC8vIHByb2ZpbGUgY29tcGF0XHJcbiAgICAgICAgc3BzWzVdLCAvLyBsZXZlbFxyXG4gICAgICAgIDB4ZmMgfCAzLCAvLyBsZW5ndGhTaXplTWludXNPbmUsIGhhcmQtY29kZWQgdG8gNCBieXRlc1xyXG4gICAgICAgIDB4RTAgfCB0cmFjay5zcHMubGVuZ3RoIC8vIDNiaXQgcmVzZXJ2ZWQgKDExMSkgKyBudW1PZlNlcXVlbmNlUGFyYW1ldGVyU2V0c1xyXG4gICAgICBdLmNvbmNhdChzcHMpLmNvbmNhdChbXHJcbiAgICAgICAgdHJhY2sucHBzLmxlbmd0aCAvLyBudW1PZlBpY3R1cmVQYXJhbWV0ZXJTZXRzXHJcbiAgICAgIF0pLmNvbmNhdChwcHMpKSksIC8vIFwiUFBTXCJcclxuICAgICAgd2lkdGggPSB0cmFjay53aWR0aCxcclxuICAgICAgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0LFxyXG4gICAgICBoU3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMF0sXHJcbiAgICAgIHZTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1sxXTtcclxuXHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuYXZjMSwgbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxyXG4gICAgICAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxyXG4gICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxyXG4gICAgICAod2lkdGggPj4gOCkgJiAweEZGLFxyXG4gICAgICB3aWR0aCAmIDB4ZmYsIC8vIHdpZHRoXHJcbiAgICAgIChoZWlnaHQgPj4gOCkgJiAweEZGLFxyXG4gICAgICBoZWlnaHQgJiAweGZmLCAvLyBoZWlnaHRcclxuICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCwgLy8gaG9yaXpyZXNvbHV0aW9uXHJcbiAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIHZlcnRyZXNvbHV0aW9uXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGZyYW1lX2NvdW50XHJcbiAgICAgIDB4MTIsXHJcbiAgICAgIDB4NjQsIDB4NjEsIDB4NjksIDB4NkMsIC8vIGRhaWx5bW90aW9uL2hscy5qc1xyXG4gICAgICAweDc5LCAweDZELCAweDZGLCAweDc0LFxyXG4gICAgICAweDY5LCAweDZGLCAweDZFLCAweDJGLFxyXG4gICAgICAweDY4LCAweDZDLCAweDczLCAweDJFLFxyXG4gICAgICAweDZBLCAweDczLCAweDAwLCAweDAwLFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBjb21wcmVzc29ybmFtZVxyXG4gICAgICAweDAwLCAweDE4LCAvLyBkZXB0aCA9IDI0XHJcbiAgICAgIDB4MTEsIDB4MTFdKSwgLy8gcHJlX2RlZmluZWQgPSAtMVxyXG4gICAgYXZjYyxcclxuICAgIE1QNC5ib3goTVA0LnR5cGVzLmJ0cnQsIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCwgMHgxYywgMHg5YywgMHg4MCwgLy8gYnVmZmVyU2l6ZURCXHJcbiAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAsIC8vIG1heEJpdHJhdGVcclxuICAgICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMF0pKSwgLy8gYXZnQml0cmF0ZVxyXG4gICAgTVA0LmJveChNUDQudHlwZXMucGFzcCwgbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAoaFNwYWNpbmcgPj4gMjQpLCAvLyBoU3BhY2luZ1xyXG4gICAgICAoaFNwYWNpbmcgPj4gMTYpICYgMHhGRixcclxuICAgICAgKGhTcGFjaW5nID4+IDgpICYgMHhGRixcclxuICAgICAgaFNwYWNpbmcgJiAweEZGLFxyXG4gICAgICAodlNwYWNpbmcgPj4gMjQpLCAvLyB2U3BhY2luZ1xyXG4gICAgICAodlNwYWNpbmcgPj4gMTYpICYgMHhGRixcclxuICAgICAgKHZTcGFjaW5nID4+IDgpICYgMHhGRixcclxuICAgICAgdlNwYWNpbmcgJiAweEZGXSkpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGVzZHMgKHRyYWNrKSB7XHJcbiAgICBsZXQgY29uZmlnbGVuID0gdHJhY2suY29uZmlnLmxlbmd0aDtcclxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xyXG5cclxuICAgICAgMHgwMywgLy8gZGVzY3JpcHRvcl90eXBlXHJcbiAgICAgIDB4MTcgKyBjb25maWdsZW4sIC8vIGxlbmd0aFxyXG4gICAgICAweDAwLCAweDAxLCAvLyBlc19pZFxyXG4gICAgICAweDAwLCAvLyBzdHJlYW1fcHJpb3JpdHlcclxuXHJcbiAgICAgIDB4MDQsIC8vIGRlc2NyaXB0b3JfdHlwZVxyXG4gICAgICAweDBmICsgY29uZmlnbGVuLCAvLyBsZW5ndGhcclxuICAgICAgMHg0MCwgLy8gY29kZWMgOiBtcGVnNF9hdWRpb1xyXG4gICAgICAweDE1LCAvLyBzdHJlYW1fdHlwZVxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBidWZmZXJfc2l6ZVxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtYXhCaXRyYXRlXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGF2Z0JpdHJhdGVcclxuXHJcbiAgICAgIDB4MDUgLy8gZGVzY3JpcHRvcl90eXBlXHJcbiAgICBdLmNvbmNhdChbY29uZmlnbGVuXSkuY29uY2F0KHRyYWNrLmNvbmZpZykuY29uY2F0KFsweDA2LCAweDAxLCAweDAyXSkpOyAvLyBHQVNwZWNpZmljQ29uZmlnKSk7IC8vIGxlbmd0aCArIGF1ZGlvIGNvbmZpZyBkZXNjcmlwdG9yXHJcbiAgfVxyXG5cclxuICBzdGF0aWMgbXA0YSAodHJhY2spIHtcclxuICAgIGxldCBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tcDRhLCBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXHJcbiAgICAgIDB4MDAsIHRyYWNrLmNoYW5uZWxDb3VudCwgLy8gY2hhbm5lbGNvdW50XHJcbiAgICAgIDB4MDAsIDB4MTAsIC8vIHNhbXBsZVNpemU6MTZiaXRzXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkMlxyXG4gICAgICAoc2FtcGxlcmF0ZSA+PiA4KSAmIDB4RkYsXHJcbiAgICAgIHNhbXBsZXJhdGUgJiAweGZmLCAvL1xyXG4gICAgICAweDAwLCAweDAwXSksXHJcbiAgICBNUDQuYm94KE1QNC50eXBlcy5lc2RzLCBNUDQuZXNkcyh0cmFjaykpKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBtcDMgKHRyYWNrKSB7XHJcbiAgICBsZXQgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXNbJy5tcDMnXSwgbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxyXG4gICAgICAweDAwLCB0cmFjay5jaGFubmVsQ291bnQsIC8vIGNoYW5uZWxjb3VudFxyXG4gICAgICAweDAwLCAweDEwLCAvLyBzYW1wbGVTaXplOjE2Yml0c1xyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDJcclxuICAgICAgKHNhbXBsZXJhdGUgPj4gOCkgJiAweEZGLFxyXG4gICAgICBzYW1wbGVyYXRlICYgMHhmZiwgLy9cclxuICAgICAgMHgwMCwgMHgwMF0pKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBzdHNkICh0cmFjaykge1xyXG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcclxuICAgICAgaWYgKCF0cmFjay5pc0FBQyAmJiB0cmFjay5jb2RlYyA9PT0gJ21wMycpIHtcclxuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDModHJhY2spKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXA0YSh0cmFjaykpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQuYXZjMSh0cmFjaykpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIHRraGQgKHRyYWNrKSB7XHJcbiAgICBsZXQgaWQgPSB0cmFjay5pZCxcclxuICAgICAgZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiAqIHRyYWNrLnRpbWVzY2FsZSxcclxuICAgICAgd2lkdGggPSB0cmFjay53aWR0aCxcclxuICAgICAgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0LFxyXG4gICAgICB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKSxcclxuICAgICAgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XHJcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudGtoZCwgbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAweDAxLCAvLyB2ZXJzaW9uIDFcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwNywgLy8gZmxhZ3NcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMiwgLy8gY3JlYXRpb25fdGltZVxyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLCAvLyBtb2RpZmljYXRpb25fdGltZVxyXG4gICAgICAoaWQgPj4gMjQpICYgMHhGRixcclxuICAgICAgKGlkID4+IDE2KSAmIDB4RkYsXHJcbiAgICAgIChpZCA+PiA4KSAmIDB4RkYsXHJcbiAgICAgIGlkICYgMHhGRiwgLy8gdHJhY2tfSURcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDI0KSxcclxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXHJcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4RkYsXHJcbiAgICAgIHVwcGVyV29yZER1cmF0aW9uICYgMHhGRixcclxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDI0KSxcclxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXHJcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4RkYsXHJcbiAgICAgIGxvd2VyV29yZER1cmF0aW9uICYgMHhGRixcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgMHgwMCwgMHgwMCwgLy8gbGF5ZXJcclxuICAgICAgMHgwMCwgMHgwMCwgLy8gYWx0ZXJuYXRlX2dyb3VwXHJcbiAgICAgIDB4MDAsIDB4MDAsIC8vIG5vbi1hdWRpbyB0cmFjayB2b2x1bWVcclxuICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcclxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcclxuICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxyXG4gICAgICAod2lkdGggPj4gOCkgJiAweEZGLFxyXG4gICAgICB3aWR0aCAmIDB4RkYsXHJcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHdpZHRoXHJcbiAgICAgIChoZWlnaHQgPj4gOCkgJiAweEZGLFxyXG4gICAgICBoZWlnaHQgJiAweEZGLFxyXG4gICAgICAweDAwLCAweDAwIC8vIGhlaWdodFxyXG4gICAgXSkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHRyYWYgKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XHJcbiAgICBsZXQgc2FtcGxlRGVwZW5kZW5jeVRhYmxlID0gTVA0LnNkdHAodHJhY2spLFxyXG4gICAgICBpZCA9IHRyYWNrLmlkLFxyXG4gICAgICB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVggKyAxKSksXHJcbiAgICAgIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgJSAoVUlOVDMyX01BWCArIDEpKTtcclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFmLFxyXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy50ZmhkLCBuZXcgVWludDhBcnJheShbXHJcbiAgICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcclxuICAgICAgICAoaWQgPj4gMjQpLFxyXG4gICAgICAgIChpZCA+PiAxNikgJiAwWEZGLFxyXG4gICAgICAgIChpZCA+PiA4KSAmIDBYRkYsXHJcbiAgICAgICAgKGlkICYgMHhGRikgLy8gdHJhY2tfSURcclxuICAgICAgXSkpLFxyXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy50ZmR0LCBuZXcgVWludDhBcnJheShbXHJcbiAgICAgICAgMHgwMSwgLy8gdmVyc2lvbiAxXHJcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcclxuICAgICAgICAodXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCksXHJcbiAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYpICYgMFhGRixcclxuICAgICAgICAodXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4KSAmIDBYRkYsXHJcbiAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweEZGKSxcclxuICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCksXHJcbiAgICAgICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYpICYgMFhGRixcclxuICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4KSAmIDBYRkYsXHJcbiAgICAgICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweEZGKVxyXG4gICAgICBdKSksXHJcbiAgICAgIE1QNC50cnVuKHRyYWNrLFxyXG4gICAgICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZS5sZW5ndGggK1xyXG4gICAgICAgICAgICAgICAgICAgIDE2ICsgLy8gdGZoZFxyXG4gICAgICAgICAgICAgICAgICAgIDIwICsgLy8gdGZkdFxyXG4gICAgICAgICAgICAgICAgICAgIDggKyAvLyB0cmFmIGhlYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIDE2ICsgLy8gbWZoZFxyXG4gICAgICAgICAgICAgICAgICAgIDggKyAvLyBtb29mIGhlYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIDgpLCAvLyBtZGF0IGhlYWRlclxyXG4gICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSB0cmFjayBib3guXHJcbiAgICogQHBhcmFtIHRyYWNrIHtvYmplY3R9IGEgdHJhY2sgZGVmaW5pdGlvblxyXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSB0cmFjayBib3hcclxuICAgKi9cclxuICBzdGF0aWMgdHJhayAodHJhY2spIHtcclxuICAgIHRyYWNrLmR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gfHwgMHhmZmZmZmZmZjtcclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFrLCBNUDQudGtoZCh0cmFjayksIE1QNC5tZGlhKHRyYWNrKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgdHJleCAodHJhY2spIHtcclxuICAgIGxldCBpZCA9IHRyYWNrLmlkO1xyXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyZXgsIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXHJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXHJcbiAgICAgIChpZCA+PiAyNCksXHJcbiAgICAgIChpZCA+PiAxNikgJiAwWEZGLFxyXG4gICAgICAoaWQgPj4gOCkgJiAwWEZGLFxyXG4gICAgICAoaWQgJiAweEZGKSwgLy8gdHJhY2tfSURcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cclxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxyXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAxIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXHJcbiAgICBdKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgdHJ1biAodHJhY2ssIG9mZnNldCkge1xyXG4gICAgbGV0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdLFxyXG4gICAgICBsZW4gPSBzYW1wbGVzLmxlbmd0aCxcclxuICAgICAgYXJyYXlsZW4gPSAxMiArICgxNiAqIGxlbiksXHJcbiAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlsZW4pLFxyXG4gICAgICBpLCBzYW1wbGUsIGR1cmF0aW9uLCBzaXplLCBmbGFncywgY3RzO1xyXG4gICAgb2Zmc2V0ICs9IDggKyBhcnJheWxlbjtcclxuICAgIGFycmF5LnNldChbXHJcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxyXG4gICAgICAweDAwLCAweDBmLCAweDAxLCAvLyBmbGFnc1xyXG4gICAgICAobGVuID4+PiAyNCkgJiAweEZGLFxyXG4gICAgICAobGVuID4+PiAxNikgJiAweEZGLFxyXG4gICAgICAobGVuID4+PiA4KSAmIDB4RkYsXHJcbiAgICAgIGxlbiAmIDB4RkYsIC8vIHNhbXBsZV9jb3VudFxyXG4gICAgICAob2Zmc2V0ID4+PiAyNCkgJiAweEZGLFxyXG4gICAgICAob2Zmc2V0ID4+PiAxNikgJiAweEZGLFxyXG4gICAgICAob2Zmc2V0ID4+PiA4KSAmIDB4RkYsXHJcbiAgICAgIG9mZnNldCAmIDB4RkYgLy8gZGF0YV9vZmZzZXRcclxuICAgIF0sIDApO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XHJcbiAgICAgIGR1cmF0aW9uID0gc2FtcGxlLmR1cmF0aW9uO1xyXG4gICAgICBzaXplID0gc2FtcGxlLnNpemU7XHJcbiAgICAgIGZsYWdzID0gc2FtcGxlLmZsYWdzO1xyXG4gICAgICBjdHMgPSBzYW1wbGUuY3RzO1xyXG4gICAgICBhcnJheS5zZXQoW1xyXG4gICAgICAgIChkdXJhdGlvbiA+Pj4gMjQpICYgMHhGRixcclxuICAgICAgICAoZHVyYXRpb24gPj4+IDE2KSAmIDB4RkYsXHJcbiAgICAgICAgKGR1cmF0aW9uID4+PiA4KSAmIDB4RkYsXHJcbiAgICAgICAgZHVyYXRpb24gJiAweEZGLCAvLyBzYW1wbGVfZHVyYXRpb25cclxuICAgICAgICAoc2l6ZSA+Pj4gMjQpICYgMHhGRixcclxuICAgICAgICAoc2l6ZSA+Pj4gMTYpICYgMHhGRixcclxuICAgICAgICAoc2l6ZSA+Pj4gOCkgJiAweEZGLFxyXG4gICAgICAgIHNpemUgJiAweEZGLCAvLyBzYW1wbGVfc2l6ZVxyXG4gICAgICAgIChmbGFncy5pc0xlYWRpbmcgPDwgMikgfCBmbGFncy5kZXBlbmRzT24sXHJcbiAgICAgICAgKGZsYWdzLmlzRGVwZW5kZWRPbiA8PCA2KSB8XHJcbiAgICAgICAgICAoZmxhZ3MuaGFzUmVkdW5kYW5jeSA8PCA0KSB8XHJcbiAgICAgICAgICAoZmxhZ3MucGFkZGluZ1ZhbHVlIDw8IDEpIHxcclxuICAgICAgICAgIGZsYWdzLmlzTm9uU3luYyxcclxuICAgICAgICBmbGFncy5kZWdyYWRQcmlvICYgMHhGMCA8PCA4LFxyXG4gICAgICAgIGZsYWdzLmRlZ3JhZFByaW8gJiAweDBGLCAvLyBzYW1wbGVfZmxhZ3NcclxuICAgICAgICAoY3RzID4+PiAyNCkgJiAweEZGLFxyXG4gICAgICAgIChjdHMgPj4+IDE2KSAmIDB4RkYsXHJcbiAgICAgICAgKGN0cyA+Pj4gOCkgJiAweEZGLFxyXG4gICAgICAgIGN0cyAmIDB4RkYgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XHJcbiAgICAgIF0sIDEyICsgMTYgKiBpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cnVuLCBhcnJheSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgaW5pdFNlZ21lbnQgKHRyYWNrcykge1xyXG4gICAgaWYgKCFNUDQudHlwZXMpIHtcclxuICAgICAgTVA0LmluaXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbW92aWUgPSBNUDQubW9vdih0cmFja3MpLCByZXN1bHQ7XHJcbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShNUDQuRlRZUC5ieXRlTGVuZ3RoICsgbW92aWUuYnl0ZUxlbmd0aCk7XHJcbiAgICByZXN1bHQuc2V0KE1QNC5GVFlQKTtcclxuICAgIHJlc3VsdC5zZXQobW92aWUsIE1QNC5GVFlQLmJ5dGVMZW5ndGgpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1QNDtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvcmVtdXgvbXA0LWdlbmVyYXRvci5qcyIsImNvbnN0IE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiA9IDkwMDAwO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvVGltZXNjYWxlRnJvbVNjYWxlICh2YWx1ZSwgZGVzdFNjYWxlOiBudW1iZXIsIHNyY1NjYWxlOiBudW1iZXIgPSAxLCByb3VuZDogYm9vbGVhbiA9IGZhbHNlKTogbnVtYmVyIHtcclxuICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZSh2YWx1ZSwgZGVzdFNjYWxlLCAxIC8gc3JjU2NhbGUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9UaW1lc2NhbGVGcm9tQmFzZSAodmFsdWUsIGRlc3RTY2FsZTogbnVtYmVyLCBzcmNCYXNlOiBudW1iZXIgPSAxLCByb3VuZDogYm9vbGVhbiA9IGZhbHNlKTogbnVtYmVyIHtcclxuICBjb25zdCByZXN1bHQgPSB2YWx1ZSAqIGRlc3RTY2FsZSAqIHNyY0Jhc2U7IC8vIGVxdWl2YWxlbnQgdG8gYCh2YWx1ZSAqIHNjYWxlKSAvICgxIC8gYmFzZSlgXHJcbiAgcmV0dXJuIHJvdW5kID8gTWF0aC5yb3VuZChyZXN1bHQpIDogcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9Nc0Zyb21NcGVnVHNDbG9jayAodmFsdWU6IG51bWJlciwgcm91bmQ6IGJvb2xlYW4gPSBmYWxzZSk6IG51bWJlciB7XHJcbiAgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2UodmFsdWUsIDEwMDAsIDEgLyBNUEVHX1RTX0NMT0NLX0ZSRVFfSFosIHJvdW5kKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlICh2YWx1ZTogbnVtYmVyLCBzcmNTY2FsZTogbnVtYmVyID0gMSk6IG51bWJlciB7XHJcbiAgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2UodmFsdWUsIE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiwgMSAvIHNyY1NjYWxlKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbi50cyIsIi8qKlxyXG4gKiBwYXNzdGhyb3VnaCByZW11eGVyXHJcbiovXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5cclxuY2xhc3MgUGFzc1Rocm91Z2hSZW11eGVyIHtcclxuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIpIHtcclxuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3kgKCkge1xyXG4gIH1cclxuXHJcbiAgcmVzZXRUaW1lU3RhbXAgKCkge1xyXG4gIH1cclxuXHJcbiAgcmVzZXRJbml0U2VnbWVudCAoKSB7XHJcbiAgfVxyXG5cclxuICByZW11eCAoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCByYXdEYXRhKSB7XHJcbiAgICBsZXQgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xyXG4gICAgbGV0IHN0cmVhbVR5cGUgPSAnJztcclxuICAgIGlmIChhdWRpb1RyYWNrKSB7XHJcbiAgICAgIHN0cmVhbVR5cGUgKz0gJ2F1ZGlvJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmlkZW9UcmFjaykge1xyXG4gICAgICBzdHJlYW1UeXBlICs9ICd2aWRlbyc7XHJcbiAgICB9XHJcblxyXG4gICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwge1xyXG4gICAgICBkYXRhMTogcmF3RGF0YSxcclxuICAgICAgc3RhcnRQVFM6IHRpbWVPZmZzZXQsXHJcbiAgICAgIHN0YXJ0RFRTOiB0aW1lT2Zmc2V0LFxyXG4gICAgICB0eXBlOiBzdHJlYW1UeXBlLFxyXG4gICAgICBoYXNBdWRpbzogISFhdWRpb1RyYWNrLFxyXG4gICAgICBoYXNWaWRlbzogISF2aWRlb1RyYWNrLFxyXG4gICAgICBuYjogMSxcclxuICAgICAgZHJvcHBlZDogMFxyXG4gICAgfSk7XHJcbiAgICAvLyBub3RpZnkgZW5kIG9mIHBhcnNpbmdcclxuICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTRUQpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGFzc1Rocm91Z2hSZW11eGVyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyLmpzIiwiLyogZGVtdXhlciB3ZWIgd29ya2VyLlxyXG4gKiAgLSBsaXN0ZW4gdG8gd29ya2VyIG1lc3NhZ2UsIGFuZCB0cmlnZ2VyIERlbXV4ZXJJbmxpbmUgdXBvbiByZWNlcHRpb24gb2YgRnJhZ21lbnRzLlxyXG4gKiAgLSBwcm92aWRlcyBNUDQgQm94ZXMgYmFjayB0byBtYWluIHRocmVhZCB1c2luZyBbdHJhbnNmZXJhYmxlIG9iamVjdHNdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTEvMTIvVHJhbnNmZXJhYmxlLU9iamVjdHMtTGlnaHRuaW5nLUZhc3QpIGluIG9yZGVyIHRvIG1pbmltaXplIG1lc3NhZ2UgcGFzc2luZyBvdmVyaGVhZC5cclxuICovXHJcblxyXG5pbXBvcnQgRGVtdXhlcklubGluZSBmcm9tICcuLi9kZW11eC9kZW11eGVyLWlubGluZSc7XHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgeyBlbmFibGVMb2dzIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xyXG5cclxubGV0IERlbXV4ZXJXb3JrZXIgPSBmdW5jdGlvbiAoc2VsZikge1xyXG4gIC8vIG9ic2VydmVyIHNldHVwXHJcbiAgbGV0IG9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gIG9ic2VydmVyLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyIChldmVudCwgLi4uZGF0YSkge1xyXG4gICAgb2JzZXJ2ZXIuZW1pdChldmVudCwgZXZlbnQsIC4uLmRhdGEpO1xyXG4gIH07XHJcblxyXG4gIG9ic2VydmVyLm9mZiA9IGZ1bmN0aW9uIG9mZiAoZXZlbnQsIC4uLmRhdGEpIHtcclxuICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCAuLi5kYXRhKTtcclxuICB9O1xyXG5cclxuICBsZXQgZm9yd2FyZE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcclxuICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBldmVudDogZXYsIGRhdGE6IGRhdGEgfSk7XHJcbiAgfTtcclxuXHJcbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICBsZXQgZGF0YSA9IGV2LmRhdGE7XHJcbiAgICAvLyBjb25zb2xlLmxvZygnZGVtdXhlciBjbWQ6JyArIGRhdGEuY21kKTtcclxuICAgIHN3aXRjaCAoZGF0YS5jbWQpIHtcclxuICAgIGNhc2UgJ2luaXQnOlxyXG4gICAgICBjb25zdCBjb25maWcgPSBKU09OLnBhcnNlKGRhdGEuY29uZmlnKTtcclxuICAgICAgc2VsZi5kZW11eGVyID0gbmV3IERlbXV4ZXJJbmxpbmUob2JzZXJ2ZXIsIGRhdGEudHlwZVN1cHBvcnRlZCwgY29uZmlnLCBkYXRhLnZlbmRvcik7XHJcblxyXG4gICAgICBlbmFibGVMb2dzKGNvbmZpZy5kZWJ1Zyk7XHJcblxyXG4gICAgICAvLyBzaWduYWwgZW5kIG9mIHdvcmtlciBpbml0XHJcbiAgICAgIGZvcndhcmRNZXNzYWdlKCdpbml0JywgbnVsbCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnZGVtdXgnOlxyXG4gICAgICBzZWxmLmRlbXV4ZXIucHVzaChkYXRhLmRhdGEsIGRhdGEuZGVjcnlwdGRhdGEsIGRhdGEuaW5pdFNlZ21lbnQsIGRhdGEuYXVkaW9Db2RlYywgZGF0YS52aWRlb0NvZGVjLCBkYXRhLnRpbWVPZmZzZXQsIGRhdGEuZGlzY29udGludWl0eSwgZGF0YS50cmFja1N3aXRjaCwgZGF0YS5jb250aWd1b3VzLCBkYXRhLmR1cmF0aW9uLCBkYXRhLmFjY3VyYXRlVGltZU9mZnNldCwgZGF0YS5kZWZhdWx0SW5pdFBUUyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXHJcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcclxuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBmb3J3YXJkTWVzc2FnZSk7XHJcbiAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTRUQsIGZvcndhcmRNZXNzYWdlKTtcclxuICBvYnNlcnZlci5vbihFdmVudC5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xyXG4gIG9ic2VydmVyLm9uKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCBmb3J3YXJkTWVzc2FnZSk7XHJcblxyXG4gIC8vIHNwZWNpYWwgY2FzZSBmb3IgRlJBR19QQVJTSU5HX0RBVEE6IHBhc3MgZGF0YTEvZGF0YTIgYXMgdHJhbnNmZXJhYmxlIG9iamVjdCAobm8gY29weSlcclxuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwgZnVuY3Rpb24gKGV2LCBkYXRhKSB7XHJcbiAgICBsZXQgdHJhbnNmZXJhYmxlID0gW107XHJcbiAgICBsZXQgbWVzc2FnZSA9IHsgZXZlbnQ6IGV2LCBkYXRhOiBkYXRhIH07XHJcbiAgICBpZiAoZGF0YS5kYXRhMSkge1xyXG4gICAgICBtZXNzYWdlLmRhdGExID0gZGF0YS5kYXRhMS5idWZmZXI7XHJcbiAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKGRhdGEuZGF0YTEuYnVmZmVyKTtcclxuICAgICAgZGVsZXRlIGRhdGEuZGF0YTE7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YS5kYXRhMikge1xyXG4gICAgICBtZXNzYWdlLmRhdGEyID0gZGF0YS5kYXRhMi5idWZmZXI7XHJcbiAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKGRhdGEuZGF0YTIuYnVmZmVyKTtcclxuICAgICAgZGVsZXRlIGRhdGEuZGF0YTI7XHJcbiAgICB9XHJcbiAgICBzZWxmLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEZW11eGVyV29ya2VyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9kZW11eC9kZW11eGVyLXdvcmtlci5qcyIsImltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xyXG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuXHJcbmV4cG9ydCBjb25zdCBTVEFMTF9NSU5JTVVNX0RVUkFUSU9OX01TID0gMjUwO1xyXG5leHBvcnQgY29uc3QgTUFYX1NUQVJUX0dBUF9KVU1QID0gMi4wO1xyXG5leHBvcnQgY29uc3QgU0tJUF9CVUZGRVJfSE9MRV9TVEVQX1NFQ09ORFMgPSAwLjE7XHJcbmV4cG9ydCBjb25zdCBTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVCA9IDAuMDU7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYXBDb250cm9sbGVyIHtcclxuICBjb25zdHJ1Y3RvciAoY29uZmlnLCBtZWRpYSwgZnJhZ21lbnRUcmFja2VyLCBobHMpIHtcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xyXG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XHJcbiAgICB0aGlzLmhscyA9IGhscztcclxuICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XHJcbiAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XHJcbiAgICB0aGlzLm1vdmVkID0gZmFsc2U7XHJcbiAgICB0aGlzLnNlZWtpbmcgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGUgcGxheWhlYWQgaXMgc3R1Y2sgd2l0aGluIGEgZ2FwLCBhbmQgaWYgc28sIGF0dGVtcHRzIHRvIGZyZWUgaXQuXHJcbiAgICogQSBnYXAgaXMgYW4gdW5idWZmZXJlZCByYW5nZSBiZXR3ZWVuIHR3byBidWZmZXJlZCByYW5nZXMgKG9yIHRoZSBzdGFydCBhbmQgdGhlIGZpcnN0IGJ1ZmZlcmVkIHJhbmdlKS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0Q3VycmVudFRpbWUgUHJldmlvdXNseSByZWFkIHBsYXloZWFkIHBvc2l0aW9uXHJcbiAgICovXHJcbiAgcG9sbCAobGFzdEN1cnJlbnRUaW1lKSB7XHJcbiAgICBjb25zdCB7IGNvbmZpZywgbWVkaWEsIHN0YWxsZWQgfSA9IHRoaXM7XHJcbiAgICBjb25zdCB7IGN1cnJlbnRUaW1lLCBzZWVraW5nIH0gPSBtZWRpYTtcclxuICAgIGNvbnN0IHNlZWtlZCA9IHRoaXMuc2Vla2luZyAmJiAhc2Vla2luZztcclxuICAgIGNvbnN0IGJlZ2luU2VlayA9ICF0aGlzLnNlZWtpbmcgJiYgc2Vla2luZztcclxuXHJcbiAgICB0aGlzLnNlZWtpbmcgPSBzZWVraW5nO1xyXG5cclxuICAgIC8vIFRoZSBwbGF5aGVhZCBpcyBtb3ZpbmcsIG5vLW9wXHJcbiAgICBpZiAoY3VycmVudFRpbWUgIT09IGxhc3RDdXJyZW50VGltZSkge1xyXG4gICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcclxuICAgICAgaWYgKHN0YWxsZWQgIT09IG51bGwpIHtcclxuICAgICAgICAvLyBUaGUgcGxheWhlYWQgaXMgbm93IG1vdmluZywgYnV0IHdhcyBwcmV2aW91c2x5IHN0YWxsZWRcclxuICAgICAgICBpZiAodGhpcy5zdGFsbFJlcG9ydGVkKSB7XHJcbiAgICAgICAgICBjb25zdCBzdGFsbGVkRHVyYXRpb24gPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhbGxlZDtcclxuICAgICAgICAgIGxvZ2dlci53YXJuKGBwbGF5YmFjayBub3Qgc3R1Y2sgYW55bW9yZSBAJHtjdXJyZW50VGltZX0sIGFmdGVyICR7TWF0aC5yb3VuZChzdGFsbGVkRHVyYXRpb24pfW1zYCk7XHJcbiAgICAgICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcclxuICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDbGVhciBzdGFsbGVkIHN0YXRlIHdoZW4gYmVnaW5uaW5nIG9yIGZpbmlzaGluZyBzZWVraW5nIHNvIHRoYXQgd2UgZG9uJ3QgcmVwb3J0IHN0YWxscyBjb21pbmcgb3V0IG9mIGEgc2Vla1xyXG4gICAgaWYgKGJlZ2luU2VlayB8fCBzZWVrZWQpIHtcclxuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgcGxheWhlYWQgc2hvdWxkIG5vdCBiZSBtb3ZpbmdcclxuICAgIGlmIChtZWRpYS5wYXVzZWQgfHwgbWVkaWEuZW5kZWQgfHwgbWVkaWEucGxheWJhY2tSYXRlID09PSAwIHx8ICFtZWRpYS5idWZmZXJlZC5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xyXG4gICAgY29uc3QgaXNCdWZmZXJlZCA9IGJ1ZmZlckluZm8ubGVuID4gMDtcclxuICAgIGNvbnN0IG5leHRTdGFydCA9IGJ1ZmZlckluZm8ubmV4dFN0YXJ0IHx8IDA7XHJcblxyXG4gICAgLy8gVGhlcmUgaXMgbm8gcGxheWFibGUgYnVmZmVyICh3YWl0aW5nIGZvciBidWZmZXIgYXBwZW5kKVxyXG4gICAgaWYgKCFpc0J1ZmZlcmVkICYmICFuZXh0U3RhcnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZWVraW5nKSB7XHJcbiAgICAgIC8vIFdhaXRpbmcgZm9yIHNlZWtpbmcgaW4gYSBidWZmZXJlZCByYW5nZSB0byBjb21wbGV0ZVxyXG4gICAgICBjb25zdCBoYXNFbm91Z2hCdWZmZXIgPSBidWZmZXJJbmZvLmxlbiA+IE1BWF9TVEFSVF9HQVBfSlVNUDtcclxuICAgICAgLy8gTmV4dCBidWZmZXJlZCByYW5nZSBpcyB0b28gZmFyIGFoZWFkIHRvIGp1bXAgdG8gd2hpbGUgc3RpbGwgc2Vla2luZ1xyXG4gICAgICBjb25zdCBub0J1ZmZlckdhcCA9ICFuZXh0U3RhcnQgfHwgbmV4dFN0YXJ0IC0gY3VycmVudFRpbWUgPiBNQVhfU1RBUlRfR0FQX0pVTVA7XHJcbiAgICAgIGlmIChoYXNFbm91Z2hCdWZmZXIgfHwgbm9CdWZmZXJHYXApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLy8gUmVzZXQgbW92ZWQgc3RhdGUgd2hlbiBzZWVraW5nIHRvIGEgcG9pbnQgaW4gb3IgYmVmb3JlIGEgZ2FwXHJcbiAgICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTa2lwIHN0YXJ0IGdhcHMgaWYgd2UgaGF2ZW4ndCBwbGF5ZWQsIGJ1dCB0aGUgbGFzdCBwb2xsIGRldGVjdGVkIHRoZSBzdGFydCBvZiBhIHN0YWxsXHJcbiAgICAvLyBUaGUgYWRkaXRpb24gcG9sbCBnaXZlcyB0aGUgYnJvd3NlciBhIGNoYW5jZSB0byBqdW1wIHRoZSBnYXAgZm9yIHVzXHJcbiAgICBpZiAoIXRoaXMubW92ZWQgJiYgdGhpcy5zdGFsbGVkKSB7XHJcbiAgICAgIC8vIEp1bXAgc3RhcnQgZ2FwcyB3aXRoaW4ganVtcCB0aHJlc2hvbGRcclxuICAgICAgY29uc3Qgc3RhcnRKdW1wID0gTWF0aC5tYXgobmV4dFN0YXJ0LCBidWZmZXJJbmZvLnN0YXJ0IHx8IDApIC0gY3VycmVudFRpbWU7XHJcbiAgICAgIGlmIChzdGFydEp1bXAgPiAwICYmIHN0YXJ0SnVtcCA8PSBNQVhfU1RBUlRfR0FQX0pVTVApIHtcclxuICAgICAgICB0aGlzLl90cnlTa2lwQnVmZmVySG9sZShudWxsKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGFydCB0cmFja2luZyBzdGFsbCB0aW1lXHJcbiAgICBjb25zdCB0bm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIGlmIChzdGFsbGVkID09PSBudWxsKSB7XHJcbiAgICAgIHRoaXMuc3RhbGxlZCA9IHRub3c7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdGFsbGVkRHVyYXRpb24gPSB0bm93IC0gc3RhbGxlZDtcclxuICAgIGlmICghc2Vla2luZyAmJiBzdGFsbGVkRHVyYXRpb24gPj0gU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUykge1xyXG4gICAgICAvLyBSZXBvcnQgc3RhbGxpbmcgYWZ0ZXIgdHJ5aW5nIHRvIGZpeFxyXG4gICAgICB0aGlzLl9yZXBvcnRTdGFsbChidWZmZXJJbmZvLmxlbik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYnVmZmVyZWRXaXRoSG9sZXMgPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcclxuICAgIHRoaXMuX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlcmVkV2l0aEhvbGVzLCBzdGFsbGVkRHVyYXRpb24pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZWN0cyBhbmQgYXR0ZW1wdHMgdG8gZml4IGtub3duIGJ1ZmZlciBzdGFsbGluZyBpc3N1ZXMuXHJcbiAgICogQHBhcmFtIGJ1ZmZlckluZm8gLSBUaGUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXHJcbiAgICogQHBhcmFtIHN0YWxsZWREdXJhdGlvbk1zIC0gVGhlIGFtb3VudCBvZiB0aW1lIEhscy5qcyBoYXMgYmVlbiBzdGFsbGluZyBmb3IuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfdHJ5Rml4QnVmZmVyU3RhbGwgKGJ1ZmZlckluZm8sIHN0YWxsZWREdXJhdGlvbk1zKSB7XHJcbiAgICBjb25zdCB7IGNvbmZpZywgZnJhZ21lbnRUcmFja2VyLCBtZWRpYSB9ID0gdGhpcztcclxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XHJcblxyXG4gICAgY29uc3QgcGFydGlhbCA9IGZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQoY3VycmVudFRpbWUpO1xyXG4gICAgaWYgKHBhcnRpYWwpIHtcclxuICAgICAgLy8gVHJ5IHRvIHNraXAgb3ZlciB0aGUgYnVmZmVyIGhvbGUgY2F1c2VkIGJ5IGEgcGFydGlhbCBmcmFnbWVudFxyXG4gICAgICAvLyBUaGlzIG1ldGhvZCBpc24ndCBsaW1pdGVkIGJ5IHRoZSBzaXplIG9mIHRoZSBnYXAgYmV0d2VlbiBidWZmZXJlZCByYW5nZXNcclxuICAgICAgY29uc3QgdGFyZ2V0VGltZSA9IHRoaXMuX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWwpO1xyXG4gICAgICAvLyB3ZSByZXR1cm4gaGVyZSBpbiB0aGlzIGNhc2UsIG1lYW5pbmdcclxuICAgICAgLy8gdGhlIGJyYW5jaCBiZWxvdyBvbmx5IGV4ZWN1dGVzIHdoZW4gd2UgZG9uJ3QgaGFuZGxlIGEgcGFydGlhbCBmcmFnbWVudFxyXG4gICAgICBpZiAodGFyZ2V0VGltZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHdlIGhhdmVuJ3QgaGFkIHRvIHNraXAgb3ZlciBhIGJ1ZmZlciBob2xlIG9mIGEgcGFydGlhbCBmcmFnbWVudFxyXG4gICAgLy8gd2UgbWF5IGp1c3QgaGF2ZSB0byBcIm51ZGdlXCIgdGhlIHBsYXlsaXN0IGFzIHRoZSBicm93c2VyIGRlY29kaW5nL3JlbmRlcmluZyBlbmdpbmVcclxuICAgIC8vIG5lZWRzIHRvIGNyb3NzIHNvbWUgc29ydCBvZiB0aHJlc2hvbGQgY292ZXJpbmcgYWxsIHNvdXJjZS1idWZmZXJzIGNvbnRlbnRcclxuICAgIC8vIHRvIHN0YXJ0IHBsYXlpbmcgcHJvcGVybHkuXHJcbiAgICBpZiAoYnVmZmVySW5mby5sZW4gPiBjb25maWcubWF4QnVmZmVySG9sZSAmJlxyXG4gICAgICBzdGFsbGVkRHVyYXRpb25NcyA+IGNvbmZpZy5oaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2QgKiAxMDAwKSB7XHJcbiAgICAgIGxvZ2dlci53YXJuKCdUcnlpbmcgdG8gbnVkZ2UgcGxheWhlYWQgb3ZlciBidWZmZXItaG9sZScpO1xyXG4gICAgICAvLyBUcnkgdG8gbnVkZ2UgY3VycmVudFRpbWUgb3ZlciBhIGJ1ZmZlciBob2xlIGlmIHdlJ3ZlIGJlZW4gc3RhbGxpbmcgZm9yIHRoZSBjb25maWd1cmVkIGFtb3VudCBvZiBzZWNvbmRzXHJcbiAgICAgIC8vIFdlIG9ubHkgdHJ5IHRvIGp1bXAgdGhlIGhvbGUgaWYgaXQncyB1bmRlciB0aGUgY29uZmlndXJlZCBzaXplXHJcbiAgICAgIC8vIFJlc2V0IHN0YWxsZWQgc28gdG8gcmVhcm0gd2F0Y2hkb2cgdGltZXJcclxuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcclxuICAgICAgdGhpcy5fdHJ5TnVkZ2VCdWZmZXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXJzIGEgQlVGRkVSX1NUQUxMRURfRVJST1IgZXZlbnQsIGJ1dCBvbmx5IG9uY2UgcGVyIHN0YWxsIHBlcmlvZC5cclxuICAgKiBAcGFyYW0gYnVmZmVyTGVuIC0gVGhlIHBsYXloZWFkIGRpc3RhbmNlIGZyb20gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXIgc2VnbWVudC5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9yZXBvcnRTdGFsbCAoYnVmZmVyTGVuKSB7XHJcbiAgICBjb25zdCB7IGhscywgbWVkaWEsIHN0YWxsUmVwb3J0ZWQgfSA9IHRoaXM7XHJcbiAgICBpZiAoIXN0YWxsUmVwb3J0ZWQpIHtcclxuICAgICAgLy8gUmVwb3J0IHN0YWxsZWQgZXJyb3Igb25jZVxyXG4gICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xyXG4gICAgICBsb2dnZXIud2FybihgUGxheWJhY2sgc3RhbGxpbmcgYXQgQCR7bWVkaWEuY3VycmVudFRpbWV9IGR1ZSB0byBsb3cgYnVmZmVyYCk7XHJcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XHJcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcclxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsXHJcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxyXG4gICAgICAgIGJ1ZmZlcjogYnVmZmVyTGVuXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkganVtcGluZyBvdmVyIGtub3duIGdhcHMgY2F1c2VkIGJ5IHBhcnRpYWwgZnJhZ21lbnRzXHJcbiAgICogQHBhcmFtIHBhcnRpYWwgLSBUaGUgcGFydGlhbCBmcmFnbWVudCBmb3VuZCBhdCB0aGUgY3VycmVudCB0aW1lICh3aGVyZSBwbGF5YmFjayBpcyBzdGFsbGluZykuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfdHJ5U2tpcEJ1ZmZlckhvbGUgKHBhcnRpYWwpIHtcclxuICAgIGNvbnN0IHsgY29uZmlnLCBobHMsIG1lZGlhIH0gPSB0aGlzO1xyXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcclxuICAgIGxldCBsYXN0RW5kVGltZSA9IDA7XHJcbiAgICAvLyBDaGVjayBpZiBjdXJyZW50VGltZSBpcyBiZXR3ZWVuIHVuYnVmZmVyZWQgcmVnaW9ucyBvZiBwYXJ0aWFsIGZyYWdtZW50c1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWRpYS5idWZmZXJlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBtZWRpYS5idWZmZXJlZC5zdGFydChpKTtcclxuICAgICAgaWYgKGN1cnJlbnRUaW1lICsgY29uZmlnLm1heEJ1ZmZlckhvbGUgPj0gbGFzdEVuZFRpbWUgJiYgY3VycmVudFRpbWUgPCBzdGFydFRpbWUpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRUaW1lID0gTWF0aC5tYXgoc3RhcnRUaW1lICsgU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQsIG1lZGlhLmN1cnJlbnRUaW1lICsgU0tJUF9CVUZGRVJfSE9MRV9TVEVQX1NFQ09ORFMpO1xyXG4gICAgICAgIGxvZ2dlci53YXJuKGBza2lwcGluZyBob2xlLCBhZGp1c3RpbmcgY3VycmVudFRpbWUgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke3RhcmdldFRpbWV9YCk7XHJcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcclxuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XHJcbiAgICAgICAgaWYgKHBhcnRpYWwpIHtcclxuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XHJcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXHJcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEUsXHJcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVhc29uOiBgZnJhZ21lbnQgbG9hZGVkIHdpdGggYnVmZmVyIGhvbGVzLCBzZWVraW5nIGZyb20gJHtjdXJyZW50VGltZX0gdG8gJHt0YXJnZXRUaW1lfWAsXHJcbiAgICAgICAgICAgIGZyYWc6IHBhcnRpYWxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0VGltZTtcclxuICAgICAgfVxyXG4gICAgICBsYXN0RW5kVGltZSA9IG1lZGlhLmJ1ZmZlcmVkLmVuZChpKTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkgYWR2YW5jaW5nIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUgYnkgYSBzbWFsbCBhbW91bnQuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfdHJ5TnVkZ2VCdWZmZXIgKCkge1xyXG4gICAgY29uc3QgeyBjb25maWcsIGhscywgbWVkaWEgfSA9IHRoaXM7XHJcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xyXG4gICAgY29uc3QgbnVkZ2VSZXRyeSA9ICh0aGlzLm51ZGdlUmV0cnkgfHwgMCkgKyAxO1xyXG4gICAgdGhpcy5udWRnZVJldHJ5ID0gbnVkZ2VSZXRyeTtcclxuXHJcbiAgICBpZiAobnVkZ2VSZXRyeSA8IGNvbmZpZy5udWRnZU1heFJldHJ5KSB7XHJcbiAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBjdXJyZW50VGltZSArIG51ZGdlUmV0cnkgKiBjb25maWcubnVkZ2VPZmZzZXQ7XHJcbiAgICAgIC8vIHBsYXliYWNrIHN0YWxsZWQgaW4gYnVmZmVyZWQgYXJlYSAuLi4gbGV0J3MgbnVkZ2UgY3VycmVudFRpbWUgdG8gdHJ5IHRvIG92ZXJjb21lIHRoaXNcclxuICAgICAgbG9nZ2VyLndhcm4oYE51ZGdpbmcgJ2N1cnJlbnRUaW1lJyBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gKTtcclxuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xyXG5cclxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcclxuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxyXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfTlVER0VfT05fU1RBTEwsXHJcbiAgICAgICAgZmF0YWw6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKGBQbGF5aGVhZCBzdGlsbCBub3QgbW92aW5nIHdoaWxlIGVub3VnaCBkYXRhIGJ1ZmZlcmVkIEAke2N1cnJlbnRUaW1lfSBhZnRlciAke2NvbmZpZy5udWRnZU1heFJldHJ5fSBudWRnZXNgKTtcclxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcclxuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxyXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUixcclxuICAgICAgICBmYXRhbDogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY29udHJvbGxlci9nYXAtY29udHJvbGxlci5qcyIsIi8qXHJcbiAqIExldmVsIENvbnRyb2xsZXJcclxuKi9cclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5pbXBvcnQgeyBpc0NvZGVjU3VwcG9ydGVkSW5NcDQgfSBmcm9tICcuLi91dGlscy9jb2RlY3MnO1xyXG5pbXBvcnQgeyBhZGRHcm91cElkLCBjb21wdXRlUmVsb2FkSW50ZXJ2YWwgfSBmcm9tICcuL2xldmVsLWhlbHBlcic7XHJcblxyXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSB3aW5kb3c7XHJcbmxldCBjaHJvbWVPckZpcmVmb3g7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXZlbENvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xyXG4gIGNvbnN0cnVjdG9yIChobHMpIHtcclxuICAgIHN1cGVyKGhscyxcclxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BREVELFxyXG4gICAgICBFdmVudC5MRVZFTF9MT0FERUQsXHJcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELFxyXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcclxuICAgICAgRXZlbnQuRVJST1IpO1xyXG5cclxuICAgIHRoaXMuY2FubG9hZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG51bGw7XHJcbiAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcclxuICAgIHRoaXMudGltZXIgPSBudWxsO1xyXG5cclxuICAgIGNocm9tZU9yRmlyZWZveCA9IC9jaHJvbWV8ZmlyZWZveC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG4gIH1cclxuXHJcbiAgb25IYW5kbGVyRGVzdHJveWluZyAoKSB7XHJcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcclxuICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IC0xO1xyXG4gIH1cclxuXHJcbiAgY2xlYXJUaW1lciAoKSB7XHJcbiAgICBpZiAodGhpcy50aW1lciAhPT0gbnVsbCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XHJcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhcnRMb2FkICgpIHtcclxuICAgIGxldCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XHJcblxyXG4gICAgdGhpcy5jYW5sb2FkID0gdHJ1ZTtcclxuICAgIHRoaXMubGV2ZWxSZXRyeUNvdW50ID0gMDtcclxuXHJcbiAgICAvLyBjbGVhbiB1cCBsaXZlIGxldmVsIGRldGFpbHMgdG8gZm9yY2UgcmVsb2FkIHRoZW0sIGFuZCByZXNldCBsb2FkIGVycm9yc1xyXG4gICAgaWYgKGxldmVscykge1xyXG4gICAgICBsZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XHJcbiAgICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcclxuICAgICAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xyXG4gICAgICAgIGlmIChsZXZlbERldGFpbHMgJiYgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcclxuICAgICAgICAgIGxldmVsLmRldGFpbHMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIHNwZWVkIHVwIGxpdmUgcGxheWxpc3QgcmVmcmVzaCBpZiB0aW1lciBleGlzdHNcclxuICAgIGlmICh0aGlzLnRpbWVyICE9PSBudWxsKSB7XHJcbiAgICAgIHRoaXMubG9hZExldmVsKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdG9wTG9hZCAoKSB7XHJcbiAgICB0aGlzLmNhbmxvYWQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIG9uTWFuaWZlc3RMb2FkZWQgKGRhdGEpIHtcclxuICAgIGxldCBsZXZlbHMgPSBbXTtcclxuICAgIGxldCBhdWRpb1RyYWNrcyA9IFtdO1xyXG4gICAgbGV0IGJpdHJhdGVTdGFydDtcclxuICAgIGxldCBsZXZlbFNldCA9IHt9O1xyXG4gICAgbGV0IGxldmVsRnJvbVNldCA9IG51bGw7XHJcbiAgICBsZXQgdmlkZW9Db2RlY0ZvdW5kID0gZmFsc2U7XHJcbiAgICBsZXQgYXVkaW9Db2RlY0ZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgLy8gcmVncm91cCByZWR1bmRhbnQgbGV2ZWxzIHRvZ2V0aGVyXHJcbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcclxuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGxldmVsLmF0dHJzO1xyXG4gICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xyXG4gICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gZmFsc2U7XHJcblxyXG4gICAgICB2aWRlb0NvZGVjRm91bmQgPSB2aWRlb0NvZGVjRm91bmQgfHwgISFsZXZlbC52aWRlb0NvZGVjO1xyXG4gICAgICBhdWRpb0NvZGVjRm91bmQgPSBhdWRpb0NvZGVjRm91bmQgfHwgISFsZXZlbC5hdWRpb0NvZGVjO1xyXG5cclxuICAgICAgLy8gZXJhc2UgYXVkaW8gY29kZWMgaW5mbyBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbXA0YS40MC4zNC5cclxuICAgICAgLy8gZGVtdXhlciB3aWxsIGF1dG9kZXRlY3QgY29kZWMgYW5kIGZhbGxiYWNrIHRvIG1wZWcvYXVkaW9cclxuICAgICAgaWYgKGNocm9tZU9yRmlyZWZveCAmJiBsZXZlbC5hdWRpb0NvZGVjICYmIGxldmVsLmF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4zNCcpICE9PSAtMSkge1xyXG4gICAgICAgIGxldmVsLmF1ZGlvQ29kZWMgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldmVsRnJvbVNldCA9IGxldmVsU2V0W2xldmVsLmJpdHJhdGVdOyAvLyBGSVhNRTogd2Ugd291bGQgYWxzbyBoYXZlIHRvIG1hdGNoIHRoZSByZXNvbHV0aW9uIGhlcmVcclxuXHJcbiAgICAgIGlmICghbGV2ZWxGcm9tU2V0KSB7XHJcbiAgICAgICAgbGV2ZWwudXJsID0gW2xldmVsLnVybF07XHJcbiAgICAgICAgbGV2ZWwudXJsSWQgPSAwO1xyXG4gICAgICAgIGxldmVsU2V0W2xldmVsLmJpdHJhdGVdID0gbGV2ZWw7XHJcbiAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldmVsRnJvbVNldC51cmwucHVzaChsZXZlbC51cmwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYXR0cmlidXRlcykge1xyXG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLkFVRElPKSB7XHJcbiAgICAgICAgICBhdWRpb0NvZGVjRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgYWRkR3JvdXBJZChsZXZlbEZyb21TZXQgfHwgbGV2ZWwsICdhdWRpbycsIGF0dHJpYnV0ZXMuQVVESU8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXR0cmlidXRlcy5TVUJUSVRMRVMpIHtcclxuICAgICAgICAgIGFkZEdyb3VwSWQobGV2ZWxGcm9tU2V0IHx8IGxldmVsLCAndGV4dCcsIGF0dHJpYnV0ZXMuU1VCVElUTEVTKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHJlbW92ZSBhdWRpby1vbmx5IGxldmVsIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCBhdWRpbyt2aWRlbyBjb2RlY3Mgc2lnbmFsbGVkXHJcbiAgICBpZiAodmlkZW9Db2RlY0ZvdW5kICYmIGF1ZGlvQ29kZWNGb3VuZCkge1xyXG4gICAgICBsZXZlbHMgPSBsZXZlbHMuZmlsdGVyKCh7IHZpZGVvQ29kZWMgfSkgPT4gISF2aWRlb0NvZGVjKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBvbmx5IGtlZXAgbGV2ZWxzIHdpdGggc3VwcG9ydGVkIGF1ZGlvL3ZpZGVvIGNvZGVjc1xyXG4gICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcigoeyBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjIH0pID0+IHtcclxuICAgICAgcmV0dXJuICghYXVkaW9Db2RlYyB8fCBpc0NvZGVjU3VwcG9ydGVkSW5NcDQoYXVkaW9Db2RlYywgJ2F1ZGlvJykpICYmICghdmlkZW9Db2RlYyB8fCBpc0NvZGVjU3VwcG9ydGVkSW5NcDQodmlkZW9Db2RlYywgJ3ZpZGVvJykpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGRhdGEuYXVkaW9UcmFja3MpIHtcclxuICAgICAgYXVkaW9UcmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzLmZpbHRlcih0cmFjayA9PiAhdHJhY2suYXVkaW9Db2RlYyB8fCBpc0NvZGVjU3VwcG9ydGVkSW5NcDQodHJhY2suYXVkaW9Db2RlYywgJ2F1ZGlvJykpO1xyXG4gICAgICAvLyBSZWFzc2lnbiBpZCdzIGFmdGVyIGZpbHRlcmluZyBzaW5jZSB0aGV5J3JlIHVzZWQgYXMgYXJyYXkgaW5kaWNlc1xyXG4gICAgICBhdWRpb1RyYWNrcy5mb3JFYWNoKCh0cmFjaywgaW5kZXgpID0+IHtcclxuICAgICAgICB0cmFjay5pZCA9IGluZGV4O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgLy8gc3RhcnQgYml0cmF0ZSBpcyB0aGUgZmlyc3QgYml0cmF0ZSBvZiB0aGUgbWFuaWZlc3RcclxuICAgICAgYml0cmF0ZVN0YXJ0ID0gbGV2ZWxzWzBdLmJpdHJhdGU7XHJcbiAgICAgIC8vIHNvcnQgbGV2ZWwgb24gYml0cmF0ZVxyXG4gICAgICBsZXZlbHMuc29ydCgoYSwgYikgPT4gYS5iaXRyYXRlIC0gYi5iaXRyYXRlKTtcclxuICAgICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xyXG4gICAgICAvLyBmaW5kIGluZGV4IG9mIGZpcnN0IGxldmVsIGluIHNvcnRlZCBsZXZlbHNcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAobGV2ZWxzW2ldLmJpdHJhdGUgPT09IGJpdHJhdGVTdGFydCkge1xyXG4gICAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IGk7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGBtYW5pZmVzdCBsb2FkZWQsJHtsZXZlbHMubGVuZ3RofSBsZXZlbChzKSBmb3VuZCwgZmlyc3QgYml0cmF0ZToke2JpdHJhdGVTdGFydH1gKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQXVkaW8gaXMgb25seSBhbHRlcm5hdGUgaWYgbWFuaWZlc3QgaW5jbHVkZSBhIFVSSSBhbG9uZyB3aXRoIHRoZSBhdWRpbyBncm91cCB0YWdcclxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5NQU5JRkVTVF9QQVJTRUQsIHtcclxuICAgICAgICBsZXZlbHMsXHJcbiAgICAgICAgYXVkaW9UcmFja3MsXHJcbiAgICAgICAgZmlyc3RMZXZlbDogdGhpcy5fZmlyc3RMZXZlbCxcclxuICAgICAgICBzdGF0czogZGF0YS5zdGF0cyxcclxuICAgICAgICBhdWRpbzogYXVkaW9Db2RlY0ZvdW5kLFxyXG4gICAgICAgIHZpZGVvOiB2aWRlb0NvZGVjRm91bmQsXHJcbiAgICAgICAgYWx0QXVkaW86IGF1ZGlvVHJhY2tzLnNvbWUodCA9PiAhIXQudXJsKVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcclxuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxyXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxyXG4gICAgICAgIGZhdGFsOiB0cnVlLFxyXG4gICAgICAgIHVybDogdGhpcy5obHMudXJsLFxyXG4gICAgICAgIHJlYXNvbjogJ25vIGxldmVsIHdpdGggY29tcGF0aWJsZSBjb2RlY3MgZm91bmQgaW4gbWFuaWZlc3QnXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0IGxldmVscyAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGxldmVsICgpIHtcclxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xyXG4gIH1cclxuXHJcbiAgc2V0IGxldmVsIChuZXdMZXZlbCkge1xyXG4gICAgbGV0IGxldmVscyA9IHRoaXMuX2xldmVscztcclxuICAgIGlmIChsZXZlbHMpIHtcclxuICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1pbihuZXdMZXZlbCwgbGV2ZWxzLmxlbmd0aCAtIDEpO1xyXG4gICAgICBpZiAodGhpcy5jdXJyZW50TGV2ZWxJbmRleCAhPT0gbmV3TGV2ZWwgfHwgIWxldmVsc1tuZXdMZXZlbF0uZGV0YWlscykge1xyXG4gICAgICAgIHRoaXMuc2V0TGV2ZWxJbnRlcm5hbChuZXdMZXZlbCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldExldmVsSW50ZXJuYWwgKG5ld0xldmVsKSB7XHJcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XHJcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcclxuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxyXG4gICAgaWYgKG5ld0xldmVsID49IDAgJiYgbmV3TGV2ZWwgPCBsZXZlbHMubGVuZ3RoKSB7XHJcbiAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxyXG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcclxuICAgICAgaWYgKHRoaXMuY3VycmVudExldmVsSW5kZXggIT09IG5ld0xldmVsKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIHRvIGxldmVsICR7bmV3TGV2ZWx9YCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG5ld0xldmVsO1xyXG4gICAgICAgIGNvbnN0IGxldmVsUHJvcGVydGllcyA9IGxldmVsc1tuZXdMZXZlbF07XHJcbiAgICAgICAgbGV2ZWxQcm9wZXJ0aWVzLmxldmVsID0gbmV3TGV2ZWw7XHJcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfU1dJVENISU5HLCBsZXZlbFByb3BlcnRpZXMpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW25ld0xldmVsXTtcclxuICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcclxuXHJcbiAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBsZXZlbFxyXG4gICAgICBpZiAoIWxldmVsRGV0YWlscyB8fCBsZXZlbERldGFpbHMubGl2ZSkge1xyXG4gICAgICAgIC8vIGxldmVsIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcclxuICAgICAgICBsZXQgdXJsSWQgPSBsZXZlbC51cmxJZDtcclxuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5MRVZFTF9MT0FESU5HLCB7IHVybDogbGV2ZWwudXJsW3VybElkXSwgbGV2ZWw6IG5ld0xldmVsLCBpZDogdXJsSWQgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcclxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcclxuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxyXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9TV0lUQ0hfRVJST1IsXHJcbiAgICAgICAgbGV2ZWw6IG5ld0xldmVsLFxyXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcclxuICAgICAgICByZWFzb246ICdpbnZhbGlkIGxldmVsIGlkeCdcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgbWFudWFsTGV2ZWwgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWFudWFsTGV2ZWxJbmRleDtcclxuICB9XHJcblxyXG4gIHNldCBtYW51YWxMZXZlbCAobmV3TGV2ZWwpIHtcclxuICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IG5ld0xldmVsO1xyXG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLl9zdGFydExldmVsID0gbmV3TGV2ZWw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xyXG4gICAgICB0aGlzLmxldmVsID0gbmV3TGV2ZWw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgZmlyc3RMZXZlbCAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcclxuICB9XHJcblxyXG4gIHNldCBmaXJzdExldmVsIChuZXdMZXZlbCkge1xyXG4gICAgdGhpcy5fZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHN0YXJ0TGV2ZWwgKCkge1xyXG4gICAgLy8gaGxzLnN0YXJ0TGV2ZWwgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGNvbmZpZy5zdGFydExldmVsXHJcbiAgICAvLyBpZiBub25lIG9mIHRoZXNlIHZhbHVlcyBhcmUgZGVmaW5lZCwgZmFsbGJhY2sgb24gdGhpcy5fZmlyc3RMZXZlbCAoZmlyc3QgcXVhbGl0eSBsZXZlbCBhcHBlYXJpbmcgaW4gdmFyaWFudCBtYW5pZmVzdClcclxuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgbGV0IGNvbmZpZ1N0YXJ0TGV2ZWwgPSB0aGlzLmhscy5jb25maWcuc3RhcnRMZXZlbDtcclxuICAgICAgaWYgKGNvbmZpZ1N0YXJ0TGV2ZWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBjb25maWdTdGFydExldmVsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5fc3RhcnRMZXZlbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldCBzdGFydExldmVsIChuZXdMZXZlbCkge1xyXG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xyXG4gIH1cclxuXHJcbiAgb25FcnJvciAoZGF0YSkge1xyXG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcclxuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbGV2ZWxFcnJvciA9IGZhbHNlLCBmcmFnbWVudEVycm9yID0gZmFsc2U7XHJcbiAgICBsZXQgbGV2ZWxJbmRleDtcclxuXHJcbiAgICAvLyB0cnkgdG8gcmVjb3ZlciBub3QgZmF0YWwgZXJyb3JzXHJcbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xyXG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxyXG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XHJcbiAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcclxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XHJcbiAgICAgIGxldmVsSW5kZXggPSBkYXRhLmZyYWcubGV2ZWw7XHJcbiAgICAgIGZyYWdtZW50RXJyb3IgPSB0cnVlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XHJcbiAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XHJcbiAgICAgIGxldmVsSW5kZXggPSBkYXRhLmNvbnRleHQubGV2ZWw7XHJcbiAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SOlxyXG4gICAgICBsZXZlbEluZGV4ID0gZGF0YS5sZXZlbDtcclxuICAgICAgbGV2ZWxFcnJvciA9IHRydWU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChsZXZlbEluZGV4ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5yZWNvdmVyTGV2ZWwoZGF0YSwgbGV2ZWxJbmRleCwgbGV2ZWxFcnJvciwgZnJhZ21lbnRFcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTd2l0Y2ggdG8gYSByZWR1bmRhbnQgc3RyZWFtIGlmIGFueSBhdmFpbGFibGUuXHJcbiAgICogSWYgcmVkdW5kYW50IHN0cmVhbSBpcyBub3QgYXZhaWxhYmxlLCBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgQUJSIG1vZGUgaXMgZW5hYmxlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvckV2ZW50XHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsSW5kZXggY3VycmVudCBsZXZlbCBpbmRleFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbGV2ZWxFcnJvclxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnJhZ21lbnRFcnJvclxyXG4gICAqL1xyXG4gIC8vIEZJWE1FIEZpbmQgYSBiZXR0ZXIgYWJzdHJhY3Rpb24gd2hlcmUgZnJhZ21lbnQvbGV2ZWwgcmV0cnkgbWFuYWdlbWVudCBpcyB3ZWxsIGRlY291cGxlZFxyXG4gIHJlY292ZXJMZXZlbCAoZXJyb3JFdmVudCwgbGV2ZWxJbmRleCwgbGV2ZWxFcnJvciwgZnJhZ21lbnRFcnJvcikge1xyXG4gICAgbGV0IHsgY29uZmlnIH0gPSB0aGlzLmhscztcclxuICAgIGxldCB7IGRldGFpbHM6IGVycm9yRGV0YWlscyB9ID0gZXJyb3JFdmVudDtcclxuICAgIGxldCBsZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbEluZGV4XTtcclxuICAgIGxldCByZWR1bmRhbnRMZXZlbHMsIGRlbGF5LCBuZXh0TGV2ZWw7XHJcblxyXG4gICAgbGV2ZWwubG9hZEVycm9yKys7XHJcbiAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gZnJhZ21lbnRFcnJvcjtcclxuXHJcbiAgICBpZiAobGV2ZWxFcnJvcikge1xyXG4gICAgICBpZiAoKHRoaXMubGV2ZWxSZXRyeUNvdW50ICsgMSkgPD0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5KSB7XHJcbiAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gbWF4IHJldHJ5IHRpbWVvdXRcclxuICAgICAgICBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIHRoaXMubGV2ZWxSZXRyeUNvdW50KSAqIGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5LCBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTtcclxuICAgICAgICAvLyBTY2hlZHVsZSBsZXZlbCByZWxvYWRcclxuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmxvYWRMZXZlbCgpLCBkZWxheSk7XHJcbiAgICAgICAgLy8gYm9vbGVhbiB1c2VkIHRvIGluZm9ybSBzdHJlYW0gY29udHJvbGxlciBub3QgdG8gc3dpdGNoIGJhY2sgdG8gSURMRSBvbiBub24gZmF0YWwgZXJyb3JcclxuICAgICAgICBlcnJvckV2ZW50LmxldmVsUmV0cnkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGV2ZWxSZXRyeUNvdW50Kys7XHJcbiAgICAgICAgbG9nZ2VyLndhcm4oYGxldmVsIGNvbnRyb2xsZXIsICR7ZXJyb3JEZXRhaWxzfSwgcmV0cnkgaW4gJHtkZWxheX0gbXMsIGN1cnJlbnQgcmV0cnkgY291bnQgaXMgJHt0aGlzLmxldmVsUmV0cnlDb3VudH1gKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsb2dnZXIuZXJyb3IoYGxldmVsIGNvbnRyb2xsZXIsIGNhbm5vdCByZWNvdmVyIGZyb20gJHtlcnJvckRldGFpbHN9IGVycm9yYCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG51bGw7XHJcbiAgICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XHJcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XHJcbiAgICAgICAgLy8gc3dpdGNoIGVycm9yIHRvIGZhdGFsXHJcbiAgICAgICAgZXJyb3JFdmVudC5mYXRhbCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJ5IGFueSByZWR1bmRhbnQgc3RyZWFtcyBpZiBhdmFpbGFibGUgZm9yIGJvdGggZXJyb3JzOiBsZXZlbCBhbmQgZnJhZ21lbnRcclxuICAgIC8vIElmIGxldmVsLmxvYWRFcnJvciByZWFjaGVzIHJlZHVuZGFudExldmVscyBpdCBtZWFucyB0aGF0IHdlIHRyaWVkIHRoZW0gYWxsLCBubyBob3BlICA9PiBsZXQncyBzd2l0Y2ggZG93blxyXG4gICAgaWYgKGxldmVsRXJyb3IgfHwgZnJhZ21lbnRFcnJvcikge1xyXG4gICAgICByZWR1bmRhbnRMZXZlbHMgPSBsZXZlbC51cmwubGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKHJlZHVuZGFudExldmVscyA+IDEgJiYgbGV2ZWwubG9hZEVycm9yIDwgcmVkdW5kYW50TGV2ZWxzKSB7XHJcbiAgICAgICAgbGV2ZWwudXJsSWQgPSAobGV2ZWwudXJsSWQgKyAxKSAlIHJlZHVuZGFudExldmVscztcclxuICAgICAgICBsZXZlbC5kZXRhaWxzID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwgJHtlcnJvckRldGFpbHN9IGZvciBsZXZlbCAke2xldmVsSW5kZXh9OiBzd2l0Y2hpbmcgdG8gcmVkdW5kYW50IFVSTC1pZCAke2xldmVsLnVybElkfWApO1xyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnQ3VycmVudCBhdWRpbyB0cmFjayBncm91cCBJRDonLCB0aGlzLmhscy5hdWRpb1RyYWNrc1t0aGlzLmhscy5hdWRpb1RyYWNrXS5ncm91cElkKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnTmV3IHZpZGVvIHF1YWxpdHkgbGV2ZWwgYXVkaW8gZ3JvdXAgaWQ6JywgbGV2ZWwuYXR0cnMuQVVESU8pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFNlYXJjaCBmb3IgYXZhaWxhYmxlIGxldmVsXHJcbiAgICAgICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgIC8vIFdoZW4gbG93ZXN0IGxldmVsIGhhcyBiZWVuIHJlYWNoZWQsIGxldCdzIHN0YXJ0IGh1bnQgZnJvbSB0aGUgdG9wXHJcbiAgICAgICAgICBuZXh0TGV2ZWwgPSAobGV2ZWxJbmRleCA9PT0gMCkgPyB0aGlzLl9sZXZlbHMubGVuZ3RoIC0gMSA6IGxldmVsSW5kZXggLSAxO1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYGxldmVsIGNvbnRyb2xsZXIsICR7ZXJyb3JEZXRhaWxzfTogc3dpdGNoIHRvICR7bmV4dExldmVsfWApO1xyXG4gICAgICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IHRoaXMuY3VycmVudExldmVsSW5kZXggPSBuZXh0TGV2ZWw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmcmFnbWVudEVycm9yKSB7XHJcbiAgICAgICAgICAvLyBBbGxvdyBmcmFnbWVudCByZXRyeSBhcyBsb25nIGFzIGNvbmZpZ3VyYXRpb24gYWxsb3dzLlxyXG4gICAgICAgICAgLy8gcmVzZXQgdGhpcy5fbGV2ZWwgc28gdGhhdCBhbm90aGVyIGNhbGwgdG8gc2V0IGxldmVsKCkgd2lsbCB0cmlnZ2VyIGFnYWluIGEgZnJhZyBsb2FkXHJcbiAgICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwgJHtlcnJvckRldGFpbHN9OiByZWxvYWQgYSBmcmFnbWVudGApO1xyXG4gICAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyByZXNldCBlcnJvcnMgb24gdGhlIHN1Y2Nlc3NmdWwgbG9hZCBvZiBhIGZyYWdtZW50XHJcbiAgb25GcmFnTG9hZGVkICh7IGZyYWcgfSkge1xyXG4gICAgaWYgKGZyYWcgIT09IHVuZGVmaW5lZCAmJiBmcmFnLnR5cGUgPT09ICdtYWluJykge1xyXG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuX2xldmVsc1tmcmFnLmxldmVsXTtcclxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gZmFsc2U7XHJcbiAgICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcclxuICAgICAgICB0aGlzLmxldmVsUmV0cnlDb3VudCA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uTGV2ZWxMb2FkZWQgKGRhdGEpIHtcclxuICAgIGNvbnN0IHsgbGV2ZWwsIGRldGFpbHMgfSA9IGRhdGE7XHJcbiAgICAvLyBvbmx5IHByb2Nlc3MgbGV2ZWwgbG9hZGVkIGV2ZW50cyBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIGxldmVsXHJcbiAgICBpZiAobGV2ZWwgIT09IHRoaXMuY3VycmVudExldmVsSW5kZXgpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGN1ckxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsXTtcclxuICAgIC8vIHJlc2V0IGxldmVsIGxvYWQgZXJyb3IgY291bnRlciBvbiBzdWNjZXNzZnVsIGxldmVsIGxvYWRlZCBvbmx5IGlmIHRoZXJlIGlzIG5vIGlzc3VlcyB3aXRoIGZyYWdtZW50c1xyXG4gICAgaWYgKCFjdXJMZXZlbC5mcmFnbWVudEVycm9yKSB7XHJcbiAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XHJcbiAgICAgIHRoaXMubGV2ZWxSZXRyeUNvdW50ID0gMDtcclxuICAgIH1cclxuICAgIC8vIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0LCBhcm0gYSB0aW1lciB0byByZWxvYWQgaXRcclxuICAgIGlmIChkZXRhaWxzLmxpdmUpIHtcclxuICAgICAgY29uc3QgcmVsb2FkSW50ZXJ2YWwgPSBjb21wdXRlUmVsb2FkSW50ZXJ2YWwoY3VyTGV2ZWwuZGV0YWlscywgZGV0YWlscywgZGF0YS5zdGF0cy50cmVxdWVzdCk7XHJcbiAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHJlbG9hZCBpbiAke01hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpfSBtc2ApO1xyXG4gICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmxvYWRMZXZlbCgpLCByZWxvYWRJbnRlcnZhbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uQXVkaW9UcmFja1N3aXRjaGVkIChkYXRhKSB7XHJcbiAgICBjb25zdCBhdWRpb0dyb3VwSWQgPSB0aGlzLmhscy5hdWRpb1RyYWNrc1tkYXRhLmlkXS5ncm91cElkO1xyXG5cclxuICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IHRoaXMuaGxzLmxldmVsc1t0aGlzLmN1cnJlbnRMZXZlbEluZGV4XTtcclxuICAgIGlmICghY3VycmVudExldmVsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY3VycmVudExldmVsLmF1ZGlvR3JvdXBJZHMpIHtcclxuICAgICAgbGV0IHVybElkID0gLTE7XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzW2ldID09PSBhdWRpb0dyb3VwSWQpIHtcclxuICAgICAgICAgIHVybElkID0gaTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHVybElkICE9PSBjdXJyZW50TGV2ZWwudXJsSWQpIHtcclxuICAgICAgICBjdXJyZW50TGV2ZWwudXJsSWQgPSB1cmxJZDtcclxuICAgICAgICB0aGlzLnN0YXJ0TG9hZCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsb2FkTGV2ZWwgKCkge1xyXG4gICAgbG9nZ2VyLmRlYnVnKCdjYWxsIHRvIGxvYWRMZXZlbCcpO1xyXG5cclxuICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ICE9PSBudWxsICYmIHRoaXMuY2FubG9hZCkge1xyXG4gICAgICBjb25zdCBsZXZlbE9iamVjdCA9IHRoaXMuX2xldmVsc1t0aGlzLmN1cnJlbnRMZXZlbEluZGV4XTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgbGV2ZWxPYmplY3QgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgbGV2ZWxPYmplY3QudXJsLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XHJcbiAgICAgICAgY29uc3QgaWQgPSBsZXZlbE9iamVjdC51cmxJZDtcclxuICAgICAgICBjb25zdCB1cmwgPSBsZXZlbE9iamVjdC51cmxbaWRdO1xyXG5cclxuICAgICAgICBsb2dnZXIubG9nKGBBdHRlbXB0IGxvYWRpbmcgbGV2ZWwgaW5kZXggJHtsZXZlbH0gd2l0aCBVUkwtaWQgJHtpZH1gKTtcclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0N1cnJlbnQgYXVkaW8gdHJhY2sgZ3JvdXAgSUQ6JywgdGhpcy5obHMuYXVkaW9UcmFja3NbdGhpcy5obHMuYXVkaW9UcmFja10uZ3JvdXBJZCk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ05ldyB2aWRlbyBxdWFsaXR5IGxldmVsIGF1ZGlvIGdyb3VwIGlkOicsIGxldmVsT2JqZWN0LmF0dHJzLkFVRElPLCBsZXZlbCk7XHJcblxyXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfTE9BRElORywgeyB1cmwsIGxldmVsLCBpZCB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0IG5leHRMb2FkTGV2ZWwgKCkge1xyXG4gICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCAhPT0gLTEpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubWFudWFsTGV2ZWxJbmRleDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmhscy5uZXh0QXV0b0xldmVsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2V0IG5leHRMb2FkTGV2ZWwgKG5leHRMZXZlbCkge1xyXG4gICAgdGhpcy5sZXZlbCA9IG5leHRMZXZlbDtcclxuICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggPT09IC0xKSB7XHJcbiAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2NvbnRyb2xsZXIvbGV2ZWwtY29udHJvbGxlci5qcyIsIi8qXHJcbiAqIGlkMyBtZXRhZGF0YSB0cmFjayBjb250cm9sbGVyXHJcbiovXHJcblxyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IElEMyBmcm9tICcuLi9kZW11eC9pZDMnO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgeyBzZW5kQWRkVHJhY2tFdmVudCwgY2xlYXJDdXJyZW50Q3VlcywgZ2V0Q2xvc2VzdEN1ZSB9IGZyb20gJy4uL3V0aWxzL3RleHR0cmFjay11dGlscyc7XHJcblxyXG5jbGFzcyBJRDNUcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xyXG4gIGNvbnN0cnVjdG9yIChobHMpIHtcclxuICAgIHN1cGVyKGhscyxcclxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXHJcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcclxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLFxyXG4gICAgICBFdmVudC5MSVZFX0JBQ0tfQlVGRkVSX1JFQUNIRURcclxuICAgICk7XHJcbiAgICB0aGlzLmlkM1RyYWNrID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5tZWRpYSA9IHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3kgKCkge1xyXG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgSUQzIG1ldGF0YWRhdGEgdGV4dCB0cmFjay5cclxuICBvbk1lZGlhQXR0YWNoZWQgKGRhdGEpIHtcclxuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xyXG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XHJcblxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25NZWRpYURldGFjaGluZyAoKSB7XHJcbiAgICBjbGVhckN1cnJlbnRDdWVzKHRoaXMuaWQzVHJhY2spO1xyXG4gICAgdGhpcy5pZDNUcmFjayA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMubWVkaWEgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBnZXRJRDNUcmFjayAodGV4dFRyYWNrcykge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGxldCB0ZXh0VHJhY2sgPSB0ZXh0VHJhY2tzW2ldO1xyXG4gICAgICBpZiAodGV4dFRyYWNrLmtpbmQgPT09ICdtZXRhZGF0YScgJiYgdGV4dFRyYWNrLmxhYmVsID09PSAnaWQzJykge1xyXG4gICAgICAgIC8vIHNlbmQgJ2FkZHRyYWNrJyB3aGVuIHJldXNpbmcgdGhlIHRleHRUcmFjayBmb3IgbWV0YWRhdGEsXHJcbiAgICAgICAgLy8gc2FtZSBhcyB3aGF0IHdlIGRvIGZvciBjYXB0aW9uc1xyXG4gICAgICAgIHNlbmRBZGRUcmFja0V2ZW50KHRleHRUcmFjaywgdGhpcy5tZWRpYSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLm1lZGlhLmFkZFRleHRUcmFjaygnbWV0YWRhdGEnLCAnaWQzJyk7XHJcbiAgfVxyXG5cclxuICBvbkZyYWdQYXJzaW5nTWV0YWRhdGEgKGRhdGEpIHtcclxuICAgIGNvbnN0IGZyYWdtZW50ID0gZGF0YS5mcmFnO1xyXG4gICAgY29uc3Qgc2FtcGxlcyA9IGRhdGEuc2FtcGxlcztcclxuXHJcbiAgICAvLyBjcmVhdGUgdHJhY2sgZHluYW1pY2FsbHlcclxuICAgIGlmICghdGhpcy5pZDNUcmFjaykge1xyXG4gICAgICB0aGlzLmlkM1RyYWNrID0gdGhpcy5nZXRJRDNUcmFjayh0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xyXG4gICAgICB0aGlzLmlkM1RyYWNrLm1vZGUgPSAnaGlkZGVuJztcclxuICAgIH1cclxuXHJcbiAgICAvLyBBdHRlbXB0IHRvIHJlY3JlYXRlIFNhZmFyaSBmdW5jdGlvbmFsaXR5IGJ5IGNyZWF0aW5nXHJcbiAgICAvLyBXZWJLaXREYXRhQ3VlIG9iamVjdHMgd2hlbiBhdmFpbGFibGUgYW5kIHN0b3JlIHRoZSBkZWNvZGVkXHJcbiAgICAvLyBJRDMgZGF0YSBpbiB0aGUgdmFsdWUgcHJvcGVydHkgb2YgdGhlIGN1ZVxyXG4gICAgbGV0IEN1ZSA9IHdpbmRvdy5XZWJLaXREYXRhQ3VlIHx8IHdpbmRvdy5WVFRDdWUgfHwgd2luZG93LlRleHRUcmFja0N1ZTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgZnJhbWVzID0gSUQzLmdldElEM0ZyYW1lcyhzYW1wbGVzW2ldLmRhdGEpO1xyXG4gICAgICBpZiAoZnJhbWVzKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gc2FtcGxlc1tpXS5wdHM7XHJcbiAgICAgICAgbGV0IGVuZFRpbWUgPSBpIDwgc2FtcGxlcy5sZW5ndGggLSAxID8gc2FtcGxlc1tpICsgMV0ucHRzIDogZnJhZ21lbnQuZW5kUFRTO1xyXG5cclxuICAgICAgICBpZiAoc3RhcnRUaW1lID09PSBlbmRUaW1lKSB7XHJcbiAgICAgICAgICAvLyBHaXZlIGEgc2xpZ2h0IGJ1bXAgdG8gdGhlIGVuZFRpbWUgaWYgaXQncyBlcXVhbCB0byBzdGFydFRpbWUgdG8gYXZvaWQgYSBTeW50YXhFcnJvciBpbiBJRVxyXG4gICAgICAgICAgZW5kVGltZSArPSAwLjAwMDE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydFRpbWUgPiBlbmRUaW1lKSB7XHJcbiAgICAgICAgICBsb2dnZXIud2FybignZGV0ZWN0ZWQgYW4gaWQzIHNhbXBsZSB3aXRoIGVuZFRpbWUgPCBzdGFydFRpbWUsIGFkanVzdGluZyBlbmRUaW1lIHRvIChzdGFydFRpbWUgKyAwLjI1KScpO1xyXG4gICAgICAgICAgZW5kVGltZSA9IHN0YXJ0VGltZSArIDAuMjU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZyYW1lcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgY29uc3QgZnJhbWUgPSBmcmFtZXNbal07XHJcbiAgICAgICAgICAvLyBTYWZhcmkgZG9lc24ndCBwdXQgdGhlIHRpbWVzdGFtcCBmcmFtZSBpbiB0aGUgVGV4dFRyYWNrXHJcbiAgICAgICAgICBpZiAoIUlEMy5pc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgJycpO1xyXG4gICAgICAgICAgICBjdWUudmFsdWUgPSBmcmFtZTtcclxuICAgICAgICAgICAgdGhpcy5pZDNUcmFjay5hZGRDdWUoY3VlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uTGl2ZUJhY2tCdWZmZXJSZWFjaGVkICh7IGJ1ZmZlckVuZCB9KSB7XHJcbiAgICBjb25zdCB7IGlkM1RyYWNrIH0gPSB0aGlzO1xyXG4gICAgaWYgKCFpZDNUcmFjayB8fCAhaWQzVHJhY2suY3VlcyB8fCAhaWQzVHJhY2suY3Vlcy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZm91bmRDdWUgPSBnZXRDbG9zZXN0Q3VlKGlkM1RyYWNrLmN1ZXMsIGJ1ZmZlckVuZCk7XHJcbiAgICBpZiAoIWZvdW5kQ3VlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHdoaWxlIChpZDNUcmFjay5jdWVzWzBdICE9PSBmb3VuZEN1ZSkge1xyXG4gICAgICBpZDNUcmFjay5yZW1vdmVDdWUoaWQzVHJhY2suY3Vlc1swXSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJRDNUcmFja0NvbnRyb2xsZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2NvbnRyb2xsZXIvaWQzLXRyYWNrLWNvbnRyb2xsZXIuanMiLCJpbXBvcnQgeyBnZXRNZWRpYVNvdXJjZSB9IGZyb20gJy4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1N1cHBvcnRlZCAoKTogYm9vbGVhbiB7XHJcbiAgY29uc3QgbWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xyXG4gIGlmICghbWVkaWFTb3VyY2UpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgY29uc3Qgc291cmNlQnVmZmVyID0gc2VsZi5Tb3VyY2VCdWZmZXIgfHwgKHNlbGYgYXMgYW55KS5XZWJLaXRTb3VyY2VCdWZmZXIgYXMgU291cmNlQnVmZmVyO1xyXG4gIGNvbnN0IGlzVHlwZVN1cHBvcnRlZCA9IG1lZGlhU291cmNlICYmXHJcbiAgICB0eXBlb2YgbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUUsbXA0YS40MC4yXCInKTtcclxuXHJcbiAgLy8gaWYgU291cmNlQnVmZmVyIGlzIGV4cG9zZWQgZW5zdXJlIGl0cyBBUEkgaXMgdmFsaWRcclxuICAvLyBzYWZhcmkgYW5kIG9sZCB2ZXJzaW9uIG9mIENocm9tZSBkb2Ugbm90IGV4cG9zZSBTb3VyY2VCdWZmZXIgZ2xvYmFsbHkgc28gY2hlY2tpbmcgU291cmNlQnVmZmVyLnByb3RvdHlwZSBpcyBpbXBvc3NpYmxlXHJcbiAgY29uc3Qgc291cmNlQnVmZmVyVmFsaWRBUEkgPSAhc291cmNlQnVmZmVyIHx8XHJcbiAgICAoc291cmNlQnVmZmVyLnByb3RvdHlwZSAmJlxyXG4gICAgICB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5hcHBlbmRCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcclxuICAgICAgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUucmVtb3ZlID09PSAnZnVuY3Rpb24nKTtcclxuICByZXR1cm4gISFpc1R5cGVTdXBwb3J0ZWQgJiYgISFzb3VyY2VCdWZmZXJWYWxpZEFQSTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9pcy1zdXBwb3J0ZWQudHMiLCIvKipcclxuICogSExTIGNvbmZpZ1xyXG4gKi9cclxuXHJcbmltcG9ydCBBYnJDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hYnItY29udHJvbGxlcic7XHJcbmltcG9ydCBCdWZmZXJDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9idWZmZXItY29udHJvbGxlcic7XHJcbmltcG9ydCBDYXBMZXZlbENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyJztcclxuaW1wb3J0IEZQU0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyJztcclxuaW1wb3J0IFhockxvYWRlciBmcm9tICcuL3V0aWxzL3hoci1sb2FkZXInO1xyXG4vLyBpbXBvcnQgRmV0Y2hMb2FkZXIgZnJvbSAnLi91dGlscy9mZXRjaC1sb2FkZXInO1xyXG5cclxuaW1wb3J0IEF1ZGlvVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hdWRpby10cmFjay1jb250cm9sbGVyJztcclxuaW1wb3J0IEF1ZGlvU3RyZWFtQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXInO1xyXG5cclxuaW1wb3J0ICogYXMgQ3VlcyBmcm9tICcuL3V0aWxzL2N1ZXMnO1xyXG5pbXBvcnQgVGltZWxpbmVDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyJztcclxuaW1wb3J0IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyJztcclxuaW1wb3J0IHsgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIH0gZnJvbSAnLi9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyJztcclxuaW1wb3J0IEVNRUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyJztcclxuaW1wb3J0IHsgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzLCBNZWRpYUtleUZ1bmMgfSBmcm9tICcuL3V0aWxzL21lZGlha2V5cy1oZWxwZXInO1xyXG5cclxudHlwZSBBQlJDb250cm9sbGVyQ29uZmlnID0ge1xyXG4gIGFickV3bWFGYXN0TGl2ZTogbnVtYmVyLFxyXG4gIGFickV3bWFTbG93TGl2ZTogbnVtYmVyLFxyXG4gIGFickV3bWFGYXN0Vm9EOiBudW1iZXIsXHJcbiAgYWJyRXdtYVNsb3dWb0Q6IG51bWJlcixcclxuICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiBudW1iZXIsXHJcbiAgYWJyQmFuZFdpZHRoRmFjdG9yOiBudW1iZXIsXHJcbiAgYWJyQmFuZFdpZHRoVXBGYWN0b3I6IG51bWJlcixcclxuICBhYnJNYXhXaXRoUmVhbEJpdHJhdGU6IGJvb2xlYW4sXHJcbiAgbWF4U3RhcnZhdGlvbkRlbGF5OiBudW1iZXIsXHJcbiAgbWF4TG9hZGluZ0RlbGF5OiBudW1iZXIsXHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBCdWZmZXJDb250cm9sbGVyQ29uZmlnID0ge1xyXG4gIGFwcGVuZEVycm9yTWF4UmV0cnk6IG51bWJlcixcclxuICBsaXZlRHVyYXRpb25JbmZpbml0eTogYm9vbGVhbixcclxuICBsaXZlQmFja0J1ZmZlckxlbmd0aDogbnVtYmVyLFxyXG59O1xyXG5cclxudHlwZSBDYXBMZXZlbENvbnRyb2xsZXJDb25maWcgPSB7XHJcbiAgY2FwTGV2ZWxUb1BsYXllclNpemU6IGJvb2xlYW5cclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIEVNRUNvbnRyb2xsZXJDb25maWcgPSB7XHJcbiAgbGljZW5zZVhoclNldHVwPzogKHhocjogWE1MSHR0cFJlcXVlc3QsIHVybDogc3RyaW5nKSA9PiB2b2lkLFxyXG4gIGVtZUVuYWJsZWQ6IGJvb2xlYW4sXHJcbiAgd2lkZXZpbmVMaWNlbnNlVXJsPzogc3RyaW5nLFxyXG4gIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM6IE1lZGlhS2V5RnVuYyB8IG51bGwsXHJcbn07XHJcblxyXG50eXBlIEZyYWdtZW50TG9hZGVyQ29uZmlnID0ge1xyXG4gIGZMb2FkZXI6IGFueSwgLy8gVE9ETyh0eXBlc2NyaXB0LWxvYWRlcik6IE9uY2UgTG9hZGVyIGlzIHR5cGVkIGZpbGwgdGhpcyBpblxyXG5cclxuICBmcmFnTG9hZGluZ1RpbWVPdXQ6IG51bWJlcixcclxuICBmcmFnTG9hZGluZ01heFJldHJ5OiBudW1iZXIsXHJcbiAgZnJhZ0xvYWRpbmdSZXRyeURlbGF5OiBudW1iZXIsXHJcbiAgZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IG51bWJlcixcclxufTtcclxuXHJcbnR5cGUgRlBTQ29udHJvbGxlckNvbmZpZyA9IHtcclxuICBjYXBMZXZlbE9uRlBTRHJvcDogYm9vbGVhbixcclxuICBmcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZDogbnVtYmVyLFxyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOiBudW1iZXIsXHJcbn07XHJcblxyXG50eXBlIExldmVsQ29udHJvbGxlckNvbmZpZyA9IHtcclxuICBzdGFydExldmVsPzogbnVtYmVyXHJcbn07XHJcblxyXG50eXBlIE1QNFJlbXV4ZXJDb25maWcgPSB7XHJcbiAgc3RyZXRjaFNob3J0VmlkZW9UcmFjazogYm9vbGVhbixcclxuICBtYXhBdWRpb0ZyYW1lc0RyaWZ0OiBudW1iZXIsXHJcbn07XHJcblxyXG50eXBlIFBsYXlsaXN0TG9hZGVyQ29uZmlnID0ge1xyXG4gIHBMb2FkZXI6IGFueSwgLy8gVE9ETyh0eXBlc2NyaXB0LWxvYWRlcik6IE9uY2UgTG9hZGVyIGlzIHR5cGVkIGZpbGwgdGhpcyBpblxyXG5cclxuICBtYW5pZmVzdExvYWRpbmdUaW1lT3V0OiBudW1iZXIsXHJcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk6IG51bWJlcixcclxuICBtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5OiBudW1iZXIsXHJcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiBudW1iZXIsXHJcblxyXG4gIGxldmVsTG9hZGluZ1RpbWVPdXQ6IG51bWJlcixcclxuICBsZXZlbExvYWRpbmdNYXhSZXRyeTogbnVtYmVyLFxyXG4gIGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6IG51bWJlcixcclxuICBsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IG51bWJlclxyXG59O1xyXG5cclxudHlwZSBTdHJlYW1Db250cm9sbGVyQ29uZmlnID0ge1xyXG4gIGF1dG9TdGFydExvYWQ6IGJvb2xlYW4sXHJcbiAgc3RhcnRQb3NpdGlvbjogbnVtYmVyLFxyXG4gIGRlZmF1bHRBdWRpb0NvZGVjPzogc3RyaW5nLFxyXG4gIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplOiBudW1iZXIsXHJcbiAgbWF4QnVmZmVyTGVuZ3RoOiBudW1iZXIsXHJcbiAgbWF4QnVmZmVyU2l6ZTogbnVtYmVyLFxyXG4gIG1heEJ1ZmZlckhvbGU6IG51bWJlcixcclxuXHJcbiAgbG93QnVmZmVyV2F0Y2hkb2dQZXJpb2Q6IG51bWJlcixcclxuICBoaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2Q6IG51bWJlcixcclxuICBudWRnZU9mZnNldDogbnVtYmVyLFxyXG4gIG51ZGdlTWF4UmV0cnk6IG51bWJlcixcclxuICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlOiBudW1iZXIsXHJcbiAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50OiBudW1iZXIsXHJcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50OiBudW1iZXIsXHJcbiAgbGl2ZVN5bmNEdXJhdGlvbj86IG51bWJlcixcclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uPzogbnVtYmVyLFxyXG4gIG1heE1heEJ1ZmZlckxlbmd0aDogbnVtYmVyLFxyXG5cclxuICBzdGFydEZyYWdQcmVmZXRjaDogYm9vbGVhbixcclxufTtcclxuXHJcbnR5cGUgVGltZWxpbmVDb250cm9sbGVyQ29uZmlnID0ge1xyXG4gIGN1ZUhhbmRsZXI6IGFueSwgLy8gVE9ETyh0eXBlc2NyaXB0LWN1ZXMpOiBUeXBlIG9uY2UgZmlsZSBpcyBkb25lXHJcbiAgZW5hYmxlQ0VBNzA4Q2FwdGlvbnM6IGJvb2xlYW4sXHJcbiAgZW5hYmxlV2ViVlRUOiBib29sZWFuLFxyXG4gIGNhcHRpb25zVGV4dFRyYWNrMUxhYmVsOiBzdHJpbmcsXHJcbiAgY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlOiBzdHJpbmcsXHJcbiAgY2FwdGlvbnNUZXh0VHJhY2syTGFiZWw6IHN0cmluZyxcclxuICBjYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGU6IHN0cmluZyxcclxufTtcclxuXHJcbnR5cGUgVFNEZW11eGVyQ29uZmlnID0ge1xyXG4gIGZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHk6IGJvb2xlYW4sXHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBIbHNDb25maWcgPVxyXG4gIHtcclxuICAgIGRlYnVnOiBib29sZWFuLFxyXG4gICAgZW5hYmxlV29ya2VyOiBib29sZWFuLFxyXG4gICAgZW5hYmxlU29mdHdhcmVBRVM6IGJvb2xlYW4sXHJcbiAgICBtaW5BdXRvQml0cmF0ZTogbnVtYmVyLFxyXG4gICAgbG9hZGVyOiBhbnksIC8vIFRPRE8odHlwZXNjcmlwdC14aHJsb2FkZXIpOiBUeXBlIG9uY2UgWEhSIGlzIGRvbmVcclxuICAgIHhoclNldHVwPzogKHhocjogWE1MSHR0cFJlcXVlc3QsIHVybDogc3RyaW5nKSA9PiB2b2lkLFxyXG4gICAgYWVzU2V0dXA/OiBhbnksXHJcbiAgICAvLyBBbHQgQXVkaW9cclxuICAgIGF1ZGlvU3RyZWFtQ29udHJvbGxlcj86IGFueSwgLy8gVE9ETyh0eXBlc2NyaXB0LWF1ZGlvc3RyZWFtY29udHJvbGxlcik6IFR5cGUgb25jZSBmaWxlIGlzIGRvbmVcclxuICAgIGF1ZGlvVHJhY2tDb250cm9sbGVyPzogYW55LCAvLyBUT0RPKHR5cGVzY3JpcHQtYXVkaW90cmFja2NvbnRyb2xsZXIpOiBUeXBlIG9uY2UgZmlsZSBpcyBkb25lXHJcbiAgICAvLyBTdWJ0aXRsZVxyXG4gICAgc3VidGl0bGVTdHJlYW1Db250cm9sbGVyPzogYW55LCAvLyBUT0RPKHR5cGVzY3JpcHQtc3VidGl0bGVzdHJlYW1jb250cm9sbGVyKTogVHlwZSBvbmNlIGZpbGUgaXMgZG9uZVxyXG4gICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXI/OiBhbnksIC8vIFRPRE8odHlwZXNjcmlwdC1zdWJ0aXRsZXRyYWNrY29udHJvbGxlcik6IFR5cGUgb25jZSBmaWxlIGlzIGRvbmVcclxuICAgIHRpbWVsaW5lQ29udHJvbGxlcj86IGFueSwgLy8gVE9ETyh0eXBlc2NyaXB0LXRpbWVsaW5lY29udHJvbGxlcik6IFR5cGUgb25jZSBmaWxlIGlzIGRvbmVcclxuICAgIC8vIEVNRVxyXG4gICAgZW1lQ29udHJvbGxlcj86IHR5cGVvZiBFTUVDb250cm9sbGVyLFxyXG5cclxuICAgIGFickNvbnRyb2xsZXI6IGFueSwgLy8gVE9ETyh0eXBlc2NyaXB0LWFicmNvbnRyb2xsZXIpOiBUeXBlIG9uY2UgZmlsZSBpcyBkb25lXHJcbiAgICBidWZmZXJDb250cm9sbGVyOiB0eXBlb2YgQnVmZmVyQ29udHJvbGxlcixcclxuICAgIGNhcExldmVsQ29udHJvbGxlcjogYW55LCAvLyBUT0RPKHR5cGVzY3JpcHQtY2FwbGV2ZWxjb250cm9sbGVyKTogVHlwZSBvbmNlIGZpbGUgaXMgZG9uZVxyXG4gICAgZnBzQ29udHJvbGxlcjogYW55LCAvLyBUT0RPKHR5cGVzY3JpcHQtZnBzY29udHJvbGxlcik6IFR5cGUgb25jZSBmaWxlIGlzIGRvbmVcclxuICB9ICZcclxuICBBQlJDb250cm9sbGVyQ29uZmlnICZcclxuICBCdWZmZXJDb250cm9sbGVyQ29uZmlnICZcclxuICBDYXBMZXZlbENvbnRyb2xsZXJDb25maWcgJlxyXG4gIEVNRUNvbnRyb2xsZXJDb25maWcgJlxyXG4gIEZQU0NvbnRyb2xsZXJDb25maWcgJlxyXG4gIEZyYWdtZW50TG9hZGVyQ29uZmlnICZcclxuICBMZXZlbENvbnRyb2xsZXJDb25maWcgJlxyXG4gIE1QNFJlbXV4ZXJDb25maWcgJlxyXG4gIFBsYXlsaXN0TG9hZGVyQ29uZmlnICZcclxuICBTdHJlYW1Db250cm9sbGVyQ29uZmlnICZcclxuICBQYXJ0aWFsPFRpbWVsaW5lQ29udHJvbGxlckNvbmZpZz4gJlxyXG4gIFRTRGVtdXhlckNvbmZpZztcclxuXHJcbi8vIElmIHBvc3NpYmxlLCBrZWVwIGhsc0RlZmF1bHRDb25maWcgc2hhbGxvd1xyXG4vLyBJdCBpcyBjbG9uZWQgd2hlbmV2ZXIgYSBuZXcgSGxzIGluc3RhbmNlIGlzIGNyZWF0ZWQsIGJ5IGtlZXBpbmcgdGhlIGNvbmZpZ1xyXG4vLyBzaGFsbG93IHRoZSBwcm9wZXJ0aWVzIGFyZSBjbG9uZWQsIGFuZCB3ZSBkb24ndCBlbmQgdXAgbWFuaXB1bGF0aW5nIHRoZSBkZWZhdWx0XHJcbmV4cG9ydCBjb25zdCBobHNEZWZhdWx0Q29uZmlnOiBIbHNDb25maWcgPSB7XHJcbiAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxyXG4gIHN0YXJ0UG9zaXRpb246IC0xLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgZGVmYXVsdEF1ZGlvQ29kZWM6IHZvaWQgMCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxyXG4gIGRlYnVnOiBmYWxzZSwgLy8gdXNlZCBieSBsb2dnZXJcclxuICBjYXBMZXZlbE9uRlBTRHJvcDogZmFsc2UsIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcclxuICBjYXBMZXZlbFRvUGxheWVyU2l6ZTogZmFsc2UsIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcclxuICBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTogMSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxyXG4gIG1heEJ1ZmZlckxlbmd0aDogMzAsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICBtYXhCdWZmZXJTaXplOiA2MCAqIDEwMDAgKiAxMDAwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgbWF4QnVmZmVySG9sZTogMC41LCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcblxyXG4gIGxvd0J1ZmZlcldhdGNoZG9nUGVyaW9kOiAwLjUsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICBoaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2Q6IDMsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICBudWRnZU9mZnNldDogMC4xLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgbnVkZ2VNYXhSZXRyeTogMywgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxyXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IDAuMjUsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICBsaXZlU3luY0R1cmF0aW9uQ291bnQ6IDMsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IEluZmluaXR5LCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgbGl2ZVN5bmNEdXJhdGlvbjogdm9pZCAwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbjogdm9pZCAwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXHJcbiAgbGl2ZUR1cmF0aW9uSW5maW5pdHk6IGZhbHNlLCAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXHJcbiAgbGl2ZUJhY2tCdWZmZXJMZW5ndGg6IEluZmluaXR5LCAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXHJcbiAgbWF4TWF4QnVmZmVyTGVuZ3RoOiA2MDAsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICBlbmFibGVXb3JrZXI6IHRydWUsIC8vIHVzZWQgYnkgZGVtdXhlclxyXG4gIGVuYWJsZVNvZnR3YXJlQUVTOiB0cnVlLCAvLyB1c2VkIGJ5IGRlY3J5cHRlclxyXG4gIG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6IDEwMDAwLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxyXG4gIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5OiAxLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxyXG4gIG1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXHJcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcclxuICBzdGFydExldmVsOiB2b2lkIDAsIC8vIHVzZWQgYnkgbGV2ZWwtY29udHJvbGxlclxyXG4gIGxldmVsTG9hZGluZ1RpbWVPdXQ6IDEwMDAwLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxyXG4gIGxldmVsTG9hZGluZ01heFJldHJ5OiA0LCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxyXG4gIGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXHJcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcclxuICBmcmFnTG9hZGluZ1RpbWVPdXQ6IDIwMDAwLCAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxyXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnk6IDYsIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXHJcbiAgZnJhZ0xvYWRpbmdSZXRyeURlbGF5OiAxMDAwLCAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxyXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCwgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcclxuICBzdGFydEZyYWdQcmVmZXRjaDogZmFsc2UsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcclxuICBmcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZDogNTAwMCwgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOiAwLjIsIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcclxuICBhcHBlbmRFcnJvck1heFJldHJ5OiAzLCAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXHJcbiAgbG9hZGVyOiBYaHJMb2FkZXIsXHJcbiAgLy8gbG9hZGVyOiBGZXRjaExvYWRlcixcclxuICBmTG9hZGVyOiB2b2lkIDAsIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXHJcbiAgcExvYWRlcjogdm9pZCAwLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxyXG4gIHhoclNldHVwOiB2b2lkIDAsIC8vIHVzZWQgYnkgeGhyLWxvYWRlclxyXG4gIGFlc1NldHVwOiB2b2lkIDAsIC8vIHVzZWQgYnkgYWVzLWxvYWRlclxyXG4gIGxpY2Vuc2VYaHJTZXR1cDogdm9pZCAwLCAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXHJcbiAgLy8gZmV0Y2hTZXR1cDogdm9pZCAwLFxyXG4gIGFickNvbnRyb2xsZXI6IEFickNvbnRyb2xsZXIsXHJcbiAgYnVmZmVyQ29udHJvbGxlcjogQnVmZmVyQ29udHJvbGxlcixcclxuICBjYXBMZXZlbENvbnRyb2xsZXI6IENhcExldmVsQ29udHJvbGxlcixcclxuICBmcHNDb250cm9sbGVyOiBGUFNDb250cm9sbGVyLFxyXG4gIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6IGZhbHNlLCAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXHJcbiAgbWF4QXVkaW9GcmFtZXNEcmlmdDogMSwgLy8gdXNlZCBieSBtcDQtcmVtdXhlclxyXG4gIGZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHk6IHRydWUsIC8vIHVzZWQgYnkgdHMtZGVtdXhlclxyXG4gIGFickV3bWFGYXN0TGl2ZTogMywgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxyXG4gIGFickV3bWFTbG93TGl2ZTogOSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxyXG4gIGFickV3bWFGYXN0Vm9EOiAzLCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXHJcbiAgYWJyRXdtYVNsb3dWb0Q6IDksIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcclxuICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiA1ZTUsIC8vIDUwMCBrYnBzICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXHJcbiAgYWJyQmFuZFdpZHRoRmFjdG9yOiAwLjk1LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXHJcbiAgYWJyQmFuZFdpZHRoVXBGYWN0b3I6IDAuNywgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxyXG4gIGFick1heFdpdGhSZWFsQml0cmF0ZTogZmFsc2UsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcclxuICBtYXhTdGFydmF0aW9uRGVsYXk6IDQsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcclxuICBtYXhMb2FkaW5nRGVsYXk6IDQsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcclxuICBtaW5BdXRvQml0cmF0ZTogMCwgLy8gdXNlZCBieSBobHNcclxuICBlbWVFbmFibGVkOiBmYWxzZSwgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxyXG4gIHdpZGV2aW5lTGljZW5zZVVybDogdm9pZCAwLCAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXHJcbiAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYzogcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzLCAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXHJcblxyXG4gIC8vIER5bmFtaWMgTW9kdWxlc1xyXG4gIC4uLnRpbWVsaW5lQ29uZmlnKCksXHJcbiAgc3VidGl0bGVTdHJlYW1Db250cm9sbGVyOiAoX19VU0VfU1VCVElUTEVTX18pID8gU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIDogdm9pZCAwLFxyXG4gIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyOiAoX19VU0VfU1VCVElUTEVTX18pID8gU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgOiB2b2lkIDAsXHJcbiAgdGltZWxpbmVDb250cm9sbGVyOiAoX19VU0VfU1VCVElUTEVTX18pID8gVGltZWxpbmVDb250cm9sbGVyIDogdm9pZCAwLFxyXG4gIGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogKF9fVVNFX0FMVF9BVURJT19fKSA/IEF1ZGlvU3RyZWFtQ29udHJvbGxlciA6IHZvaWQgMCxcclxuICBhdWRpb1RyYWNrQ29udHJvbGxlcjogKF9fVVNFX0FMVF9BVURJT19fKSA/IEF1ZGlvVHJhY2tDb250cm9sbGVyIDogdm9pZCAwLFxyXG4gIGVtZUNvbnRyb2xsZXI6IChfX1VTRV9FTUVfRFJNX18pID8gRU1FQ29udHJvbGxlciA6IHZvaWQgMFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdGltZWxpbmVDb25maWcgKCk6IFRpbWVsaW5lQ29udHJvbGxlckNvbmZpZyB7XHJcbiAgaWYgKCFfX1VTRV9TVUJUSVRMRVNfXykge1xyXG4gICAgLy8gaW50ZW50aW9uYWxseSBkb2luZyB0aGlzIG92ZXIgcmV0dXJuaW5nIFBhcnRpYWw8VGltZWxpbmVDb250cm9sbGVyQ29uZmlnPiBhYm92ZVxyXG4gICAgLy8gdGhpcyBoYXMgdGhlIGFkZGVkIG5pY2UgcHJvcGVydHkgb2Ygc3RpbGwgcmVxdWlyaW5nIHRoZSBvYmplY3QgYmVsb3cgdG8gY29tcGxldGVseSBkZWZpbmUgYWxsIHByb3BzLlxyXG4gICAgcmV0dXJuIHt9IGFzIGFueTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIGN1ZUhhbmRsZXI6IEN1ZXMsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxyXG4gICAgZW5hYmxlQ0VBNzA4Q2FwdGlvbnM6IHRydWUsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxyXG4gICAgZW5hYmxlV2ViVlRUOiB0cnVlLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMUxhYmVsOiAnRW5nbGlzaCcsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlOiAnZW4nLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMkxhYmVsOiAnU3BhbmlzaCcsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlOiAnZXMnIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxyXG4gIH07XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY29uZmlnLnRzIiwiLypcclxuICogc2ltcGxlIEFCUiBDb250cm9sbGVyXHJcbiAqICAtIGNvbXB1dGUgbmV4dCBsZXZlbCBiYXNlZCBvbiBsYXN0IGZyYWdtZW50IGJ3IGhldXJpc3RpY3NcclxuICogIC0gaW1wbGVtZW50IGFuIGFiYW5kb24gcnVsZXMgdHJpZ2dlcmVkIGlmIHdlIGhhdmUgbGVzcyB0aGFuIDIgZnJhZyBidWZmZXJlZCBhbmQgaWYgY29tcHV0ZWQgYncgc2hvd3MgdGhhdCB3ZSByaXNrIGJ1ZmZlciBzdGFsbGluZ1xyXG4gKi9cclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQgeyBCdWZmZXJIZWxwZXIgfSBmcm9tICcuLi91dGlscy9idWZmZXItaGVscGVyJztcclxuaW1wb3J0IHsgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuaW1wb3J0IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IgZnJvbSAnLi4vdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yJztcclxuXHJcbmNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IHdpbmRvdztcclxuXHJcbmNsYXNzIEFickNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xyXG4gIGNvbnN0cnVjdG9yIChobHMpIHtcclxuICAgIHN1cGVyKGhscywgRXZlbnQuRlJBR19MT0FESU5HLFxyXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcclxuICAgICAgRXZlbnQuRlJBR19CVUZGRVJFRCxcclxuICAgICAgRXZlbnQuRVJST1IpO1xyXG4gICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gMDtcclxuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcclxuICAgIHRoaXMuaGxzID0gaGxzO1xyXG4gICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICB0aGlzLl9id0VzdGltYXRvciA9IG51bGw7XHJcbiAgICB0aGlzLm9uQ2hlY2sgPSB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjay5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSAoKSB7XHJcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcclxuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgb25GcmFnTG9hZGluZyAoZGF0YSkge1xyXG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcclxuICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJykge1xyXG4gICAgICBpZiAoIXRoaXMudGltZXIpIHtcclxuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcclxuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbkNoZWNrLCAxMDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBsYXp5IGluaXQgb2YgQndFc3RpbWF0b3IsIHJhdGlvbmFsZSBpcyB0aGF0IHdlIHVzZSBkaWZmZXJlbnQgcGFyYW1zIGZvciBMaXZlL1ZvRFxyXG4gICAgICAvLyBzbyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHN0cmVhbSBtYW5pZmVzdCAvIHBsYXlsaXN0IHR5cGUgdG8gaW5zdGFudGlhdGUgaXQuXHJcbiAgICAgIGlmICghdGhpcy5fYndFc3RpbWF0b3IpIHtcclxuICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcclxuICAgICAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xyXG4gICAgICAgIGNvbnN0IGxldmVsID0gZnJhZy5sZXZlbDtcclxuICAgICAgICBjb25zdCBpc0xpdmUgPSBobHMubGV2ZWxzW2xldmVsXS5kZXRhaWxzLmxpdmU7XHJcblxyXG4gICAgICAgIGxldCBld21hRmFzdDtcclxuICAgICAgICBsZXQgZXdtYVNsb3c7XHJcbiAgICAgICAgaWYgKGlzTGl2ZSkge1xyXG4gICAgICAgICAgZXdtYUZhc3QgPSBjb25maWcuYWJyRXdtYUZhc3RMaXZlO1xyXG4gICAgICAgICAgZXdtYVNsb3cgPSBjb25maWcuYWJyRXdtYVNsb3dMaXZlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBld21hRmFzdCA9IGNvbmZpZy5hYnJFd21hRmFzdFZvRDtcclxuICAgICAgICAgIGV3bWFTbG93ID0gY29uZmlnLmFickV3bWFTbG93Vm9EO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9id0VzdGltYXRvciA9IG5ldyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yKGhscywgZXdtYVNsb3csIGV3bWFGYXN0LCBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9hYmFuZG9uUnVsZXNDaGVjayAoKSB7XHJcbiAgICAvKlxyXG4gICAgICBtb25pdG9yIGZyYWdtZW50IHJldHJpZXZhbCB0aW1lLi4uXHJcbiAgICAgIHdlIGNvbXB1dGUgZXhwZWN0ZWQgdGltZSBvZiBhcnJpdmFsIG9mIHRoZSBjb21wbGV0ZSBmcmFnbWVudC5cclxuICAgICAgd2UgY29tcGFyZSBpdCB0byBleHBlY3RlZCB0aW1lIG9mIGJ1ZmZlciBzdGFydmF0aW9uXHJcbiAgICAqL1xyXG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XHJcbiAgICBjb25zdCB2aWRlbyA9IGhscy5tZWRpYTtcclxuICAgIGNvbnN0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xyXG5cclxuICAgIGlmICghZnJhZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbG9hZGVyID0gZnJhZy5sb2FkZXI7XHJcbiAgICBjb25zdCBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xyXG5cclxuICAgIC8vIGlmIGxvYWRlciBoYXMgYmVlbiBkZXN0cm95ZWQgb3IgbG9hZGluZyBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHRpbWVyIGFuZCByZXR1cm5cclxuICAgIGlmICghbG9hZGVyIHx8IChsb2FkZXIuc3RhdHMgJiYgbG9hZGVyLnN0YXRzLmFib3J0ZWQpKSB7XHJcbiAgICAgIGxvZ2dlci53YXJuKCdmcmFnIGxvYWRlciBkZXN0cm95IG9yIGFib3J0ZWQsIGRpc2FybSBhYmFuZG9uUnVsZXMnKTtcclxuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XHJcbiAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXHJcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IHN0YXRzID0gbG9hZGVyLnN0YXRzO1xyXG4gICAgLyogb25seSBtb25pdG9yIGZyYWcgcmV0cmlldmFsIHRpbWUgaWZcclxuICAgICh2aWRlbyBub3QgcGF1c2VkIE9SIGZpcnN0IGZyYWdtZW50IGJlaW5nIGxvYWRlZChyZWFkeSBzdGF0ZSA9PT0gSEFWRV9OT1RISU5HID0gMCkpIEFORCBhdXRvc3dpdGNoaW5nIGVuYWJsZWQgQU5EIG5vdCBsb3dlc3QgbGV2ZWwgKD0+IG1lYW5zIHRoYXQgd2UgaGF2ZSBzZXZlcmFsIGxldmVscykgKi9cclxuICAgIGlmICh2aWRlbyAmJiBzdGF0cyAmJiAoKCF2aWRlby5wYXVzZWQgJiYgKHZpZGVvLnBsYXliYWNrUmF0ZSAhPT0gMCkpIHx8ICF2aWRlby5yZWFkeVN0YXRlKSAmJiBmcmFnLmF1dG9MZXZlbCAmJiBmcmFnLmxldmVsKSB7XHJcbiAgICAgIGNvbnN0IHJlcXVlc3REZWxheSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhdHMudHJlcXVlc3Q7XHJcbiAgICAgIGNvbnN0IHBsYXliYWNrUmF0ZSA9IE1hdGguYWJzKHZpZGVvLnBsYXliYWNrUmF0ZSk7XHJcblxyXG4gICAgICAvLyBtb25pdG9yIGZyYWdtZW50IGxvYWQgcHJvZ3Jlc3MgYWZ0ZXIgaGFsZiBvZiBleHBlY3RlZCBmcmFnbWVudCBkdXJhdGlvbix0byBzdGFiaWxpemUgYml0cmF0ZVxyXG4gICAgICBpZiAocmVxdWVzdERlbGF5ID4gKDUwMCAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSB7XHJcbiAgICAgICAgY29uc3QgbGV2ZWxzID0gaGxzLmxldmVscztcclxuICAgICAgICBjb25zdCBsb2FkUmF0ZSA9IE1hdGgubWF4KDEsIHN0YXRzLmJ3ID8gc3RhdHMuYncgLyA4IDogc3RhdHMubG9hZGVkICogMTAwMCAvIHJlcXVlc3REZWxheSk7IC8vIGJ5dGUvczsgYXQgbGVhc3QgMSBieXRlL3MgdG8gYXZvaWQgZGl2aXNpb24gYnkgemVyb1xyXG5cclxuICAgICAgICAvLyBjb21wdXRlIGV4cGVjdGVkIGZyYWdtZW50IGxlbmd0aCB1c2luZyBmcmFnIGR1cmF0aW9uIGFuZCBsZXZlbCBiaXRyYXRlLiBhbHNvIGVuc3VyZSB0aGF0IGV4cGVjdGVkIGxlbiBpcyBndGUgdGhhbiBhbHJlYWR5IGxvYWRlZCBzaXplXHJcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbZnJhZy5sZXZlbF07XHJcbiAgICAgICAgY29uc3QgbGV2ZWxCaXRyYXRlID0gbGV2ZWwucmVhbEJpdHJhdGUgPyBNYXRoLm1heChsZXZlbC5yZWFsQml0cmF0ZSwgbGV2ZWwuYml0cmF0ZSkgOiBsZXZlbC5iaXRyYXRlO1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkTGVuID0gc3RhdHMudG90YWwgPyBzdGF0cy50b3RhbCA6IE1hdGgubWF4KHN0YXRzLmxvYWRlZCwgTWF0aC5yb3VuZChmcmFnLmR1cmF0aW9uICogbGV2ZWxCaXRyYXRlIC8gOCkpO1xyXG4gICAgICAgIGNvbnN0IHBvcyA9IHZpZGVvLmN1cnJlbnRUaW1lO1xyXG4gICAgICAgIGNvbnN0IGZyYWdMb2FkZWREZWxheSA9IChleHBlY3RlZExlbiAtIHN0YXRzLmxvYWRlZCkgLyBsb2FkUmF0ZTtcclxuICAgICAgICBjb25zdCBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odmlkZW8sIHBvcywgaGxzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKS5lbmQgLSBwb3MpIC8gcGxheWJhY2tSYXRlO1xyXG5cclxuICAgICAgICAvLyBjb25zaWRlciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb25seSBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgQU5EXHJcbiAgICAgICAgLy8gdGltZSB0byBmaW5pc2ggbG9hZGluZyBjdXJyZW50IGZyYWdtZW50IGlzIGJpZ2dlciB0aGFuIGJ1ZmZlciBzdGFydmF0aW9uIGRlbGF5XHJcbiAgICAgICAgLy8gaWUgaWYgd2UgcmlzayBidWZmZXIgc3RhcnZhdGlvbiBpZiBidyBkb2VzIG5vdCBpbmNyZWFzZSBxdWlja2x5XHJcbiAgICAgICAgaWYgKChidWZmZXJTdGFydmF0aW9uRGVsYXkgPCAoMiAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSAmJiAoZnJhZ0xvYWRlZERlbGF5ID4gYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSkge1xyXG4gICAgICAgICAgbGV0IGZyYWdMZXZlbE5leHRMb2FkZWREZWxheTtcclxuICAgICAgICAgIGxldCBuZXh0TG9hZExldmVsO1xyXG4gICAgICAgICAgLy8gbGV0cyBpdGVyYXRlIHRocm91Z2ggbG93ZXIgbGV2ZWwgYW5kIHRyeSB0byBmaW5kIHRoZSBiaWdnZXN0IG9uZSB0aGF0IGNvdWxkIGF2b2lkIHJlYnVmZmVyaW5nXHJcbiAgICAgICAgICAvLyB3ZSBzdGFydCBmcm9tIGN1cnJlbnQgbGV2ZWwgLSAxIGFuZCB3ZSBzdGVwIGRvd24gLCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2hpbmcgbGV2ZWxcclxuICAgICAgICAgIGZvciAobmV4dExvYWRMZXZlbCA9IGZyYWcubGV2ZWwgLSAxOyBuZXh0TG9hZExldmVsID4gbWluQXV0b0xldmVsOyBuZXh0TG9hZExldmVsLS0pIHtcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSB0aW1lIHRvIGxvYWQgbmV4dCBmcmFnbWVudCBhdCBsb3dlciBsZXZlbFxyXG4gICAgICAgICAgICAvLyAwLjggOiBjb25zaWRlciBvbmx5IDgwJSBvZiBjdXJyZW50IGJ3IHRvIGJlIGNvbnNlcnZhdGl2ZVxyXG4gICAgICAgICAgICAvLyA4ID0gYml0cyBwZXIgYnl0ZSAoYnBzL0JwcylcclxuICAgICAgICAgICAgY29uc3QgbGV2ZWxOZXh0Qml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5yZWFsQml0cmF0ZVxyXG4gICAgICAgICAgICAgID8gTWF0aC5tYXgobGV2ZWxzW25leHRMb2FkTGV2ZWxdLnJlYWxCaXRyYXRlLCBsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZSlcclxuICAgICAgICAgICAgICA6IGxldmVsc1tuZXh0TG9hZExldmVsXS5iaXRyYXRlO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gZnJhZy5kdXJhdGlvbiAqIGxldmVsTmV4dEJpdHJhdGUgLyAoOCAqIDAuOCAqIGxvYWRSYXRlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPCBidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcclxuICAgICAgICAgICAgICAvLyB3ZSBmb3VuZCBhIGxvd2VyIGxldmVsIHRoYXQgYmUgcmVidWZmZXJpbmcgZnJlZSB3aXRoIGN1cnJlbnQgZXN0aW1hdGVkIGJ3ICFcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gb25seSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgaXQgdGFrZXMgbGVzcyB0aW1lIHRvIGxvYWQgbmV3IGZyYWdtZW50IGF0IGxvd2VzdCBsZXZlbCBpbnN0ZWFkXHJcbiAgICAgICAgICAvLyBvZiBmaW5pc2hpbmcgbG9hZGluZyBjdXJyZW50IG9uZSAuLi5cclxuICAgICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPCBmcmFnTG9hZGVkRGVsYXkpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGxvYWRpbmcgdG9vIHNsb3csIGFib3J0IGZyYWdtZW50IGxvYWRpbmcgYW5kIHN3aXRjaCB0byBsZXZlbCAke25leHRMb2FkTGV2ZWx9OmZyYWdMb2FkZWREZWxheVske25leHRMb2FkTGV2ZWx9XTxmcmFnTG9hZGVkRGVsYXlbJHtmcmFnLmxldmVsIC0gMX1dO2J1ZmZlclN0YXJ2YXRpb25EZWxheToke2ZyYWdMZXZlbE5leHRMb2FkZWREZWxheS50b0ZpeGVkKDEpfTwke2ZyYWdMb2FkZWREZWxheS50b0ZpeGVkKDEpfToke2J1ZmZlclN0YXJ2YXRpb25EZWxheS50b0ZpeGVkKDEpfWApO1xyXG4gICAgICAgICAgICAvLyBmb3JjZSBuZXh0IGxvYWQgbGV2ZWwgaW4gYXV0byBtb2RlXHJcbiAgICAgICAgICAgIGhscy5uZXh0TG9hZExldmVsID0gbmV4dExvYWRMZXZlbDtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGJ3IGVzdGltYXRlIGZvciB0aGlzIGZyYWdtZW50IGJlZm9yZSBjYW5jZWxsaW5nIGxvYWQgKHRoaXMgd2lsbCBoZWxwIHJlZHVjaW5nIHRoZSBidylcclxuICAgICAgICAgICAgdGhpcy5fYndFc3RpbWF0b3Iuc2FtcGxlKHJlcXVlc3REZWxheSwgc3RhdHMubG9hZGVkKTtcclxuICAgICAgICAgICAgLy8gYWJvcnQgZnJhZ21lbnQgbG9hZGluZ1xyXG4gICAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcclxuICAgICAgICAgICAgLy8gc3RvcCBhYmFuZG9uIHJ1bGVzIHRpbWVyXHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xyXG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHsgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcmFnTG9hZGVkIChkYXRhKSB7XHJcbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xyXG4gICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nICYmIE51bWJlci5pc0Zpbml0ZShmcmFnLnNuKSkge1xyXG4gICAgICAvLyBzdG9wIG1vbml0b3JpbmcgYncgb25jZSBmcmFnIGxvYWRlZFxyXG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcclxuICAgICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkXHJcbiAgICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IGZyYWcubGV2ZWw7XHJcbiAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXHJcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcclxuXHJcbiAgICAgIC8vIGNvbXB1dGUgbGV2ZWwgYXZlcmFnZSBiaXRyYXRlXHJcbiAgICAgIGlmICh0aGlzLmhscy5jb25maWcuYWJyTWF4V2l0aFJlYWxCaXRyYXRlKSB7XHJcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XHJcbiAgICAgICAgbGV0IGxvYWRlZEJ5dGVzID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5ieXRlcyA6IDApICsgZGF0YS5zdGF0cy5sb2FkZWQ7XHJcbiAgICAgICAgbGV0IGxvYWRlZER1cmF0aW9uID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZGF0YS5mcmFnLmR1cmF0aW9uO1xyXG4gICAgICAgIGxldmVsLmxvYWRlZCA9IHsgYnl0ZXM6IGxvYWRlZEJ5dGVzLCBkdXJhdGlvbjogbG9hZGVkRHVyYXRpb24gfTtcclxuICAgICAgICBsZXZlbC5yZWFsQml0cmF0ZSA9IE1hdGgucm91bmQoOCAqIGxvYWRlZEJ5dGVzIC8gbG9hZGVkRHVyYXRpb24pO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGlmIGZyYWdtZW50IGhhcyBiZWVuIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0LFxyXG4gICAgICBpZiAoZGF0YS5mcmFnLmJpdHJhdGVUZXN0KSB7XHJcbiAgICAgICAgbGV0IHN0YXRzID0gZGF0YS5zdGF0cztcclxuICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gc3RhdHMudGxvYWQ7XHJcbiAgICAgICAgdGhpcy5vbkZyYWdCdWZmZXJlZChkYXRhKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcmFnQnVmZmVyZWQgKGRhdGEpIHtcclxuICAgIGNvbnN0IHN0YXRzID0gZGF0YS5zdGF0cztcclxuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XHJcbiAgICAvLyBvbmx5IHVwZGF0ZSBzdGF0cyBvbiBmaXJzdCBmcmFnIGJ1ZmZlcmluZ1xyXG4gICAgLy8gaWYgc2FtZSBmcmFnIGlzIGxvYWRlZCBtdWx0aXBsZSB0aW1lcywgaXQgbWlnaHQgYmUgaW4gYnJvd3NlciBjYWNoZSwgYW5kIGxvYWRlZCBxdWlja2x5XHJcbiAgICAvLyBhbmQgbGVhZGluZyB0byB3cm9uZyBidyBlc3RpbWF0aW9uXHJcbiAgICAvLyBvbiBiaXRyYXRlIHRlc3QsIGFsc28gb25seSB1cGRhdGUgc3RhdHMgb25jZSAoaWYgdGxvYWQgPSB0YnVmZmVyZWQgPT0gb24gRlJBR19MT0FERUQpXHJcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCAhPT0gdHJ1ZSAmJiBmcmFnLnR5cGUgPT09ICdtYWluJyAmJiBOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbikgJiYgKCghZnJhZy5iaXRyYXRlVGVzdCB8fCBzdGF0cy50bG9hZCA9PT0gc3RhdHMudGJ1ZmZlcmVkKSkpIHtcclxuICAgICAgLy8gdXNlIHRwYXJzZWQtdHJlcXVlc3QgaW5zdGVhZCBvZiB0YnVmZmVyZWQtdHJlcXVlc3QgdG8gY29tcHV0ZSBmcmFnTG9hZGluZ1Byb2Nlc3Npbmc7IHJhdGlvbmFsZSBpcyB0aGF0ICBidWZmZXIgYXBwZW5kaW5nIG9ubHkgaGFwcGVucyBvbmNlIG1lZGlhIGlzIGF0dGFjaGVkXHJcbiAgICAgIC8vIGluIGNhc2Ugd2UgdXNlIGNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCB3aGlsZSBtZWRpYSBpcyBub3QgYXR0YWNoZWQgeWV0LCBmcmFnbWVudCBtaWdodCBiZSBwYXJzZWQgd2hpbGUgbWVkaWEgbm90IGF0dGFjaGVkIHlldCwgYnV0IGl0IHdpbGwgb25seSBiZSBidWZmZXJlZCBvbiBtZWRpYSBhdHRhY2hlZFxyXG4gICAgICAvLyBhcyBhIGNvbnNlcXVlbmNlIGl0IGNvdWxkIGhhcHBlbiByZWFsbHkgbGF0ZSBpbiB0aGUgcHJvY2Vzcy4gbWVhbmluZyB0aGF0IGFwcGVuZGluZyBkdXJhdGlvbiBtaWdodCBhcHBlYXJzIGh1Z2UgLi4uIGxlYWRpbmcgdG8gdW5kZXJlc3RpbWF0ZWQgdGhyb3VnaHB1dCBlc3RpbWF0aW9uXHJcbiAgICAgIGxldCBmcmFnTG9hZGluZ1Byb2Nlc3NpbmdNcyA9IHN0YXRzLnRwYXJzZWQgLSBzdGF0cy50cmVxdWVzdDtcclxuICAgICAgbG9nZ2VyLmxvZyhgbGF0ZW5jeS9sb2FkaW5nL3BhcnNpbmcvYXBwZW5kL2ticHM6JHtNYXRoLnJvdW5kKHN0YXRzLnRmaXJzdCAtIHN0YXRzLnRyZXF1ZXN0KX0vJHtNYXRoLnJvdW5kKHN0YXRzLnRsb2FkIC0gc3RhdHMudGZpcnN0KX0vJHtNYXRoLnJvdW5kKHN0YXRzLnRwYXJzZWQgLSBzdGF0cy50bG9hZCl9LyR7TWF0aC5yb3VuZChzdGF0cy50YnVmZmVyZWQgLSBzdGF0cy50cGFyc2VkKX0vJHtNYXRoLnJvdW5kKDggKiBzdGF0cy5sb2FkZWQgLyAoc3RhdHMudGJ1ZmZlcmVkIC0gc3RhdHMudHJlcXVlc3QpKX1gKTtcclxuICAgICAgdGhpcy5fYndFc3RpbWF0b3Iuc2FtcGxlKGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zLCBzdGF0cy5sb2FkZWQpO1xyXG4gICAgICBzdGF0cy5id0VzdGltYXRlID0gdGhpcy5fYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTtcclxuICAgICAgLy8gaWYgZnJhZ21lbnQgaGFzIGJlZW4gbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3QsIChobHMuc3RhcnRMZXZlbCA9IC0xKSwgc3RvcmUgYml0cmF0ZSB0ZXN0IGRlbGF5IGR1cmF0aW9uXHJcbiAgICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XHJcbiAgICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMgLyAxMDAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRXJyb3IgKGRhdGEpIHtcclxuICAgIC8vIHN0b3AgdGltZXIgaW4gY2FzZSBvZiBmcmFnIGxvYWRpbmcgZXJyb3JcclxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XHJcbiAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XHJcbiAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcclxuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjbGVhclRpbWVyICgpIHtcclxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XHJcbiAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIHJldHVybiBuZXh0IGF1dG8gbGV2ZWxcclxuICBnZXQgbmV4dEF1dG9MZXZlbCAoKSB7XHJcbiAgICBjb25zdCBmb3JjZWRBdXRvTGV2ZWwgPSB0aGlzLl9uZXh0QXV0b0xldmVsO1xyXG4gICAgY29uc3QgYndFc3RpbWF0b3IgPSB0aGlzLl9id0VzdGltYXRvcjtcclxuICAgIC8vIGluIGNhc2UgbmV4dCBhdXRvIGxldmVsIGhhcyBiZWVuIGZvcmNlZCwgYW5kIGJ3IG5vdCBhdmFpbGFibGUgb3Igbm90IHJlbGlhYmxlLCByZXR1cm4gZm9yY2VkIHZhbHVlXHJcbiAgICBpZiAoZm9yY2VkQXV0b0xldmVsICE9PSAtMSAmJiAoIWJ3RXN0aW1hdG9yIHx8ICFid0VzdGltYXRvci5jYW5Fc3RpbWF0ZSgpKSkge1xyXG4gICAgICByZXR1cm4gZm9yY2VkQXV0b0xldmVsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbXB1dGUgbmV4dCBsZXZlbCB1c2luZyBBQlIgbG9naWNcclxuICAgIGxldCBuZXh0QUJSQXV0b0xldmVsID0gdGhpcy5fbmV4dEFCUkF1dG9MZXZlbDtcclxuICAgIC8vIGlmIGZvcmNlZCBhdXRvIGxldmVsIGhhcyBiZWVuIGRlZmluZWQsIHVzZSBpdCB0byBjYXAgQUJSIGNvbXB1dGVkIHF1YWxpdHkgbGV2ZWxcclxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XHJcbiAgICAgIG5leHRBQlJBdXRvTGV2ZWwgPSBNYXRoLm1pbihmb3JjZWRBdXRvTGV2ZWwsIG5leHRBQlJBdXRvTGV2ZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXh0QUJSQXV0b0xldmVsO1xyXG4gIH1cclxuICBnZXQgX25leHRBQlJBdXRvTGV2ZWwgKCkge1xyXG4gICAgbGV0IGhscyA9IHRoaXMuaGxzO1xyXG4gICAgY29uc3QgeyBtYXhBdXRvTGV2ZWwsIGxldmVscywgY29uZmlnLCBtaW5BdXRvTGV2ZWwgfSA9IGhscztcclxuICAgIGNvbnN0IHZpZGVvID0gaGxzLm1lZGlhO1xyXG4gICAgY29uc3QgY3VycmVudExldmVsID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsO1xyXG4gICAgY29uc3QgY3VycmVudEZyYWdEdXJhdGlvbiA9IHRoaXMuZnJhZ0N1cnJlbnQgPyB0aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uIDogMDtcclxuICAgIGNvbnN0IHBvcyA9ICh2aWRlbyA/IHZpZGVvLmN1cnJlbnRUaW1lIDogMCk7XHJcblxyXG4gICAgLy8gcGxheWJhY2tSYXRlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgcGxheWJhY2sgcmF0ZTsgaWYgdmlkZW8ucGxheWJhY2tSYXRlIGlzIDAsIHdlIHVzZSAxIHRvIGxvYWQgYXNcclxuICAgIC8vIGlmIHdlJ3JlIHBsYXlpbmcgYmFjayBhdCB0aGUgbm9ybWFsIHJhdGUuXHJcbiAgICBjb25zdCBwbGF5YmFja1JhdGUgPSAoKHZpZGVvICYmICh2aWRlby5wbGF5YmFja1JhdGUgIT09IDApKSA/IE1hdGguYWJzKHZpZGVvLnBsYXliYWNrUmF0ZSkgOiAxLjApO1xyXG4gICAgY29uc3QgYXZnYncgPSB0aGlzLl9id0VzdGltYXRvciA/IHRoaXMuX2J3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTtcclxuICAgIC8vIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSBpcyB0aGUgd2FsbC1jbG9jayB0aW1lIGxlZnQgdW50aWwgdGhlIHBsYXliYWNrIGJ1ZmZlciBpcyBleGhhdXN0ZWQuXHJcbiAgICBjb25zdCBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odmlkZW8sIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLmVuZCAtIHBvcykgLyBwbGF5YmFja1JhdGU7XHJcblxyXG4gICAgLy8gRmlyc3QsIGxvb2sgdG8gc2VlIGlmIHdlIGNhbiBmaW5kIGEgbGV2ZWwgbWF0Y2hpbmcgd2l0aCBvdXIgYXZnIGJhbmR3aWR0aCBBTkQgdGhhdCBjb3VsZCBhbHNvIGd1YXJhbnRlZSBubyByZWJ1ZmZlcmluZyBhdCBhbGxcclxuICAgIGxldCBiZXN0TGV2ZWwgPSB0aGlzLl9maW5kQmVzdExldmVsKGN1cnJlbnRMZXZlbCwgY3VycmVudEZyYWdEdXJhdGlvbiwgYXZnYncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXksIGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IsIGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvciwgbGV2ZWxzKTtcclxuICAgIGlmIChiZXN0TGV2ZWwgPj0gMCkge1xyXG4gICAgICByZXR1cm4gYmVzdExldmVsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbG9nZ2VyLnRyYWNlKCdyZWJ1ZmZlcmluZyBleHBlY3RlZCB0byBoYXBwZW4sIGxldHMgdHJ5IHRvIGZpbmQgYSBxdWFsaXR5IGxldmVsIG1pbmltaXppbmcgdGhlIHJlYnVmZmVyaW5nJyk7XHJcbiAgICAgIC8vIG5vdCBwb3NzaWJsZSB0byBnZXQgcmlkIG9mIHJlYnVmZmVyaW5nIC4uLiBsZXQncyB0cnkgdG8gZmluZCBsZXZlbCB0aGF0IHdpbGwgZ3VhcmFudGVlIGxlc3MgdGhhbiBtYXhTdGFydmF0aW9uRGVsYXkgb2YgcmVidWZmZXJpbmdcclxuICAgICAgLy8gaWYgbm8gbWF0Y2hpbmcgbGV2ZWwgZm91bmQsIGxvZ2ljIHdpbGwgcmV0dXJuIDBcclxuICAgICAgbGV0IG1heFN0YXJ2YXRpb25EZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5KSA6IGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXk7XHJcbiAgICAgIGxldCBid0ZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3I7XHJcbiAgICAgIGxldCBid1VwRmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yO1xyXG5cclxuICAgICAgaWYgKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9PT0gMCkge1xyXG4gICAgICAgIC8vIGluIGNhc2UgYnVmZmVyIGlzIGVtcHR5LCBsZXQncyBjaGVjayBpZiBwcmV2aW91cyBmcmFnbWVudCB3YXMgbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3RcclxuICAgICAgICBsZXQgYml0cmF0ZVRlc3REZWxheSA9IHRoaXMuYml0cmF0ZVRlc3REZWxheTtcclxuICAgICAgICBpZiAoYml0cmF0ZVRlc3REZWxheSkge1xyXG4gICAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGNhc2UsIHRoZW4gd2UgbmVlZCB0byBhZGp1c3Qgb3VyIG1heCBzdGFydmF0aW9uIGRlbGF5IHVzaW5nIG1heExvYWRpbmdEZWxheSBjb25maWcgdmFsdWVcclxuICAgICAgICAgIC8vIG1heCB2aWRlbyBsb2FkaW5nIGRlbGF5IHVzZWQgaW4gIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24gOlxyXG4gICAgICAgICAgLy8gaW4gdGhhdCBtb2RlIEFCUiBjb250cm9sbGVyIHdpbGwgZW5zdXJlIHRoYXQgdmlkZW8gbG9hZGluZyB0aW1lIChpZSB0aGUgdGltZSB0byBmZXRjaCB0aGUgZmlyc3QgZnJhZ21lbnQgYXQgbG93ZXN0IHF1YWxpdHkgbGV2ZWwgK1xyXG4gICAgICAgICAgLy8gdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZyYWdtZW50IGF0IHRoZSBhcHByb3ByaWF0ZSBxdWFsaXR5IGxldmVsIGlzIGxlc3MgdGhhbiBgYGBtYXhMb2FkaW5nRGVsYXlgYGAgKVxyXG4gICAgICAgICAgLy8gY2FwIG1heExvYWRpbmdEZWxheSBhbmQgZW5zdXJlIGl0IGlzIG5vdCBiaWdnZXIgJ3RoYW4gYml0cmF0ZSB0ZXN0JyBmcmFnIGR1cmF0aW9uXHJcbiAgICAgICAgICBjb25zdCBtYXhMb2FkaW5nRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heExvYWRpbmdEZWxheSkgOiBjb25maWcubWF4TG9hZGluZ0RlbGF5O1xyXG4gICAgICAgICAgbWF4U3RhcnZhdGlvbkRlbGF5ID0gbWF4TG9hZGluZ0RlbGF5IC0gYml0cmF0ZVRlc3REZWxheTtcclxuICAgICAgICAgIGxvZ2dlci50cmFjZShgYml0cmF0ZSB0ZXN0IHRvb2sgJHtNYXRoLnJvdW5kKDEwMDAgKiBiaXRyYXRlVGVzdERlbGF5KX1tcywgc2V0IGZpcnN0IGZyYWdtZW50IG1heCBmZXRjaER1cmF0aW9uIHRvICR7TWF0aC5yb3VuZCgxMDAwICogbWF4U3RhcnZhdGlvbkRlbGF5KX0gbXNgKTtcclxuICAgICAgICAgIC8vIGRvbid0IHVzZSBjb25zZXJ2YXRpdmUgZmFjdG9yIG9uIGJpdHJhdGUgdGVzdFxyXG4gICAgICAgICAgYndGYWN0b3IgPSBid1VwRmFjdG9yID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYmVzdExldmVsID0gdGhpcy5fZmluZEJlc3RMZXZlbChjdXJyZW50TGV2ZWwsIGN1cnJlbnRGcmFnRHVyYXRpb24sIGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ICsgbWF4U3RhcnZhdGlvbkRlbGF5LCBid0ZhY3RvciwgYndVcEZhY3RvciwgbGV2ZWxzKTtcclxuICAgICAgcmV0dXJuIE1hdGgubWF4KGJlc3RMZXZlbCwgMCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfZmluZEJlc3RMZXZlbCAoY3VycmVudExldmVsLCBjdXJyZW50RnJhZ0R1cmF0aW9uLCBjdXJyZW50QncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBtYXhGZXRjaER1cmF0aW9uLCBid0ZhY3RvciwgYndVcEZhY3RvciwgbGV2ZWxzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gbWF4QXV0b0xldmVsOyBpID49IG1pbkF1dG9MZXZlbDsgaS0tKSB7XHJcbiAgICAgIGxldCBsZXZlbEluZm8gPSBsZXZlbHNbaV07XHJcblxyXG4gICAgICBpZiAoIWxldmVsSW5mbykge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcclxuICAgICAgY29uc3QgYXZnRHVyYXRpb24gPSBsZXZlbERldGFpbHMgPyBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbiAvIGxldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIDogY3VycmVudEZyYWdEdXJhdGlvbjtcclxuICAgICAgY29uc3QgbGl2ZSA9IGxldmVsRGV0YWlscyA/IGxldmVsRGV0YWlscy5saXZlIDogZmFsc2U7XHJcblxyXG4gICAgICBsZXQgYWRqdXN0ZWRidztcclxuICAgICAgLy8gZm9sbG93IGFsZ29yaXRobSBjYXB0dXJlZCBmcm9tIHN0YWdlZnJpZ2h0IDpcclxuICAgICAgLy8gaHR0cHM6Ly9hbmRyb2lkLmdvb2dsZXNvdXJjZS5jb20vcGxhdGZvcm0vZnJhbWV3b3Jrcy9hdi8rL21hc3Rlci9tZWRpYS9saWJzdGFnZWZyaWdodC9odHRwbGl2ZS9MaXZlU2Vzc2lvbi5jcHBcclxuICAgICAgLy8gUGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggc3RyZWFtIGJlbG93IG9yIGVxdWFsIHRvIGVzdGltYXRlZCBiYW5kd2lkdGguXHJcbiAgICAgIC8vIGNvbnNpZGVyIG9ubHkgODAlIG9mIHRoZSBhdmFpbGFibGUgYmFuZHdpZHRoLCBidXQgaWYgd2UgYXJlIHN3aXRjaGluZyB1cCxcclxuICAgICAgLy8gYmUgZXZlbiBtb3JlIGNvbnNlcnZhdGl2ZSAoNzAlKSB0byBhdm9pZCBvdmVyZXN0aW1hdGluZyBhbmQgaW1tZWRpYXRlbHlcclxuICAgICAgLy8gc3dpdGNoaW5nIGJhY2suXHJcbiAgICAgIGlmIChpIDw9IGN1cnJlbnRMZXZlbCkge1xyXG4gICAgICAgIGFkanVzdGVkYncgPSBid0ZhY3RvciAqIGN1cnJlbnRCdztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhZGp1c3RlZGJ3ID0gYndVcEZhY3RvciAqIGN1cnJlbnRCdztcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYml0cmF0ZSA9IGxldmVsc1tpXS5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsc1tpXS5yZWFsQml0cmF0ZSwgbGV2ZWxzW2ldLmJpdHJhdGUpIDogbGV2ZWxzW2ldLmJpdHJhdGU7XHJcbiAgICAgIGNvbnN0IGZldGNoRHVyYXRpb24gPSBiaXRyYXRlICogYXZnRHVyYXRpb24gLyBhZGp1c3RlZGJ3O1xyXG5cclxuICAgICAgbG9nZ2VyLnRyYWNlKGBsZXZlbC9hZGp1c3RlZGJ3L2JpdHJhdGUvYXZnRHVyYXRpb24vbWF4RmV0Y2hEdXJhdGlvbi9mZXRjaER1cmF0aW9uOiAke2l9LyR7TWF0aC5yb3VuZChhZGp1c3RlZGJ3KX0vJHtiaXRyYXRlfS8ke2F2Z0R1cmF0aW9ufS8ke21heEZldGNoRHVyYXRpb259LyR7ZmV0Y2hEdXJhdGlvbn1gKTtcclxuICAgICAgLy8gaWYgYWRqdXN0ZWQgYncgaXMgZ3JlYXRlciB0aGFuIGxldmVsIGJpdHJhdGUgQU5EXHJcbiAgICAgIGlmIChhZGp1c3RlZGJ3ID4gYml0cmF0ZSAmJlxyXG4gICAgICAvLyBmcmFnbWVudCBmZXRjaER1cmF0aW9uIHVua25vd24gT1IgbGl2ZSBzdHJlYW0gT1IgZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiBsZXNzIHRoYW4gbWF4IGFsbG93ZWQgZmV0Y2ggZHVyYXRpb24sIHRoZW4gdGhpcyBsZXZlbCBtYXRjaGVzXHJcbiAgICAgIC8vIHdlIGRvbid0IGFjY291bnQgZm9yIG1heCBGZXRjaCBEdXJhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zLCB0aGlzIGlzIHRvIGF2b2lkIHN3aXRjaGluZyBkb3duIHdoZW4gbmVhciB0aGUgZWRnZSBvZiBsaXZlIHNsaWRpbmcgd2luZG93IC4uLlxyXG4gICAgICAvLyBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBzdGFydExldmVsID0gLTEgKGJpdHJhdGVUZXN0KSBvbiBsaXZlIHN0cmVhbXMgOiBpbiB0aGF0IGNhc2Ugd2Ugc2hvdWxkIG5vdCBleGl0IGxvb3Agc28gdGhhdCBfZmluZEJlc3RMZXZlbCB3aWxsIHJldHVybiAtMVxyXG4gICAgICAgICghZmV0Y2hEdXJhdGlvbiB8fCAobGl2ZSAmJiAhdGhpcy5iaXRyYXRlVGVzdERlbGF5KSB8fCBmZXRjaER1cmF0aW9uIDwgbWF4RmV0Y2hEdXJhdGlvbikpIHtcclxuICAgICAgICAvLyBhcyB3ZSBhcmUgbG9vcGluZyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0LCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGFjaGlldmFibGUgcXVhbGl0eSBsZXZlbFxyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBub3QgZW5vdWdoIHRpbWUgYnVkZ2V0IGV2ZW4gd2l0aCBxdWFsaXR5IGxldmVsIDAgLi4uIHJlYnVmZmVyaW5nIG1pZ2h0IGhhcHBlblxyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgc2V0IG5leHRBdXRvTGV2ZWwgKG5leHRMZXZlbCkge1xyXG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFickNvbnRyb2xsZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIuanMiLCIvKlxyXG4gKiBFV01BIEJhbmR3aWR0aCBFc3RpbWF0b3JcclxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxyXG4gKiBUcmFja3MgYmFuZHdpZHRoIHNhbXBsZXMgYW5kIGVzdGltYXRlcyBhdmFpbGFibGUgYmFuZHdpZHRoLlxyXG4gKiBCYXNlZCBvbiB0aGUgbWluaW11bSBvZiB0d28gZXhwb25lbnRpYWxseS13ZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZXMgd2l0aFxyXG4gKiBkaWZmZXJlbnQgaGFsZi1saXZlcy5cclxuICovXHJcblxyXG5pbXBvcnQgRVdNQSBmcm9tICcuLi91dGlscy9ld21hJztcclxuXHJcbmNsYXNzIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3Ige1xyXG4gIGhsczogYW55O1xyXG5cclxuICBwcml2YXRlIGRlZmF1bHRFc3RpbWF0ZV86IG51bWJlcjtcclxuICBwcml2YXRlIG1pbldlaWdodF86IG51bWJlcjtcclxuICBwcml2YXRlIG1pbkRlbGF5TXNfOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBzbG93XzogRVdNQTtcclxuICBwcml2YXRlIGZhc3RfOiBFV01BO1xyXG5cclxuICAvLyBUT0RPKHR5cGVzY3JpcHQtaGxzKVxyXG4gIGNvbnN0cnVjdG9yIChobHM6IGFueSwgc2xvdzogbnVtYmVyLCBmYXN0OiBudW1iZXIsIGRlZmF1bHRFc3RpbWF0ZTogbnVtYmVyKSB7XHJcbiAgICB0aGlzLmhscyA9IGhscztcclxuICAgIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IGRlZmF1bHRFc3RpbWF0ZTtcclxuICAgIHRoaXMubWluV2VpZ2h0XyA9IDAuMDAxO1xyXG4gICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xyXG4gICAgdGhpcy5zbG93XyA9IG5ldyBFV01BKHNsb3cpO1xyXG4gICAgdGhpcy5mYXN0XyA9IG5ldyBFV01BKGZhc3QpO1xyXG4gIH1cclxuXHJcbiAgc2FtcGxlIChkdXJhdGlvbk1zOiBudW1iZXIsIG51bUJ5dGVzOiBudW1iZXIpIHtcclxuICAgIGR1cmF0aW9uTXMgPSBNYXRoLm1heChkdXJhdGlvbk1zLCB0aGlzLm1pbkRlbGF5TXNfKTtcclxuICAgIGxldCBudW1CaXRzID0gOCAqIG51bUJ5dGVzLFxyXG4gICAgICAvLyB3ZWlnaHQgaXMgZHVyYXRpb24gaW4gc2Vjb25kc1xyXG4gICAgICBkdXJhdGlvblMgPSBkdXJhdGlvbk1zIC8gMTAwMCxcclxuICAgICAgLy8gdmFsdWUgaXMgYmFuZHdpZHRoIGluIGJpdHMvc1xyXG4gICAgICBiYW5kd2lkdGhJbkJwcyA9IG51bUJpdHMgLyBkdXJhdGlvblM7XHJcbiAgICB0aGlzLmZhc3RfLnNhbXBsZShkdXJhdGlvblMsIGJhbmR3aWR0aEluQnBzKTtcclxuICAgIHRoaXMuc2xvd18uc2FtcGxlKGR1cmF0aW9uUywgYmFuZHdpZHRoSW5CcHMpO1xyXG4gIH1cclxuXHJcbiAgY2FuRXN0aW1hdGUgKCk6IGJvb2xlYW4ge1xyXG4gICAgbGV0IGZhc3QgPSB0aGlzLmZhc3RfO1xyXG4gICAgcmV0dXJuIChmYXN0ICYmIGZhc3QuZ2V0VG90YWxXZWlnaHQoKSA+PSB0aGlzLm1pbldlaWdodF8pO1xyXG4gIH1cclxuXHJcbiAgZ2V0RXN0aW1hdGUgKCk6IG51bWJlciB7XHJcbiAgICBpZiAodGhpcy5jYW5Fc3RpbWF0ZSgpKSB7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdzbG93IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKSk7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdmYXN0IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpKSk7XHJcbiAgICAgIC8vIFRha2UgdGhlIG1pbmltdW0gb2YgdGhlc2UgdHdvIGVzdGltYXRlcy4gIFRoaXMgc2hvdWxkIGhhdmUgdGhlIGVmZmVjdCBvZlxyXG4gICAgICAvLyBhZGFwdGluZyBkb3duIHF1aWNrbHksIGJ1dCB1cCBtb3JlIHNsb3dseS5cclxuICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSwgdGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRFc3RpbWF0ZV87XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZXN0cm95ICgpIHtcclxuICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgRXdtYUJhbmRXaWR0aEVzdGltYXRvcjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLnRzIiwiLypcclxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxyXG4gKiAtIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vdmluZ19hdmVyYWdlI0V4cG9uZW50aWFsX21vdmluZ19hdmVyYWdlXHJcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcclxuICovXHJcblxyXG5jbGFzcyBFV01BIHtcclxuICBwcml2YXRlIGFscGhhXzogbnVtYmVyO1xyXG4gIHByaXZhdGUgZXN0aW1hdGVfOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSB0b3RhbFdlaWdodF86IG51bWJlcjtcclxuXHJcbiAgLy8gIEFib3V0IGhhbGYgb2YgdGhlIGVzdGltYXRlZCB2YWx1ZSB3aWxsIGJlIGZyb20gdGhlIGxhc3QgfGhhbGZMaWZlfCBzYW1wbGVzIGJ5IHdlaWdodC5cclxuICBjb25zdHJ1Y3RvciAoaGFsZkxpZmU6IG51bWJlcikge1xyXG4gICAgLy8gTGFyZ2VyIHZhbHVlcyBvZiBhbHBoYSBleHBpcmUgaGlzdG9yaWNhbCBkYXRhIG1vcmUgc2xvd2x5LlxyXG4gICAgdGhpcy5hbHBoYV8gPSBoYWxmTGlmZSA/IE1hdGguZXhwKE1hdGgubG9nKDAuNSkgLyBoYWxmTGlmZSkgOiAwO1xyXG4gICAgdGhpcy5lc3RpbWF0ZV8gPSAwO1xyXG4gICAgdGhpcy50b3RhbFdlaWdodF8gPSAwO1xyXG4gIH1cclxuXHJcbiAgc2FtcGxlICh3ZWlnaHQ6IG51bWJlciwgdmFsdWU6IG51bWJlcikge1xyXG4gICAgbGV0IGFkakFscGhhID0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHdlaWdodCk7XHJcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZhbHVlICogKDEgLSBhZGpBbHBoYSkgKyBhZGpBbHBoYSAqIHRoaXMuZXN0aW1hdGVfO1xyXG4gICAgdGhpcy50b3RhbFdlaWdodF8gKz0gd2VpZ2h0O1xyXG4gIH1cclxuXHJcbiAgZ2V0VG90YWxXZWlnaHQgKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XHJcbiAgfVxyXG5cclxuICBnZXRFc3RpbWF0ZSAoKTogbnVtYmVyIHtcclxuICAgIGlmICh0aGlzLmFscGhhXykge1xyXG4gICAgICBsZXQgemVyb0ZhY3RvciA9IDEgLSBNYXRoLnBvdyh0aGlzLmFscGhhXywgdGhpcy50b3RhbFdlaWdodF8pO1xyXG4gICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV8gLyB6ZXJvRmFjdG9yO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRVdNQTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMvZXdtYS50cyIsIi8qXHJcbiAqIEJ1ZmZlciBDb250cm9sbGVyXHJcbiAqL1xyXG5cclxuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5pbXBvcnQgeyBnZXRNZWRpYVNvdXJjZSB9IGZyb20gJy4uL3V0aWxzL21lZGlhc291cmNlLWhlbHBlcic7XHJcblxyXG5pbXBvcnQgeyBUcmFja1NldCB9IGZyb20gJy4uL3R5cGVzL3RyYWNrJztcclxuaW1wb3J0IHsgU2VnbWVudCB9IGZyb20gJy4uL3R5cGVzL3NlZ21lbnQnO1xyXG5pbXBvcnQgeyBCdWZmZXJDb250cm9sbGVyQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcclxuXHJcbi8vIEFkZCBleHRlbnNpb24gcHJvcGVydGllcyB0byBTb3VyY2VCdWZmZXJzIGZyb20gdGhlIERPTSBBUEkuXHJcbnR5cGUgRXh0ZW5kZWRTb3VyY2VCdWZmZXIgPSBTb3VyY2VCdWZmZXIgJiB7XHJcbiAgZW5kZWQ/OiBib29sZWFuXHJcbn07XHJcblxyXG50eXBlIFNvdXJjZUJ1ZmZlck5hbWUgPSAndmlkZW8nIHwgJ2F1ZGlvJztcclxudHlwZSBTb3VyY2VCdWZmZXJzID0gUGFydGlhbDxSZWNvcmQ8U291cmNlQnVmZmVyTmFtZSwgRXh0ZW5kZWRTb3VyY2VCdWZmZXI+PjtcclxuXHJcbmludGVyZmFjZSBTb3VyY2VCdWZmZXJGbHVzaFJhbmdlIHtcclxuICBzdGFydDogbnVtYmVyO1xyXG4gIGVuZDogbnVtYmVyO1xyXG4gIHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWVcclxufVxyXG5cclxuY29uc3QgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xyXG5cclxuY2xhc3MgQnVmZmVyQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcbiAgLy8gdGhlIHZhbHVlIHRoYXQgd2UgaGF2ZSBzZXQgbWVkaWFzb3VyY2UuZHVyYXRpb24gdG9cclxuICAvLyAodGhlIGFjdHVhbCBkdXJhdGlvbiBtYXkgYmUgdHdlYWtlZCBzbGlnaGx5IGJ5IHRoZSBicm93c2VyKVxyXG4gIHByaXZhdGUgX21zRHVyYXRpb246IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG4gIC8vIHRoZSB2YWx1ZSB0aGF0IHdlIHdhbnQgdG8gc2V0IG1lZGlhU291cmNlLmR1cmF0aW9uIHRvXHJcbiAgcHJpdmF0ZSBfbGV2ZWxEdXJhdGlvbjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XHJcbiAgLy8gdGhlIHRhcmdldCBkdXJhdGlvbiBvZiB0aGUgY3VycmVudCBtZWRpYSBwbGF5bGlzdFxyXG4gIHByaXZhdGUgX2xldmVsVGFyZ2V0RHVyYXRpb246IG51bWJlciA9IDEwO1xyXG4gIC8vIGN1cnJlbnQgc3RyZWFtIHN0YXRlOiB0cnVlIC0gZm9yIGxpdmUgYnJvYWRjYXN0LCBmYWxzZSAtIGZvciBWb0QgY29udGVudFxyXG4gIHByaXZhdGUgX2xpdmU6IGJvb2xlYW4gfCBudWxsID0gbnVsbDtcclxuICAvLyBjYWNoZSB0aGUgc2VsZiBnZW5lcmF0ZWQgb2JqZWN0IHVybCB0byBkZXRlY3QgaGlqYWNrIG9mIHZpZGVvIHRhZ1xyXG4gIHByaXZhdGUgX29iamVjdFVybDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIC8vIHNpZ25hbHMgdGhhdCB0aGUgc291cmNlQnVmZmVycyBuZWVkIHRvIGJlIGZsdXNoZWRcclxuICBwcml2YXRlIF9uZWVkc0ZsdXNoOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gIC8vIHNpZ25hbHMgdGhhdCBtZWRpYVNvdXJjZSBzaG91bGQgaGF2ZSBlbmRPZlN0cmVhbSBjYWxsZWRcclxuICBwcml2YXRlIF9uZWVkc0VvczogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICBwcml2YXRlIGNvbmZpZzogQnVmZmVyQ29udHJvbGxlckNvbmZpZztcclxuXHJcbiAgLy8gdGhpcyBpcyBvcHRpb25hbCBiZWNhdXNlIHRoaXMgcHJvcGVydHkgaXMgcmVtb3ZlZCBmcm9tIHRoZSBjbGFzcyBzb21ldGltZXNcclxuICBwdWJsaWMgYXVkaW9UaW1lc3RhbXBPZmZzZXQ/OiBudW1iZXI7XHJcblxyXG4gIC8vIFRoZSBudW1iZXIgb2YgQlVGRkVSX0NPREVDIGV2ZW50cyByZWNlaXZlZCBiZWZvcmUgYW55IHNvdXJjZUJ1ZmZlcnMgYXJlIGNyZWF0ZWRcclxuICBwdWJsaWMgYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZDogbnVtYmVyID0gMDtcclxuXHJcbiAgLy8gVGhlIHRvdGFsIG51bWJlciBvZiBCVUZGRVJfQ09ERUMgZXZlbnRzIHJlY2VpdmVkXHJcbiAgcHJpdmF0ZSBfYnVmZmVyQ29kZWNFdmVudHNUb3RhbDogbnVtYmVyID0gMDtcclxuXHJcbiAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGF0dGFjaGVkIG1lZGlhIGVsZW1lbnRcclxuICBwdWJsaWMgbWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGFjdGl2ZSBtZWRpYSBzb3VyY2VcclxuICBwdWJsaWMgbWVkaWFTb3VyY2U6IE1lZGlhU291cmNlIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIC8vIExpc3Qgb2YgcGVuZGluZyBzZWdtZW50cyB0byBiZSBhcHBlbmRlZCB0byBzb3VyY2UgYnVmZmVyXHJcbiAgcHVibGljIHNlZ21lbnRzOiBTZWdtZW50W10gPSBbXTtcclxuXHJcbiAgcHVibGljIHBhcmVudD86IHN0cmluZztcclxuXHJcbiAgLy8gQSBndWFyZCB0byBzZWUgaWYgd2UgYXJlIGN1cnJlbnRseSBhcHBlbmRpbmcgdG8gdGhlIHNvdXJjZSBidWZmZXJcclxuICBwdWJsaWMgYXBwZW5kaW5nOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gIC8vIGNvdW50ZXJzXHJcbiAgcHVibGljIGFwcGVuZGVkOiBudW1iZXIgPSAwO1xyXG4gIHB1YmxpYyBhcHBlbmRFcnJvcjogbnVtYmVyID0gMDtcclxuICBwdWJsaWMgZmx1c2hCdWZmZXJDb3VudGVyOiBudW1iZXIgPSAwO1xyXG5cclxuICBwdWJsaWMgdHJhY2tzOiBUcmFja1NldCA9IHt9O1xyXG4gIHB1YmxpYyBwZW5kaW5nVHJhY2tzOiBUcmFja1NldCA9IHt9O1xyXG4gIHB1YmxpYyBzb3VyY2VCdWZmZXI6IFNvdXJjZUJ1ZmZlcnMgPSB7fTtcclxuICBwdWJsaWMgZmx1c2hSYW5nZTogU291cmNlQnVmZmVyRmx1c2hSYW5nZVtdID0gW107XHJcblxyXG4gIGNvbnN0cnVjdG9yIChobHM6IGFueSkge1xyXG4gICAgc3VwZXIoaGxzLFxyXG4gICAgICBFdmVudHMuTUVESUFfQVRUQUNISU5HLFxyXG4gICAgICBFdmVudHMuTUVESUFfREVUQUNISU5HLFxyXG4gICAgICBFdmVudHMuTUFOSUZFU1RfUEFSU0VELFxyXG4gICAgICBFdmVudHMuQlVGRkVSX1JFU0VULFxyXG4gICAgICBFdmVudHMuQlVGRkVSX0FQUEVORElORyxcclxuICAgICAgRXZlbnRzLkJVRkZFUl9DT0RFQ1MsXHJcbiAgICAgIEV2ZW50cy5CVUZGRVJfRU9TLFxyXG4gICAgICBFdmVudHMuQlVGRkVSX0ZMVVNISU5HLFxyXG4gICAgICBFdmVudHMuTEVWRUxfUFRTX1VQREFURUQsXHJcbiAgICAgIEV2ZW50cy5MRVZFTF9VUERBVEVEKTtcclxuXHJcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95ICgpIHtcclxuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgb25MZXZlbFB0c1VwZGF0ZWQgKGRhdGE6IHsgdHlwZTogU291cmNlQnVmZmVyTmFtZSwgc3RhcnQ6IG51bWJlciB9KSB7XHJcbiAgICBsZXQgdHlwZSA9IGRhdGEudHlwZTtcclxuICAgIGxldCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3MuYXVkaW87XHJcblxyXG4gICAgLy8gQWRqdXN0aW5nIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YCAoZGVzaXJlZCBwb2ludCBpbiB0aGUgdGltZWxpbmUgd2hlcmUgdGhlIG5leHQgZnJhbWVzIHNob3VsZCBiZSBhcHBlbmRlZClcclxuICAgIC8vIGluIENocm9tZSBicm93c2VyIHdoZW4gd2UgZGV0ZWN0IE1QRUcgYXVkaW8gY29udGFpbmVyIGFuZCB0aW1lIGRlbHRhIGJldHdlZW4gbGV2ZWwgUFRTIGFuZCBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGBcclxuICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiAxMDBtcyAodGhpcyBpcyBlbm91Z2ggdG8gaGFuZGxlIHNlZWsgZm9yIFZPRCBvciBsZXZlbCBjaGFuZ2UgZm9yIExJVkUgdmlkZW9zKS4gQXQgdGhlIHRpbWUgb2YgY2hhbmdlIHdlIGlzc3VlXHJcbiAgICAvLyBgU291cmNlQnVmZmVyLmFib3J0KClgIGFuZCBhZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIGlmIGBTb3VyY2VCdWZmZXIudXBkYXRpbmdgIGlzIGZhbHNlIG9yIGF3YWl0aW5nIGB1cGRhdGVlbmRgXHJcbiAgICAvLyBldmVudCBpZiBTQiBpcyBpbiB1cGRhdGluZyBzdGF0ZS5cclxuICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzMyI2lzc3VlY29tbWVudC0yNTc5ODY0ODZcclxuXHJcbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiBhdWRpb1RyYWNrICYmIGF1ZGlvVHJhY2suY29udGFpbmVyID09PSAnYXVkaW8vbXBlZycpIHsgLy8gQ2hyb21lIGF1ZGlvIG1wMyB0cmFja1xyXG4gICAgICBsZXQgYXVkaW9CdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlci5hdWRpbztcclxuICAgICAgaWYgKCFhdWRpb0J1ZmZlcikge1xyXG4gICAgICAgIHRocm93IEVycm9yKCdMZXZlbCBQVFMgVXBkYXRlZCBhbmQgc291cmNlIGJ1ZmZlciBmb3IgYXVkaW8gdW5pbml0YWxpemVkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBkZWx0YSA9IE1hdGguYWJzKGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCAtIGRhdGEuc3RhcnQpO1xyXG5cclxuICAgICAgLy8gYWRqdXN0IHRpbWVzdGFtcCBvZmZzZXQgaWYgdGltZSBkZWx0YSBpcyBncmVhdGVyIHRoYW4gMTAwbXNcclxuICAgICAgaWYgKGRlbHRhID4gMC4xKSB7XHJcbiAgICAgICAgbGV0IHVwZGF0aW5nID0gYXVkaW9CdWZmZXIudXBkYXRpbmc7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhdWRpb0J1ZmZlci5hYm9ydCgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ2NhbiBub3QgYWJvcnQgYXVkaW8gYnVmZmVyOiAnICsgZXJyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdXBkYXRpbmcpIHtcclxuICAgICAgICAgIGxvZ2dlci53YXJuKCdjaGFuZ2UgbXBlZyBhdWRpbyB0aW1lc3RhbXAgb2Zmc2V0IGZyb20gJyArIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCArICcgdG8gJyArIGRhdGEuc3RhcnQpO1xyXG4gICAgICAgICAgYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0ID0gZGF0YS5zdGFydDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldCA9IGRhdGEuc3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbk1hbmlmZXN0UGFyc2VkIChkYXRhOiB7IGFsdEF1ZGlvOiBib29sZWFuIH0pIHtcclxuICAgIC8vIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIDIgQlVGRkVSX0NPREVDUyBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQsIG9uZSBwZXIgc3RyZWFtIGNvbnRyb2xsZXJcclxuICAgIC8vIHNvdXJjZWJ1ZmZlcnMgd2lsbCBiZSBjcmVhdGVkIGFsbCBhdCBvbmNlIHdoZW4gdGhlIGV4cGVjdGVkIG5iIG9mIHRyYWNrcyB3aWxsIGJlIHJlYWNoZWRcclxuICAgIC8vIGluIGNhc2UgYWx0IGF1ZGlvIGlzIG5vdCB1c2VkLCBvbmx5IG9uZSBCVUZGRVJfQ09ERUMgZXZlbnQgd2lsbCBiZSBmaXJlZCBmcm9tIG1haW4gc3RyZWFtIGNvbnRyb2xsZXJcclxuICAgIC8vIGl0IHdpbGwgY29udGFpbiB0aGUgZXhwZWN0ZWQgbmIgb2Ygc291cmNlIGJ1ZmZlcnMsIG5vIG5lZWQgdG8gY29tcHV0ZSBpdFxyXG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gdGhpcy5fYnVmZmVyQ29kZWNFdmVudHNUb3RhbCA9IGRhdGEuYWx0QXVkaW8gPyAyIDogMTtcclxuICAgIGxvZ2dlci5sb2coYCR7dGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkfSBidWZmZXJDb2RlYyBldmVudChzKSBleHBlY3RlZGApO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYUF0dGFjaGluZyAoZGF0YTogeyBtZWRpYTogSFRNTE1lZGlhRWxlbWVudCB9KSB7XHJcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcclxuICAgIGlmIChtZWRpYSAmJiBNZWRpYVNvdXJjZSkge1xyXG4gICAgICAvLyBzZXR1cCB0aGUgbWVkaWEgc291cmNlXHJcbiAgICAgIGxldCBtcyA9IHRoaXMubWVkaWFTb3VyY2UgPSBuZXcgTWVkaWFTb3VyY2UoKTtcclxuICAgICAgLy8gTWVkaWEgU291cmNlIGxpc3RlbmVyc1xyXG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pO1xyXG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCk7XHJcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlKTtcclxuICAgICAgLy8gbGluayB2aWRlbyBhbmQgbWVkaWEgU291cmNlXHJcbiAgICAgIG1lZGlhLnNyYyA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG1zKTtcclxuICAgICAgLy8gY2FjaGUgdGhlIGxvY2FsbHkgZ2VuZXJhdGVkIG9iamVjdCB1cmxcclxuICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbWVkaWEuc3JjO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25NZWRpYURldGFjaGluZyAoKSB7XHJcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgZGV0YWNoaW5nJyk7XHJcbiAgICBsZXQgbXMgPSB0aGlzLm1lZGlhU291cmNlO1xyXG4gICAgaWYgKG1zKSB7XHJcbiAgICAgIGlmIChtcy5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gZW5kT2ZTdHJlYW0gY291bGQgdHJpZ2dlciBleGNlcHRpb24gaWYgYW55IHNvdXJjZWJ1ZmZlciBpcyBpbiB1cGRhdGluZyBzdGF0ZVxyXG4gICAgICAgICAgLy8gd2UgZG9uJ3QgcmVhbGx5IGNhcmUgYWJvdXQgY2hlY2tpbmcgc291cmNlYnVmZmVyIHN0YXRlIGhlcmUsXHJcbiAgICAgICAgICAvLyBhcyB3ZSBhcmUgYW55d2F5IGRldGFjaGluZyB0aGUgTWVkaWFTb3VyY2VcclxuICAgICAgICAgIC8vIGxldCdzIGp1c3QgYXZvaWQgdGhpcyBleGNlcHRpb24gdG8gcHJvcGFnYXRlXHJcbiAgICAgICAgICBtcy5lbmRPZlN0cmVhbSgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG9uTWVkaWFEZXRhY2hpbmc6JHtlcnIubWVzc2FnZX0gd2hpbGUgY2FsbGluZyBlbmRPZlN0cmVhbWApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pO1xyXG4gICAgICBtcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCk7XHJcbiAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlKTtcclxuXHJcbiAgICAgIC8vIERldGFjaCBwcm9wZXJseSB0aGUgTWVkaWFTb3VyY2UgZnJvbSB0aGUgSFRNTE1lZGlhRWxlbWVudCBhc1xyXG4gICAgICAvLyBzdWdnZXN0ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3czYy9tZWRpYS1zb3VyY2UvaXNzdWVzLzUzLlxyXG4gICAgICBpZiAodGhpcy5tZWRpYSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9vYmplY3RVcmwpIHtcclxuICAgICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMuX29iamVjdFVybCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjbGVhbiB1cCB2aWRlbyB0YWcgc3JjIG9ubHkgaWYgaXQncyBvdXIgb3duIHVybC4gc29tZSBleHRlcm5hbCBsaWJyYXJpZXMgbWlnaHRcclxuICAgICAgICAvLyBoaWphY2sgdGhlIHZpZGVvIHRhZyBhbmQgY2hhbmdlIGl0cyAnc3JjJyB3aXRob3V0IGRlc3Ryb3lpbmcgdGhlIEhscyBpbnN0YW5jZSBmaXJzdFxyXG4gICAgICAgIGlmICh0aGlzLm1lZGlhLnNyYyA9PT0gdGhpcy5fb2JqZWN0VXJsKSB7XHJcbiAgICAgICAgICB0aGlzLm1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XHJcbiAgICAgICAgICB0aGlzLm1lZGlhLmxvYWQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ21lZGlhLnNyYyB3YXMgY2hhbmdlZCBieSBhIHRoaXJkIHBhcnR5IC0gc2tpcCBjbGVhbnVwJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcclxuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XHJcbiAgICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XHJcbiAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWw7XHJcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xyXG4gICAgICB0aGlzLnRyYWNrcyA9IHt9O1xyXG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xyXG4gICAgICB0aGlzLmZsdXNoUmFuZ2UgPSBbXTtcclxuICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xyXG4gICAgICB0aGlzLmFwcGVuZGVkID0gMDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCk7XHJcbiAgfVxyXG5cclxuICBjaGVja1BlbmRpbmdUcmFja3MgKCkge1xyXG4gICAgbGV0IHsgYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCwgcGVuZGluZ1RyYWNrcyB9ID0gdGhpcztcclxuXHJcbiAgICAvLyBDaGVjayBpZiB3ZSd2ZSByZWNlaXZlZCBhbGwgb2YgdGhlIGV4cGVjdGVkIGJ1ZmZlckNvZGVjIGV2ZW50cy4gV2hlbiBub25lIHJlbWFpbiwgY3JlYXRlIGFsbCB0aGUgc291cmNlQnVmZmVycyBhdCBvbmNlLlxyXG4gICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgTVNFIHNwZWMgYWxsb3dzIGltcGxlbWVudGF0aW9ucyB0byB0aHJvdyBRdW90YUV4Y2VlZGVkRXJyb3JzIGlmIGNyZWF0aW5nIG5ldyBzb3VyY2VCdWZmZXJzIGFmdGVyXHJcbiAgICAvLyBkYXRhIGhhcyBiZWVuIGFwcGVuZGVkIHRvIGV4aXN0aW5nIG9uZXMuXHJcbiAgICAvLyAyIHRyYWNrcyBpcyB0aGUgbWF4IChvbmUgZm9yIGF1ZGlvLCBvbmUgZm9yIHZpZGVvKS4gSWYgd2UndmUgcmVhY2ggdGhpcyBtYXggZ28gYWhlYWQgYW5kIGNyZWF0ZSB0aGUgYnVmZmVycy5cclxuICAgIGNvbnN0IHBlbmRpbmdUcmFja3NDb3VudCA9IE9iamVjdC5rZXlzKHBlbmRpbmdUcmFja3MpLmxlbmd0aDtcclxuICAgIGlmICgocGVuZGluZ1RyYWNrc0NvdW50ICYmICFidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkKSB8fCBwZW5kaW5nVHJhY2tzQ291bnQgPT09IDIpIHtcclxuICAgICAgLy8gb2ssIGxldCdzIGNyZWF0ZSB0aGVtIG5vdyAhXHJcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlQnVmZmVycyhwZW5kaW5nVHJhY2tzKTtcclxuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XHJcbiAgICAgIC8vIGFwcGVuZCBhbnkgcGVuZGluZyBzZWdtZW50cyBub3cgIVxyXG4gICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9vbk1lZGlhU291cmNlT3BlbiA9ICgpID0+IHtcclxuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBvcGVuZWQnKTtcclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB7IG1lZGlhOiB0aGlzLm1lZGlhIH0pO1xyXG4gICAgbGV0IG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcclxuICAgIGlmIChtZWRpYVNvdXJjZSkge1xyXG4gICAgICAvLyBvbmNlIHJlY2VpdmVkLCBkb24ndCBsaXN0ZW4gYW55bW9yZSB0byBzb3VyY2VvcGVuIGV2ZW50XHJcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfb25NZWRpYVNvdXJjZUNsb3NlID0gKCkgPT4ge1xyXG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGNsb3NlZCcpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfb25NZWRpYVNvdXJjZUVuZGVkID0gKCkgPT4ge1xyXG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGVuZGVkJyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9vblNCVXBkYXRlRW5kID0gKCkgPT4ge1xyXG4gICAgLy8gdXBkYXRlIHRpbWVzdGFtcE9mZnNldFxyXG4gICAgaWYgKHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQgJiYgdGhpcy5zb3VyY2VCdWZmZXIuYXVkaW8pIHtcclxuICAgICAgbGV0IGF1ZGlvQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIuYXVkaW87XHJcblxyXG4gICAgICBsb2dnZXIud2FybihgY2hhbmdlIG1wZWcgYXVkaW8gdGltZXN0YW1wIG9mZnNldCBmcm9tICR7YXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0fSB0byAke3RoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXR9YCk7XHJcbiAgICAgIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCA9IHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQ7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9uZWVkc0ZsdXNoKSB7XHJcbiAgICAgIHRoaXMuZG9GbHVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9uZWVkc0Vvcykge1xyXG4gICAgICB0aGlzLmNoZWNrRW9zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hcHBlbmRpbmcgPSBmYWxzZTtcclxuICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgIC8vIGNvdW50IG5iIG9mIHBlbmRpbmcgc2VnbWVudHMgd2FpdGluZyBmb3IgYXBwZW5kaW5nIG9uIHRoaXMgc291cmNlYnVmZmVyXHJcbiAgICBsZXQgcGVuZGluZyA9IHRoaXMuc2VnbWVudHMucmVkdWNlKChjb3VudGVyLCBzZWdtZW50KSA9PiAoc2VnbWVudC5wYXJlbnQgPT09IHBhcmVudCkgPyBjb3VudGVyICsgMSA6IGNvdW50ZXIsIDApO1xyXG5cclxuICAgIC8vIHRoaXMuc291cmNlQnVmZmVyIGlzIGJldHRlciB0byB1c2UgdGhhbiBtZWRpYS5idWZmZXJlZCBhcyBpdCBpcyBjbG9zZXIgdG8gdGhlIFBUUyBkYXRhIGZyb20gdGhlIGZyYWdtZW50c1xyXG4gICAgY29uc3QgdGltZVJhbmdlczogUGFydGlhbDxSZWNvcmQ8U291cmNlQnVmZmVyTmFtZSwgVGltZVJhbmdlcz4+ID0ge307XHJcbiAgICBjb25zdCBzYlNldCA9IHRoaXMuc291cmNlQnVmZmVyO1xyXG4gICAgZm9yIChsZXQgc3RyZWFtVHlwZSBpbiBzYlNldCkge1xyXG4gICAgICBjb25zdCBzYiA9IHNiU2V0W3N0cmVhbVR5cGUgYXMgU291cmNlQnVmZmVyTmFtZV07XHJcbiAgICAgIGlmICghc2IpIHtcclxuICAgICAgICB0aHJvdyBFcnJvcihgaGFuZGxpbmcgc291cmNlIGJ1ZmZlciB1cGRhdGUgZW5kIGVycm9yOiBzb3VyY2UgYnVmZmVyIGZvciAke3N0cmVhbVR5cGV9IHVuaW5pdGlsaXplZCBhbmQgdW5hYmxlIHRvIHVwZGF0ZSBidWZmZXJlZCBUaW1lUmFuZ2VzLmApO1xyXG4gICAgICB9XHJcbiAgICAgIHRpbWVSYW5nZXNbc3RyZWFtVHlwZSBhcyBTb3VyY2VCdWZmZXJOYW1lXSA9IHNiLmJ1ZmZlcmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwgeyBwYXJlbnQsIHBlbmRpbmcsIHRpbWVSYW5nZXMgfSk7XHJcbiAgICAvLyBkb24ndCBhcHBlbmQgaW4gZmx1c2hpbmcgbW9kZVxyXG4gICAgaWYgKCF0aGlzLl9uZWVkc0ZsdXNoKSB7XHJcbiAgICAgIHRoaXMuZG9BcHBlbmRpbmcoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XHJcblxyXG4gICAgLy8gYXBwZW5kaW5nIGdvZXMgZmlyc3RcclxuICAgIGlmIChwZW5kaW5nID09PSAwKSB7XHJcbiAgICAgIHRoaXMuZmx1c2hMaXZlQmFja0J1ZmZlcigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfb25TQlVwZGF0ZUVycm9yID0gKGV2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgbG9nZ2VyLmVycm9yKCdzb3VyY2VCdWZmZXIgZXJyb3I6JywgZXZlbnQpO1xyXG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxyXG4gICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcclxuICAgIC8vIGl0IHdpbGwgYmUgZm9sbG93ZWQgYnkgYSBtZWRpYUVsZW1lbnQgZXJyb3IgLi4uKVxyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSB9KTtcclxuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gZG8gbW9yZSB0aGFuIHRoYXQsIGFzIGFjY29yZGluIHRvIHRoZSBzcGVjLCB1cGRhdGVlbmQgd2lsbCBiZSBmaXJlZCBqdXN0IGFmdGVyXHJcbiAgfVxyXG5cclxuICBvbkJ1ZmZlclJlc2V0ICgpIHtcclxuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xyXG4gICAgZm9yIChsZXQgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcclxuICAgICAgY29uc3Qgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHNiKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5tZWRpYVNvdXJjZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcihzYik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzYi5yZW1vdmVFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLl9vblNCVXBkYXRlRW5kKTtcclxuICAgICAgICAgIHNiLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fb25TQlVwZGF0ZUVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xyXG4gICAgdGhpcy5mbHVzaFJhbmdlID0gW107XHJcbiAgICB0aGlzLnNlZ21lbnRzID0gW107XHJcbiAgICB0aGlzLmFwcGVuZGVkID0gMDtcclxuICB9XHJcblxyXG4gIG9uQnVmZmVyQ29kZWNzICh0cmFja3M6IFRyYWNrU2V0KSB7XHJcbiAgICAvLyBpZiBzb3VyY2UgYnVmZmVyKHMpIG5vdCBjcmVhdGVkIHlldCwgYXBwZW5kZWQgYnVmZmVyIHRyYWNrcyBpbiB0aGlzLnBlbmRpbmdUcmFja3NcclxuICAgIC8vIGlmIHNvdXJjZWJ1ZmZlcnMgYWxyZWFkeSBjcmVhdGVkLCBkbyBub3RoaW5nIC4uLlxyXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVyKS5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIE9iamVjdC5rZXlzKHRyYWNrcykuZm9yRWFjaCh0cmFja05hbWUgPT4ge1xyXG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3NbdHJhY2tOYW1lXSA9IHRyYWNrc1t0cmFja05hbWVdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gTWF0aC5tYXgodGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkIC0gMSwgMCk7XHJcbiAgICBpZiAodGhpcy5tZWRpYVNvdXJjZSAmJiB0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xyXG4gICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY3JlYXRlU291cmNlQnVmZmVycyAodHJhY2tzOiBUcmFja1NldCkge1xyXG4gICAgY29uc3QgeyBzb3VyY2VCdWZmZXIsIG1lZGlhU291cmNlIH0gPSB0aGlzO1xyXG4gICAgaWYgKCFtZWRpYVNvdXJjZSkge1xyXG4gICAgICB0aHJvdyBFcnJvcignY3JlYXRlU291cmNlQnVmZmVycyBjYWxsZWQgd2hlbiBtZWRpYVNvdXJjZSB3YXMgbnVsbCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcclxuICAgICAgaWYgKCFzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSkge1xyXG4gICAgICAgIGxldCB0cmFjayA9IHRyYWNrc1t0cmFja05hbWUgYXMga2V5b2YgVHJhY2tTZXRdO1xyXG4gICAgICAgIGlmICghdHJhY2spIHtcclxuICAgICAgICAgIHRocm93IEVycm9yKGBzb3VyY2UgYnVmZmVyIGV4aXN0cyBmb3IgdHJhY2sgJHt0cmFja05hbWV9LCBob3dldmVyIHRyYWNrIGRvZXMgbm90YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHVzZSBsZXZlbENvZGVjIGFzIGZpcnN0IHByaW9yaXR5XHJcbiAgICAgICAgbGV0IGNvZGVjID0gdHJhY2subGV2ZWxDb2RlYyB8fCB0cmFjay5jb2RlYztcclxuICAgICAgICBsZXQgbWltZVR5cGUgPSBgJHt0cmFjay5jb250YWluZXJ9O2NvZGVjcz0ke2NvZGVjfWA7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgY3JlYXRpbmcgc291cmNlQnVmZmVyKCR7bWltZVR5cGV9KWApO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBsZXQgc2IgPSBzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSA9IG1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihtaW1lVHlwZSk7XHJcbiAgICAgICAgICBzYi5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLl9vblNCVXBkYXRlRW5kKTtcclxuICAgICAgICAgIHNiLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fb25TQlVwZGF0ZUVycm9yKTtcclxuICAgICAgICAgIHRoaXMudHJhY2tzW3RyYWNrTmFtZV0gPSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcjogc2IsXHJcbiAgICAgICAgICAgIGNvZGVjOiBjb2RlYyxcclxuICAgICAgICAgICAgaWQ6IHRyYWNrLmlkLFxyXG4gICAgICAgICAgICBjb250YWluZXI6IHRyYWNrLmNvbnRhaW5lcixcclxuICAgICAgICAgICAgbGV2ZWxDb2RlYzogdHJhY2subGV2ZWxDb2RlY1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIGxvZ2dlci5lcnJvcihgZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGFkZCBzb3VyY2VCdWZmZXI6JHtlcnIubWVzc2FnZX1gKTtcclxuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SLCBmYXRhbDogZmFsc2UsIGVycjogZXJyLCBtaW1lVHlwZTogbWltZVR5cGUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgeyB0cmFja3M6IHRoaXMudHJhY2tzIH0pO1xyXG4gIH1cclxuXHJcbiAgb25CdWZmZXJBcHBlbmRpbmcgKGRhdGE6IFNlZ21lbnQpIHtcclxuICAgIGlmICghdGhpcy5fbmVlZHNGbHVzaCkge1xyXG4gICAgICBpZiAoIXRoaXMuc2VnbWVudHMpIHtcclxuICAgICAgICB0aGlzLnNlZ21lbnRzID0gWyBkYXRhIF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKGRhdGEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBvbiBCVUZGRVJfRU9TIG1hcmsgbWF0Y2hpbmcgc291cmNlYnVmZmVyKHMpIGFzIGVuZGVkIGFuZCB0cmlnZ2VyIGNoZWNrRW9zKClcclxuICAvLyBhbiB1bmRlZmluZWQgZGF0YS50eXBlIHdpbGwgbWFyayBhbGwgYnVmZmVycyBhcyBFT1MuXHJcbiAgb25CdWZmZXJFb3MgKGRhdGE6IHsgdHlwZT86IFNvdXJjZUJ1ZmZlck5hbWUgfSkge1xyXG4gICAgZm9yIChjb25zdCB0eXBlIGluIHRoaXMuc291cmNlQnVmZmVyKSB7XHJcbiAgICAgIGlmICghZGF0YS50eXBlIHx8IGRhdGEudHlwZSA9PT0gdHlwZSkge1xyXG4gICAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZSBhcyBTb3VyY2VCdWZmZXJOYW1lXTtcclxuICAgICAgICBpZiAoc2IgJiYgIXNiLmVuZGVkKSB7XHJcbiAgICAgICAgICBzYi5lbmRlZCA9IHRydWU7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKGAke3R5cGV9IHNvdXJjZUJ1ZmZlciBub3cgRU9TYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jaGVja0VvcygpO1xyXG4gIH1cclxuXHJcbiAgLy8gaWYgYWxsIHNvdXJjZSBidWZmZXJzIGFyZSBtYXJrZWQgYXMgZW5kZWQsIHNpZ25hbCBlbmRPZlN0cmVhbSgpIHRvIE1lZGlhU291cmNlLlxyXG4gIGNoZWNrRW9zICgpIHtcclxuICAgIGNvbnN0IHsgc291cmNlQnVmZmVyLCBtZWRpYVNvdXJjZSB9ID0gdGhpcztcclxuICAgIGlmICghbWVkaWFTb3VyY2UgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XHJcbiAgICAgIHRoaXMuX25lZWRzRW9zID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xyXG4gICAgICBjb25zdCBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlIGFzIFNvdXJjZUJ1ZmZlck5hbWVdO1xyXG4gICAgICBpZiAoIXNiKSBjb250aW51ZTtcclxuXHJcbiAgICAgIGlmICghc2IuZW5kZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzYi51cGRhdGluZykge1xyXG4gICAgICAgIHRoaXMuX25lZWRzRW9zID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsb2dnZXIubG9nKCdhbGwgbWVkaWEgZGF0YSBhcmUgYXZhaWxhYmxlLCBzaWduYWwgZW5kT2ZTdHJlYW0oKSB0byBNZWRpYVNvdXJjZSBhbmQgc3RvcCBsb2FkaW5nIGZyYWdtZW50Jyk7XHJcbiAgICAvLyBOb3RpZnkgdGhlIG1lZGlhIGVsZW1lbnQgdGhhdCBpdCBub3cgaGFzIGFsbCBvZiB0aGUgbWVkaWEgZGF0YVxyXG4gICAgdHJ5IHtcclxuICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgbG9nZ2VyLndhcm4oJ2V4Y2VwdGlvbiB3aGlsZSBjYWxsaW5nIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCknKTtcclxuICAgIH1cclxuICAgIHRoaXMuX25lZWRzRW9zID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBvbkJ1ZmZlckZsdXNoaW5nIChkYXRhOiB7IHN0YXJ0T2Zmc2V0OiBudW1iZXIsIGVuZE9mZnNldDogbnVtYmVyLCB0eXBlPzogU291cmNlQnVmZmVyTmFtZSB9KSB7XHJcbiAgICBpZiAoZGF0YS50eXBlKSB7XHJcbiAgICAgIHRoaXMuZmx1c2hSYW5nZS5wdXNoKHsgc3RhcnQ6IGRhdGEuc3RhcnRPZmZzZXQsIGVuZDogZGF0YS5lbmRPZmZzZXQsIHR5cGU6IGRhdGEudHlwZSB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZmx1c2hSYW5nZS5wdXNoKHsgc3RhcnQ6IGRhdGEuc3RhcnRPZmZzZXQsIGVuZDogZGF0YS5lbmRPZmZzZXQsIHR5cGU6ICd2aWRlbycgfSk7XHJcbiAgICAgIHRoaXMuZmx1c2hSYW5nZS5wdXNoKHsgc3RhcnQ6IGRhdGEuc3RhcnRPZmZzZXQsIGVuZDogZGF0YS5lbmRPZmZzZXQsIHR5cGU6ICdhdWRpbycgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYXR0ZW1wdCBmbHVzaCBpbW1lZGlhdGVseVxyXG4gICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIgPSAwO1xyXG4gICAgdGhpcy5kb0ZsdXNoKCk7XHJcbiAgfVxyXG5cclxuICBmbHVzaExpdmVCYWNrQnVmZmVyICgpIHtcclxuICAgIC8vIGNsZWFyIGJhY2sgYnVmZmVyIGZvciBsaXZlIG9ubHlcclxuICAgIGlmICghdGhpcy5fbGl2ZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbGl2ZUJhY2tCdWZmZXJMZW5ndGggPSB0aGlzLmNvbmZpZy5saXZlQmFja0J1ZmZlckxlbmd0aDtcclxuICAgIGlmICghaXNGaW5pdGUobGl2ZUJhY2tCdWZmZXJMZW5ndGgpIHx8IGxpdmVCYWNrQnVmZmVyTGVuZ3RoIDwgMCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcignZmx1c2hMaXZlQmFja0J1ZmZlciBjYWxsZWQgd2l0aG91dCBhdHRhY2hpbmcgbWVkaWEnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZTtcclxuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xyXG4gICAgY29uc3QgYnVmZmVyVHlwZXMgPSBPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpO1xyXG4gICAgY29uc3QgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uID0gY3VycmVudFRpbWUgLSBNYXRoLm1heChsaXZlQmFja0J1ZmZlckxlbmd0aCwgdGhpcy5fbGV2ZWxUYXJnZXREdXJhdGlvbik7XHJcblxyXG4gICAgZm9yIChsZXQgaW5kZXggPSBidWZmZXJUeXBlcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XHJcbiAgICAgIGNvbnN0IGJ1ZmZlclR5cGUgPSBidWZmZXJUeXBlc1tpbmRleF07XHJcbiAgICAgIGNvbnN0IHNiID0gc291cmNlQnVmZmVyW2J1ZmZlclR5cGUgYXMgU291cmNlQnVmZmVyTmFtZV07XHJcbiAgICAgIGlmIChzYikge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gc2IuYnVmZmVyZWQ7XHJcbiAgICAgICAgLy8gd2hlbiB0YXJnZXQgYnVmZmVyIHN0YXJ0IGV4Y2VlZHMgYWN0dWFsIGJ1ZmZlciBzdGFydFxyXG4gICAgICAgIGlmIChidWZmZXJlZC5sZW5ndGggPiAwICYmIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA+IGJ1ZmZlcmVkLnN0YXJ0KDApKSB7XHJcbiAgICAgICAgICAvLyByZW1vdmUgYnVmZmVyIHVwIHVudGlsIGN1cnJlbnQgdGltZSBtaW51cyBtaW5pbXVtIGJhY2sgYnVmZmVyIGxlbmd0aCAocmVtb3ZpbmcgYnVmZmVyIHRvbyBjbG9zZSB0byBjdXJyZW50XHJcbiAgICAgICAgICAvLyB0aW1lIHdpbGwgbGVhZCB0byBwbGF5YmFjayBmcmVlemluZylcclxuICAgICAgICAgIC8vIGNyZWRpdHMgZm9yIGxldmVsIHRhcmdldCBkdXJhdGlvbiAtIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL2h0dHAtc3RyZWFtaW5nL2Jsb2IvMzEzMjkzM2I2YWE5OWRkZWZhYjI5YzEwNDQ3NjI0ZWZkNmZkNmU1Mi9zcmMvc2VnbWVudC1sb2FkZXIuanMjTDkxXHJcbiAgICAgICAgICBpZiAodGhpcy5yZW1vdmVCdWZmZXJSYW5nZShidWZmZXJUeXBlLCBzYiwgMCwgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MSVZFX0JBQ0tfQlVGRkVSX1JFQUNIRUQsIHsgYnVmZmVyRW5kOiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkxldmVsVXBkYXRlZCAoeyBkZXRhaWxzIH06IHsgZGV0YWlsczogeyB0b3RhbGR1cmF0aW9uOiBudW1iZXIsIHRhcmdldGR1cmF0aW9uPzogbnVtYmVyLCBhdmVyYWdldGFyZ2V0ZHVyYXRpb24/OiBudW1iZXIsIGxpdmU6IGJvb2xlYW4sIGZyYWdtZW50czogYW55W10gfSB9KSB7XHJcbiAgICBpZiAoZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLl9sZXZlbER1cmF0aW9uID0gZGV0YWlscy50b3RhbGR1cmF0aW9uICsgZGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XHJcbiAgICAgIHRoaXMuX2xldmVsVGFyZ2V0RHVyYXRpb24gPSBkZXRhaWxzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiB8fCBkZXRhaWxzLnRhcmdldGR1cmF0aW9uIHx8IDEwO1xyXG4gICAgICB0aGlzLl9saXZlID0gZGV0YWlscy5saXZlO1xyXG4gICAgICB0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvIGN1cnJlbnQgbGV2ZWwgZHVyYXRpb24gb3Igb3ZlcnJpZGUgdG8gSW5maW5pdHkgaWYgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJcclxuICAgKiAnbGl2ZUR1cmF0aW9uSW5maW5pdHlgIGlzIHNldCB0byBgdHJ1ZWBcclxuICAgKiBNb3JlIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zNTVcclxuICAgKi9cclxuICB1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbiAoKSB7XHJcbiAgICBsZXQgeyBjb25maWcgfSA9IHRoaXM7XHJcbiAgICBsZXQgZHVyYXRpb246IG51bWJlcjtcclxuXHJcbiAgICBpZiAodGhpcy5fbGV2ZWxEdXJhdGlvbiA9PT0gbnVsbCB8fFxyXG4gICAgICAhdGhpcy5tZWRpYSB8fFxyXG4gICAgICAhdGhpcy5tZWRpYVNvdXJjZSB8fFxyXG4gICAgICAhdGhpcy5zb3VyY2VCdWZmZXIgfHxcclxuICAgICAgdGhpcy5tZWRpYS5yZWFkeVN0YXRlID09PSAwIHx8XHJcbiAgICAgIHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCB0eXBlIGluIHRoaXMuc291cmNlQnVmZmVyKSB7XHJcbiAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XHJcbiAgICAgIGlmIChzYiAmJiBzYi51cGRhdGluZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIC8vIGNhbid0IHNldCBkdXJhdGlvbiB3aGlsc3QgYSBidWZmZXIgaXMgdXBkYXRpbmdcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkdXJhdGlvbiA9IHRoaXMubWVkaWEuZHVyYXRpb247XHJcbiAgICAvLyBpbml0aWFsaXNlIHRvIHRoZSB2YWx1ZSB0aGF0IHRoZSBtZWRpYSBzb3VyY2UgaXMgcmVwb3J0aW5nXHJcbiAgICBpZiAodGhpcy5fbXNEdXJhdGlvbiA9PT0gbnVsbCkge1xyXG4gICAgICB0aGlzLl9tc0R1cmF0aW9uID0gdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fbGl2ZSA9PT0gdHJ1ZSAmJiBjb25maWcubGl2ZUR1cmF0aW9uSW5maW5pdHkgPT09IHRydWUpIHtcclxuICAgICAgLy8gT3ZlcnJpZGUgZHVyYXRpb24gdG8gSW5maW5pdHlcclxuICAgICAgbG9nZ2VyLmxvZygnTWVkaWEgU291cmNlIGR1cmF0aW9uIGlzIHNldCB0byBJbmZpbml0eScpO1xyXG4gICAgICB0aGlzLl9tc0R1cmF0aW9uID0gdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbiA9IEluZmluaXR5O1xyXG4gICAgfSBlbHNlIGlmICgodGhpcy5fbGV2ZWxEdXJhdGlvbiA+IHRoaXMuX21zRHVyYXRpb24gJiYgdGhpcy5fbGV2ZWxEdXJhdGlvbiA+IGR1cmF0aW9uKSB8fCAhTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uKSkge1xyXG4gICAgICAvLyBsZXZlbER1cmF0aW9uIHdhcyB0aGUgbGFzdCB2YWx1ZSB3ZSBzZXQuXHJcbiAgICAgIC8vIG5vdCB1c2luZyBtZWRpYVNvdXJjZS5kdXJhdGlvbiBhcyB0aGUgYnJvd3NlciBtYXkgdHdlYWsgdGhpcyB2YWx1ZVxyXG4gICAgICAvLyBvbmx5IHVwZGF0ZSBNZWRpYSBTb3VyY2UgZHVyYXRpb24gaWYgaXRzIHZhbHVlIGluY3JlYXNlLCB0aGlzIGlzIHRvIGF2b2lkXHJcbiAgICAgIC8vIGZsdXNoaW5nIGFscmVhZHkgYnVmZmVyZWQgcG9ydGlvbiB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIHF1YWxpdHkgbGV2ZWxcclxuICAgICAgbG9nZ2VyLmxvZyhgVXBkYXRpbmcgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvICR7dGhpcy5fbGV2ZWxEdXJhdGlvbi50b0ZpeGVkKDMpfWApO1xyXG4gICAgICB0aGlzLl9tc0R1cmF0aW9uID0gdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbiA9IHRoaXMuX2xldmVsRHVyYXRpb247XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkb0ZsdXNoICgpIHtcclxuICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgYnVmZmVyIHJhbmdlcyB0byBmbHVzaFxyXG4gICAgd2hpbGUgKHRoaXMuZmx1c2hSYW5nZS5sZW5ndGgpIHtcclxuICAgICAgbGV0IHJhbmdlID0gdGhpcy5mbHVzaFJhbmdlWzBdO1xyXG4gICAgICAvLyBmbHVzaEJ1ZmZlciB3aWxsIGFib3J0IGFueSBidWZmZXIgYXBwZW5kIGluIHByb2dyZXNzIGFuZCBmbHVzaCBBdWRpby9WaWRlbyBCdWZmZXJcclxuICAgICAgaWYgKHRoaXMuZmx1c2hCdWZmZXIocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgcmFuZ2UudHlwZSkpIHtcclxuICAgICAgICAvLyByYW5nZSBmbHVzaGVkLCByZW1vdmUgZnJvbSBmbHVzaCBhcnJheVxyXG4gICAgICAgIHRoaXMuZmx1c2hSYW5nZS5zaGlmdCgpO1xyXG4gICAgICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyID0gMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9uZWVkc0ZsdXNoID0gdHJ1ZTtcclxuICAgICAgICAvLyBhdm9pZCBsb29waW5nLCB3YWl0IGZvciBTQiB1cGRhdGUgZW5kIHRvIHJldHJpZ2dlciBhIGZsdXNoXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5mbHVzaFJhbmdlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAvLyBldmVyeXRoaW5nIGZsdXNoZWRcclxuICAgICAgdGhpcy5fbmVlZHNGbHVzaCA9IGZhbHNlO1xyXG5cclxuICAgICAgLy8gbGV0J3MgcmVjb21wdXRlIHRoaXMuYXBwZW5kZWQsIHdoaWNoIGlzIHVzZWQgdG8gYXZvaWQgZmx1c2ggbG9vcGluZ1xyXG4gICAgICBsZXQgYXBwZW5kZWQgPSAwO1xyXG4gICAgICBsZXQgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcclxuICAgICAgICAgIGNvbnN0IHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xyXG4gICAgICAgICAgaWYgKHNiKSB7XHJcbiAgICAgICAgICAgIGFwcGVuZGVkICs9IHNiLmJ1ZmZlcmVkLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgLy8gZXJyb3IgY291bGQgYmUgdGhyb3duIHdoaWxlIGFjY2Vzc2luZyBidWZmZXJlZCwgaW4gY2FzZSBzb3VyY2VidWZmZXIgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIGZyb20gTWVkaWFTb3VyY2VcclxuICAgICAgICAvLyB0aGlzIGlzIGhhcm1lc3MgYXQgdGhpcyBzdGFnZSwgY2F0Y2ggdGhpcyB0byBhdm9pZCByZXBvcnRpbmcgYW4gaW50ZXJuYWwgZXhjZXB0aW9uXHJcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdlcnJvciB3aGlsZSBhY2Nlc3Npbmcgc291cmNlQnVmZmVyLmJ1ZmZlcmVkJyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5hcHBlbmRlZCA9IGFwcGVuZGVkO1xyXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkb0FwcGVuZGluZyAoKSB7XHJcbiAgICBsZXQgeyBjb25maWcsIGhscywgc2VnbWVudHMsIHNvdXJjZUJ1ZmZlciB9ID0gdGhpcztcclxuICAgIGlmICghT2JqZWN0LmtleXMoc291cmNlQnVmZmVyKS5sZW5ndGgpIHtcclxuICAgICAgLy8gZWFybHkgZXhpdCBpZiBubyBzb3VyY2UgYnVmZmVycyBoYXZlIGJlZW4gaW5pdGlhbGl6ZWQgeWV0XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMubWVkaWEgfHwgdGhpcy5tZWRpYS5lcnJvcikge1xyXG4gICAgICB0aGlzLnNlZ21lbnRzID0gW107XHJcbiAgICAgIGxvZ2dlci5lcnJvcigndHJ5aW5nIHRvIGFwcGVuZCBhbHRob3VnaCBhIG1lZGlhIGVycm9yIG9jY3VyZWQsIGZsdXNoIHNlZ21lbnQgYW5kIGFib3J0Jyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5hcHBlbmRpbmcpIHtcclxuICAgICAgLy8gbG9nZ2VyLmxvZyhgc2IgYXBwZW5kaW5nIGluIHByb2dyZXNzYCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHMuc2hpZnQoKTtcclxuICAgIGlmICghc2VnbWVudCkgeyAvLyBoYW5kbGUgdW5kZWZpbmVkIHNoaWZ0XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzYiA9IHNvdXJjZUJ1ZmZlcltzZWdtZW50LnR5cGVdO1xyXG4gICAgICBpZiAoIXNiKSB7XHJcbiAgICAgICAgLy8gaW4gY2FzZSB3ZSBkb24ndCBoYXZlIGFueSBzb3VyY2UgYnVmZmVyIG1hdGNoaW5nIHdpdGggdGhpcyBzZWdtZW50IHR5cGUsXHJcbiAgICAgICAgLy8gaXQgbWVhbnMgdGhhdCBNZWRpYXNvdXJjZSBmYWlscyB0byBjcmVhdGUgc291cmNlYnVmZmVyXHJcbiAgICAgICAgLy8gZGlzY2FyZCB0aGlzIHNlZ21lbnQsIGFuZCB0cmlnZ2VyIHVwZGF0ZSBlbmRcclxuICAgICAgICB0aGlzLl9vblNCVXBkYXRlRW5kKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2IudXBkYXRpbmcpIHtcclxuICAgICAgICAvLyBpZiB3ZSBhcmUgc3RpbGwgdXBkYXRpbmcgdGhlIHNvdXJjZSBidWZmZXIgZnJvbSB0aGUgbGFzdCBzZWdtZW50LCBwbGFjZSB0aGlzIGJhY2sgYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxyXG4gICAgICAgIHNlZ21lbnRzLnVuc2hpZnQoc2VnbWVudCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZXNldCBzb3VyY2VCdWZmZXIgZW5kZWQgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIHNlZ21lbnRcclxuICAgICAgc2IuZW5kZWQgPSBmYWxzZTtcclxuICAgICAgLy8gbG9nZ2VyLmxvZyhgYXBwZW5kaW5nICR7c2VnbWVudC5jb250ZW50fSAke3R5cGV9IFNCLCBzaXplOiR7c2VnbWVudC5kYXRhLmxlbmd0aH0sICR7c2VnbWVudC5wYXJlbnR9YCk7XHJcbiAgICAgIHRoaXMucGFyZW50ID0gc2VnbWVudC5wYXJlbnQ7XHJcbiAgICAgIHNiLmFwcGVuZEJ1ZmZlcihzZWdtZW50LmRhdGEpO1xyXG4gICAgICB0aGlzLmFwcGVuZEVycm9yID0gMDtcclxuICAgICAgdGhpcy5hcHBlbmRlZCsrO1xyXG4gICAgICB0aGlzLmFwcGVuZGluZyA9IHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgLy8gaW4gY2FzZSBhbnkgZXJyb3Igb2NjdXJlZCB3aGlsZSBhcHBlbmRpbmcsIHB1dCBiYWNrIHNlZ21lbnQgaW4gc2VnbWVudHMgdGFibGVcclxuICAgICAgbG9nZ2VyLmVycm9yKGBlcnJvciB3aGlsZSB0cnlpbmcgdG8gYXBwZW5kIGJ1ZmZlcjoke2Vyci5tZXNzYWdlfWApO1xyXG4gICAgICBzZWdtZW50cy51bnNoaWZ0KHNlZ21lbnQpO1xyXG4gICAgICBsZXQgZXZlbnQgPSB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIHBhcmVudDogc2VnbWVudC5wYXJlbnQsIGRldGFpbHM6ICcnLCBmYXRhbDogZmFsc2UgfTtcclxuICAgICAgaWYgKGVyci5jb2RlID09PSAyMikge1xyXG4gICAgICAgIC8vIFF1b3RhRXhjZWVkZWRFcnJvcjogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNxdW90YWV4Y2VlZGVkZXJyb3JcclxuICAgICAgICAvLyBsZXQncyBzdG9wIGFwcGVuZGluZyBhbnkgc2VnbWVudHMsIGFuZCByZXBvcnQgQlVGRkVSX0ZVTExfRVJST1IgZXJyb3JcclxuICAgICAgICB0aGlzLnNlZ21lbnRzID0gW107XHJcbiAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmFwcGVuZEVycm9yKys7XHJcbiAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SO1xyXG4gICAgICAgIC8qIHdpdGggVUhEIGNvbnRlbnQsIHdlIGNvdWxkIGdldCBsb29wIG9mIHF1b3RhIGV4Y2VlZGVkIGVycm9yIHVudGlsXHJcbiAgICAgICAgICBicm93c2VyIGlzIGFibGUgdG8gZXZpY3Qgc29tZSBkYXRhIGZyb20gc291cmNlYnVmZmVyLiByZXRyeWluZyBoZWxwIHJlY292ZXJpbmcgdGhpc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kRXJyb3IgPiBjb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeSkge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgZmFpbCAke2NvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5fSB0aW1lcyB0byBhcHBlbmQgc2VnbWVudCBpbiBzb3VyY2VCdWZmZXJgKTtcclxuICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcclxuICAgICAgICAgIGV2ZW50LmZhdGFsID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBldmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAgZmx1c2ggc3BlY2lmaWVkIGJ1ZmZlcmVkIHJhbmdlLFxyXG4gICAgcmV0dXJuIHRydWUgb25jZSByYW5nZSBoYXMgYmVlbiBmbHVzaGVkLlxyXG4gICAgYXMgc291cmNlQnVmZmVyLnJlbW92ZSgpIGlzIGFzeW5jaHJvbm91cywgZmx1c2hCdWZmZXIgd2lsbCBiZSByZXRyaWdnZXJlZCBvbiBzb3VyY2VCdWZmZXIgdXBkYXRlIGVuZFxyXG4gICovXHJcbiAgZmx1c2hCdWZmZXIgKHN0YXJ0T2Zmc2V0OiBudW1iZXIsIGVuZE9mZnNldDogbnVtYmVyLCBzYlR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xyXG4gICAgLy8gZXhpdCBpZiBubyBzb3VyY2VCdWZmZXJzIGFyZSBpbml0aWFsaXplZFxyXG4gICAgaWYgKCFPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY3VycmVudFRpbWU6IHN0cmluZyA9ICdudWxsJztcclxuICAgIGlmICh0aGlzLm1lZGlhKSB7XHJcbiAgICAgIGN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZS50b0ZpeGVkKDMpO1xyXG4gICAgfVxyXG4gICAgbG9nZ2VyLmxvZyhgZmx1c2hCdWZmZXIscG9zL3N0YXJ0L2VuZDogJHtjdXJyZW50VGltZX0vJHtzdGFydE9mZnNldH0vJHtlbmRPZmZzZXR9YCk7XHJcblxyXG4gICAgLy8gc2FmZWd1YXJkIHRvIGF2b2lkIGluZmluaXRlIGxvb3BpbmcgOiBkb24ndCB0cnkgdG8gZmx1c2ggbW9yZSB0aGFuIHRoZSBuYiBvZiBhcHBlbmRlZCBzZWdtZW50c1xyXG4gICAgaWYgKHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyID49IHRoaXMuYXBwZW5kZWQpIHtcclxuICAgICAgbG9nZ2VyLndhcm4oJ2Fib3J0IGZsdXNoaW5nIHRvbyBtYW55IHJldHJpZXMnKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2IgPSBzb3VyY2VCdWZmZXJbc2JUeXBlXTtcclxuICAgIC8vIHdlIGFyZSBnb2luZyB0byBmbHVzaCBidWZmZXIsIG1hcmsgc291cmNlIGJ1ZmZlciBhcyAnbm90IGVuZGVkJ1xyXG4gICAgaWYgKHNiKSB7XHJcbiAgICAgIHNiLmVuZGVkID0gZmFsc2U7XHJcbiAgICAgIGlmICghc2IudXBkYXRpbmcpIHtcclxuICAgICAgICBpZiAodGhpcy5yZW1vdmVCdWZmZXJSYW5nZShzYlR5cGUsIHNiLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSkge1xyXG4gICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIrKztcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbG9nZ2VyLndhcm4oJ2Nhbm5vdCBmbHVzaCwgc2IgdXBkYXRpbmcgaW4gcHJvZ3Jlc3MnKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsb2dnZXIubG9nKCdidWZmZXIgZmx1c2hlZCcpO1xyXG4gICAgLy8gZXZlcnl0aGluZyBmbHVzaGVkICFcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBmaXJzdCBidWZmZXJlZCByYW5nZSBmcm9tIHByb3ZpZGVkIHNvdXJjZSBidWZmZXIgdGhhdCBsaWVzIHdpdGhpbiBnaXZlbiBzdGFydCBhbmQgZW5kIG9mZnNldHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlIG9mIHRoZSBzb3VyY2UgYnVmZmVyLCBsb2dnaW5nIHB1cnBvc2VzIG9ubHkuXHJcbiAgICogQHBhcmFtIHtTb3VyY2VCdWZmZXJ9IHNiIFRhcmdldCBTb3VyY2VCdWZmZXIgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0T2Zmc2V0XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZE9mZnNldFxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiBzb3VyY2UgYnVmZmVyIHJlbW92ZSByZXF1ZXN0ZWQuXHJcbiAgICovXHJcbiAgcmVtb3ZlQnVmZmVyUmFuZ2UgKHR5cGU6IHN0cmluZywgc2I6IEV4dGVuZGVkU291cmNlQnVmZmVyLCBzdGFydE9mZnNldDogbnVtYmVyLCBlbmRPZmZzZXQ6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYi5idWZmZXJlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBidWZTdGFydCA9IHNiLmJ1ZmZlcmVkLnN0YXJ0KGkpO1xyXG4gICAgICAgIGxldCBidWZFbmQgPSBzYi5idWZmZXJlZC5lbmQoaSk7XHJcbiAgICAgICAgbGV0IHJlbW92ZVN0YXJ0ID0gTWF0aC5tYXgoYnVmU3RhcnQsIHN0YXJ0T2Zmc2V0KTtcclxuICAgICAgICBsZXQgcmVtb3ZlRW5kID0gTWF0aC5taW4oYnVmRW5kLCBlbmRPZmZzZXQpO1xyXG5cclxuICAgICAgICAvKiBzb21ldGltZXMgc291cmNlYnVmZmVyLnJlbW92ZSgpIGRvZXMgbm90IGZsdXNoXHJcbiAgICAgICAgICB0aGUgZXhhY3QgZXhwZWN0ZWQgdGltZSByYW5nZS5cclxuICAgICAgICAgIHRvIGF2b2lkIHJvdW5kaW5nIGlzc3Vlcy9pbmZpbml0ZSBsb29wLFxyXG4gICAgICAgICAgb25seSBmbHVzaCBidWZmZXIgcmFuZ2Ugb2YgbGVuZ3RoIGdyZWF0ZXIgdGhhbiA1MDBtcy5cclxuICAgICAgICAqL1xyXG4gICAgICAgIGlmIChNYXRoLm1pbihyZW1vdmVFbmQsIGJ1ZkVuZCkgLSByZW1vdmVTdGFydCA+IDAuNSkge1xyXG4gICAgICAgICAgbGV0IGN1cnJlbnRUaW1lOiBzdHJpbmcgPSAnbnVsbCc7XHJcbiAgICAgICAgICBpZiAodGhpcy5tZWRpYSkge1xyXG4gICAgICAgICAgICBjdXJyZW50VGltZSA9IHRoaXMubWVkaWEuY3VycmVudFRpbWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBsb2dnZXIubG9nKGBzYiByZW1vdmUgJHt0eXBlfSBbJHtyZW1vdmVTdGFydH0sJHtyZW1vdmVFbmR9XSwgb2YgWyR7YnVmU3RhcnR9LCR7YnVmRW5kfV0sIHBvczoke2N1cnJlbnRUaW1lfWApO1xyXG4gICAgICAgICAgc2IucmVtb3ZlKHJlbW92ZVN0YXJ0LCByZW1vdmVFbmQpO1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIud2FybigncmVtb3ZlQnVmZmVyUmFuZ2UgZmFpbGVkJywgZXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJ1ZmZlckNvbnRyb2xsZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXIudHMiLCIvKlxyXG4gKiBjYXAgc3RyZWFtIGxldmVsIHRvIG1lZGlhIHNpemUgZGltZW5zaW9uIGNvbnRyb2xsZXJcclxuKi9cclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5cclxuY2xhc3MgQ2FwTGV2ZWxDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcclxuICBjb25zdHJ1Y3RvciAoaGxzKSB7XHJcbiAgICBzdXBlcihobHMsXHJcbiAgICAgIEV2ZW50LkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsXHJcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSElORyxcclxuICAgICAgRXZlbnQuTUFOSUZFU1RfUEFSU0VELFxyXG4gICAgICBFdmVudC5CVUZGRVJfQ09ERUNTLFxyXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcpO1xyXG5cclxuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgIHRoaXMuZmlyc3RMZXZlbCA9IG51bGw7XHJcbiAgICB0aGlzLmxldmVscyA9IFtdO1xyXG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XHJcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcclxuICAgIHRoaXMudGltZXIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSAoKSB7XHJcbiAgICBpZiAodGhpcy5obHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XHJcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xyXG4gICAgICB0aGlzLnN0b3BDYXBwaW5nKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkZwc0Ryb3BMZXZlbENhcHBpbmcgKGRhdGEpIHtcclxuICAgIC8vIERvbid0IGFkZCBhIHJlc3RyaWN0ZWQgbGV2ZWwgbW9yZSB0aGFuIG9uY2VcclxuICAgIGlmIChDYXBMZXZlbENvbnRyb2xsZXIuaXNMZXZlbEFsbG93ZWQoZGF0YS5kcm9wcGVkTGV2ZWwsIHRoaXMucmVzdHJpY3RlZExldmVscykpIHtcclxuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLnB1c2goZGF0YS5kcm9wcGVkTGV2ZWwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25NZWRpYUF0dGFjaGluZyAoZGF0YSkge1xyXG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgb25NYW5pZmVzdFBhcnNlZCAoZGF0YSkge1xyXG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XHJcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcclxuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XHJcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSBkYXRhLmZpcnN0TGV2ZWw7XHJcbiAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XHJcbiAgICAgIC8vIFN0YXJ0IGNhcHBpbmcgaW1tZWRpYXRlbHkgaWYgdGhlIG1hbmlmZXN0IGhhcyBzaWduYWxlZCB2aWRlbyBjb2RlY3NcclxuICAgICAgdGhpcy5zdGFydENhcHBpbmcoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE9ubHkgYWN0aXZhdGUgY2FwcGluZyB3aGVuIHBsYXlpbmcgYSB2aWRlbyBzdHJlYW07IG90aGVyd2lzZSwgbXVsdGktYml0cmF0ZSBhdWRpby1vbmx5IHN0cmVhbXMgd2lsbCBiZSByZXN0cmljdGVkXHJcbiAgLy8gdG8gdGhlIGZpcnN0IGxldmVsXHJcbiAgb25CdWZmZXJDb2RlY3MgKGRhdGEpIHtcclxuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xyXG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xyXG4gICAgICAvLyBJZiB0aGUgbWFuaWZlc3QgZGlkIG5vdCBzaWduYWwgYSB2aWRlbyBjb2RlYyBjYXBwaW5nIGhhcyBiZWVuIGRlZmVycmVkIHVudGlsIHdlJ3JlIGNlcnRhaW4gdmlkZW8gaXMgcHJlc2VudFxyXG4gICAgICB0aGlzLnN0YXJ0Q2FwcGluZygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25MZXZlbHNVcGRhdGVkIChkYXRhKSB7XHJcbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYURldGFjaGluZyAoKSB7XHJcbiAgICB0aGlzLnN0b3BDYXBwaW5nKCk7XHJcbiAgfVxyXG5cclxuICBkZXRlY3RQbGF5ZXJTaXplICgpIHtcclxuICAgIGlmICh0aGlzLm1lZGlhKSB7XHJcbiAgICAgIGxldCBsZXZlbHNMZW5ndGggPSB0aGlzLmxldmVscyA/IHRoaXMubGV2ZWxzLmxlbmd0aCA6IDA7XHJcbiAgICAgIGlmIChsZXZlbHNMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcclxuICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IHRoaXMuZ2V0TWF4TGV2ZWwobGV2ZWxzTGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgaWYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID4gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nKSB7XHJcbiAgICAgICAgICAvLyBpZiBhdXRvIGxldmVsIGNhcHBpbmcgaGFzIGEgaGlnaGVyIHZhbHVlIGZvciB0aGUgcHJldmlvdXMgb25lLCBmbHVzaCB0aGUgYnVmZmVyIHVzaW5nIG5leHRMZXZlbFN3aXRjaFxyXG4gICAgICAgICAgLy8gdXN1YWxseSBoYXBwZW4gd2hlbiB0aGUgdXNlciBnbyB0byB0aGUgZnVsbHNjcmVlbiBtb2RlLlxyXG4gICAgICAgICAgaGxzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICogcmV0dXJucyBsZXZlbCBzaG91bGQgYmUgdGhlIG9uZSB3aXRoIHRoZSBkaW1lbnNpb25zIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWVkaWEgKHBsYXllcikgZGltZW5zaW9ucyAoc28gdGhlIHZpZGVvIHdpbGwgYmUgZG93bnNjYWxlZClcclxuICAqL1xyXG4gIGdldE1heExldmVsIChjYXBMZXZlbEluZGV4KSB7XHJcbiAgICBpZiAoIXRoaXMubGV2ZWxzKSB7XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB2YWxpZExldmVscyA9IHRoaXMubGV2ZWxzLmZpbHRlcigobGV2ZWwsIGluZGV4KSA9PlxyXG4gICAgICBDYXBMZXZlbENvbnRyb2xsZXIuaXNMZXZlbEFsbG93ZWQoaW5kZXgsIHRoaXMucmVzdHJpY3RlZExldmVscykgJiYgaW5kZXggPD0gY2FwTGV2ZWxJbmRleFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gQ2FwTGV2ZWxDb250cm9sbGVyLmdldE1heExldmVsQnlNZWRpYVNpemUodmFsaWRMZXZlbHMsIHRoaXMubWVkaWFXaWR0aCwgdGhpcy5tZWRpYUhlaWdodCk7XHJcbiAgfVxyXG5cclxuICBzdGFydENhcHBpbmcgKCkge1xyXG4gICAgaWYgKHRoaXMudGltZXIpIHtcclxuICAgICAgLy8gRG9uJ3QgcmVzZXQgY2FwcGluZyBpZiBzdGFydGVkIHR3aWNlOyB0aGlzIGNhbiBoYXBwZW4gaWYgdGhlIG1hbmlmZXN0IHNpZ25hbHMgYSB2aWRlbyBjb2RlY1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICB0aGlzLmhscy5maXJzdExldmVsID0gdGhpcy5nZXRNYXhMZXZlbCh0aGlzLmZpcnN0TGV2ZWwpO1xyXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcclxuICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLmRldGVjdFBsYXllclNpemUuYmluZCh0aGlzKSwgMTAwMCk7XHJcbiAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcclxuICB9XHJcblxyXG4gIHN0b3BDYXBwaW5nICgpIHtcclxuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xyXG4gICAgdGhpcy5maXJzdExldmVsID0gbnVsbDtcclxuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgIGlmICh0aGlzLnRpbWVyKSB7XHJcbiAgICAgIHRoaXMudGltZXIgPSBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xyXG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBtZWRpYVdpZHRoICgpIHtcclxuICAgIGxldCB3aWR0aDtcclxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcclxuICAgIGlmIChtZWRpYSkge1xyXG4gICAgICB3aWR0aCA9IG1lZGlhLndpZHRoIHx8IG1lZGlhLmNsaWVudFdpZHRoIHx8IG1lZGlhLm9mZnNldFdpZHRoO1xyXG4gICAgICB3aWR0aCAqPSBDYXBMZXZlbENvbnRyb2xsZXIuY29udGVudFNjYWxlRmFjdG9yO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHdpZHRoO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG1lZGlhSGVpZ2h0ICgpIHtcclxuICAgIGxldCBoZWlnaHQ7XHJcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgaGVpZ2h0ID0gbWVkaWEuaGVpZ2h0IHx8IG1lZGlhLmNsaWVudEhlaWdodCB8fCBtZWRpYS5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgIGhlaWdodCAqPSBDYXBMZXZlbENvbnRyb2xsZXIuY29udGVudFNjYWxlRmFjdG9yO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhlaWdodDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXQgY29udGVudFNjYWxlRmFjdG9yICgpIHtcclxuICAgIGxldCBwaXhlbFJhdGlvID0gMTtcclxuICAgIHRyeSB7XHJcbiAgICAgIHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICByZXR1cm4gcGl4ZWxSYXRpbztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBpc0xldmVsQWxsb3dlZCAobGV2ZWwsIHJlc3RyaWN0ZWRMZXZlbHMgPSBbXSkge1xyXG4gICAgcmV0dXJuIHJlc3RyaWN0ZWRMZXZlbHMuaW5kZXhPZihsZXZlbCkgPT09IC0xO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldE1heExldmVsQnlNZWRpYVNpemUgKGxldmVscywgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgaWYgKCFsZXZlbHMgfHwgKGxldmVscyAmJiAhbGV2ZWxzLmxlbmd0aCkpIHtcclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExldmVscyBjYW4gaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zIGJ1dCBkaWZmZXJpbmcgYmFuZHdpZHRocyAtIHNpbmNlIGxldmVscyBhcmUgb3JkZXJlZCwgd2UgY2FuIGxvb2sgdG8gdGhlIG5leHRcclxuICAgIC8vIHRvIGRldGVybWluZSB3aGV0aGVyIHdlJ3ZlIGNob3NlbiB0aGUgZ3JlYXRlc3QgYmFuZHdpZHRoIGZvciB0aGUgbWVkaWEncyBkaW1lbnNpb25zXHJcbiAgICBjb25zdCBhdEdyZWF0ZXN0QmFuZGl3ZHRoID0gKGN1ckxldmVsLCBuZXh0TGV2ZWwpID0+IHtcclxuICAgICAgaWYgKCFuZXh0TGV2ZWwpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGN1ckxldmVsLndpZHRoICE9PSBuZXh0TGV2ZWwud2lkdGggfHwgY3VyTGV2ZWwuaGVpZ2h0ICE9PSBuZXh0TGV2ZWwuaGVpZ2h0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJZiB3ZSBydW4gdGhyb3VnaCB0aGUgbG9vcCB3aXRob3V0IGJyZWFraW5nLCB0aGUgbWVkaWEncyBkaW1lbnNpb25zIGFyZSBncmVhdGVyIHRoYW4gZXZlcnkgbGV2ZWwsIHNvIGRlZmF1bHQgdG9cclxuICAgIC8vIHRoZSBtYXggbGV2ZWxcclxuICAgIGxldCBtYXhMZXZlbEluZGV4ID0gbGV2ZWxzLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbaV07XHJcbiAgICAgIGlmICgobGV2ZWwud2lkdGggPj0gd2lkdGggfHwgbGV2ZWwuaGVpZ2h0ID49IGhlaWdodCkgJiYgYXRHcmVhdGVzdEJhbmRpd2R0aChsZXZlbCwgbGV2ZWxzW2kgKyAxXSkpIHtcclxuICAgICAgICBtYXhMZXZlbEluZGV4ID0gaTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtYXhMZXZlbEluZGV4O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FwTGV2ZWxDb250cm9sbGVyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyLmpzIiwiLypcclxuICogRlBTIENvbnRyb2xsZXJcclxuKi9cclxuXHJcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xyXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5cclxuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gd2luZG93O1xyXG5cclxuY2xhc3MgRlBTQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcbiAgY29uc3RydWN0b3IgKGhscykge1xyXG4gICAgc3VwZXIoaGxzLCBFdmVudC5NRURJQV9BVFRBQ0hJTkcpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSAoKSB7XHJcbiAgICBpZiAodGhpcy50aW1lcikge1xyXG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYUF0dGFjaGluZyAoZGF0YSkge1xyXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xyXG4gICAgaWYgKGNvbmZpZy5jYXBMZXZlbE9uRlBTRHJvcCkge1xyXG4gICAgICBjb25zdCB2aWRlbyA9IHRoaXMudmlkZW8gPSBkYXRhLm1lZGlhIGluc3RhbmNlb2Ygd2luZG93LkhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcclxuICAgICAgaWYgKHR5cGVvZiB2aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XHJcbiAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrRlBTSW50ZXJ2YWwuYmluZCh0aGlzKSwgY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNoZWNrRlBTICh2aWRlbywgZGVjb2RlZEZyYW1lcywgZHJvcHBlZEZyYW1lcykge1xyXG4gICAgbGV0IGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICBpZiAoZGVjb2RlZEZyYW1lcykge1xyXG4gICAgICBpZiAodGhpcy5sYXN0VGltZSkge1xyXG4gICAgICAgIGxldCBjdXJyZW50UGVyaW9kID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUaW1lLFxyXG4gICAgICAgICAgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyxcclxuICAgICAgICAgIGN1cnJlbnREZWNvZGVkID0gZGVjb2RlZEZyYW1lcyAtIHRoaXMubGFzdERlY29kZWRGcmFtZXMsXHJcbiAgICAgICAgICBkcm9wcGVkRlBTID0gMTAwMCAqIGN1cnJlbnREcm9wcGVkIC8gY3VycmVudFBlcmlvZCxcclxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xyXG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZQU19EUk9QLCB7IGN1cnJlbnREcm9wcGVkOiBjdXJyZW50RHJvcHBlZCwgY3VycmVudERlY29kZWQ6IGN1cnJlbnREZWNvZGVkLCB0b3RhbERyb3BwZWRGcmFtZXM6IGRyb3BwZWRGcmFtZXMgfSk7XHJcbiAgICAgICAgaWYgKGRyb3BwZWRGUFMgPiAwKSB7XHJcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdjaGVja0ZQUyA6IGRyb3BwZWRGUFMvZGVjb2RlZEZQUzonICsgZHJvcHBlZEZQUy8oMTAwMCAqIGN1cnJlbnREZWNvZGVkIC8gY3VycmVudFBlcmlvZCkpO1xyXG4gICAgICAgICAgaWYgKGN1cnJlbnREcm9wcGVkID4gaGxzLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZCAqIGN1cnJlbnREZWNvZGVkKSB7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSBobHMuY3VycmVudExldmVsO1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybignZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgKyBjdXJyZW50TGV2ZWwpO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudExldmVsID4gMCAmJiAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPT09IC0xIHx8IGhscy5hdXRvTGV2ZWxDYXBwaW5nID49IGN1cnJlbnRMZXZlbCkpIHtcclxuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWwgLSAxO1xyXG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHsgbGV2ZWw6IGN1cnJlbnRMZXZlbCwgZHJvcHBlZExldmVsOiBobHMuY3VycmVudExldmVsIH0pO1xyXG4gICAgICAgICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gY3VycmVudExldmVsO1xyXG4gICAgICAgICAgICAgIGhscy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcclxuICAgICAgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IGRyb3BwZWRGcmFtZXM7XHJcbiAgICAgIHRoaXMubGFzdERlY29kZWRGcmFtZXMgPSBkZWNvZGVkRnJhbWVzO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2hlY2tGUFNJbnRlcnZhbCAoKSB7XHJcbiAgICBjb25zdCB2aWRlbyA9IHRoaXMudmlkZW87XHJcbiAgICBpZiAodmlkZW8pIHtcclxuICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSkge1xyXG4gICAgICAgIGxldCB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XHJcbiAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW9QbGF5YmFja1F1YWxpdHkudG90YWxWaWRlb0ZyYW1lcywgdmlkZW9QbGF5YmFja1F1YWxpdHkuZHJvcHBlZFZpZGVvRnJhbWVzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmNoZWNrRlBTKHZpZGVvLCB2aWRlby53ZWJraXREZWNvZGVkRnJhbWVDb3VudCwgdmlkZW8ud2Via2l0RHJvcHBlZEZyYW1lQ291bnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGUFNDb250cm9sbGVyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyLmpzIiwiaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcbmltcG9ydCBUYXNrTG9vcCBmcm9tICcuLi90YXNrLWxvb3AnO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBBdWRpb1RyYWNrQ29udHJvbGxlclxyXG4gKiBAaW1wbGVtZW50cyB7RXZlbnRIYW5kbGVyfVxyXG4gKlxyXG4gKiBIYW5kbGVzIG1haW4gbWFuaWZlc3QgYW5kIGF1ZGlvLXRyYWNrIG1ldGFkYXRhIGxvYWRlZCxcclxuICogb3ducyBhbmQgZXhwb3NlcyB0aGUgc2VsZWN0YWJsZSBhdWRpby10cmFja3MgZGF0YS1tb2RlbHMuXHJcbiAqXHJcbiAqIEV4cG9zZXMgaW50ZXJuYWwgaW50ZXJmYWNlIHRvIHNlbGVjdCBhdmFpbGFibGUgYXVkaW8tdHJhY2tzLlxyXG4gKlxyXG4gKiBIYW5kbGVzIGVycm9ycyBvbiBsb2FkaW5nIGF1ZGlvLXRyYWNrIHBsYXlsaXN0cy4gTWFuYWdlcyBmYWxsYmFjayBtZWNoYW5pc21cclxuICogd2l0aCByZWR1bmRhbnRzIHRyYWNrcyAoZ3JvdXAtSURzKS5cclxuICpcclxuICogSGFuZGxlcyBsZXZlbC1sb2FkaW5nIGFuZCBncm91cC1JRCBzd2l0Y2hlcyBmb3IgdmlkZW8gKGZhbGxiYWNrIG9uIHZpZGVvIGxldmVscyksXHJcbiAqIGFuZCBldmVudHVhbGx5IGFkYXB0cyB0aGUgYXVkaW8tdHJhY2sgZ3JvdXAtSUQgdG8gbWF0Y2guXHJcbiAqXHJcbiAqIEBmaXJlcyBBVURJT19UUkFDS19MT0FESU5HXHJcbiAqIEBmaXJlcyBBVURJT19UUkFDS19TV0lUQ0hJTkdcclxuICogQGZpcmVzIEFVRElPX1RSQUNLU19VUERBVEVEXHJcbiAqIEBmaXJlcyBFUlJPUlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgQXVkaW9UcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBUYXNrTG9vcCB7XHJcbiAgY29uc3RydWN0b3IgKGhscykge1xyXG4gICAgc3VwZXIoaGxzLFxyXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxyXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQsXHJcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCxcclxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENIRUQsXHJcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURFRCxcclxuICAgICAgRXZlbnQuRVJST1JcclxuICAgICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQ3VycmVudGx5IHNlbGVjdGVkIGluZGV4IGluIGB0cmFja3NgXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHRyYWNrSWRcclxuICAgICAqL1xyXG4gICAgdGhpcy5fdHJhY2tJZCA9IC0xO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIElmIHNob3VsZCBzZWxlY3QgdHJhY2tzIGFjY29yZGluZyB0byBkZWZhdWx0IHRyYWNrIGF0dHJpYnV0ZVxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gX3NlbGVjdERlZmF1bHRUcmFja1xyXG4gICAgICovXHJcbiAgICB0aGlzLl9zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQWxsIHRyYWNrcyBhdmFpbGFibGVcclxuICAgICAqIEBtZW1iZXIge0F1ZGlvVHJhY2tbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmFja3MgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIExpc3Qgb2YgYmxhY2tsaXN0ZWQgYXVkaW8gdHJhY2sgSURzICh0aGF0IGhhdmUgY2F1c2VkIGZhaWx1cmUpXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmFja0lkQmxhY2tsaXN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIFRoZSBjdXJyZW50bHkgcnVubmluZyBncm91cCBJRCBmb3IgYXVkaW9cclxuICAgICAqICh3ZSBncmFiIHRoaXMgb24gbWFuaWZlc3QtcGFyc2VkIGFuZCBuZXcgbGV2ZWwtbG9hZGVkKVxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmF1ZGlvR3JvdXBJZCA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNldCBhdWRpbyB0cmFja3Mgb24gbmV3IG1hbmlmZXN0IGxvYWRpbmcuXHJcbiAgICovXHJcbiAgb25NYW5pZmVzdExvYWRpbmcgKCkge1xyXG4gICAgdGhpcy50cmFja3MgPSBbXTtcclxuICAgIHRoaXMuX3RyYWNrSWQgPSAtMTtcclxuICAgIHRoaXMuX3NlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9yZSB0cmFja3MgZGF0YSBmcm9tIG1hbmlmZXN0IHBhcnNlZCBkYXRhLlxyXG4gICAqXHJcbiAgICogVHJpZ2dlciBBVURJT19UUkFDS1NfVVBEQVRFRCBldmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gZGF0YVxyXG4gICAqL1xyXG4gIG9uTWFuaWZlc3RQYXJzZWQgKGRhdGEpIHtcclxuICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcyB8fCBbXTtcclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tTX1VQREFURUQsIHsgYXVkaW9UcmFja3M6IHRyYWNrcyB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3JlIHRyYWNrIGRldGFpbHMgb2YgbG9hZGVkIHRyYWNrIGluIG91ciBkYXRhLW1vZGVsLlxyXG4gICAqXHJcbiAgICogU2V0LXVwIG1ldGFkYXRhIHVwZGF0ZSBpbnRlcnZhbCB0YXNrIGZvciBsaXZlLW1vZGUgc3RyZWFtcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gZGF0YVxyXG4gICAqL1xyXG4gIG9uQXVkaW9UcmFja0xvYWRlZCAoZGF0YSkge1xyXG4gICAgaWYgKGRhdGEuaWQgPj0gdGhpcy50cmFja3MubGVuZ3RoKSB7XHJcbiAgICAgIGxvZ2dlci53YXJuKCdJbnZhbGlkIGF1ZGlvIHRyYWNrIGlkOicsIGRhdGEuaWQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbG9nZ2VyLmxvZyhgYXVkaW9UcmFjayAke2RhdGEuaWR9IGxvYWRlZGApO1xyXG5cclxuICAgIHRoaXMudHJhY2tzW2RhdGEuaWRdLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XHJcblxyXG4gICAgLy8gY2hlY2sgaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3RcclxuICAgIC8vIGFuZCBpZiB3ZSBoYXZlIGFscmVhZHkgb3VyIHJlbG9hZCBpbnRlcnZhbCBzZXR1cFxyXG4gICAgaWYgKGRhdGEuZGV0YWlscy5saXZlICYmICF0aGlzLmhhc0ludGVydmFsKCkpIHtcclxuICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCB3ZSB3aWxsIGhhdmUgdG8gcmVsb2FkIGl0IHBlcmlvZGljYWxseVxyXG4gICAgICAvLyBzZXQgcmVsb2FkIHBlcmlvZCB0byBwbGF5bGlzdCB0YXJnZXQgZHVyYXRpb25cclxuICAgICAgY29uc3QgdXBkYXRlUGVyaW9kTXMgPSBkYXRhLmRldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAxMDAwO1xyXG4gICAgICB0aGlzLnNldEludGVydmFsKHVwZGF0ZVBlcmlvZE1zKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWRhdGEuZGV0YWlscy5saXZlICYmIHRoaXMuaGFzSW50ZXJ2YWwoKSkge1xyXG4gICAgICAvLyBwbGF5bGlzdCBpcyBub3QgbGl2ZSBhbmQgdGltZXIgaXMgc2NoZWR1bGVkOiBjYW5jZWwgaXRcclxuICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGludGVybmFsIGdyb3VwIElEIHRvIGFueSBhdWRpby10cmFjayB3ZSBtYXkgaGF2ZSBzZXQgbWFudWFsbHlcclxuICAgKiBvciBiZWNhdXNlIG9mIGEgZmFpbHVyZS1oYW5kbGluZyBmYWxsYmFjay5cclxuICAgKlxyXG4gICAqIFF1YWxpdHktbGV2ZWxzIHNob3VsZCB1cGRhdGUgdG8gdGhhdCBncm91cCBJRCBpbiB0aGlzIGNhc2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGRhdGFcclxuICAgKi9cclxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hlZCAoZGF0YSkge1xyXG4gICAgY29uc3QgYXVkaW9Hcm91cElkID0gdGhpcy50cmFja3NbZGF0YS5pZF0uZ3JvdXBJZDtcclxuICAgIGlmIChhdWRpb0dyb3VwSWQgJiYgKHRoaXMuYXVkaW9Hcm91cElkICE9PSBhdWRpb0dyb3VwSWQpKSB7XHJcbiAgICAgIHRoaXMuYXVkaW9Hcm91cElkID0gYXVkaW9Hcm91cElkO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbiBhIGxldmVsIGdldHMgbG9hZGVkLCBpZiBpdCBoYXMgcmVkdW5kYW50IGF1ZGlvR3JvdXBJZHMgKGluIHRoZSBzYW1lIG9yZGluYWxpdHkgYXMgaXQncyByZWR1bmRhbnQgVVJMcylcclxuICAgKiB3ZSBhcmUgc2V0dGluZyBvdXIgYXVkaW8tZ3JvdXAgSUQgaW50ZXJuYWxseSB0byB0aGUgb25lIHNldCwgaWYgaXQgaXMgZGlmZmVyZW50IGZyb20gdGhlIGdyb3VwIElEIGN1cnJlbnRseSBzZXQuXHJcbiAgICpcclxuICAgKiBJZiBncm91cC1JRCBnb3QgdXBkYXRlLCB3ZSByZS1zZWxlY3QgdGhlIGFwcHJvcHJpYXRlIGF1ZGlvLXRyYWNrIHdpdGggdGhpcyBncm91cC1JRCBtYXRjaGluZyB0aGUgY3VycmVudGx5XHJcbiAgICogc2VsZWN0ZWQgb25lIChiYXNlZCBvbiBOQU1FIHByb3BlcnR5KS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gZGF0YVxyXG4gICAqL1xyXG4gIG9uTGV2ZWxMb2FkZWQgKGRhdGEpIHtcclxuICAgIC8vIEZJWE1FOiBjcmFzaGVzIGJlY2F1c2UgY3VycmVudExldmVsIGlzIHVuZGVmaW5lZFxyXG4gICAgLy8gY29uc3QgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW3RoaXMuaGxzLmN1cnJlbnRMZXZlbF07XHJcblxyXG4gICAgY29uc3QgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW2RhdGEubGV2ZWxdO1xyXG5cclxuICAgIGlmICghbGV2ZWxJbmZvLmF1ZGlvR3JvdXBJZHMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGF1ZGlvR3JvdXBJZCA9IGxldmVsSW5mby5hdWRpb0dyb3VwSWRzW2xldmVsSW5mby51cmxJZF07XHJcbiAgICBpZiAodGhpcy5hdWRpb0dyb3VwSWQgIT09IGF1ZGlvR3JvdXBJZCkge1xyXG4gICAgICB0aGlzLmF1ZGlvR3JvdXBJZCA9IGF1ZGlvR3JvdXBJZDtcclxuICAgICAgdGhpcy5fc2VsZWN0SW5pdGlhbEF1ZGlvVHJhY2soKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBuZXR3b3JrIGVycm9ycyBsb2FkaW5nIGF1ZGlvIHRyYWNrIG1hbmlmZXN0c1xyXG4gICAqIGFuZCBhbHNvIHBhdXNpbmcgb24gYW55IG5ldHdvayBlcnJvcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Vycm9yRXZlbnREYXRhfSBkYXRhXHJcbiAgICovXHJcbiAgb25FcnJvciAoZGF0YSkge1xyXG4gICAgLy8gT25seSBoYW5kbGUgbmV0d29yayBlcnJvcnNcclxuICAgIGlmIChkYXRhLnR5cGUgIT09IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgZmF0YWwgbmV0d29yayBlcnJvciwgY2FuY2VsIHVwZGF0ZSB0YXNrXHJcbiAgICBpZiAoZGF0YS5mYXRhbCkge1xyXG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBub3QgYW4gYXVkaW8tdHJhY2sgbG9hZGluZyBlcnJvciBkb24ndCBoYW5kbGUgZnVydGhlclxyXG4gICAgaWYgKGRhdGEuZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1IpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxvZ2dlci53YXJuKCdOZXR3b3JrIGZhaWx1cmUgb24gYXVkaW8tdHJhY2sgaWQ6JywgZGF0YS5jb250ZXh0LmlkKTtcclxuICAgIHRoaXMuX2hhbmRsZUxvYWRFcnJvcigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge0F1ZGlvVHJhY2tbXX0gQXVkaW8tdHJhY2sgbGlzdCB3ZSBvd25cclxuICAgKi9cclxuICBnZXQgYXVkaW9UcmFja3MgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn0gSW5kZXggaW50byBhdWRpby10cmFja3MgbGlzdCBvZiBjdXJyZW50bHkgc2VsZWN0ZWQgdHJhY2suXHJcbiAgICovXHJcbiAgZ2V0IGF1ZGlvVHJhY2sgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrSWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZWxlY3QgY3VycmVudCB0cmFjayBieSBpbmRleFxyXG4gICAqL1xyXG4gIHNldCBhdWRpb1RyYWNrIChuZXdJZCkge1xyXG4gICAgdGhpcy5fc2V0QXVkaW9UcmFjayhuZXdJZCk7XHJcbiAgICAvLyBJZiBhdWRpbyB0cmFjayBpcyBzZWxlY3RlZCBmcm9tIEFQSSB0aGVuIGRvbid0IGNob29zZSBmcm9tIHRoZSBtYW5pZmVzdCBkZWZhdWx0IHRyYWNrXHJcbiAgICB0aGlzLl9zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0lkXHJcbiAgICovXHJcbiAgX3NldEF1ZGlvVHJhY2sgKG5ld0lkKSB7XHJcbiAgICAvLyBub29wIG9uIHNhbWUgYXVkaW8gdHJhY2sgaWQgYXMgYWxyZWFkeSBzZXRcclxuICAgIGlmICh0aGlzLl90cmFja0lkID09PSBuZXdJZCAmJiB0aGlzLnRyYWNrc1t0aGlzLl90cmFja0lkXS5kZXRhaWxzKSB7XHJcbiAgICAgIGxvZ2dlci5kZWJ1ZygnU2FtZSBpZCBhcyBjdXJyZW50IGF1ZGlvLXRyYWNrIHBhc3NlZCwgYW5kIHRyYWNrIGRldGFpbHMgYXZhaWxhYmxlIC0+IG5vLW9wJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcclxuICAgIGlmIChuZXdJZCA8IDAgfHwgbmV3SWQgPj0gdGhpcy50cmFja3MubGVuZ3RoKSB7XHJcbiAgICAgIGxvZ2dlci53YXJuKCdJbnZhbGlkIGlkIHBhc3NlZCB0byBhdWRpby10cmFjayBjb250cm9sbGVyJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdO1xyXG5cclxuICAgIGxvZ2dlci5sb2coYE5vdyBzd2l0Y2hpbmcgdG8gYXVkaW8tdHJhY2sgaW5kZXggJHtuZXdJZH1gKTtcclxuXHJcbiAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcclxuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xyXG4gICAgdGhpcy5fdHJhY2tJZCA9IG5ld0lkO1xyXG5cclxuICAgIGNvbnN0IHsgdXJsLCB0eXBlLCBpZCB9ID0gYXVkaW9UcmFjaztcclxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB7IGlkLCB0eXBlLCB1cmwgfSk7XHJcbiAgICB0aGlzLl9sb2FkVHJhY2tEZXRhaWxzSWZOZWVkZWQoYXVkaW9UcmFjayk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cclxuICBkb1RpY2sgKCkge1xyXG4gICAgdGhpcy5fdXBkYXRlVHJhY2sodGhpcy5fdHJhY2tJZCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZWxlY3QgaW5pdGlhbCB0cmFja1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3NlbGVjdEluaXRpYWxBdWRpb1RyYWNrICgpIHtcclxuICAgIGxldCB0cmFja3MgPSB0aGlzLnRyYWNrcztcclxuICAgIGlmICghdHJhY2tzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY3VycmVudEF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLl90cmFja0lkXTtcclxuXHJcbiAgICBsZXQgbmFtZSA9IG51bGw7XHJcbiAgICBpZiAoY3VycmVudEF1ZGlvVHJhY2spIHtcclxuICAgICAgbmFtZSA9IGN1cnJlbnRBdWRpb1RyYWNrLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJlLXNlbGVjdCBkZWZhdWx0IHRyYWNrcyBpZiB0aGVyZSBhcmUgYW55XHJcbiAgICBpZiAodGhpcy5fc2VsZWN0RGVmYXVsdFRyYWNrKSB7XHJcbiAgICAgIGNvbnN0IGRlZmF1bHRUcmFja3MgPSB0cmFja3MuZmlsdGVyKCh0cmFjaykgPT4gdHJhY2suZGVmYXVsdCk7XHJcbiAgICAgIGlmIChkZWZhdWx0VHJhY2tzLmxlbmd0aCkge1xyXG4gICAgICAgIHRyYWNrcyA9IGRlZmF1bHRUcmFja3M7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbG9nZ2VyLndhcm4oJ05vIGRlZmF1bHQgYXVkaW8gdHJhY2tzIGRlZmluZWQnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCB0cmFja0ZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3QgdHJhdmVyc2VUcmFja3MgPSAoKSA9PiB7XHJcbiAgICAgIC8vIFNlbGVjdCB0cmFjayB3aXRoIHJpZ2h0IGdyb3VwIElEXHJcbiAgICAgIHRyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4ge1xyXG4gICAgICAgIGlmICh0cmFja0ZvdW5kKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gbWF0Y2ggdGhlIChwcmUtKXNlbGVjdGVkIGdyb3VwIElEXHJcbiAgICAgICAgLy8gYW5kIHRoZSBOQU1FIG9mIHRoZSBjdXJyZW50IHRyYWNrLlxyXG4gICAgICAgIGlmICgoIXRoaXMuYXVkaW9Hcm91cElkIHx8IHRyYWNrLmdyb3VwSWQgPT09IHRoaXMuYXVkaW9Hcm91cElkKSAmJlxyXG4gICAgICAgICAgKCFuYW1lIHx8IG5hbWUgPT09IHRyYWNrLm5hbWUpKSB7XHJcbiAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcmV2aW91cyB0cmFjayB0cnkgdG8gc3RheSB3aXRoIHRoZSBzYW1lIGBOQU1FYC5cclxuICAgICAgICAgIC8vIEl0IHNob3VsZCBiZSB1bmlxdWUgYWNyb3NzIHRyYWNrcyBvZiBzYW1lIGdyb3VwLCBhbmQgY29uc2lzdGVudCB0aHJvdWdoIHJlZHVuZGFudCB0cmFjayBncm91cHMuXHJcbiAgICAgICAgICB0aGlzLl9zZXRBdWRpb1RyYWNrKHRyYWNrLmlkKTtcclxuICAgICAgICAgIHRyYWNrRm91bmQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRyYXZlcnNlVHJhY2tzKCk7XHJcblxyXG4gICAgaWYgKCF0cmFja0ZvdW5kKSB7XHJcbiAgICAgIG5hbWUgPSBudWxsO1xyXG4gICAgICB0cmF2ZXJzZVRyYWNrcygpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdHJhY2tGb3VuZCkge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoYE5vIHRyYWNrIGZvdW5kIGZvciBydW5uaW5nIGF1ZGlvIGdyb3VwLUlEOiAke3RoaXMuYXVkaW9Hcm91cElkfWApO1xyXG5cclxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xyXG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXHJcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1IsXHJcbiAgICAgICAgZmF0YWw6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja30gYXVkaW9UcmFja1xyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIF9uZWVkc1RyYWNrTG9hZGluZyAoYXVkaW9UcmFjaykge1xyXG4gICAgY29uc3QgeyBkZXRhaWxzLCB1cmwgfSA9IGF1ZGlvVHJhY2s7XHJcblxyXG4gICAgaWYgKCFkZXRhaWxzIHx8IGRldGFpbHMubGl2ZSkge1xyXG4gICAgICAvLyBjaGVjayBpZiB3ZSBmYWNlIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcclxuICAgICAgcmV0dXJuICEhdXJsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtBdWRpb1RyYWNrfSBhdWRpb1RyYWNrXHJcbiAgICovXHJcbiAgX2xvYWRUcmFja0RldGFpbHNJZk5lZWRlZCAoYXVkaW9UcmFjaykge1xyXG4gICAgaWYgKHRoaXMuX25lZWRzVHJhY2tMb2FkaW5nKGF1ZGlvVHJhY2spKSB7XHJcbiAgICAgIGNvbnN0IHsgdXJsLCBpZCB9ID0gYXVkaW9UcmFjaztcclxuICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxyXG4gICAgICBsb2dnZXIubG9nKGBsb2FkaW5nIGF1ZGlvLXRyYWNrIHBsYXlsaXN0IGZvciBpZDogJHtpZH1gKTtcclxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19MT0FESU5HLCB7IHVybCwgaWQgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdJZFxyXG4gICAqL1xyXG4gIF91cGRhdGVUcmFjayAobmV3SWQpIHtcclxuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxyXG4gICAgaWYgKG5ld0lkIDwgMCB8fCBuZXdJZCA+PSB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxyXG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XHJcbiAgICB0aGlzLl90cmFja0lkID0gbmV3SWQ7XHJcbiAgICBsb2dnZXIubG9nKGB0cnlpbmcgdG8gdXBkYXRlIGF1ZGlvLXRyYWNrICR7bmV3SWR9YCk7XHJcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdO1xyXG4gICAgdGhpcy5fbG9hZFRyYWNrRGV0YWlsc0lmTmVlZGVkKGF1ZGlvVHJhY2spO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfaGFuZGxlTG9hZEVycm9yICgpIHtcclxuICAgIC8vIEZpcnN0LCBsZXQncyBibGFjayBsaXN0IGN1cnJlbnQgdHJhY2sgaWRcclxuICAgIHRoaXMudHJhY2tJZEJsYWNrbGlzdFt0aGlzLl90cmFja0lkXSA9IHRydWU7XHJcblxyXG4gICAgLy8gTGV0J3MgdHJ5IHRvIGZhbGwgYmFjayBvbiBhIGZ1bmN0aW9uYWwgYXVkaW8tdHJhY2sgd2l0aCB0aGUgc2FtZSBncm91cCBJRFxyXG4gICAgY29uc3QgcHJldmlvdXNJZCA9IHRoaXMuX3RyYWNrSWQ7XHJcbiAgICBjb25zdCB7IG5hbWUsIGxhbmd1YWdlLCBncm91cElkIH0gPSB0aGlzLnRyYWNrc1twcmV2aW91c0lkXTtcclxuXHJcbiAgICBsb2dnZXIud2FybihgTG9hZGluZyBmYWlsZWQgb24gYXVkaW8gdHJhY2sgaWQ6ICR7cHJldmlvdXNJZH0sIGdyb3VwLWlkOiAke2dyb3VwSWR9LCBuYW1lL2xhbmd1YWdlOiBcIiR7bmFtZX1cIiAvIFwiJHtsYW5ndWFnZX1cImApO1xyXG5cclxuICAgIC8vIEZpbmQgYSBub24tYmxhY2tsaXN0ZWQgdHJhY2sgSUQgd2l0aCB0aGUgc2FtZSBOQU1FXHJcbiAgICAvLyBBdCBsZWFzdCBhIHRyYWNrIHRoYXQgaXMgbm90IGJsYWNrbGlzdGVkLCB0aHVzIG9uIGFub3RoZXIgZ3JvdXAtSUQuXHJcbiAgICBsZXQgbmV3SWQgPSBwcmV2aW91c0lkO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAodGhpcy50cmFja0lkQmxhY2tsaXN0W2ldKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgbmV3VHJhY2sgPSB0aGlzLnRyYWNrc1tpXTtcclxuICAgICAgaWYgKG5ld1RyYWNrLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgICBuZXdJZCA9IGk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAobmV3SWQgPT09IHByZXZpb3VzSWQpIHtcclxuICAgICAgbG9nZ2VyLndhcm4oYE5vIGZhbGxiYWNrIGF1ZGlvLXRyYWNrIGZvdW5kIGZvciBuYW1lL2xhbmd1YWdlOiBcIiR7bmFtZX1cIiAvIFwiJHtsYW5ndWFnZX1cImApO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbG9nZ2VyLmxvZygnQXR0ZW1wdGluZyBhdWRpby10cmFjayBmYWxsYmFjayBpZDonLCBuZXdJZCwgJ2dyb3VwLWlkOicsIHRoaXMudHJhY2tzW25ld0lkXS5ncm91cElkKTtcclxuXHJcbiAgICB0aGlzLl9zZXRBdWRpb1RyYWNrKG5ld0lkKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEF1ZGlvVHJhY2tDb250cm9sbGVyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXIuanMiLCIvKlxyXG4gKiBBdWRpbyBTdHJlYW0gQ29udHJvbGxlclxyXG4qL1xyXG5cclxuaW1wb3J0IEJpbmFyeVNlYXJjaCBmcm9tICcuLi91dGlscy9iaW5hcnktc2VhcmNoJztcclxuaW1wb3J0IHsgQnVmZmVySGVscGVyIH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyLWhlbHBlcic7XHJcbmltcG9ydCBEZW11eGVyIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXInO1xyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0ICogYXMgTGV2ZWxIZWxwZXIgZnJvbSAnLi9sZXZlbC1oZWxwZXInO1xyXG5pbXBvcnQgVGltZVJhbmdlcyBmcm9tICcuLi91dGlscy90aW1lLXJhbmdlcyc7XHJcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcbmltcG9ydCB7IGZpbmRGcmFnV2l0aENDIH0gZnJvbSAnLi4vdXRpbHMvZGlzY29udGludWl0aWVzJztcclxuaW1wb3J0IHsgRnJhZ21lbnRTdGF0ZSB9IGZyb20gJy4vZnJhZ21lbnQtdHJhY2tlcic7XHJcbmltcG9ydCBGcmFnbWVudCwgeyBFbGVtZW50YXJ5U3RyZWFtVHlwZXMgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xyXG5pbXBvcnQgQmFzZVN0cmVhbUNvbnRyb2xsZXIsIHsgU3RhdGUgfSBmcm9tICcuL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXInO1xyXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSB3aW5kb3c7XHJcblxyXG5jb25zdCBUSUNLX0lOVEVSVkFMID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xyXG5cclxuY2xhc3MgQXVkaW9TdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgQmFzZVN0cmVhbUNvbnRyb2xsZXIge1xyXG4gIGNvbnN0cnVjdG9yIChobHMsIGZyYWdtZW50VHJhY2tlcikge1xyXG4gICAgc3VwZXIoaGxzLFxyXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcclxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxyXG4gICAgICBFdmVudC5BVURJT19UUkFDS1NfVVBEQVRFRCxcclxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENISU5HLFxyXG4gICAgICBFdmVudC5BVURJT19UUkFDS19MT0FERUQsXHJcbiAgICAgIEV2ZW50LktFWV9MT0FERUQsXHJcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxyXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULFxyXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfREFUQSxcclxuICAgICAgRXZlbnQuRlJBR19QQVJTRUQsXHJcbiAgICAgIEV2ZW50LkVSUk9SLFxyXG4gICAgICBFdmVudC5CVUZGRVJfUkVTRVQsXHJcbiAgICAgIEV2ZW50LkJVRkZFUl9DUkVBVEVELFxyXG4gICAgICBFdmVudC5CVUZGRVJfQVBQRU5ERUQsXHJcbiAgICAgIEV2ZW50LkJVRkZFUl9GTFVTSEVELFxyXG4gICAgICBFdmVudC5JTklUX1BUU19GT1VORCk7XHJcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcclxuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcclxuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcclxuICAgIHRoaXMuX3N0YXRlID0gU3RhdGUuU1RPUFBFRDtcclxuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xyXG4gICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBudWxsO1xyXG4gICAgdGhpcy52aWRlb1RyYWNrQ0MgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gU2lnbmFsIHRoYXQgdmlkZW8gUFRTIHdhcyBmb3VuZFxyXG4gIG9uSW5pdFB0c0ZvdW5kIChkYXRhKSB7XHJcbiAgICBsZXQgZGVtdXhlcklkID0gZGF0YS5pZCwgY2MgPSBkYXRhLmZyYWcuY2MsIGluaXRQVFMgPSBkYXRhLmluaXRQVFM7XHJcbiAgICBpZiAoZGVtdXhlcklkID09PSAnbWFpbicpIHtcclxuICAgICAgLy8gQWx3YXlzIHVwZGF0ZSB0aGUgbmV3IElOSVQgUFRTXHJcbiAgICAgIC8vIENhbiBjaGFuZ2UgZHVlIGxldmVsIHN3aXRjaFxyXG4gICAgICB0aGlzLmluaXRQVFNbY2NdID0gaW5pdFBUUztcclxuICAgICAgdGhpcy52aWRlb1RyYWNrQ0MgPSBjYztcclxuICAgICAgbG9nZ2VyLmxvZyhgSW5pdFBUUyBmb3IgY2M6ICR7Y2N9IGZvdW5kIGZyb20gdmlkZW8gdHJhY2s6ICR7aW5pdFBUU31gKTtcclxuXHJcbiAgICAgIC8vIElmIHdlIGFyZSB3YWl0aW5nIHdlIG5lZWQgdG8gZGVtdXgvcmVtdXggdGhlIHdhaXRpbmcgZnJhZ1xyXG4gICAgICAvLyBXaXRoIHRoZSBuZXcgaW5pdFBUU1xyXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19JTklUX1BUUykge1xyXG4gICAgICAgIHRoaXMudGljaygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGFydExvYWQgKHN0YXJ0UG9zaXRpb24pIHtcclxuICAgIGlmICh0aGlzLnRyYWNrcykge1xyXG4gICAgICBsZXQgbGFzdEN1cnJlbnRUaW1lID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XHJcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcclxuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcclxuICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcclxuICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcclxuICAgICAgICBsb2dnZXIubG9nKGBhdWRpbzpvdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uID8gdGhpcy5zdGFydFBvc2l0aW9uIDogc3RhcnRQb3NpdGlvbjtcclxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RBUlRJTkc7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XHJcbiAgICAgIHRoaXMudGljaygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXQgc3RhdGUgKG5leHRTdGF0ZSkge1xyXG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IG5leHRTdGF0ZSkge1xyXG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgICAgdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XHJcbiAgICAgIGxvZ2dlci5sb2coYGF1ZGlvIHN0cmVhbToke3ByZXZpb3VzU3RhdGV9LT4ke25leHRTdGF0ZX1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBzdGF0ZSAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XHJcbiAgfVxyXG5cclxuICBkb1RpY2sgKCkge1xyXG4gICAgbGV0IHBvcywgdHJhY2ssIHRyYWNrRGV0YWlscywgaGxzID0gdGhpcy5obHMsIGNvbmZpZyA9IGhscy5jb25maWc7XHJcbiAgICAvLyBsb2dnZXIubG9nKCdhdWRpb1N0cmVhbTonICsgdGhpcy5zdGF0ZSk7XHJcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcclxuICAgIGNhc2UgU3RhdGUuRVJST1I6XHJcbiAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGluIGVycm9yIHN0YXRlIHRvIGF2b2lkIGJyZWFraW5nIGZ1cnRoZXIgLi4uXHJcbiAgICBjYXNlIFN0YXRlLlBBVVNFRDpcclxuICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaW4gcGF1c2VkIHN0YXRlIGVpdGhlciAuLi5cclxuICAgIGNhc2UgU3RhdGUuQlVGRkVSX0ZMVVNISU5HOlxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgU3RhdGUuU1RBUlRJTkc6XHJcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX1RSQUNLO1xyXG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBTdGF0ZS5JRExFOlxyXG4gICAgICBjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrcztcclxuICAgICAgLy8gYXVkaW8gdHJhY2tzIG5vdCByZWNlaXZlZCA9PiBleGl0IGxvb3BcclxuICAgICAgaWYgKCF0cmFja3MpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORFxyXG4gICAgICAvLyBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIGRpc2FibGVcclxuICAgICAgLy8gZXhpdCBsb29wXHJcbiAgICAgIC8vID0+IGlmIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcclxuICAgICAgaWYgKCF0aGlzLm1lZGlhICYmXHJcbiAgICAgICAgICAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmRcclxuICAgICAgLy8gIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cclxuICAgICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxyXG4gICAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSkge1xyXG4gICAgICAgIHBvcyA9IHRoaXMubWVkaWEuY3VycmVudFRpbWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xyXG4gICAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYSxcclxuICAgICAgICB2aWRlb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYSxcclxuICAgICAgICBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLFxyXG4gICAgICAgIG1haW5CdWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odmlkZW9CdWZmZXIsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLFxyXG4gICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuLFxyXG4gICAgICAgIGJ1ZmZlckVuZCA9IGJ1ZmZlckluZm8uZW5kLFxyXG4gICAgICAgIGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzLFxyXG4gICAgICAgIC8vIGVuc3VyZSB3ZSBidWZmZXIgYXQgbGVhc3QgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCAoZGVmYXVsdCAzMHMpIG9yIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggKGRlZmF1bHQ6IDYwMHMpXHJcbiAgICAgICAgLy8gd2hpY2hldmVyIGlzIHNtYWxsZXIuXHJcbiAgICAgICAgLy8gb25jZSB3ZSByZWFjaCB0aGF0IHRocmVzaG9sZCwgZG9uJ3QgYnVmZmVyIG1vcmUgdGhhbiB2aWRlbyAobWFpbkJ1ZmZlckluZm8ubGVuKVxyXG4gICAgICAgIG1heENvbmZpZ0J1ZmZlciA9IE1hdGgubWluKGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgsIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpLFxyXG4gICAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWF4KG1heENvbmZpZ0J1ZmZlciwgbWFpbkJ1ZmZlckluZm8ubGVuKSxcclxuICAgICAgICBhdWRpb1N3aXRjaCA9IHRoaXMuYXVkaW9Td2l0Y2gsXHJcbiAgICAgICAgdHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcclxuXHJcbiAgICAgICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50XHJcbiAgICAgIGlmICgoYnVmZmVyTGVuIDwgbWF4QnVmTGVuIHx8IGF1ZGlvU3dpdGNoKSAmJiB0cmFja0lkIDwgdHJhY2tzLmxlbmd0aCkge1xyXG4gICAgICAgIHRyYWNrRGV0YWlscyA9IHRyYWNrc1t0cmFja0lkXS5kZXRhaWxzO1xyXG4gICAgICAgIC8vIGlmIHRyYWNrIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgdHJhY2sgcmV0cmlldmFsXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFja0RldGFpbHMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFhdWRpb1N3aXRjaCAmJiB0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCB0cmFja0RldGFpbHMpKSB7XHJcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9FT1MsIHsgdHlwZTogJ2F1ZGlvJyB9KTtcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXHJcbiAgICAgICAgbGV0IGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHMsXHJcbiAgICAgICAgICBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aCxcclxuICAgICAgICAgIHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0LFxyXG4gICAgICAgICAgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uZHVyYXRpb24sXHJcbiAgICAgICAgICBmcmFnO1xyXG5cclxuICAgICAgICAgIC8vIFdoZW4gc3dpdGNoaW5nIGF1ZGlvIHRyYWNrLCByZWxvYWQgYXVkaW8gYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gY3VycmVudFRpbWVcclxuICAgICAgICBpZiAoYXVkaW9Td2l0Y2gpIHtcclxuICAgICAgICAgIGlmICh0cmFja0RldGFpbHMubGl2ZSAmJiAhdHJhY2tEZXRhaWxzLlBUU0tub3duKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpb3RyYWNrLCBsaXZlIHN0cmVhbSwgdW5rbm93biBQVFMsbG9hZCBmaXJzdCBmcmFnbWVudCcpO1xyXG4gICAgICAgICAgICBidWZmZXJFbmQgPSAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyRW5kID0gcG9zO1xyXG4gICAgICAgICAgICAvLyBpZiBjdXJyZW50VGltZSAocG9zKSBpcyBsZXNzIHRoYW4gYWx0IGF1ZGlvIHBsYXlsaXN0IHN0YXJ0IHRpbWUsIGl0IG1lYW5zIHRoYXQgYWx0IGF1ZGlvIGlzIGFoZWFkIG9mIGN1cnJlbnRUaW1lXHJcbiAgICAgICAgICAgIGlmICh0cmFja0RldGFpbHMuUFRTS25vd24gJiYgcG9zIDwgc3RhcnQpIHtcclxuICAgICAgICAgICAgICAvLyBpZiBldmVyeXRoaW5nIGlzIGJ1ZmZlcmVkIGZyb20gcG9zIHRvIHN0YXJ0IG9yIGlmIGF1ZGlvIGJ1ZmZlciB1cGZyb250LCBsZXQncyBzZWVrIHRvIHN0YXJ0XHJcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlckluZm8uZW5kID4gc3RhcnQgfHwgYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ2FsdCBhdWRpbyB0cmFjayBhaGVhZCBvZiBtYWluIHRyYWNrLCBzZWVrIHRvIHN0YXJ0IG9mIGFsdCBhdWRpbyB0cmFjaycpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0ICsgMC4wNTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhY2tEZXRhaWxzLmluaXRTZWdtZW50ICYmICF0cmFja0RldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSkge1xyXG4gICAgICAgICAgZnJhZyA9IHRyYWNrRGV0YWlscy5pbml0U2VnbWVudDtcclxuICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcclxuICAgICAgICAvLyBpZiBidWZmZXJFbmQgYmVmb3JlIHN0YXJ0IG9mIHBsYXlsaXN0LCBsb2FkIGZpcnN0IGZyYWdtZW50XHJcbiAgICAgICAgZWxzZSBpZiAoYnVmZmVyRW5kIDw9IHN0YXJ0KSB7XHJcbiAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xyXG4gICAgICAgICAgaWYgKHRoaXMudmlkZW9UcmFja0NDICE9PSBudWxsICYmIGZyYWcuY2MgIT09IHRoaXMudmlkZW9UcmFja0NDKSB7XHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSBmaW5kIGEgZnJhZ21lbnQgd2hpY2ggbWF0Y2hlcyB0aGUgY29udGludWl0eSBvZiB0aGUgdmlkZW8gdHJhY2tcclxuICAgICAgICAgICAgZnJhZyA9IGZpbmRGcmFnV2l0aENDKGZyYWdtZW50cywgdGhpcy52aWRlb1RyYWNrQ0MpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5saXZlICYmIGZyYWcubG9hZElkeCAmJiBmcmFnLmxvYWRJZHggPT09IHRoaXMuZnJhZ0xvYWRJZHgpIHtcclxuICAgICAgICAgICAgLy8gd2UganVzdCBsb2FkZWQgdGhpcyBmaXJzdCBmcmFnbWVudCwgYW5kIHdlIGFyZSBzdGlsbCBsYWdnaW5nIGJlaGluZCB0aGUgc3RhcnQgb2YgdGhlIGxpdmUgcGxheWxpc3RcclxuICAgICAgICAgICAgLy8gbGV0J3MgZm9yY2Ugc2VlayB0byBzdGFydFxyXG4gICAgICAgICAgICBjb25zdCBuZXh0QnVmZmVyZWQgPSBidWZmZXJJbmZvLm5leHRTdGFydCA/IGJ1ZmZlckluZm8ubmV4dFN0YXJ0IDogc3RhcnQ7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYG5vIGFsdCBhdWRpbyBhdmFpbGFibGUgQGN1cnJlbnRUaW1lOiR7dGhpcy5tZWRpYS5jdXJyZW50VGltZX0sIHNlZWtpbmcgQCR7bmV4dEJ1ZmZlcmVkICsgMC4wNX1gKTtcclxuICAgICAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IG5leHRCdWZmZXJlZCArIDAuMDU7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGV0IGZvdW5kRnJhZztcclxuICAgICAgICAgIGxldCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XHJcbiAgICAgICAgICBjb25zdCBmcmFnTmV4dCA9IGZyYWdQcmV2aW91cyA/IGZyYWdtZW50c1tmcmFnUHJldmlvdXMuc24gLSBmcmFnbWVudHNbMF0uc24gKyAxXSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgIGxldCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QgPSAoY2FuZGlkYXRlKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXHJcbiAgICAgICAgICAgIC8vIGZyYWdbw5hdIDogWzAsMTBdXHJcbiAgICAgICAgICAgIC8vIGZyYWdbMV0gOiBbMTAsMjBdXHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cclxuICAgICAgICAgICAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxyXG4gICAgICAgICAgICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcclxuICAgICAgICAgICAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcclxuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgbGV2ZWwvc24vc3RhcnQvZW5kL2J1ZkVuZDoke2xldmVsfS8ke2NhbmRpZGF0ZS5zbn0vJHtjYW5kaWRhdGUuc3RhcnR9LyR7KGNhbmRpZGF0ZS5zdGFydCtjYW5kaWRhdGUuZHVyYXRpb24pfS8ke2J1ZmZlckVuZH1gKTtcclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBsb29rdXAgdG9sZXJhbmNlIHRvIGJlIHNtYWxsIGVub3VnaCB0byBkZXRlY3QgdGhlIGN1cnJlbnQgc2VnbWVudCAtIGVuc3VyZXMgd2UgZG9uJ3Qgc2tpcCBvdmVyIHZlcnkgc21hbGwgc2VnbWVudHNcclxuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbik7XHJcbiAgICAgICAgICAgIGlmICgoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlKSA8PSBidWZmZXJFbmQpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgLy8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcclxuICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XHJcbiAgICAgICAgICAgIGlmIChidWZmZXJFbmQgPiBlbmQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XHJcbiAgICAgICAgICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFByZWZlciB0aGUgbmV4dCBmcmFnbWVudCBpZiBpdCdzIHdpdGhpbiB0b2xlcmFuY2VcclxuICAgICAgICAgICAgaWYgKGZyYWdOZXh0ICYmICFmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoZnJhZ05leHQpKSB7XHJcbiAgICAgICAgICAgICAgZm91bmRGcmFnID0gZnJhZ05leHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgZm91bmRGcmFnID0gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxyXG4gICAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGZvdW5kRnJhZykge1xyXG4gICAgICAgICAgICBmcmFnID0gZm91bmRGcmFnO1xyXG4gICAgICAgICAgICBzdGFydCA9IGZvdW5kRnJhZy5zdGFydDtcclxuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmluZCBTTiBtYXRjaGluZyB3aXRoIHBvczonICsgIGJ1ZmZlckVuZCArICc6JyArIGZyYWcuc24pO1xyXG4gICAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbCAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcclxuICAgICAgICAgICAgICBpZiAoZnJhZy5zbiA8IHRyYWNrRGV0YWlscy5lbmRTTikge1xyXG4gICAgICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tmcmFnLnNuICsgMSAtIHRyYWNrRGV0YWlscy5zdGFydFNOXTtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNOIGp1c3QgbG9hZGVkLCBsb2FkIG5leHQgb25lOiAke2ZyYWcuc259YCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZyYWcgPSBudWxsO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJhZykge1xyXG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnICAgICAgbG9hZGluZyBmcmFnICcgKyBpICsnLHBvcy9idWZFbmQ6JyArIHBvcy50b0ZpeGVkKDMpICsgJy8nICsgYnVmZmVyRW5kLnRvRml4ZWQoMykpO1xyXG4gICAgICAgICAgaWYgKGZyYWcuZW5jcnlwdGVkKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcga2V5IGZvciAke2ZyYWcuc259IG9mIFske3RyYWNrRGV0YWlscy5zdGFydFNOfSAsJHt0cmFja0RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcclxuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuS0VZX0xPQURJTkcsIHsgZnJhZzogZnJhZyB9KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcgJHtmcmFnLnNufSwgY2M6ICR7ZnJhZy5jY30gb2YgWyR7dHJhY2tEZXRhaWxzLnN0YXJ0U059ICwke3RyYWNrRGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dHJhY2tJZH0sIGN1cnJlbnRUaW1lOiR7cG9zfSxidWZmZXJFbmQ6JHtidWZmZXJFbmQudG9GaXhlZCgzKX1gKTtcclxuICAgICAgICAgICAgLy8gb25seSBsb2FkIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWQgb3IgaWYgaW4gYXVkaW8gc3dpdGNoXHJcbiAgICAgICAgICAgIC8vIHdlIGZvcmNlIGEgZnJhZyBsb2FkaW5nIGluIGF1ZGlvIHN3aXRjaCBhcyBmcmFnbWVudCB0cmFja2VyIG1pZ2h0IG5vdCBoYXZlIGV2aWN0ZWQgcHJldmlvdXMgZnJhZ3MgaW4gY2FzZSBvZiBxdWljayBhdWRpbyBzd2l0Y2hcclxuICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XHJcbiAgICAgICAgICAgIGlmIChhdWRpb1N3aXRjaCB8fCB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLnNuKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURJTkcsIHsgZnJhZyB9KTtcclxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBTdGF0ZS5XQUlUSU5HX1RSQUNLOlxyXG4gICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF07XHJcbiAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXHJcbiAgICAgIGlmICh0cmFjayAmJiB0cmFjay5kZXRhaWxzKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcclxuICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICB2YXIgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XHJcbiAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcclxuICAgICAgdmFyIGlzU2Vla2luZyA9IG1lZGlhICYmIG1lZGlhLnNlZWtpbmc7XHJcbiAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXHJcbiAgICAgIGlmICghcmV0cnlEYXRlIHx8IChub3cgPj0gcmV0cnlEYXRlKSB8fCBpc1NlZWtpbmcpIHtcclxuICAgICAgICBsb2dnZXIubG9nKCdhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IHJldHJ5RGF0ZSByZWFjaGVkLCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlJyk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFN0YXRlLldBSVRJTkdfSU5JVF9QVFM6XHJcbiAgICAgIGNvbnN0IHZpZGVvVHJhY2tDQyA9IHRoaXMudmlkZW9UcmFja0NDO1xyXG4gICAgICBpZiAodGhpcy5pbml0UFRTW3ZpZGVvVHJhY2tDQ10gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIHRoZSBXQUlUSU5HX0lOSVRfUFRTIHN0YXRlIGlmIHRoZSB3YWl0aW5nIGZyYWcgQ0MgZG9lc24ndCBtYXRjaCBhbnkgaW5pdFBUU1xyXG4gICAgICBjb25zdCB3YWl0aW5nRnJhZyA9IHRoaXMud2FpdGluZ0ZyYWdtZW50O1xyXG4gICAgICBpZiAod2FpdGluZ0ZyYWcpIHtcclxuICAgICAgICBjb25zdCB3YWl0aW5nRnJhZ0NDID0gd2FpdGluZ0ZyYWcuZnJhZy5jYztcclxuICAgICAgICBpZiAodmlkZW9UcmFja0NDICE9PSB3YWl0aW5nRnJhZ0NDKSB7XHJcbiAgICAgICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF07XHJcbiAgICAgICAgICBpZiAodHJhY2suZGV0YWlscyAmJiB0cmFjay5kZXRhaWxzLmxpdmUpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFdhaXRpbmcgZnJhZ21lbnQgQ0MgKCR7d2FpdGluZ0ZyYWdDQ30pIGRvZXMgbm90IG1hdGNoIHZpZGVvIHRyYWNrIENDICgke3ZpZGVvVHJhY2tDQ30pYCk7XHJcbiAgICAgICAgICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XHJcbiAgICAgICAgICB0aGlzLm9uRnJhZ0xvYWRlZCh0aGlzLndhaXRpbmdGcmFnbWVudCk7XHJcbiAgICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcclxuICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxyXG4gICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxyXG4gICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XHJcbiAgICBjYXNlIFN0YXRlLkVOREVEOlxyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25NZWRpYUF0dGFjaGVkIChkYXRhKSB7XHJcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IGRhdGEubWVkaWE7XHJcbiAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKTtcclxuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xyXG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcclxuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcclxuICAgIGlmICh0aGlzLnRyYWNrcyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xyXG4gICAgICB0aGlzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcclxuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XHJcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuZW5kZWQpIHtcclxuICAgICAgbG9nZ2VyLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcclxuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcclxuICAgIGlmIChtZWRpYSkge1xyXG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcclxuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcclxuICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9udmVuZGVkID0gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XHJcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XHJcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcclxuICAgIHRoaXMuc3RvcExvYWQoKTtcclxuICB9XHJcblxyXG4gIG9uQXVkaW9UcmFja3NVcGRhdGVkIChkYXRhKSB7XHJcbiAgICBsb2dnZXIubG9nKCdhdWRpbyB0cmFja3MgdXBkYXRlZCcpO1xyXG4gICAgdGhpcy50cmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzO1xyXG4gIH1cclxuXHJcbiAgb25BdWRpb1RyYWNrU3dpdGNoaW5nIChkYXRhKSB7XHJcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXHJcbiAgICBsZXQgYWx0QXVkaW8gPSAhIWRhdGEudXJsO1xyXG4gICAgdGhpcy50cmFja0lkID0gZGF0YS5pZDtcclxuXHJcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcclxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVVTRUQ7XHJcbiAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XHJcbiAgICAvLyBkZXN0cm95IHVzZWxlc3MgZGVtdXhlciB3aGVuIHN3aXRjaGluZyBhdWRpbyB0byBtYWluXHJcbiAgICBpZiAoIWFsdEF1ZGlvKSB7XHJcbiAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcclxuICAgICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHN3aXRjaGluZyB0byBhdWRpbyB0cmFjaywgc3RhcnQgdGltZXIgaWYgbm90IGFscmVhZHkgc3RhcnRlZFxyXG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNob3VsZCB3ZSBzd2l0Y2ggdHJhY2tzID9cclxuICAgIGlmIChhbHRBdWRpbykge1xyXG4gICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gdHJ1ZTtcclxuICAgICAgLy8gbWFpbiBhdWRpbyB0cmFjayBhcmUgaGFuZGxlZCBieSBzdHJlYW0tY29udHJvbGxlciwganVzdCBkbyBzb21ldGhpbmcgaWYgc3dpdGNoaW5nIHRvIGFsdCBhdWRpbyB0cmFja1xyXG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgIH1cclxuICAgIHRoaXMudGljaygpO1xyXG4gIH1cclxuXHJcbiAgb25BdWRpb1RyYWNrTG9hZGVkIChkYXRhKSB7XHJcbiAgICBsZXQgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscyxcclxuICAgICAgdHJhY2tJZCA9IGRhdGEuaWQsXHJcbiAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tJZF0sXHJcbiAgICAgIGR1cmF0aW9uID0gbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uLFxyXG4gICAgICBzbGlkaW5nID0gMDtcclxuXHJcbiAgICBsb2dnZXIubG9nKGB0cmFjayAke3RyYWNrSWR9IGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dLGR1cmF0aW9uOiR7ZHVyYXRpb259YCk7XHJcblxyXG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xyXG4gICAgICBsZXQgY3VyRGV0YWlscyA9IHRyYWNrLmRldGFpbHM7XHJcbiAgICAgIGlmIChjdXJEZXRhaWxzICYmIG5ld0RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyB3ZSBhbHJlYWR5IGhhdmUgZGV0YWlscyBmb3IgdGhhdCBsZXZlbCwgbWVyZ2UgdGhlbVxyXG4gICAgICAgIExldmVsSGVscGVyLm1lcmdlRGV0YWlscyhjdXJEZXRhaWxzLCBuZXdEZXRhaWxzKTtcclxuICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XHJcbiAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgIC8vIHRoaXMubGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBjdXJEZXRhaWxzKTtcclxuICAgICAgICBpZiAobmV3RGV0YWlscy5QVFNLbm93bikge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBhdWRpbyBwbGF5bGlzdCBzbGlkaW5nOiR7c2xpZGluZy50b0ZpeGVkKDMpfWApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKCdsaXZlIGF1ZGlvIHBsYXlsaXN0IC0gb3V0ZGF0ZWQgUFRTLCB1bmtub3duIHNsaWRpbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xyXG4gICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdHJhY2suZGV0YWlscyA9IG5ld0RldGFpbHM7XHJcblxyXG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvblxyXG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xyXG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcclxuICAgICAgaWYgKHRoaXMuc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcclxuICAgICAgICAvLyBmaXJzdCwgY2hlY2sgaWYgc3RhcnQgdGltZSBvZmZzZXQgaGFzIGJlZW4gc2V0IGluIHBsYXlsaXN0LCBpZiB5ZXMsIHVzZSB0aGlzIHZhbHVlXHJcbiAgICAgICAgbGV0IHN0YXJ0VGltZU9mZnNldCA9IG5ld0RldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xyXG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc3RhcnRUaW1lT2Zmc2V0KSkge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgc3RhcnQgdGltZSBvZmZzZXQgZm91bmQgaW4gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvICR7c3RhcnRUaW1lT2Zmc2V0fWApO1xyXG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRUaW1lT2Zmc2V0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBuZXdEZXRhaWxzKTtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgY29tcHV0ZSBzdGFydFBvc2l0aW9uIGZvciBhdWRpby10cmFjayB0byAke3RoaXMuc3RhcnRQb3NpdGlvbn1gKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcclxuICAgIH1cclxuICAgIC8vIG9ubHkgc3dpdGNoIGJhdGNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciB0cmFjayB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxyXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfVFJBQ0spIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xyXG4gICAgdGhpcy50aWNrKCk7XHJcbiAgfVxyXG5cclxuICBvbktleUxvYWRlZCAoKSB7XHJcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICAgIHRoaXMudGljaygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcmFnTG9hZGVkIChkYXRhKSB7XHJcbiAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LFxyXG4gICAgICBmcmFnTG9hZGVkID0gZGF0YS5mcmFnO1xyXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyAmJlxyXG4gICAgICAgIGZyYWdDdXJyZW50ICYmXHJcbiAgICAgICAgZnJhZ0xvYWRlZC50eXBlID09PSAnYXVkaW8nICYmXHJcbiAgICAgICAgZnJhZ0xvYWRlZC5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcclxuICAgICAgICBmcmFnTG9hZGVkLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xyXG4gICAgICBsZXQgdHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdLFxyXG4gICAgICAgIGRldGFpbHMgPSB0cmFjay5kZXRhaWxzLFxyXG4gICAgICAgIGR1cmF0aW9uID0gZGV0YWlscy50b3RhbGR1cmF0aW9uLFxyXG4gICAgICAgIHRyYWNrSWQgPSBmcmFnQ3VycmVudC5sZXZlbCxcclxuICAgICAgICBzbiA9IGZyYWdDdXJyZW50LnNuLFxyXG4gICAgICAgIGNjID0gZnJhZ0N1cnJlbnQuY2MsXHJcbiAgICAgICAgYXVkaW9Db2RlYyA9IHRoaXMuY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IHRyYWNrLmF1ZGlvQ29kZWMgfHwgJ21wNGEuNDAuMicsXHJcbiAgICAgICAgc3RhdHMgPSB0aGlzLnN0YXRzID0gZGF0YS5zdGF0cztcclxuICAgICAgaWYgKHNuID09PSAnaW5pdFNlZ21lbnQnKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcblxyXG4gICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgPSBkYXRhLnBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZ0N1cnJlbnQsIGlkOiAnYXVkaW8nIH0pO1xyXG4gICAgICAgIHRoaXMudGljaygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTSU5HO1xyXG4gICAgICAgIC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcclxuICAgICAgICB0aGlzLmFwcGVuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRlbXV4ZXIpIHtcclxuICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKHRoaXMuaGxzLCAnYXVkaW8nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdmlkZW8gaW5pdFBUU1xyXG4gICAgICAgIC8vIElmIG5vdCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0XHJcbiAgICAgICAgbGV0IGluaXRQVFMgPSB0aGlzLmluaXRQVFNbY2NdO1xyXG4gICAgICAgIGxldCBpbml0U2VnbWVudERhdGEgPSBkZXRhaWxzLmluaXRTZWdtZW50ID8gZGV0YWlscy5pbml0U2VnbWVudC5kYXRhIDogW107XHJcbiAgICAgICAgaWYgKGRldGFpbHMuaW5pdFNlZ21lbnQgfHwgaW5pdFBUUyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgRGVtdXhpbmcgJHtzbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xyXG4gICAgICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXHJcbiAgICAgICAgICBsZXQgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gZmFsc2U7IC8vIGRldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZTtcclxuICAgICAgICAgIHRoaXMuZGVtdXhlci5wdXNoKGRhdGEucGF5bG9hZCwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCBudWxsLCBmcmFnQ3VycmVudCwgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgaW5pdFBUUyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coYHVua25vd24gdmlkZW8gUFRTIGZvciBjb250aW51aXR5IGNvdW50ZXIgJHtjY30sIHdhaXRpbmcgZm9yIHZpZGVvIFBUUyBiZWZvcmUgZGVtdXhpbmcgYXVkaW8gZnJhZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XHJcbiAgICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IGRhdGE7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19JTklUX1BUUztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XHJcbiAgfVxyXG5cclxuICBvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQgKGRhdGEpIHtcclxuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XHJcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcclxuICAgICAgICBkYXRhLmlkID09PSAnYXVkaW8nICYmXHJcbiAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcclxuICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxyXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcclxuICAgICAgbGV0IHRyYWNrcyA9IGRhdGEudHJhY2tzLCB0cmFjaztcclxuXHJcbiAgICAgIC8vIGRlbGV0ZSBhbnkgdmlkZW8gdHJhY2sgZm91bmQgb24gYXVkaW8gZGVtdXhlclxyXG4gICAgICBpZiAodHJhY2tzLnZpZGVvKSB7XHJcbiAgICAgICAgZGVsZXRlIHRyYWNrcy52aWRlbztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcclxuICAgICAgdHJhY2sgPSB0cmFja3MuYXVkaW87XHJcbiAgICAgIGlmICh0cmFjaykge1xyXG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSB0cmFjay5jb2RlYztcclxuICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XHJcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQ09ERUNTLCB0cmFja3MpO1xyXG4gICAgICAgIGxvZ2dlci5sb2coYGF1ZGlvIHRyYWNrOmF1ZGlvLGNvbnRhaW5lcjoke3RyYWNrLmNvbnRhaW5lcn0sY29kZWNzW2xldmVsL3BhcnNlZF09WyR7dHJhY2subGV2ZWxDb2RlY30vJHt0cmFjay5jb2RlY31dYCk7XHJcbiAgICAgICAgbGV0IGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XHJcbiAgICAgICAgaWYgKGluaXRTZWdtZW50KSB7XHJcbiAgICAgICAgICBsZXQgYXBwZW5kT2JqID0geyB0eXBlOiAnYXVkaW8nLCBkYXRhOiBpbml0U2VnbWVudCwgcGFyZW50OiAnYXVkaW8nLCBjb250ZW50OiAnaW5pdFNlZ21lbnQnIH07XHJcbiAgICAgICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCkge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEYXRhID0gW2FwcGVuZE9ial07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XHJcbiAgICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRnJhZ1BhcnNpbmdEYXRhIChkYXRhKSB7XHJcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XHJcbiAgICBjb25zdCBmcmFnTmV3ID0gZGF0YS5mcmFnO1xyXG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXHJcbiAgICAgICAgZGF0YS5pZCA9PT0gJ2F1ZGlvJyAmJlxyXG4gICAgICAgIGRhdGEudHlwZSA9PT0gJ2F1ZGlvJyAmJlxyXG4gICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXHJcbiAgICAgICAgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcclxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XHJcbiAgICAgIGxldCB0cmFja0lkID0gdGhpcy50cmFja0lkLFxyXG4gICAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tJZF0sXHJcbiAgICAgICAgaGxzID0gdGhpcy5obHM7XHJcblxyXG4gICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShkYXRhLmVuZFBUUykpIHtcclxuICAgICAgICBkYXRhLmVuZFBUUyA9IGRhdGEuc3RhcnRQVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcclxuICAgICAgICBkYXRhLmVuZERUUyA9IGRhdGEuc3RhcnREVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnJhZ0N1cnJlbnQuYWRkRWxlbWVudGFyeVN0cmVhbShFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8pO1xyXG5cclxuICAgICAgbG9nZ2VyLmxvZyhgcGFyc2VkICR7ZGF0YS50eXBlfSxQVFM6WyR7ZGF0YS5zdGFydFBUUy50b0ZpeGVkKDMpfSwke2RhdGEuZW5kUFRTLnRvRml4ZWQoMyl9XSxEVFM6WyR7ZGF0YS5zdGFydERUUy50b0ZpeGVkKDMpfS8ke2RhdGEuZW5kRFRTLnRvRml4ZWQoMyl9XSxuYjoke2RhdGEubmJ9YCk7XHJcbiAgICAgIExldmVsSGVscGVyLnVwZGF0ZUZyYWdQVFNEVFModHJhY2suZGV0YWlscywgZnJhZ0N1cnJlbnQsIGRhdGEuc3RhcnRQVFMsIGRhdGEuZW5kUFRTKTtcclxuXHJcbiAgICAgIGxldCBhdWRpb1N3aXRjaCA9IHRoaXMuYXVkaW9Td2l0Y2gsIG1lZGlhID0gdGhpcy5tZWRpYSwgYXBwZW5kT25CdWZmZXJGbHVzaCA9IGZhbHNlO1xyXG4gICAgICAvLyBPbmx5IGZsdXNoIGF1ZGlvIGZyb20gb2xkIGF1ZGlvIHRyYWNrcyB3aGVuIFBUUyBpcyBrbm93biBvbiBuZXcgYXVkaW8gdHJhY2tcclxuICAgICAgaWYgKGF1ZGlvU3dpdGNoKSB7XHJcbiAgICAgICAgaWYgKG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcclxuICAgICAgICAgIGxldCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIGF1ZGlvIHRyYWNrIDogY3VycmVudFRpbWU6JyArIGN1cnJlbnRUaW1lKTtcclxuICAgICAgICAgIGlmIChjdXJyZW50VGltZSA+PSBkYXRhLnN0YXJ0UFRTKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGZsdXNoaW5nIGFsbCBhdWRpbycpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQlVGRkVSX0ZMVVNISU5HO1xyXG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHsgc3RhcnRPZmZzZXQ6IDAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlOiAnYXVkaW8nIH0pO1xyXG4gICAgICAgICAgICBhcHBlbmRPbkJ1ZmZlckZsdXNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gTGV0cyBhbm5vdW5jZSB0aGF0IHRoZSBpbml0aWFsIGF1ZGlvIHRyYWNrIHN3aXRjaCBmbHVzaCBvY2N1clxyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7IGlkOiB0cmFja0lkIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBMZXRzIGFubm91bmNlIHRoYXQgdGhlIGluaXRpYWwgYXVkaW8gdHJhY2sgc3dpdGNoIGZsdXNoIG9jY3VyXHJcbiAgICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwgeyBpZDogdHJhY2tJZCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBwZW5kaW5nRGF0YSA9IHRoaXMucGVuZGluZ0RhdGE7XHJcblxyXG4gICAgICBpZiAoIXBlbmRpbmdEYXRhKSB7XHJcbiAgICAgICAgbG9nZ2VyLndhcm4oJ0FwcGFyZW50bHkgYXR0ZW1wdCB0byBlbnF1ZXVlIG1lZGlhIHBheWxvYWQgd2l0aG91dCBjb2RlYyBpbml0aWFsaXphdGlvbiBkYXRhIHVwZnJvbnQnKTtcclxuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBudWxsLCBmYXRhbDogdHJ1ZSB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdGhpcy5hdWRpb1N3aXRjaCkge1xyXG4gICAgICAgIFtkYXRhLmRhdGExLCBkYXRhLmRhdGEyXS5mb3JFYWNoKGJ1ZmZlciA9PiB7XHJcbiAgICAgICAgICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcGVuZGluZ0RhdGEucHVzaCh7IHR5cGU6IGRhdGEudHlwZSwgZGF0YTogYnVmZmVyLCBwYXJlbnQ6ICdhdWRpbycsIGNvbnRlbnQ6ICdkYXRhJyB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWFwcGVuZE9uQnVmZmVyRmx1c2ggJiYgcGVuZGluZ0RhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICBwZW5kaW5nRGF0YS5mb3JFYWNoKGFwcGVuZE9iaiA9PiB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgYXBwZW5kIGluIFBBUlNJTkcgc3RhdGUgKHJhdGlvbmFsZSBpcyB0aGF0IGFuIGFwcGVuZGluZyBlcnJvciBjb3VsZCBoYXBwZW4gc3luY2hyb25vdXNseSBvbiBmaXJzdCBzZWdtZW50IGFwcGVuZGluZylcclxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGl0IGlzIHVzZWxlc3MgdG8gYXBwZW5kIGZvbGxvd2luZyBzZWdtZW50c1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xyXG4gICAgICAgICAgICAgIC8vIGFybSBwZW5kaW5nIEJ1ZmZlcmluZyBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgYSBzZWdtZW50XHJcbiAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIGFwcGVuZE9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YSA9IFtdO1xyXG4gICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcclxuICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkZyYWdQYXJzZWQgKGRhdGEpIHtcclxuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XHJcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcclxuICAgICAgICBkYXRhLmlkID09PSAnYXVkaW8nICYmXHJcbiAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcclxuICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxyXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcclxuICAgICAgdGhpcy5zdGF0cy50cGFyc2VkID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XHJcbiAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uQnVmZmVyUmVzZXQgKCkge1xyXG4gICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIHNvdXJjZWJ1ZmZlcnNcclxuICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcclxuICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIG9uQnVmZmVyQ3JlYXRlZCAoZGF0YSkge1xyXG4gICAgbGV0IGF1ZGlvVHJhY2sgPSBkYXRhLnRyYWNrcy5hdWRpbztcclxuICAgIGlmIChhdWRpb1RyYWNrKSB7XHJcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBhdWRpb1RyYWNrLmJ1ZmZlcjtcclxuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YS50cmFja3MudmlkZW8pIHtcclxuICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IGRhdGEudHJhY2tzLnZpZGVvLmJ1ZmZlcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uQnVmZmVyQXBwZW5kZWQgKGRhdGEpIHtcclxuICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ2F1ZGlvJykge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCBzdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIGFwcGVuZGVkXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gKGRhdGEucGVuZGluZyA+IDApO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2NoZWNrQXBwZW5kZWRQYXJzZWQgKCkge1xyXG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xyXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCAmJiAoIXRoaXMuYXBwZW5kZWQgfHwgIXRoaXMucGVuZGluZ0J1ZmZlcmluZykpIHtcclxuICAgICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50LCBzdGF0cyA9IHRoaXMuc3RhdHMsIGhscyA9IHRoaXMuaGxzO1xyXG4gICAgICBpZiAoZnJhZykge1xyXG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcclxuICAgICAgICBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZywgaWQ6ICdhdWRpbycgfSk7XHJcbiAgICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xyXG4gICAgICAgIGlmIChtZWRpYSkge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW8gYnVmZmVyZWQgOiAke1RpbWVSYW5nZXMudG9TdHJpbmcobWVkaWEuYnVmZmVyZWQpfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCAmJiB0aGlzLmFwcGVuZGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwgeyBpZDogdGhpcy50cmFja0lkIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnRpY2soKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRXJyb3IgKGRhdGEpIHtcclxuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xyXG4gICAgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gYXVkaW8gZnJhZ21lbnRcclxuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gJ2F1ZGlvJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcclxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcclxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxyXG4gICAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xyXG4gICAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBhdWRpbyBmcmFnbWVudFxyXG4gICAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdhdWRpbycpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFkYXRhLmZhdGFsKSB7XHJcbiAgICAgICAgbGV0IGxvYWRFcnJvciA9IHRoaXMuZnJhZ0xvYWRFcnJvcjtcclxuICAgICAgICBpZiAobG9hZEVycm9yKSB7XHJcbiAgICAgICAgICBsb2FkRXJyb3IrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbG9hZEVycm9yID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xyXG4gICAgICAgIGlmIChsb2FkRXJyb3IgPD0gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnkpIHtcclxuICAgICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IGxvYWRFcnJvcjtcclxuICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxyXG4gICAgICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLCBsb2FkRXJyb3IgLSAxKSAqIGNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCk7XHJcbiAgICAgICAgICBsb2dnZXIud2FybihgQXVkaW9TdHJlYW1Db250cm9sbGVyOiBmcmFnIGxvYWRpbmcgZmFpbGVkLCByZXRyeSBpbiAke2RlbGF5fSBtc2ApO1xyXG4gICAgICAgICAgdGhpcy5yZXRyeURhdGUgPSBwZXJmb3JtYW5jZS5ub3coKSArIGRlbGF5O1xyXG4gICAgICAgICAgLy8gcmV0cnkgbG9hZGluZyBzdGF0ZVxyXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYEF1ZGlvU3RyZWFtQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9IHJlYWNoZXMgbWF4IHJldHJ5LCByZWRpc3BhdGNoIGFzIGZhdGFsIC4uLmApO1xyXG4gICAgICAgICAgLy8gc3dpdGNoIGVycm9yIHRvIGZhdGFsXHJcbiAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxyXG4gICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOlxyXG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XHJcbiAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxyXG4gICAgICAvLyAgd2hlbiBpbiBFUlJPUiBzdGF0ZSwgZG9uJ3Qgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpbiBjYXNlIGEgbm9uLWZhdGFsIGVycm9yIGlzIHJlY2VpdmVkXHJcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xyXG4gICAgICAgIC8vIGlmIGZhdGFsIGVycm9yLCBzdG9wIHByb2Nlc3NpbmcsIG90aGVyd2lzZSBtb3ZlIHRvIElETEUgdG8gcmV0cnkgbG9hZGluZ1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBkYXRhLmZhdGFsID8gU3RhdGUuRVJST1IgOiBTdGF0ZS5JRExFO1xyXG4gICAgICAgIGxvZ2dlci53YXJuKGBBdWRpb1N0cmVhbUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSB3aGlsZSBsb2FkaW5nIGZyYWcsIG5vdyBzd2l0Y2hpbmcgdG8gJHt0aGlzLnN0YXRlfSBzdGF0ZSAuLi5gKTtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxyXG4gICAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcclxuICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnYXVkaW8nICYmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8wqB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpKSB7XHJcbiAgICAgICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyLFxyXG4gICAgICAgICAgY3VycmVudFRpbWUgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lLFxyXG4gICAgICAgICAgbWVkaWFCdWZmZXJlZCA9IG1lZGlhICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLCBjdXJyZW50VGltZSkgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIGN1cnJlbnRUaW1lICsgMC41KTtcclxuICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXHJcbiAgICAgICAgaWYgKG1lZGlhQnVmZmVyZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xyXG4gICAgICAgICAgaWYgKGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggPj0gY29uZmlnLm1heEJ1ZmZlckxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggYXMgaXQgbWlnaHQgYmUgdG9vIGhpZ2guIHdlIGRvIHRoaXMgdG8gYXZvaWQgbG9vcCBmbHVzaGluZyAuLi5cclxuICAgICAgICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCAvPSAyO1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihgQXVkaW9TdHJlYW1Db250cm9sbGVyOiByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJHtjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RofXNgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCwgYnV0IGJyb3dzZXIgaXMgc3RpbGwgY29tcGxhaW5pbmcgYWJvdXQgYnVmZmVyIGZ1bGwgZXJyb3JcclxuICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzcwOFxyXG4gICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBhdWRpbyBidWZmZXIgdG8gcmVjb3ZlclxyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ0F1ZGlvU3RyZWFtQ29udHJvbGxlcjogYnVmZmVyIGZ1bGwgZXJyb3IgYWxzbyBtZWRpYS5jdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGZsdXNoIGF1ZGlvIGJ1ZmZlcicpO1xyXG4gICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAvLyBmbHVzaCBldmVyeXRoaW5nXHJcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQlVGRkVSX0ZMVVNISU5HO1xyXG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIHsgc3RhcnRPZmZzZXQ6IDAsIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB0eXBlOiAnYXVkaW8nIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25CdWZmZXJGbHVzaGVkICgpIHtcclxuICAgIGxldCBwZW5kaW5nRGF0YSA9IHRoaXMucGVuZGluZ0RhdGE7XHJcbiAgICBpZiAocGVuZGluZ0RhdGEgJiYgcGVuZGluZ0RhdGEubGVuZ3RoKSB7XHJcbiAgICAgIGxvZ2dlci5sb2coJ0F1ZGlvU3RyZWFtQ29udHJvbGxlcjogYXBwZW5kaW5nIHBlbmRpbmcgYXVkaW8gZGF0YSBhZnRlciBidWZmZXIgZmx1c2hlZCcpO1xyXG4gICAgICBwZW5kaW5nRGF0YS5mb3JFYWNoKGFwcGVuZE9iaiA9PiB7XHJcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XHJcbiAgICAgIHRoaXMucGVuZGluZ0RhdGEgPSBbXTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIG1vdmUgdG8gSURMRSBvbmNlIGZsdXNoIGNvbXBsZXRlLiB0aGlzIHNob3VsZCB0cmlnZ2VyIG5ldyBmcmFnbWVudCBsb2FkaW5nXHJcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gZnJhZ1xyXG4gICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XHJcbiAgICAgIHRoaXMudGljaygpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBBdWRpb1N0cmVhbUNvbnRyb2xsZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9obHMuanMvc3JjL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJpbXBvcnQgeyBmaXhMaW5lQnJlYWtzIH0gZnJvbSAnLi92dHRwYXJzZXInO1xyXG5pbXBvcnQgeyBDYXB0aW9uU2NyZWVuLCBSb3cgfSBmcm9tICcuL2NlYS02MDgtcGFyc2VyJztcclxuXHJcbmludGVyZmFjZSBWVFRDdWUgZXh0ZW5kcyBUZXh0VHJhY2tDdWUge1xyXG4gIG5ldyhzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgY3VlVGV4dDogc3RyaW5nKTogVlRUQ3VlXHJcbiAgbGluZTogbnVtYmVyXHJcbiAgYWxpZ246IHN0cmluZ1xyXG4gIHBvc2l0aW9uOiBudW1iZXJcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5ld0N1ZSAodHJhY2s6IFRleHRUcmFjaywgc3RhcnRUaW1lOiBudW1iZXIsIGVuZFRpbWU6IG51bWJlciwgY2FwdGlvblNjcmVlbjogQ2FwdGlvblNjcmVlbikge1xyXG4gIGxldCByb3c6IFJvdztcclxuICAvLyB0aGUgdHlwZSBkYXRhIHN0YXRlcyB0aGlzIGlzIFZUVEN1ZSwgYnV0IGl0IGNhbiBwb3RlbnRpYWxseSBiZSBhIFRleHRUcmFja0N1ZSBvbiBvbGQgYnJvd3NlcnNcclxuICBsZXQgY3VlOiBWVFRDdWU7XHJcbiAgbGV0IGluZGVudGluZzogYm9vbGVhbjtcclxuICBsZXQgaW5kZW50OiBudW1iZXI7XHJcbiAgbGV0IHRleHQ6IHN0cmluZztcclxuICBsZXQgVlRUQ3VlOiBWVFRDdWUgPSAod2luZG93IGFzIGFueSkuVlRUQ3VlIGFzIFZUVEN1ZSB8fCBUZXh0VHJhY2tDdWU7XHJcblxyXG4gIGZvciAobGV0IHIgPSAwOyByIDwgY2FwdGlvblNjcmVlbi5yb3dzLmxlbmd0aDsgcisrKSB7XHJcbiAgICByb3cgPSBjYXB0aW9uU2NyZWVuLnJvd3Nbcl07XHJcbiAgICBpbmRlbnRpbmcgPSB0cnVlO1xyXG4gICAgaW5kZW50ID0gMDtcclxuICAgIHRleHQgPSAnJztcclxuXHJcbiAgICBpZiAoIXJvdy5pc0VtcHR5KCkpIHtcclxuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCByb3cuY2hhcnMubGVuZ3RoOyBjKyspIHtcclxuICAgICAgICBpZiAocm93LmNoYXJzW2NdLnVjaGFyLm1hdGNoKC9cXHMvKSAmJiBpbmRlbnRpbmcpIHtcclxuICAgICAgICAgIGluZGVudCsrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0ZXh0ICs9IHJvdy5jaGFyc1tjXS51Y2hhcjtcclxuICAgICAgICAgIGluZGVudGluZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBUbyBiZSB1c2VkIGZvciBjbGVhbmluZy11cCBvcnBoYW5lZCByb2xsLXVwIGNhcHRpb25zXHJcbiAgICAgIHJvdy5jdWVTdGFydFRpbWUgPSBzdGFydFRpbWU7XHJcblxyXG4gICAgICAvLyBHaXZlIGEgc2xpZ2h0IGJ1bXAgdG8gdGhlIGVuZFRpbWUgaWYgaXQncyBlcXVhbCB0byBzdGFydFRpbWUgdG8gYXZvaWQgYSBTeW50YXhFcnJvciBpbiBJRVxyXG4gICAgICBpZiAoc3RhcnRUaW1lID09PSBlbmRUaW1lKSB7XHJcbiAgICAgICAgZW5kVGltZSArPSAwLjAwMDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN1ZSA9IG5ldyBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCBmaXhMaW5lQnJlYWtzKHRleHQudHJpbSgpKSk7XHJcblxyXG4gICAgICBpZiAoaW5kZW50ID49IDE2KSB7XHJcbiAgICAgICAgaW5kZW50LS07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW5kZW50Kys7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFZUVEN1ZS5saW5lIGdldCdzIGZsYWtleSB3aGVuIHVzaW5nIGNvbnRyb2xzLCBzbyBsZXQncyBub3cgaW5jbHVkZSBsaW5lIDEzJjE0XHJcbiAgICAgIC8vIGFsc28sIGRyb3AgbGluZSAxIHNpbmNlIGl0J3MgdG8gY2xvc2UgdG8gdGhlIHRvcFxyXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLy8pKSB7XHJcbiAgICAgICAgY3VlLmxpbmUgPSByICsgMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdWUubGluZSA9IChyID4gNyA/IHIgLSAyIDogciArIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjdWUuYWxpZ24gPSAnbGVmdCc7XHJcbiAgICAgIC8vIENsYW1wIHRoZSBwb3NpdGlvbiBiZXR3ZWVuIDAgYW5kIDEwMCAtIGlmIG91dCBvZiB0aGVzZSBib3VuZHMsIEZpcmVmb3ggdGhyb3dzIGFuIGV4Y2VwdGlvbiBhbmQgY2FwdGlvbnMgYnJlYWtcclxuICAgICAgY3VlLnBvc2l0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCAxMDAgKiAoaW5kZW50IC8gMzIpKSk7XHJcbiAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy91dGlscy9jdWVzLnRzIiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WVFRDdWUpIHtcclxuICAgIHJldHVybiB3aW5kb3cuVlRUQ3VlO1xyXG4gIH1cclxuXHJcbiAgbGV0IGF1dG9LZXl3b3JkID0gJ2F1dG8nO1xyXG4gIGxldCBkaXJlY3Rpb25TZXR0aW5nID0ge1xyXG4gICAgJyc6IHRydWUsXHJcbiAgICBscjogdHJ1ZSxcclxuICAgIHJsOiB0cnVlXHJcbiAgfTtcclxuICBsZXQgYWxpZ25TZXR0aW5nID0ge1xyXG4gICAgc3RhcnQ6IHRydWUsXHJcbiAgICBtaWRkbGU6IHRydWUsXHJcbiAgICBlbmQ6IHRydWUsXHJcbiAgICBsZWZ0OiB0cnVlLFxyXG4gICAgcmlnaHQ6IHRydWVcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBmaW5kRGlyZWN0aW9uU2V0dGluZyAodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZGlyID0gZGlyZWN0aW9uU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcclxuICAgIHJldHVybiBkaXIgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaW5kQWxpZ25TZXR0aW5nICh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBhbGlnbiA9IGFsaWduU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcclxuICAgIHJldHVybiBhbGlnbiA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGV4dGVuZCAob2JqKSB7XHJcbiAgICBsZXQgaSA9IDE7XHJcbiAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsZXQgY29iaiA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgZm9yIChsZXQgcCBpbiBjb2JqKSB7XHJcbiAgICAgICAgb2JqW3BdID0gY29ialtwXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvYmo7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBWVFRDdWUgKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xyXG4gICAgbGV0IGN1ZSA9IHRoaXM7XHJcbiAgICBsZXQgYmFzZU9iaiA9IHt9O1xyXG5cclxuICAgIGJhc2VPYmouZW51bWVyYWJsZSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaGltIGltcGxlbWVudGF0aW9uIHNwZWNpZmljIHByb3BlcnRpZXMuIFRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBpblxyXG4gICAgICogdGhlIHNwZWMuXHJcbiAgICAgKi9cclxuXHJcbiAgICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxyXG4gICAgLy8gdG8gcmVjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlLiBUaGlzIGxldHMgdXMgY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZVxyXG4gICAgLy8gbGF6aWx5LlxyXG4gICAgY3VlLmhhc0JlZW5SZXNldCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVlRUQ3VlIGFuZCBUZXh0VHJhY2tDdWUgcHJvcGVydGllc1xyXG4gICAgICogaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2VidnR0LyN2dHRjdWUtaW50ZXJmYWNlXHJcbiAgICAgKi9cclxuXHJcbiAgICBsZXQgX2lkID0gJyc7XHJcbiAgICBsZXQgX3BhdXNlT25FeGl0ID0gZmFsc2U7XHJcbiAgICBsZXQgX3N0YXJ0VGltZSA9IHN0YXJ0VGltZTtcclxuICAgIGxldCBfZW5kVGltZSA9IGVuZFRpbWU7XHJcbiAgICBsZXQgX3RleHQgPSB0ZXh0O1xyXG4gICAgbGV0IF9yZWdpb24gPSBudWxsO1xyXG4gICAgbGV0IF92ZXJ0aWNhbCA9ICcnO1xyXG4gICAgbGV0IF9zbmFwVG9MaW5lcyA9IHRydWU7XHJcbiAgICBsZXQgX2xpbmUgPSAnYXV0byc7XHJcbiAgICBsZXQgX2xpbmVBbGlnbiA9ICdzdGFydCc7XHJcbiAgICBsZXQgX3Bvc2l0aW9uID0gNTA7XHJcbiAgICBsZXQgX3Bvc2l0aW9uQWxpZ24gPSAnbWlkZGxlJztcclxuICAgIGxldCBfc2l6ZSA9IDUwO1xyXG4gICAgbGV0IF9hbGlnbiA9ICdtaWRkbGUnO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdpZCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2lkO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIF9pZCA9ICcnICsgdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncGF1c2VPbkV4aXQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9wYXVzZU9uRXhpdDtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBfcGF1c2VPbkV4aXQgPSAhIXZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3N0YXJ0VGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3N0YXJ0VGltZTtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RhcnQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9zdGFydFRpbWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnZW5kVGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2VuZFRpbWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuZCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2VuZFRpbWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndGV4dCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3RleHQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgX3RleHQgPSAnJyArIHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdyZWdpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9yZWdpb247XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgX3JlZ2lvbiA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd2ZXJ0aWNhbCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBzZXR0aW5nID0gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpO1xyXG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICAgIGlmIChzZXR0aW5nID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfdmVydGljYWwgPSBzZXR0aW5nO1xyXG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzbmFwVG9MaW5lcycsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3NuYXBUb0xpbmVzO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIF9zbmFwVG9MaW5lcyA9ICEhdmFsdWU7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9saW5lO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIHZhbHVlICE9PSBhdXRvS2V5d29yZCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG51bWJlciBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2xpbmUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZUFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfbGluZUFsaWduO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9saW5lQWxpZ24gPSBzZXR0aW5nO1xyXG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwb3NpdGlvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zaXRpb24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwb3NpdGlvbkFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfcG9zaXRpb25BbGlnbjtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBsZXQgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xyXG4gICAgICAgIGlmICghc2V0dGluZykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfcG9zaXRpb25BbGlnbiA9IHNldHRpbmc7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NpemUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zaXplO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2l6ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3NpemUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnYWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9hbGlnbjtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBsZXQgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xyXG4gICAgICAgIGlmICghc2V0dGluZykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfYWxpZ24gPSBzZXR0aW5nO1xyXG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3RoZXIgPHRyYWNrPiBzcGVjIGRlZmluZWQgcHJvcGVydGllc1xyXG4gICAgICovXHJcblxyXG4gICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLXZpZGVvLWVsZW1lbnQuaHRtbCN0ZXh0LXRyYWNrLWN1ZS1kaXNwbGF5LXN0YXRlXHJcbiAgICBjdWUuZGlzcGxheVN0YXRlID0gdm9pZCAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVlRUQ3VlIG1ldGhvZHNcclxuICAgKi9cclxuXHJcbiAgVlRUQ3VlLnByb3RvdHlwZS5nZXRDdWVBc0hUTUwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBBc3N1bWUgV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUgaXMgb24gdGhlIGdsb2JhbC5cclxuICAgIGxldCBXZWJWVFQgPSB3aW5kb3cuV2ViVlRUO1xyXG4gICAgcmV0dXJuIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlKHdpbmRvdywgdGhpcy50ZXh0KTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gVlRUQ3VlO1xyXG59KSgpO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy91dGlscy92dHRjdWUuanMiLCJpbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IENlYTYwOFBhcnNlciwgeyBDYXB0aW9uU2NyZWVuIH0gZnJvbSAnLi4vdXRpbHMvY2VhLTYwOC1wYXJzZXInO1xyXG5pbXBvcnQgT3V0cHV0RmlsdGVyIGZyb20gJy4uL3V0aWxzL291dHB1dC1maWx0ZXInO1xyXG5pbXBvcnQgV2ViVlRUUGFyc2VyIGZyb20gJy4uL3V0aWxzL3dlYnZ0dC1wYXJzZXInO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgeyBzZW5kQWRkVHJhY2tFdmVudCwgY2xlYXJDdXJyZW50Q3VlcyB9IGZyb20gJy4uL3V0aWxzL3RleHR0cmFjay11dGlscyc7XHJcbmltcG9ydCBGcmFnbWVudCBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xyXG5pbXBvcnQgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xyXG5cclxuLy8gVFMgdG9kbzogUmVkdWNlIHVzYWdlIG9mIGFueVxyXG5jbGFzcyBUaW1lbGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xyXG4gIHByaXZhdGUgbWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIGNvbmZpZzogSGxzQ29uZmlnO1xyXG4gIHByaXZhdGUgZW5hYmxlZDogYm9vbGVhbiA9IHRydWU7XHJcbiAgcHJpdmF0ZSBDdWVzOiBhbnk7XHJcbiAgcHJpdmF0ZSB0ZXh0VHJhY2tzOiBBcnJheTxUZXh0VHJhY2s+ID0gW107XHJcbiAgcHJpdmF0ZSB0cmFja3M6IEFycmF5PGFueT4gPSBbXTtcclxuICBwcml2YXRlIGluaXRQVFM6IEFycmF5PG51bWJlcj4gPSBbXTtcclxuICBwcml2YXRlIHVucGFyc2VkVnR0RnJhZ3M6IEFycmF5PHtmcmFnOiBGcmFnbWVudCwgcGF5bG9hZDogYW55fT4gPSBbXTtcclxuICBwcml2YXRlIGN1ZVJhbmdlczogQXJyYXk8YW55PiA9IFtdO1xyXG4gIHByaXZhdGUgY2FwdGlvbnNUcmFja3M6IGFueSA9IHt9O1xyXG4gIHByaXZhdGUgY2FwdGlvbnNQcm9wZXJ0aWVzOiBhbnk7XHJcbiAgcHJpdmF0ZSBjZWE2MDhQYXJzZXIhOiBDZWE2MDhQYXJzZXI7XHJcbiAgcHJpdmF0ZSBsYXN0U246IG51bWJlciA9IC0xO1xyXG4gIHByaXZhdGUgcHJldkNDOiBudW1iZXIgPSAtMTtcclxuICBwcml2YXRlIHZ0dENDczogYW55ID0gbnVsbDtcclxuXHJcbiAgY29uc3RydWN0b3IgKGhscykge1xyXG4gICAgc3VwZXIoaGxzLCBFdmVudC5NRURJQV9BVFRBQ0hJTkcsXHJcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcclxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX1VTRVJEQVRBLFxyXG4gICAgICBFdmVudC5GUkFHX0RFQ1JZUFRFRCxcclxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcclxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BREVELFxyXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcclxuICAgICAgRXZlbnQuSU5JVF9QVFNfRk9VTkQpO1xyXG5cclxuICAgIHRoaXMuaGxzID0gaGxzO1xyXG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xyXG4gICAgdGhpcy5DdWVzID0gaGxzLmNvbmZpZy5jdWVIYW5kbGVyO1xyXG5cclxuICAgIHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzID0ge1xyXG4gICAgICB0ZXh0VHJhY2sxOiB7XHJcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhYmVsLFxyXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlXHJcbiAgICAgIH0sXHJcbiAgICAgIHRleHRUcmFjazI6IHtcclxuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwsXHJcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGVcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpIHtcclxuICAgICAgY29uc3QgY2hhbm5lbDEgPSBuZXcgT3V0cHV0RmlsdGVyKHRoaXMsICd0ZXh0VHJhY2sxJyk7XHJcbiAgICAgIGNvbnN0IGNoYW5uZWwyID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrMicpO1xyXG4gICAgICB0aGlzLmNlYTYwOFBhcnNlciA9IG5ldyBDZWE2MDhQYXJzZXIoMCwgY2hhbm5lbDEsIGNoYW5uZWwyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFkZEN1ZXMgKHRyYWNrTmFtZTogc3RyaW5nLCBzdGFydFRpbWU6IG51bWJlciwgZW5kVGltZTogbnVtYmVyLCBzY3JlZW46IENhcHRpb25TY3JlZW4pIHtcclxuICAgIC8vIHNraXAgY3VlcyB3aGljaCBvdmVybGFwIG1vcmUgdGhhbiA1MCUgd2l0aCBwcmV2aW91c2x5IHBhcnNlZCB0aW1lIHJhbmdlc1xyXG4gICAgY29uc3QgcmFuZ2VzID0gdGhpcy5jdWVSYW5nZXM7XHJcbiAgICBsZXQgbWVyZ2VkID0gZmFsc2U7XHJcbiAgICBmb3IgKGxldCBpID0gcmFuZ2VzLmxlbmd0aDsgaS0tOykge1xyXG4gICAgICBsZXQgY3VlUmFuZ2UgPSByYW5nZXNbaV07XHJcbiAgICAgIGxldCBvdmVybGFwID0gaW50ZXJzZWN0aW9uKGN1ZVJhbmdlWzBdLCBjdWVSYW5nZVsxXSwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcclxuICAgICAgaWYgKG92ZXJsYXAgPj0gMCkge1xyXG4gICAgICAgIGN1ZVJhbmdlWzBdID0gTWF0aC5taW4oY3VlUmFuZ2VbMF0sIHN0YXJ0VGltZSk7XHJcbiAgICAgICAgY3VlUmFuZ2VbMV0gPSBNYXRoLm1heChjdWVSYW5nZVsxXSwgZW5kVGltZSk7XHJcbiAgICAgICAgbWVyZ2VkID0gdHJ1ZTtcclxuICAgICAgICBpZiAoKG92ZXJsYXAgLyAoZW5kVGltZSAtIHN0YXJ0VGltZSkpID4gMC41KSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIW1lcmdlZCkge1xyXG4gICAgICByYW5nZXMucHVzaChbc3RhcnRUaW1lLCBlbmRUaW1lXSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5DdWVzLm5ld0N1ZSh0aGlzLmNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcclxuICB9XHJcblxyXG4gIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGluaXRpYWwgUFRTIGlzIGZvdW5kOyB1c2VkIGZvciBzeW5jaHJvbmlzYXRpb24gb2YgV2ViVlRULlxyXG4gIG9uSW5pdFB0c0ZvdW5kIChkYXRhOiB7IGlkOiBzdHJpbmcsIGZyYWc6IEZyYWdtZW50LCBpbml0UFRTOiBudW1iZXJ9KSB7XHJcbiAgICBjb25zdCB7IGZyYWcsIGlkLCBpbml0UFRTIH0gPSBkYXRhO1xyXG4gICAgY29uc3QgeyB1bnBhcnNlZFZ0dEZyYWdzIH0gPSB0aGlzO1xyXG4gICAgaWYgKGlkID09PSAnbWFpbicpIHtcclxuICAgICAgdGhpcy5pbml0UFRTW2ZyYWcuY2NdID0gaW5pdFBUUztcclxuICAgIH1cclxuXHJcbiAgICAvLyBEdWUgdG8gYXN5bmNocm9ub3VzIHByb2Nlc3NpbmcsIGluaXRpYWwgUFRTIG1heSBhcnJpdmUgbGF0ZXIgdGhhbiB0aGUgZmlyc3QgVlRUIGZyYWdtZW50cyBhcmUgbG9hZGVkLlxyXG4gICAgLy8gUGFyc2UgYW55IHVucGFyc2VkIGZyYWdtZW50cyB1cG9uIHJlY2VpdmluZyB0aGUgaW5pdGlhbCBQVFMuXHJcbiAgICBpZiAodW5wYXJzZWRWdHRGcmFncy5sZW5ndGgpIHtcclxuICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XHJcbiAgICAgIHVucGFyc2VkVnR0RnJhZ3MuZm9yRWFjaChmcmFnID0+IHtcclxuICAgICAgICB0aGlzLm9uRnJhZ0xvYWRlZChmcmFnKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRFeGlzdGluZ1RyYWNrICh0cmFja05hbWU6IHN0cmluZyk6IFRleHRUcmFjayB8IG51bGwge1xyXG4gICAgY29uc3QgeyBtZWRpYSB9ID0gdGhpcztcclxuICAgIGlmIChtZWRpYSkge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lZGlhLnRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgdGV4dFRyYWNrID0gbWVkaWEudGV4dFRyYWNrc1tpXTtcclxuICAgICAgICBpZiAodGV4dFRyYWNrW3RyYWNrTmFtZV0pIHtcclxuICAgICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNyZWF0ZUNhcHRpb25zVHJhY2sgKHRyYWNrTmFtZTogc3RyaW5nKSB7XHJcbiAgICBjb25zdCB7IGNhcHRpb25zUHJvcGVydGllcywgY2FwdGlvbnNUcmFja3MsIG1lZGlhIH0gPSB0aGlzO1xyXG4gICAgY29uc3QgeyBsYWJlbCwgbGFuZ3VhZ2VDb2RlIH0gPSBjYXB0aW9uc1Byb3BlcnRpZXNbdHJhY2tOYW1lXTtcclxuICAgIGlmICghY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSkge1xyXG4gICAgICAvLyBFbmFibGUgcmV1c2Ugb2YgZXhpc3RpbmcgdGV4dCB0cmFjay5cclxuICAgICAgY29uc3QgZXhpc3RpbmdUcmFjayA9IHRoaXMuZ2V0RXhpc3RpbmdUcmFjayh0cmFja05hbWUpO1xyXG4gICAgICBpZiAoIWV4aXN0aW5nVHJhY2spIHtcclxuICAgICAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLmNyZWF0ZVRleHRUcmFjaygnY2FwdGlvbnMnLCBsYWJlbCwgbGFuZ3VhZ2VDb2RlKTtcclxuICAgICAgICBpZiAodGV4dFRyYWNrKSB7XHJcbiAgICAgICAgICAvLyBTZXQgYSBzcGVjaWFsIHByb3BlcnR5IG9uIHRoZSB0cmFjayBzbyB3ZSBrbm93IGl0J3MgbWFuYWdlZCBieSBIbHMuanNcclxuICAgICAgICAgIHRleHRUcmFja1t0cmFja05hbWVdID0gdHJ1ZTtcclxuICAgICAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0ZXh0VHJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSBleGlzdGluZ1RyYWNrO1xyXG4gICAgICAgIGNsZWFyQ3VycmVudEN1ZXMoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XHJcbiAgICAgICAgc2VuZEFkZFRyYWNrRXZlbnQoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSwgbWVkaWEgYXMgSFRNTE1lZGlhRWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNyZWF0ZVRleHRUcmFjayAoa2luZDogVGV4dFRyYWNrS2luZCwgbGFiZWw6IHN0cmluZywgbGFuZzogc3RyaW5nKTogVGV4dFRyYWNrIHwgdW5kZWZpbmVkIHtcclxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcclxuICAgIGlmICghbWVkaWEpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lZGlhLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZyk7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95ICgpIHtcclxuICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICB9XHJcblxyXG4gIG9uTWVkaWFBdHRhY2hpbmcgKGRhdGE6IHsgbWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQgfSkge1xyXG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XHJcbiAgICB0aGlzLl9jbGVhblRyYWNrcygpO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYURldGFjaGluZyAoKSB7XHJcbiAgICBjb25zdCB7IGNhcHRpb25zVHJhY2tzIH0gPSB0aGlzO1xyXG4gICAgT2JqZWN0LmtleXMoY2FwdGlvbnNUcmFja3MpLmZvckVhY2godHJhY2tOYW1lID0+IHtcclxuICAgICAgY2xlYXJDdXJyZW50Q3VlcyhjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKTtcclxuICAgICAgZGVsZXRlIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIG9uTWFuaWZlc3RMb2FkaW5nICgpIHtcclxuICAgIHRoaXMubGFzdFNuID0gLTE7IC8vIERldGVjdCBkaXNjb250aWd1aXR5IGluIGZyYWdtZW50IHBhcnNpbmdcclxuICAgIHRoaXMucHJldkNDID0gLTE7XHJcbiAgICB0aGlzLnZ0dENDcyA9IHsgLy8gRGV0ZWN0IGRpc2NvbnRpbnVpdHkgaW4gc3VidGl0bGUgbWFuaWZlc3RzXHJcbiAgICAgIGNjT2Zmc2V0OiAwLFxyXG4gICAgICBwcmVzZW50YXRpb25PZmZzZXQ6IDAsXHJcbiAgICAgIDA6IHtcclxuICAgICAgICBzdGFydDogMCwgcHJldkNDOiAtMSwgbmV3OiBmYWxzZVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5fY2xlYW5UcmFja3MoKTtcclxuICB9XHJcblxyXG4gIF9jbGVhblRyYWNrcyAoKSB7XHJcbiAgICAvLyBjbGVhciBvdXRkYXRlZCBzdWJ0aXRsZXNcclxuICAgIGNvbnN0IHsgbWVkaWEgfSA9IHRoaXM7XHJcbiAgICBpZiAoIW1lZGlhKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHRleHRUcmFja3MgPSBtZWRpYS50ZXh0VHJhY2tzO1xyXG4gICAgaWYgKHRleHRUcmFja3MpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2xlYXJDdXJyZW50Q3Vlcyh0ZXh0VHJhY2tzW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25NYW5pZmVzdExvYWRlZCAoZGF0YTogeyBzdWJ0aXRsZXM6IEFycmF5PGFueT4gfSkge1xyXG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XHJcbiAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgfHwgW107XHJcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcclxuICAgIHRoaXMuY3VlUmFuZ2VzID0gW107XHJcblxyXG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZVdlYlZUVCkge1xyXG4gICAgICB0aGlzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVzIHx8IFtdO1xyXG4gICAgICBjb25zdCBpblVzZVRyYWNrcyA9IHRoaXMubWVkaWEgPyB0aGlzLm1lZGlhLnRleHRUcmFja3MgOiBbXTtcclxuXHJcbiAgICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHRyYWNrLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGxldCB0ZXh0VHJhY2s7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgaW5Vc2VUcmFja3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICBsZXQgaW5Vc2VUcmFjazogVGV4dFRyYWNrIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpblVzZVRyYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY2FuUmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFja3NbaV0sIHRyYWNrKSkge1xyXG4gICAgICAgICAgICAgIGluVXNlVHJhY2sgPSBpblVzZVRyYWNrc1tpXTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJldXNlIHRyYWNrcyB3aXRoIHRoZSBzYW1lIGxhYmVsLCBidXQgZG8gbm90IHJldXNlIDYwOC83MDggdHJhY2tzXHJcbiAgICAgICAgICBpZiAoaW5Vc2VUcmFjaykge1xyXG4gICAgICAgICAgICB0ZXh0VHJhY2sgPSBpblVzZVRyYWNrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRleHRUcmFjaykge1xyXG4gICAgICAgICAgdGV4dFRyYWNrID0gdGhpcy5jcmVhdGVUZXh0VHJhY2soJ3N1YnRpdGxlcycsIHRyYWNrLm5hbWUsIHRyYWNrLmxhbmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRyYWNrLmRlZmF1bHQpIHtcclxuICAgICAgICAgIHRleHRUcmFjay5tb2RlID0gdGhpcy5obHMuc3VidGl0bGVEaXNwbGF5ID8gJ3Nob3dpbmcnIDogJ2hpZGRlbic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRleHRUcmFjay5tb2RlID0gJ2Rpc2FibGVkJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudGV4dFRyYWNrcy5wdXNoKHRleHRUcmFjayk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25GcmFnTG9hZGVkIChkYXRhOiB7IGZyYWc6IEZyYWdtZW50LCBwYXlsb2FkOiBhbnkgfSkge1xyXG4gICAgY29uc3QgeyBmcmFnLCBwYXlsb2FkIH0gPSBkYXRhO1xyXG4gICAgY29uc3QgeyBjZWE2MDhQYXJzZXIsIGluaXRQVFMsIGxhc3RTbiwgdW5wYXJzZWRWdHRGcmFncyB9ID0gdGhpcztcclxuICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJykge1xyXG4gICAgICBjb25zdCBzbiA9IGZyYWcuc247XHJcbiAgICAgIC8vIGlmIHRoaXMgZnJhZyBpc24ndCBjb250aWd1b3VzLCBjbGVhciB0aGUgcGFyc2VyIHNvIGN1ZXMgd2l0aCBiYWQgc3RhcnQvZW5kIHRpbWVzIGFyZW4ndCBhZGRlZCB0byB0aGUgdGV4dFRyYWNrXHJcbiAgICAgIGlmIChmcmFnLnNuICE9PSBsYXN0U24gKyAxKSB7XHJcbiAgICAgICAgaWYgKGNlYTYwOFBhcnNlcikge1xyXG4gICAgICAgICAgY2VhNjA4UGFyc2VyLnJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubGFzdFNuID0gc24gYXMgbnVtYmVyO1xyXG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJyYWNlLXN0eWxlXHJcbiAgICAvLyBJZiBmcmFnbWVudCBpcyBzdWJ0aXRsZSB0eXBlLCBwYXJzZSBhcyBXZWJWVFQuXHJcbiAgICBlbHNlIGlmIChmcmFnLnR5cGUgPT09ICdzdWJ0aXRsZScpIHtcclxuICAgICAgaWYgKHBheWxvYWQuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIC8vIFdlIG5lZWQgYW4gaW5pdGlhbCBzeW5jaHJvbmlzYXRpb24gUFRTLiBTdG9yZSBmcmFnbWVudHMgYXMgbG9uZyBhcyBub25lIGhhcyBhcnJpdmVkLlxyXG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGluaXRQVFNbZnJhZy5jY10pKSB7XHJcbiAgICAgICAgICB1bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICBpZiAoaW5pdFBUUy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gZmluaXNoIHVuc3VjY2Vzc2Z1bGx5LCBvdGhlcndpc2UgdGhlIHN1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyIGNvdWxkIGJlIGJsb2NrZWQgZnJvbSBsb2FkaW5nIG5ldyBmcmFncy5cclxuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZyB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBkZWNyeXB0RGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XHJcbiAgICAgICAgLy8gSWYgdGhlIHN1YnRpdGxlcyBhcmUgbm90IGVuY3J5cHRlZCwgcGFyc2UgVlRUcyBub3cuIE90aGVyd2lzZSwgd2UgbmVlZCB0byB3YWl0LlxyXG4gICAgICAgIGlmICgoZGVjcnlwdERhdGEgPT0gbnVsbCkgfHwgKGRlY3J5cHREYXRhLmtleSA9PSBudWxsKSB8fCAoZGVjcnlwdERhdGEubWV0aG9kICE9PSAnQUVTLTEyOCcpKSB7XHJcbiAgICAgICAgICB0aGlzLl9wYXJzZVZUVHMoZnJhZywgcGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbm8gcGF5bG9hZCwgZmluaXNoIHVuc3VjY2Vzc2Z1bGx5LlxyXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHsgc3VjY2VzczogZmFsc2UsIGZyYWcgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9wYXJzZVZUVHMgKGZyYWc6IEZyYWdtZW50LCBwYXlsb2FkKSB7XHJcbiAgICBjb25zdCB7IGhscywgcHJldkNDLCB0ZXh0VHJhY2tzLCB2dHRDQ3MgfSA9IHRoaXM7XHJcbiAgICBpZiAoIXZ0dENDc1tmcmFnLmNjXSkge1xyXG4gICAgICB2dHRDQ3NbZnJhZy5jY10gPSB7IHN0YXJ0OiBmcmFnLnN0YXJ0LCBwcmV2Q0MsIG5ldzogdHJ1ZSB9O1xyXG4gICAgICB0aGlzLnByZXZDQyA9IGZyYWcuY2M7XHJcbiAgICB9XHJcbiAgICAvLyBQYXJzZSB0aGUgV2ViVlRUIGZpbGUgY29udGVudHMuXHJcbiAgICBXZWJWVFRQYXJzZXIucGFyc2UocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCB2dHRDQ3MsIGZyYWcuY2MsIGZ1bmN0aW9uIChjdWVzKSB7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRleHRUcmFja3NbZnJhZy5sZXZlbF07XHJcbiAgICAgIC8vIFdlYlZUVFBhcnNlci5wYXJzZSBpcyBhbiBhc3luYyBtZXRob2QgYW5kIGlmIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dCB0cmFjayBtb2RlIGlzIHNldCB0byBcImRpc2FibGVkXCJcclxuICAgICAgLy8gYmVmb3JlIHBhcnNpbmcgaXMgZG9uZSB0aGVuIGRvbid0IHRyeSB0byBhY2Nlc3MgY3VycmVudFRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZCBhcyBjdWVzIHdpbGwgYmUgbnVsbFxyXG4gICAgICAvLyBhbmQgdHJ5aW5nIHRvIGFjY2VzcyBnZXRDdWVCeUlkIG1ldGhvZCBvZiBjdWVzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uXHJcbiAgICAgIGlmIChjdXJyZW50VHJhY2subW9kZSA9PT0gJ2Rpc2FibGVkJykge1xyXG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7IHN1Y2Nlc3M6IGZhbHNlLCBmcmFnOiBmcmFnIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICAvLyBBZGQgY3VlcyBhbmQgdHJpZ2dlciBldmVudCB3aXRoIHN1Y2Nlc3MgdHJ1ZS5cclxuICAgICAgY3Vlcy5mb3JFYWNoKGN1ZSA9PiB7XHJcbiAgICAgICAgLy8gU29tZXRpbWVzIHRoZXJlIGFyZSBjdWUgb3ZlcmxhcHMgb24gc2VnbWVudGVkIHZ0dHMgc28gdGhlIHNhbWVcclxuICAgICAgICAvLyBjdWUgY2FuIGFwcGVhciBtb3JlIHRoYW4gb25jZSBpbiBkaWZmZXJlbnQgdnR0IGZpbGVzLlxyXG4gICAgICAgIC8vIFRoaXMgYXZvaWQgc2hvd2luZyBkdXBsaWNhdGVkIGN1ZXMgd2l0aCBzYW1lIHRpbWVjb2RlIGFuZCB0ZXh0LlxyXG4gICAgICAgIGlmICghY3VycmVudFRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjdXJyZW50VHJhY2suYWRkQ3VlKGN1ZSk7XHJcbiAgICAgICAgICAgIGlmICghY3VycmVudFRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhZGRDdWUgaXMgZmFpbGVkIGZvcjogJHtjdWV9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYEZhaWxlZCBvY2N1cnJlZCBvbiBhZGRpbmcgY3VlczogJHtlcnJ9YCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHRUcmFja0N1ZSA9IG5ldyAod2luZG93IGFzIGFueSkuVGV4dFRyYWNrQ3VlKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCBjdWUudGV4dCk7XHJcbiAgICAgICAgICAgIHRleHRUcmFja0N1ZS5pZCA9IGN1ZS5pZDtcclxuICAgICAgICAgICAgY3VycmVudFRyYWNrLmFkZEN1ZSh0ZXh0VHJhY2tDdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiB0cnVlLCBmcmFnOiBmcmFnIH0pO1xyXG4gICAgfSxcclxuICAgIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHBhcnNpbmcuIFRyaWdnZXIgZXZlbnQgd2l0aCBzdWNjZXNzIGZhbHNlLlxyXG4gICAgICBsb2dnZXIubG9nKGBGYWlsZWQgdG8gcGFyc2UgVlRUIGN1ZTogJHtlfWApO1xyXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgb25GcmFnRGVjcnlwdGVkIChkYXRhOiB7IGZyYWc6IEZyYWdtZW50LCBwYXlsb2FkOiBhbnl9KSB7XHJcbiAgICBjb25zdCB7IGZyYWcsIHBheWxvYWQgfSA9IGRhdGE7XHJcbiAgICBpZiAoZnJhZy50eXBlID09PSAnc3VidGl0bGUnKSB7XHJcbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHRoaXMuaW5pdFBUU1tmcmFnLmNjXSkpIHtcclxuICAgICAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX3BhcnNlVlRUcyhmcmFnLCBwYXlsb2FkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRnJhZ1BhcnNpbmdVc2VyZGF0YSAoZGF0YTogeyBzYW1wbGVzOiBBcnJheTxhbnk+IH0pIHtcclxuICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICF0aGlzLmNlYTYwOFBhcnNlcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIGV2ZW50IGNvbnRhaW5zIGNhcHRpb25zIChmb3VuZCBpbiB0aGUgYnl0ZXMgcHJvcGVydHkpLCBwdXNoIGFsbCBieXRlcyBpbnRvIHRoZSBwYXJzZXIgaW1tZWRpYXRlbHlcclxuICAgIC8vIEl0IHdpbGwgY3JlYXRlIHRoZSBwcm9wZXIgdGltZXN0YW1wcyBiYXNlZCBvbiB0aGUgUFRTIHZhbHVlXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuc2FtcGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBjY0J5dGVzID0gZGF0YS5zYW1wbGVzW2ldLmJ5dGVzO1xyXG4gICAgICBpZiAoY2NCeXRlcykge1xyXG4gICAgICAgIGNvbnN0IGNjZGF0YXMgPSB0aGlzLmV4dHJhY3RDZWE2MDhEYXRhKGNjQnl0ZXMpO1xyXG4gICAgICAgIHRoaXMuY2VhNjA4UGFyc2VyLmFkZERhdGEoZGF0YS5zYW1wbGVzW2ldLnB0cywgY2NkYXRhcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV4dHJhY3RDZWE2MDhEYXRhIChieXRlQXJyYXk6IFVpbnQ4QXJyYXkpOiBBcnJheTxudW1iZXI+IHtcclxuICAgIGxldCBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDMxO1xyXG4gICAgbGV0IHBvc2l0aW9uID0gMjtcclxuICAgIGxldCB0bXBCeXRlLCBjY2J5dGUxLCBjY2J5dGUyLCBjY1ZhbGlkLCBjY1R5cGU7XHJcbiAgICBsZXQgYWN0dWFsQ0NCeXRlczogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcclxuICAgICAgdG1wQnl0ZSA9IGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcclxuICAgICAgY2NieXRlMSA9IDB4N0YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XHJcbiAgICAgIGNjYnl0ZTIgPSAweDdGICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xyXG4gICAgICBjY1ZhbGlkID0gKDQgJiB0bXBCeXRlKSAhPT0gMDtcclxuICAgICAgY2NUeXBlID0gMyAmIHRtcEJ5dGU7XHJcblxyXG4gICAgICBpZiAoY2NieXRlMSA9PT0gMCAmJiBjY2J5dGUyID09PSAwKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjY1ZhbGlkKSB7XHJcbiAgICAgICAgaWYgKGNjVHlwZSA9PT0gMCkgeyAvLyB8fCBjY1R5cGUgPT09IDFcclxuICAgICAgICAgIGFjdHVhbENDQnl0ZXMucHVzaChjY2J5dGUxKTtcclxuICAgICAgICAgIGFjdHVhbENDQnl0ZXMucHVzaChjY2J5dGUyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhY3R1YWxDQ0J5dGVzO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2FuUmV1c2VWdHRUZXh0VHJhY2sgKGluVXNlVHJhY2ssIG1hbmlmZXN0VHJhY2spOiBib29sZWFuIHtcclxuICByZXR1cm4gaW5Vc2VUcmFjayAmJiBpblVzZVRyYWNrLmxhYmVsID09PSBtYW5pZmVzdFRyYWNrLm5hbWUgJiYgIShpblVzZVRyYWNrLnRleHRUcmFjazEgfHwgaW5Vc2VUcmFjay50ZXh0VHJhY2syKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uICh4MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MTogbnVtYmVyLCB5MjogbnVtYmVyKTogbnVtYmVyIHtcclxuICByZXR1cm4gTWF0aC5taW4oeDIsIHkyKSAtIE1hdGgubWF4KHgxLCB5MSk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRpbWVsaW5lQ29udHJvbGxlcjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyLnRzIiwiaW1wb3J0IE91dHB1dEZpbHRlciBmcm9tICcuL291dHB1dC1maWx0ZXInO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIFRoaXMgY29kZSB3YXMgcG9ydGVkIGZyb20gdGhlIGRhc2guanMgcHJvamVjdCBhdDpcclxuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2Jsb2IvZGV2ZWxvcG1lbnQvZXh0ZXJuYWxzL2NlYTYwOC1wYXJzZXIuanNcclxuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2NvbW1pdC84MjY5YjI2YTc2MWUwODUzYmIyMWQ3ODc4MGVkOTQ1MTQ0ZWNkZDRkI2RpZmYtNzFiYzI5NWEyZDZiNmI3MDkzYTFkMzI5MGQ1M2E0YjJcclxuICpcclxuICogVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBhcHBlYXJzIGJlbG93OlxyXG4gKlxyXG4gKiBUaGUgY29weXJpZ2h0IGluIHRoaXMgc29mdHdhcmUgaXMgYmVpbmcgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLFxyXG4gKiBpbmNsdWRlZCBiZWxvdy4gVGhpcyBzb2Z0d2FyZSBtYXkgYmUgc3ViamVjdCB0byBvdGhlciB0aGlyZCBwYXJ0eSBhbmQgY29udHJpYnV0b3JcclxuICogcmlnaHRzLCBpbmNsdWRpbmcgcGF0ZW50IHJpZ2h0cywgYW5kIG5vIHN1Y2ggcmlnaHRzIGFyZSBncmFudGVkIHVuZGVyIHRoaXMgbGljZW5zZS5cclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYsIERBU0ggSW5kdXN0cnkgRm9ydW0uXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xyXG4gKiAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yXHJcbiAqICBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAgMi4gTmVpdGhlciB0aGUgbmFtZSBvZiBEYXNoIEluZHVzdHJ5IEZvcnVtIG5vciB0aGUgbmFtZXMgb2YgaXRzXHJcbiAqICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXHJcbiAqICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgQVMgSVMgQU5EIEFOWVxyXG4gKiAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxyXG4gKiAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELlxyXG4gKiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcclxuICogIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVRcclxuICogIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLFxyXG4gKiAgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxyXG4gKiAgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcclxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuLyoqXHJcbiAgICAgKiAgRXhjZXB0aW9ucyBmcm9tIHJlZ3VsYXIgQVNDSUkuIENvZGVQb2ludHMgYXJlIG1hcHBlZCB0byBVVEYtMTYgY29kZXNcclxuICAgICAqL1xyXG5cclxubGV0IHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzID0ge1xyXG4gIDB4MmE6IDB4ZTEsIC8vIGxvd2VyY2FzZSBhLCBhY3V0ZSBhY2NlbnRcclxuICAweDVjOiAweGU5LCAvLyBsb3dlcmNhc2UgZSwgYWN1dGUgYWNjZW50XHJcbiAgMHg1ZTogMHhlZCwgLy8gbG93ZXJjYXNlIGksIGFjdXRlIGFjY2VudFxyXG4gIDB4NWY6IDB4ZjMsIC8vIGxvd2VyY2FzZSBvLCBhY3V0ZSBhY2NlbnRcclxuICAweDYwOiAweGZhLCAvLyBsb3dlcmNhc2UgdSwgYWN1dGUgYWNjZW50XHJcbiAgMHg3YjogMHhlNywgLy8gbG93ZXJjYXNlIGMgd2l0aCBjZWRpbGxhXHJcbiAgMHg3YzogMHhmNywgLy8gZGl2aXNpb24gc3ltYm9sXHJcbiAgMHg3ZDogMHhkMSwgLy8gdXBwZXJjYXNlIE4gdGlsZGVcclxuICAweDdlOiAweGYxLCAvLyBsb3dlcmNhc2UgbiB0aWxkZVxyXG4gIDB4N2Y6IDB4MjU4OCwgLy8gRnVsbCBibG9ja1xyXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXHJcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDExIEFORCBMT1cgQkVUV0VFTiAweDMwIEFORCAweDNGXHJcbiAgLy8gVEhJUyBNRUFOUyBUSEFUIFxceDUwIE1VU1QgQkUgQURERUQgVE8gVEhFIFZBTFVFU1xyXG4gIDB4ODA6IDB4YWUsIC8vIFJlZ2lzdGVyZWQgc3ltYm9sIChSKVxyXG4gIDB4ODE6IDB4YjAsIC8vIGRlZ3JlZSBzaWduXHJcbiAgMHg4MjogMHhiZCwgLy8gMS8yIHN5bWJvbFxyXG4gIDB4ODM6IDB4YmYsIC8vIEludmVydGVkIChvcGVuKSBxdWVzdGlvbiBtYXJrXHJcbiAgMHg4NDogMHgyMTIyLCAvLyBUcmFkZW1hcmsgc3ltYm9sIChUTSlcclxuICAweDg1OiAweGEyLCAvLyBDZW50cyBzeW1ib2xcclxuICAweDg2OiAweGEzLCAvLyBQb3VuZHMgc3RlcmxpbmdcclxuICAweDg3OiAweDI2NmEsIC8vIE11c2ljIDgndGggbm90ZVxyXG4gIDB4ODg6IDB4ZTAsIC8vIGxvd2VyY2FzZSBhLCBncmF2ZSBhY2NlbnRcclxuICAweDg5OiAweDIwLCAvLyB0cmFuc3BhcmVudCBzcGFjZSAocmVndWxhcilcclxuICAweDhhOiAweGU4LCAvLyBsb3dlcmNhc2UgZSwgZ3JhdmUgYWNjZW50XHJcbiAgMHg4YjogMHhlMiwgLy8gbG93ZXJjYXNlIGEsIGNpcmN1bWZsZXggYWNjZW50XHJcbiAgMHg4YzogMHhlYSwgLy8gbG93ZXJjYXNlIGUsIGNpcmN1bWZsZXggYWNjZW50XHJcbiAgMHg4ZDogMHhlZSwgLy8gbG93ZXJjYXNlIGksIGNpcmN1bWZsZXggYWNjZW50XHJcbiAgMHg4ZTogMHhmNCwgLy8gbG93ZXJjYXNlIG8sIGNpcmN1bWZsZXggYWNjZW50XHJcbiAgMHg4ZjogMHhmYiwgLy8gbG93ZXJjYXNlIHUsIGNpcmN1bWZsZXggYWNjZW50XHJcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcclxuICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTIgQU5EIExPVyBCRVRXRUVOIDB4MjAgQU5EIDB4M0ZcclxuICAweDkwOiAweGMxLCAvLyBjYXBpdGFsIGxldHRlciBBIHdpdGggYWN1dGVcclxuICAweDkxOiAweGM5LCAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggYWN1dGVcclxuICAweDkyOiAweGQzLCAvLyBjYXBpdGFsIGxldHRlciBPIHdpdGggYWN1dGVcclxuICAweDkzOiAweGRhLCAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggYWN1dGVcclxuICAweDk0OiAweGRjLCAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggZGlhcmVzaXNcclxuICAweDk1OiAweGZjLCAvLyBsb3dlcmNhc2UgbGV0dGVyIFUgd2l0aCBkaWFlcmVzaXNcclxuICAweDk2OiAweDIwMTgsIC8vIG9wZW5pbmcgc2luZ2xlIHF1b3RlXHJcbiAgMHg5NzogMHhhMSwgLy8gaW52ZXJ0ZWQgZXhjbGFtYXRpb24gbWFya1xyXG4gIDB4OTg6IDB4MmEsIC8vIGFzdGVyaXNrXHJcbiAgMHg5OTogMHgyMDE5LCAvLyBjbG9zaW5nIHNpbmdsZSBxdW90ZVxyXG4gIDB4OWE6IDB4MjUwMSwgLy8gYm94IGRyYXdpbmdzIGhlYXZ5IGhvcml6b250YWxcclxuICAweDliOiAweGE5LCAvLyBjb3B5cmlnaHQgc2lnblxyXG4gIDB4OWM6IDB4MjEyMCwgLy8gU2VydmljZSBtYXJrXHJcbiAgMHg5ZDogMHgyMDIyLCAvLyAocm91bmQpIGJ1bGxldFxyXG4gIDB4OWU6IDB4MjAxYywgLy8gTGVmdCBkb3VibGUgcXVvdGF0aW9uIG1hcmtcclxuICAweDlmOiAweDIwMWQsIC8vIFJpZ2h0IGRvdWJsZSBxdW90YXRpb24gbWFya1xyXG4gIDB4YTA6IDB4YzAsIC8vIHVwcGVyY2FzZSBBLCBncmF2ZSBhY2NlbnRcclxuICAweGExOiAweGMyLCAvLyB1cHBlcmNhc2UgQSwgY2lyY3VtZmxleFxyXG4gIDB4YTI6IDB4YzcsIC8vIHVwcGVyY2FzZSBDIHdpdGggY2VkaWxsYVxyXG4gIDB4YTM6IDB4YzgsIC8vIHVwcGVyY2FzZSBFLCBncmF2ZSBhY2NlbnRcclxuICAweGE0OiAweGNhLCAvLyB1cHBlcmNhc2UgRSwgY2lyY3VtZmxleFxyXG4gIDB4YTU6IDB4Y2IsIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBkaWFyZXNpc1xyXG4gIDB4YTY6IDB4ZWIsIC8vIGxvd2VyY2FzZSBsZXR0ZXIgZSB3aXRoIGRpYXJlc2lzXHJcbiAgMHhhNzogMHhjZSwgLy8gdXBwZXJjYXNlIEksIGNpcmN1bWZsZXhcclxuICAweGE4OiAweGNmLCAvLyB1cHBlcmNhc2UgSSwgd2l0aCBkaWFyZXNpc1xyXG4gIDB4YTk6IDB4ZWYsIC8vIGxvd2VyY2FzZSBpLCB3aXRoIGRpYXJlc2lzXHJcbiAgMHhhYTogMHhkNCwgLy8gdXBwZXJjYXNlIE8sIGNpcmN1bWZsZXhcclxuICAweGFiOiAweGQ5LCAvLyB1cHBlcmNhc2UgVSwgZ3JhdmUgYWNjZW50XHJcbiAgMHhhYzogMHhmOSwgLy8gbG93ZXJjYXNlIHUsIGdyYXZlIGFjY2VudFxyXG4gIDB4YWQ6IDB4ZGIsIC8vIHVwcGVyY2FzZSBVLCBjaXJjdW1mbGV4XHJcbiAgMHhhZTogMHhhYiwgLy8gbGVmdC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcclxuICAweGFmOiAweGJiLCAvLyByaWdodC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcclxuICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xyXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMyBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxyXG4gIDB4YjA6IDB4YzMsIC8vIFVwcGVyY2FzZSBBLCB0aWxkZVxyXG4gIDB4YjE6IDB4ZTMsIC8vIExvd2VyY2FzZSBhLCB0aWxkZVxyXG4gIDB4YjI6IDB4Y2QsIC8vIFVwcGVyY2FzZSBJLCBhY3V0ZSBhY2NlbnRcclxuICAweGIzOiAweGNjLCAvLyBVcHBlcmNhc2UgSSwgZ3JhdmUgYWNjZW50XHJcbiAgMHhiNDogMHhlYywgLy8gTG93ZXJjYXNlIGksIGdyYXZlIGFjY2VudFxyXG4gIDB4YjU6IDB4ZDIsIC8vIFVwcGVyY2FzZSBPLCBncmF2ZSBhY2NlbnRcclxuICAweGI2OiAweGYyLCAvLyBMb3dlcmNhc2UgbywgZ3JhdmUgYWNjZW50XHJcbiAgMHhiNzogMHhkNSwgLy8gVXBwZXJjYXNlIE8sIHRpbGRlXHJcbiAgMHhiODogMHhmNSwgLy8gTG93ZXJjYXNlIG8sIHRpbGRlXHJcbiAgMHhiOTogMHg3YiwgLy8gT3BlbiBjdXJseSBicmFjZVxyXG4gIDB4YmE6IDB4N2QsIC8vIENsb3NpbmcgY3VybHkgYnJhY2VcclxuICAweGJiOiAweDVjLCAvLyBCYWNrc2xhc2hcclxuICAweGJjOiAweDVlLCAvLyBDYXJldFxyXG4gIDB4YmQ6IDB4NWYsIC8vIFVuZGVyc2NvcmVcclxuICAweGJlOiAweDdjLCAvLyBQaXBlICh2ZXJ0aWNhbCBsaW5lKVxyXG4gIDB4YmY6IDB4MjIzYywgLy8gVGlsZGUgb3BlcmF0b3JcclxuICAweGMwOiAweGM0LCAvLyBVcHBlcmNhc2UgQSwgdW1sYXV0XHJcbiAgMHhjMTogMHhlNCwgLy8gTG93ZXJjYXNlIEEsIHVtbGF1dFxyXG4gIDB4YzI6IDB4ZDYsIC8vIFVwcGVyY2FzZSBPLCB1bWxhdXRcclxuICAweGMzOiAweGY2LCAvLyBMb3dlcmNhc2UgbywgdW1sYXV0XHJcbiAgMHhjNDogMHhkZiwgLy8gRXNzemV0dCAoc2hhcnAgUylcclxuICAweGM1OiAweGE1LCAvLyBZZW4gc3ltYm9sXHJcbiAgMHhjNjogMHhhNCwgLy8gR2VuZXJpYyBjdXJyZW5jeSBzaWduXHJcbiAgMHhjNzogMHgyNTAzLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdmVydGljYWxcclxuICAweGM4OiAweGM1LCAvLyBVcHBlcmNhc2UgQSwgcmluZ1xyXG4gIDB4Yzk6IDB4ZTUsIC8vIExvd2VyY2FzZSBBLCByaW5nXHJcbiAgMHhjYTogMHhkOCwgLy8gVXBwZXJjYXNlIE8sIHN0cm9rZVxyXG4gIDB4Y2I6IDB4ZjgsIC8vIExvd2VyY2FzZSBvLCBzdHJva1xyXG4gIDB4Y2M6IDB4MjUwZiwgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIHJpZ2h0XHJcbiAgMHhjZDogMHgyNTEzLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgbGVmdFxyXG4gIDB4Y2U6IDB4MjUxNywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCByaWdodFxyXG4gIDB4Y2Y6IDB4MjUxYiAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIGxlZnRcclxufTtcclxuXHJcbi8qKlxyXG4gKiBVdGlsc1xyXG4gKi9cclxubGV0IGdldENoYXJGb3JCeXRlID0gZnVuY3Rpb24gKGJ5dGU6IG51bWJlcikge1xyXG4gIGxldCBjaGFyQ29kZSA9IGJ5dGU7XHJcbiAgaWYgKHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzLmhhc093blByb3BlcnR5KGJ5dGUpKSB7XHJcbiAgICBjaGFyQ29kZSA9IHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzW2J5dGVdO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xyXG59O1xyXG5cclxubGV0IE5SX1JPV1MgPSAxNSxcclxuICBOUl9DT0xTID0gMTAwO1xyXG4vLyBUYWJsZXMgdG8gbG9vayB1cCByb3cgZnJvbSBQQUMgZGF0YVxyXG5sZXQgcm93c0xvd0NoMSA9IHsgMHgxMTogMSwgMHgxMjogMywgMHgxNTogNSwgMHgxNjogNywgMHgxNzogOSwgMHgxMDogMTEsIDB4MTM6IDEyLCAweDE0OiAxNCB9O1xyXG5sZXQgcm93c0hpZ2hDaDEgPSB7IDB4MTE6IDIsIDB4MTI6IDQsIDB4MTU6IDYsIDB4MTY6IDgsIDB4MTc6IDEwLCAweDEzOiAxMywgMHgxNDogMTUgfTtcclxubGV0IHJvd3NMb3dDaDIgPSB7IDB4MTk6IDEsIDB4MUE6IDMsIDB4MUQ6IDUsIDB4MUU6IDcsIDB4MUY6IDksIDB4MTg6IDExLCAweDFCOiAxMiwgMHgxQzogMTQgfTtcclxubGV0IHJvd3NIaWdoQ2gyID0geyAweDE5OiAyLCAweDFBOiA0LCAweDFEOiA2LCAweDFFOiA4LCAweDFGOiAxMCwgMHgxQjogMTMsIDB4MUM6IDE1IH07XHJcblxyXG5sZXQgYmFja2dyb3VuZENvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICdibGFjaycsICd0cmFuc3BhcmVudCddO1xyXG5cclxuZW51bSBWZXJib3NlRmlsdGVyIHtcclxuICBFUlJPUiA9IDAsXHJcbiAgVEVYVCA9IDEsXHJcbiAgV0FSTklORyA9IDIsXHJcbiAgSU5GTyA9IDIsXHJcbiAgREVCVUcgPSAzLFxyXG4gIERBVEEgPSAzLFxyXG59XHJcblxyXG4vKipcclxuICogU2ltcGxlIGxvZ2dlciBjbGFzcyB0byBiZSBhYmxlIHRvIHdyaXRlIHdpdGggdGltZS1zdGFtcHMgYW5kIGZpbHRlciBvbiBsZXZlbC5cclxuICovXHJcbmxldCBsb2dnZXI6IHtcclxuICB2ZXJib3NlRmlsdGVyOiB7XHJcbiAgICAnREFUQSc6IFZlcmJvc2VGaWx0ZXIuREFUQTtcclxuICAgICdERUJVRyc6IFZlcmJvc2VGaWx0ZXIuREVCVUc7XHJcbiAgICAnSU5GTyc6IFZlcmJvc2VGaWx0ZXIuSU5GTztcclxuICAgICdXQVJOSU5HJzogVmVyYm9zZUZpbHRlci5XQVJOSU5HO1xyXG4gICAgJ1RFWFQnOiBWZXJib3NlRmlsdGVyLlRFWFQ7XHJcbiAgICAnRVJST1InOiBWZXJib3NlRmlsdGVyLkVSUk9SO1xyXG4gIH0sXHJcbiAgdGltZTogbnVtYmVyIHwgbnVsbFxyXG4gIHZlcmJvc2VMZXZlbDogVmVyYm9zZUZpbHRlcixcclxuICBzZXRUaW1lOiAobmV3VGltZTogbnVtYmVyIHwgbnVsbCkgPT4gdm9pZCxcclxuICBsb2c6IChzZXZlcml0eToga2V5b2YgdHlwZW9mIFZlcmJvc2VGaWx0ZXIsIG1zZzogc3RyaW5nKSA9PiB2b2lkLFxyXG59ID0ge1xyXG4gIHZlcmJvc2VGaWx0ZXI6IHsgJ0RBVEEnOiAzLCAnREVCVUcnOiAzLCAnSU5GTyc6IDIsICdXQVJOSU5HJzogMiwgJ1RFWFQnOiAxLCAnRVJST1InOiAwIH0sXHJcbiAgdGltZTogbnVsbCxcclxuICB2ZXJib3NlTGV2ZWw6IDAsIC8vIE9ubHkgd3JpdGUgZXJyb3JzXHJcbiAgc2V0VGltZTogZnVuY3Rpb24gKG5ld1RpbWUpIHtcclxuICAgIHRoaXMudGltZSA9IG5ld1RpbWU7XHJcbiAgfSxcclxuICBsb2c6IGZ1bmN0aW9uIChzZXZlcml0eSwgbXNnKSB7XHJcbiAgICBsZXQgbWluTGV2ZWwgPSB0aGlzLnZlcmJvc2VGaWx0ZXJbc2V2ZXJpdHldO1xyXG4gICAgaWYgKHRoaXMudmVyYm9zZUxldmVsID49IG1pbkxldmVsKSB7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMudGltZSArICcgWycgKyBzZXZlcml0eSArICddICcgKyBtc2cpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmxldCBudW1BcnJheVRvSGV4QXJyYXkgPSBmdW5jdGlvbiAobnVtQXJyYXk6IG51bWJlcltdKTogc3RyaW5nW10ge1xyXG4gIGxldCBoZXhBcnJheTogc3RyaW5nW10gPSBbXTtcclxuICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUFycmF5Lmxlbmd0aDsgaisrKSB7XHJcbiAgICBoZXhBcnJheS5wdXNoKG51bUFycmF5W2pdLnRvU3RyaW5nKDE2KSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaGV4QXJyYXk7XHJcbn07XHJcblxyXG50eXBlIFBlblN0eWxlcyA9IHtcclxuICBmb3JlZ3JvdW5kOiBzdHJpbmcgfCBudWxsLFxyXG4gIHVuZGVybGluZTogYm9vbGVhbixcclxuICBpdGFsaWNzOiBib29sZWFuLFxyXG4gIGJhY2tncm91bmQ6IHN0cmluZyxcclxuICBmbGFzaDogYm9vbGVhbixcclxufTtcclxuXHJcbmNsYXNzIFBlblN0YXRlIHtcclxuICBwdWJsaWMgZm9yZWdyb3VuZDogc3RyaW5nO1xyXG4gIHB1YmxpYyB1bmRlcmxpbmU6IGJvb2xlYW47XHJcbiAgcHVibGljIGl0YWxpY3M6IGJvb2xlYW47XHJcbiAgcHVibGljIGJhY2tncm91bmQ6IHN0cmluZztcclxuICBwdWJsaWMgZmxhc2g6IGJvb2xlYW47XHJcblxyXG4gIGNvbnN0cnVjdG9yIChmb3JlZ3JvdW5kPzogc3RyaW5nLCB1bmRlcmxpbmU/OiBib29sZWFuLCBpdGFsaWNzPzogYm9vbGVhbiwgYmFja2dyb3VuZD86IHN0cmluZywgZmxhc2g/OiBib29sZWFuKSB7XHJcbiAgICB0aGlzLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kIHx8ICd3aGl0ZSc7XHJcbiAgICB0aGlzLnVuZGVybGluZSA9IHVuZGVybGluZSB8fCBmYWxzZTtcclxuICAgIHRoaXMuaXRhbGljcyA9IGl0YWxpY3MgfHwgZmFsc2U7XHJcbiAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kIHx8ICdibGFjayc7XHJcbiAgICB0aGlzLmZsYXNoID0gZmxhc2ggfHwgZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXNldCAoKSB7XHJcbiAgICB0aGlzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xyXG4gICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcclxuICAgIHRoaXMuaXRhbGljcyA9IGZhbHNlO1xyXG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gJ2JsYWNrJztcclxuICAgIHRoaXMuZmxhc2ggPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIHNldFN0eWxlcyAoc3R5bGVzOiBQYXJ0aWFsPFBlblN0eWxlcz4pIHtcclxuICAgIGxldCBhdHRyaWJzID0gWydmb3JlZ3JvdW5kJywgJ3VuZGVybGluZScsICdpdGFsaWNzJywgJ2JhY2tncm91bmQnLCAnZmxhc2gnXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsZXQgc3R5bGUgPSBhdHRyaWJzW2ldO1xyXG4gICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xyXG4gICAgICAgIHRoaXNbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaXNEZWZhdWx0ICgpIHtcclxuICAgIHJldHVybiAodGhpcy5mb3JlZ3JvdW5kID09PSAnd2hpdGUnICYmICF0aGlzLnVuZGVybGluZSAmJiAhdGhpcy5pdGFsaWNzICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmQgPT09ICdibGFjaycgJiYgIXRoaXMuZmxhc2gpO1xyXG4gIH1cclxuXHJcbiAgZXF1YWxzIChvdGhlcjogUGVuU3RhdGUpIHtcclxuICAgIHJldHVybiAoKHRoaXMuZm9yZWdyb3VuZCA9PT0gb3RoZXIuZm9yZWdyb3VuZCkgJiZcclxuICAgICAgICAgICAgICAgICAodGhpcy51bmRlcmxpbmUgPT09IG90aGVyLnVuZGVybGluZSkgJiZcclxuICAgICAgICAgICAgICAgICAodGhpcy5pdGFsaWNzID09PSBvdGhlci5pdGFsaWNzKSAmJlxyXG4gICAgICAgICAgICAgICAgICh0aGlzLmJhY2tncm91bmQgPT09IG90aGVyLmJhY2tncm91bmQpICYmXHJcbiAgICAgICAgICAgICAgICAgKHRoaXMuZmxhc2ggPT09IG90aGVyLmZsYXNoKSk7XHJcbiAgfVxyXG5cclxuICBjb3B5IChuZXdQZW5TdGF0ZTogUGVuU3RhdGUpIHtcclxuICAgIHRoaXMuZm9yZWdyb3VuZCA9IG5ld1BlblN0YXRlLmZvcmVncm91bmQ7XHJcbiAgICB0aGlzLnVuZGVybGluZSA9IG5ld1BlblN0YXRlLnVuZGVybGluZTtcclxuICAgIHRoaXMuaXRhbGljcyA9IG5ld1BlblN0YXRlLml0YWxpY3M7XHJcbiAgICB0aGlzLmJhY2tncm91bmQgPSBuZXdQZW5TdGF0ZS5iYWNrZ3JvdW5kO1xyXG4gICAgdGhpcy5mbGFzaCA9IG5ld1BlblN0YXRlLmZsYXNoO1xyXG4gIH1cclxuXHJcbiAgdG9TdHJpbmcgKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gKCdjb2xvcj0nICsgdGhpcy5mb3JlZ3JvdW5kICsgJywgdW5kZXJsaW5lPScgKyB0aGlzLnVuZGVybGluZSArICcsIGl0YWxpY3M9JyArIHRoaXMuaXRhbGljcyArXHJcbiAgICAgICAgICAgICcsIGJhY2tncm91bmQ9JyArIHRoaXMuYmFja2dyb3VuZCArICcsIGZsYXNoPScgKyB0aGlzLmZsYXNoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVbmljb2RlIGNoYXJhY3RlciB3aXRoIHN0eWxpbmcgYW5kIGJhY2tncm91bmQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuY2xhc3MgU3R5bGVkVW5pY29kZUNoYXIge1xyXG4gIHVjaGFyOiBzdHJpbmc7XHJcbiAgcGVuU3RhdGU6IFBlblN0YXRlO1xyXG4gIGNvbnN0cnVjdG9yICh1Y2hhcj86IHN0cmluZywgZm9yZWdyb3VuZD86IHN0cmluZywgdW5kZXJsaW5lPzogYm9vbGVhbiwgaXRhbGljcz86IGJvb2xlYW4sIGJhY2tncm91bmQ/OiBzdHJpbmcsIGZsYXNoPzogYm9vbGVhbikge1xyXG4gICAgdGhpcy51Y2hhciA9IHVjaGFyIHx8ICcgJzsgLy8gdW5pY29kZSBjaGFyYWN0ZXJcclxuICAgIHRoaXMucGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCk7XHJcbiAgfVxyXG5cclxuICByZXNldCAoKSB7XHJcbiAgICB0aGlzLnVjaGFyID0gJyAnO1xyXG4gICAgdGhpcy5wZW5TdGF0ZS5yZXNldCgpO1xyXG4gIH1cclxuXHJcbiAgc2V0Q2hhciAodWNoYXI6IHN0cmluZywgbmV3UGVuU3RhdGU6IFBlblN0YXRlKSB7XHJcbiAgICB0aGlzLnVjaGFyID0gdWNoYXI7XHJcbiAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgc2V0UGVuU3RhdGUgKG5ld1BlblN0YXRlOiBQZW5TdGF0ZSkge1xyXG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcclxuICB9XHJcblxyXG4gIGVxdWFscyAob3RoZXI6IFN0eWxlZFVuaWNvZGVDaGFyKSB7XHJcbiAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gb3RoZXIudWNoYXIgJiYgdGhpcy5wZW5TdGF0ZS5lcXVhbHMob3RoZXIucGVuU3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgY29weSAobmV3Q2hhcjogU3R5bGVkVW5pY29kZUNoYXIpIHtcclxuICAgIHRoaXMudWNoYXIgPSBuZXdDaGFyLnVjaGFyO1xyXG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld0NoYXIucGVuU3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgaXNFbXB0eSAoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gJyAnICYmIHRoaXMucGVuU3RhdGUuaXNEZWZhdWx0KCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ0VBLTYwOCByb3cgY29uc2lzdGluZyBvZiBOUl9DT0xTIGluc3RhbmNlcyBvZiBTdHlsZWRVbmljb2RlQ2hhci5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUm93IHtcclxuICBwdWJsaWMgY2hhcnM6IFN0eWxlZFVuaWNvZGVDaGFyW107XHJcbiAgcHVibGljIHBvczogbnVtYmVyO1xyXG4gIHB1YmxpYyBjdXJyUGVuU3RhdGU6IFBlblN0YXRlO1xyXG4gIHB1YmxpYyBjdWVTdGFydFRpbWU/OiBudW1iZXI7XHJcbiAgY29uc3RydWN0b3IgKCkge1xyXG4gICAgdGhpcy5jaGFycyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcclxuICAgICAgdGhpcy5jaGFycy5wdXNoKG5ldyBTdHlsZWRVbmljb2RlQ2hhcigpKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBvcyA9IDA7XHJcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZXF1YWxzIChvdGhlcjogUm93KSB7XHJcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcclxuICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmVxdWFscyhvdGhlci5jaGFyc1tpXSkpIHtcclxuICAgICAgICBlcXVhbCA9IGZhbHNlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXF1YWw7XHJcbiAgfVxyXG5cclxuICBjb3B5IChvdGhlcjogUm93KSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xyXG4gICAgICB0aGlzLmNoYXJzW2ldLmNvcHkob3RoZXIuY2hhcnNbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaXNFbXB0eSAoKTogYm9vbGVhbiB7XHJcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcclxuICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmlzRW1wdHkoKSkge1xyXG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBlbXB0eTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAgICogIFNldCB0aGUgY3Vyc29yIHRvIGEgdmFsaWQgY29sdW1uLlxyXG4gICAgICovXHJcbiAgc2V0Q3Vyc29yIChhYnNQb3M6IG51bWJlcikge1xyXG4gICAgaWYgKHRoaXMucG9zICE9PSBhYnNQb3MpIHtcclxuICAgICAgdGhpcy5wb3MgPSBhYnNQb3M7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucG9zIDwgMCkge1xyXG4gICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdOZWdhdGl2ZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcclxuICAgICAgdGhpcy5wb3MgPSAwO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLnBvcyA+IE5SX0NPTFMpIHtcclxuICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnVG9vIGxhcmdlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xyXG4gICAgICB0aGlzLnBvcyA9IE5SX0NPTFM7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICAqIE1vdmUgdGhlIGN1cnNvciByZWxhdGl2ZSB0byBjdXJyZW50IHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgbW92ZUN1cnNvciAocmVsUG9zOiBudW1iZXIpIHtcclxuICAgIGxldCBuZXdQb3MgPSB0aGlzLnBvcyArIHJlbFBvcztcclxuICAgIGlmIChyZWxQb3MgPiAxKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnBvcyArIDE7IGkgPCBuZXdQb3MgKyAxOyBpKyspIHtcclxuICAgICAgICB0aGlzLmNoYXJzW2ldLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5zZXRDdXJzb3IobmV3UG9zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAgICogQmFja3NwYWNlLCBtb3ZlIG9uZSBzdGVwIGJhY2sgYW5kIGNsZWFyIGNoYXJhY3Rlci5cclxuICAgICAqL1xyXG4gIGJhY2tTcGFjZSAoKSB7XHJcbiAgICB0aGlzLm1vdmVDdXJzb3IoLTEpO1xyXG4gICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcignICcsIHRoaXMuY3VyclBlblN0YXRlKTtcclxuICB9XHJcblxyXG4gIGluc2VydENoYXIgKGJ5dGU6IG51bWJlcikge1xyXG4gICAgaWYgKGJ5dGUgPj0gMHg5MCkgeyAvLyBFeHRlbmRlZCBjaGFyXHJcbiAgICAgIHRoaXMuYmFja1NwYWNlKCk7XHJcbiAgICB9XHJcbiAgICBsZXQgY2hhciA9IGdldENoYXJGb3JCeXRlKGJ5dGUpO1xyXG4gICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcclxuICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnQ2Fubm90IGluc2VydCAnICsgYnl0ZS50b1N0cmluZygxNikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnICgnICsgY2hhciArICcpIGF0IHBvc2l0aW9uICcgKyB0aGlzLnBvcyArICcuIFNraXBwaW5nIGl0IScpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKGNoYXIsIHRoaXMuY3VyclBlblN0YXRlKTtcclxuICAgIHRoaXMubW92ZUN1cnNvcigxKTtcclxuICB9XHJcblxyXG4gIGNsZWFyRnJvbVBvcyAoc3RhcnRQb3M6IG51bWJlcikge1xyXG4gICAgbGV0IGk6IG51bWJlcjtcclxuICAgIGZvciAoaSA9IHN0YXJ0UG9zOyBpIDwgTlJfQ09MUzsgaSsrKSB7XHJcbiAgICAgIHRoaXMuY2hhcnNbaV0ucmVzZXQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNsZWFyICgpIHtcclxuICAgIHRoaXMuY2xlYXJGcm9tUG9zKDApO1xyXG4gICAgdGhpcy5wb3MgPSAwO1xyXG4gICAgdGhpcy5jdXJyUGVuU3RhdGUucmVzZXQoKTtcclxuICB9XHJcblxyXG4gIGNsZWFyVG9FbmRPZlJvdyAoKSB7XHJcbiAgICB0aGlzLmNsZWFyRnJvbVBvcyh0aGlzLnBvcyk7XHJcbiAgfVxyXG5cclxuICBnZXRUZXh0U3RyaW5nICgpIHtcclxuICAgIGxldCBjaGFyczogc3RyaW5nW10gPSBbXTtcclxuICAgIGxldCBlbXB0eSA9IHRydWU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xyXG4gICAgICBsZXQgY2hhciA9IHRoaXMuY2hhcnNbaV0udWNoYXI7XHJcbiAgICAgIGlmIChjaGFyICE9PSAnICcpIHtcclxuICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjaGFycy5wdXNoKGNoYXIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGVtcHR5KSB7XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldFBlblN0eWxlcyAoc3R5bGVzOiBQYXJ0aWFsPFBlblN0eWxlcz4pIHtcclxuICAgIHRoaXMuY3VyclBlblN0YXRlLnNldFN0eWxlcyhzdHlsZXMpO1xyXG4gICAgbGV0IGN1cnJDaGFyID0gdGhpcy5jaGFyc1t0aGlzLnBvc107XHJcbiAgICBjdXJyQ2hhci5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogS2VlcCBhIENFQS02MDggc2NyZWVuIG9mIDMyeDE1IHN0eWxlZCBjaGFyYWN0ZXJzXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4qL1xyXG5leHBvcnQgY2xhc3MgQ2FwdGlvblNjcmVlbiB7XHJcbiAgcm93czogUm93W107XHJcbiAgY3VyclJvdzogbnVtYmVyO1xyXG4gIG5yUm9sbFVwUm93czogbnVtYmVyIHwgbnVsbDtcclxuICBsYXN0T3V0cHV0U2NyZWVuOiBhbnk7XHJcbiAgY29uc3RydWN0b3IgKCkge1xyXG4gICAgdGhpcy5yb3dzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xyXG4gICAgICB0aGlzLnJvd3MucHVzaChuZXcgUm93KCkpO1xyXG4gICAgfSAvLyBOb3RlIHRoYXQgd2UgdXNlIHplcm8tYmFzZWQgbnVtYmVyaW5nICgwLTE0KVxyXG5cclxuICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xyXG4gICAgdGhpcy5uclJvbGxVcFJvd3MgPSBudWxsO1xyXG4gICAgdGhpcy5yZXNldCgpO1xyXG4gIH1cclxuXHJcbiAgcmVzZXQgKCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcclxuICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XHJcbiAgfVxyXG5cclxuICBlcXVhbHMgKG90aGVyOiBDYXB0aW9uU2NyZWVuKTogYm9vbGVhbiB7XHJcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcclxuICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uZXF1YWxzKG90aGVyLnJvd3NbaV0pKSB7XHJcbiAgICAgICAgZXF1YWwgPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVxdWFsO1xyXG4gIH1cclxuXHJcbiAgY29weSAob3RoZXI6IENhcHRpb25TY3JlZW4pIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XHJcbiAgICAgIHRoaXMucm93c1tpXS5jb3B5KG90aGVyLnJvd3NbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaXNFbXB0eSAoKTogYm9vbGVhbiB7XHJcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcclxuICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVtcHR5O1xyXG4gIH1cclxuXHJcbiAgYmFja1NwYWNlICgpIHtcclxuICAgIGxldCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcclxuICAgIHJvdy5iYWNrU3BhY2UoKTtcclxuICB9XHJcblxyXG4gIGNsZWFyVG9FbmRPZlJvdyAoKSB7XHJcbiAgICBsZXQgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XHJcbiAgICByb3cuY2xlYXJUb0VuZE9mUm93KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICAqIEluc2VydCBhIGNoYXJhY3RlciAod2l0aG91dCBzdHlsaW5nKSBpbiB0aGUgY3VycmVudCByb3cuXHJcbiAgICAgKi9cclxuICBpbnNlcnRDaGFyIChjaGFyOiBudW1iZXIpIHtcclxuICAgIGxldCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcclxuICAgIHJvdy5pbnNlcnRDaGFyKGNoYXIpO1xyXG4gIH1cclxuXHJcbiAgc2V0UGVuIChzdHlsZXM6IFBhcnRpYWw8UGVuU3R5bGVzPikge1xyXG4gICAgbGV0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xyXG4gICAgcm93LnNldFBlblN0eWxlcyhzdHlsZXMpO1xyXG4gIH1cclxuXHJcbiAgbW92ZUN1cnNvciAocmVsUG9zOiBudW1iZXIpIHtcclxuICAgIGxldCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcclxuICAgIHJvdy5tb3ZlQ3Vyc29yKHJlbFBvcyk7XHJcbiAgfVxyXG5cclxuICBzZXRDdXJzb3IgKGFic1BvczogbnVtYmVyKSB7XHJcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ3NldEN1cnNvcjogJyArIGFic1Bvcyk7XHJcbiAgICBsZXQgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XHJcbiAgICByb3cuc2V0Q3Vyc29yKGFic1Bvcyk7XHJcbiAgfVxyXG5cclxuICBzZXRQQUMgKHBhY0RhdGE6IFBBQ0RhdGEpIHtcclxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAncGFjRGF0YSA9ICcgKyBKU09OLnN0cmluZ2lmeShwYWNEYXRhKSk7XHJcbiAgICBsZXQgbmV3Um93ID0gcGFjRGF0YS5yb3cgLSAxO1xyXG4gICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICYmIG5ld1JvdyA8IHRoaXMubnJSb2xsVXBSb3dzIC0gMSkge1xyXG4gICAgICBuZXdSb3cgPSB0aGlzLm5yUm9sbFVwUm93cyAtIDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFrZSBzdXJlIHRoaXMgb25seSBhZmZlY3RzIFJvbGwtdXAgQ2FwdGlvbnMgYnkgY2hlY2tpbmcgdGhpcy5uclJvbGxVcFJvd3NcclxuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiB0aGlzLmN1cnJSb3cgIT09IG5ld1Jvdykge1xyXG4gICAgICAvLyBjbGVhciBhbGwgcm93cyBmaXJzdFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xyXG4gICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb3B5IHRoaXMubnJSb2xsVXBSb3dzIHJvd3MgZnJvbSBsYXN0T3V0cHV0U2NyZWVuIGFuZCBwbGFjZSBpdCBpbiB0aGUgbmV3Um93IGxvY2F0aW9uXHJcbiAgICAgIC8vIHRvcFJvd0luZGV4IC0gdGhlIHN0YXJ0IG9mIHJvd3MgdG8gY29weSAoaW5jbHVzaXZlIGluZGV4KVxyXG4gICAgICBsZXQgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gKHRoaXMubnJSb2xsVXBSb3dzKTtcclxuICAgICAgLy8gV2Ugb25seSBjb3B5IGlmIHRoZSBsYXN0IHBvc2l0aW9uIHdhcyBhbHJlYWR5IHNob3duLlxyXG4gICAgICAvLyBXZSB1c2UgdGhlIGN1ZVN0YXJ0VGltZSB2YWx1ZSB0byBjaGVjayB0aGlzLlxyXG4gICAgICBjb25zdCBsYXN0T3V0cHV0U2NyZWVuID0gdGhpcy5sYXN0T3V0cHV0U2NyZWVuIGFzIGFueTtcclxuICAgICAgaWYgKGxhc3RPdXRwdXRTY3JlZW4pIHtcclxuICAgICAgICBsZXQgcHJldkxpbmVUaW1lID0gbGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4XS5jdWVTdGFydFRpbWU7XHJcbiAgICAgICAgaWYgKHByZXZMaW5lVGltZSAmJiBsb2dnZXIudGltZSAmJiBwcmV2TGluZVRpbWUgPCBsb2dnZXIudGltZSkge1xyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5yUm9sbFVwUm93czsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm93c1tuZXdSb3cgLSB0aGlzLm5yUm9sbFVwUm93cyArIGkgKyAxXS5jb3B5KGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleCArIGldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmN1cnJSb3cgPSBuZXdSb3c7XHJcbiAgICBsZXQgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XHJcbiAgICBpZiAocGFjRGF0YS5pbmRlbnQgIT09IG51bGwpIHtcclxuICAgICAgbGV0IGluZGVudCA9IHBhY0RhdGEuaW5kZW50O1xyXG4gICAgICBsZXQgcHJldlBvcyA9IE1hdGgubWF4KGluZGVudCAtIDEsIDApO1xyXG4gICAgICByb3cuc2V0Q3Vyc29yKHBhY0RhdGEuaW5kZW50KTtcclxuICAgICAgcGFjRGF0YS5jb2xvciA9IHJvdy5jaGFyc1twcmV2UG9zXS5wZW5TdGF0ZS5mb3JlZ3JvdW5kO1xyXG4gICAgfVxyXG4gICAgbGV0IHN0eWxlczogUGVuU3R5bGVzID0geyBmb3JlZ3JvdW5kOiBwYWNEYXRhLmNvbG9yLCB1bmRlcmxpbmU6IHBhY0RhdGEudW5kZXJsaW5lLCBpdGFsaWNzOiBwYWNEYXRhLml0YWxpY3MsIGJhY2tncm91bmQ6ICdibGFjaycsIGZsYXNoOiBmYWxzZSB9O1xyXG4gICAgdGhpcy5zZXRQZW4oc3R5bGVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAgICogU2V0IGJhY2tncm91bmQvZXh0cmEgZm9yZWdyb3VuZCwgYnV0IGZpcnN0IGRvIGJhY2tfc3BhY2UsIGFuZCB0aGVuIGluc2VydCBzcGFjZSAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLlxyXG4gICAgICovXHJcbiAgc2V0QmtnRGF0YSAoYmtnRGF0YTogUGFydGlhbDxQZW5TdHlsZXM+KSB7XHJcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ2JrZ0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkoYmtnRGF0YSkpO1xyXG4gICAgdGhpcy5iYWNrU3BhY2UoKTtcclxuICAgIHRoaXMuc2V0UGVuKGJrZ0RhdGEpO1xyXG4gICAgdGhpcy5pbnNlcnRDaGFyKDB4MjApOyAvLyBTcGFjZVxyXG4gIH1cclxuXHJcbiAgc2V0Um9sbFVwUm93cyAobnJSb3dzOiBudW1iZXIgfCBudWxsKSB7XHJcbiAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG5yUm93cztcclxuICB9XHJcblxyXG4gIHJvbGxVcCAoKSB7XHJcbiAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgPT09IG51bGwpIHtcclxuICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAncm9sbF91cCBidXQgbnJSb2xsVXBSb3dzIG5vdCBzZXQgeWV0Jyk7XHJcbiAgICAgIHJldHVybjsgLy8gTm90IHByb3Blcmx5IHNldHVwXHJcbiAgICB9XHJcbiAgICBsb2dnZXIubG9nKCdURVhUJywgdGhpcy5nZXREaXNwbGF5VGV4dCgpKTtcclxuICAgIGxldCB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSB0aGlzLm5yUm9sbFVwUm93cztcclxuICAgIGxldCB0b3BSb3cgPSB0aGlzLnJvd3Muc3BsaWNlKHRvcFJvd0luZGV4LCAxKVswXTtcclxuICAgIHRvcFJvdy5jbGVhcigpO1xyXG4gICAgdGhpcy5yb3dzLnNwbGljZSh0aGlzLmN1cnJSb3csIDAsIHRvcFJvdyk7XHJcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JvbGxpbmcgdXAnKTtcclxuICAgIC8vIGxvZ2dlci5sb2coJ1RFWFQnLCB0aGlzLmdldF9kaXNwbGF5X3RleHQoKSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAgKiBHZXQgYWxsIG5vbi1lbXB0eSByb3dzIHdpdGggYXMgdW5pY29kZSB0ZXh0LlxyXG4gICAgKi9cclxuICBnZXREaXNwbGF5VGV4dCAoYXNPbmVSb3c/OiBib29sZWFuKSB7XHJcbiAgICBhc09uZVJvdyA9IGFzT25lUm93IHx8IGZhbHNlO1xyXG4gICAgbGV0IGRpc3BsYXlUZXh0OiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgbGV0IHRleHQgPSAnJztcclxuICAgIGxldCByb3dOciA9IC0xO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcclxuICAgICAgbGV0IHJvd1RleHQgPSB0aGlzLnJvd3NbaV0uZ2V0VGV4dFN0cmluZygpO1xyXG4gICAgICBpZiAocm93VGV4dCkge1xyXG4gICAgICAgIHJvd05yID0gaSArIDE7XHJcbiAgICAgICAgaWYgKGFzT25lUm93KSB7XHJcbiAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKCdSb3cgJyArIHJvd05yICsgJzogXFwnJyArIHJvd1RleHQgKyAnXFwnJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2gocm93VGV4dC50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGRpc3BsYXlUZXh0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgaWYgKGFzT25lUm93KSB7XHJcbiAgICAgICAgdGV4dCA9ICdbJyArIGRpc3BsYXlUZXh0LmpvaW4oJyB8ICcpICsgJ10nO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRleHQ7XHJcbiAgfVxyXG5cclxuICBnZXRUZXh0QW5kRm9ybWF0ICgpIHtcclxuICAgIHJldHVybiB0aGlzLnJvd3M7XHJcbiAgfVxyXG59XHJcblxyXG4vLyB2YXIgbW9kZXMgPSBbJ01PREVfUk9MTC1VUCcsICdNT0RFX1BPUC1PTicsICdNT0RFX1BBSU5ULU9OJywgJ01PREVfVEVYVCddO1xyXG5cclxudHlwZSBDYXB0aW9uTW9kZXMgPSAnTU9ERV9ST0xMLVVQJyB8ICdNT0RFX1BPUC1PTicgfCAnTU9ERV9QQUlOVC1PTicgfCAnTU9ERV9URVhUJyB8IG51bGw7XHJcblxyXG5jbGFzcyBDZWE2MDhDaGFubmVsIHtcclxuICBjaE5yOiBudW1iZXI7XHJcbiAgb3V0cHV0RmlsdGVyOiBPdXRwdXRGaWx0ZXI7XHJcbiAgbW9kZTogQ2FwdGlvbk1vZGVzO1xyXG4gIHZlcmJvc2U6IG51bWJlcjtcclxuICBkaXNwbGF5ZWRNZW1vcnk6IENhcHRpb25TY3JlZW47XHJcbiAgbm9uRGlzcGxheWVkTWVtb3J5OiBDYXB0aW9uU2NyZWVuO1xyXG4gIGxhc3RPdXRwdXRTY3JlZW46IENhcHRpb25TY3JlZW47XHJcbiAgY3VyclJvbGxVcFJvdzogUm93O1xyXG4gIHdyaXRlU2NyZWVuOiBDYXB0aW9uU2NyZWVuO1xyXG4gIGN1ZVN0YXJ0VGltZTogbnVtYmVyIHwgbnVsbDtcclxuICBsYXN0Q3VlRW5kVGltZTogbnVsbDtcclxuICBjb25zdHJ1Y3RvciAoY2hhbm5lbE51bWJlcjogbnVtYmVyLCBvdXRwdXRGaWx0ZXI6IE91dHB1dEZpbHRlcikge1xyXG4gICAgdGhpcy5jaE5yID0gY2hhbm5lbE51bWJlcjtcclxuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gb3V0cHV0RmlsdGVyO1xyXG4gICAgdGhpcy5tb2RlID0gbnVsbDtcclxuICAgIHRoaXMudmVyYm9zZSA9IDA7XHJcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XHJcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XHJcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xyXG4gICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XHJcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XHJcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xyXG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsOyAvLyBLZWVwcyB0cmFjayBvZiB3aGVyZSBhIGN1ZSBzdGFydGVkLlxyXG4gIH1cclxuXHJcbiAgcmVzZXQgKCkge1xyXG4gICAgdGhpcy5tb2RlID0gbnVsbDtcclxuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XHJcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xyXG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuLnJlc2V0KCk7XHJcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MgLSAxXTtcclxuICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcclxuICAgIHRoaXMubW9kZSA9IG51bGw7XHJcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBnZXRIYW5kbGVyICgpOiBPdXRwdXRGaWx0ZXIge1xyXG4gICAgcmV0dXJuIHRoaXMub3V0cHV0RmlsdGVyO1xyXG4gIH1cclxuXHJcbiAgc2V0SGFuZGxlciAobmV3SGFuZGxlcjogT3V0cHV0RmlsdGVyKSB7XHJcbiAgICB0aGlzLm91dHB1dEZpbHRlciA9IG5ld0hhbmRsZXI7XHJcbiAgfVxyXG5cclxuICBzZXRQQUMgKHBhY0RhdGE6IFBBQ0RhdGEpIHtcclxuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UEFDKHBhY0RhdGEpO1xyXG4gIH1cclxuXHJcbiAgc2V0QmtnRGF0YSAoYmtnRGF0YTogUGFydGlhbDxQZW5TdHlsZXM+KSB7XHJcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldEJrZ0RhdGEoYmtnRGF0YSk7XHJcbiAgfVxyXG5cclxuICBzZXRNb2RlIChuZXdNb2RlOiBDYXB0aW9uTW9kZXMpIHtcclxuICAgIGlmIChuZXdNb2RlID09PSB0aGlzLm1vZGUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XHJcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ01PREU9JyArIG5ld01vZGUpO1xyXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xyXG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XHJcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4ucmVzZXQoKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm1vZGUgIT09ICdNT0RFX1JPTEwtVVAnKSB7XHJcbiAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XHJcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xyXG4gIH1cclxuXHJcbiAgaW5zZXJ0Q2hhcnMgKGNoYXJzOiBudW1iZXJbXSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB0aGlzLndyaXRlU2NyZWVuLmluc2VydENoYXIoY2hhcnNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBzY3JlZW4gPSB0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSA/ICdESVNQJyA6ICdOT05fRElTUCc7XHJcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgc2NyZWVuICsgJzogJyArIHRoaXMud3JpdGVTY3JlZW4uZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xyXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUEFJTlQtT04nIHx8IHRoaXMubW9kZSA9PT0gJ01PREVfUk9MTC1VUCcpIHtcclxuICAgICAgbG9nZ2VyLmxvZygnVEVYVCcsICdESVNQTEFZRUQ6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCh0cnVlKSk7XHJcbiAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2NSQ0wgKCkgeyAvLyBSZXN1bWUgQ2FwdGlvbiBMb2FkaW5nIChzd2l0Y2ggbW9kZSB0byBQb3AgT24pXHJcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JDTCAtIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcnKTtcclxuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QT1AtT04nKTtcclxuICB9XHJcblxyXG4gIGNjQlMgKCkgeyAvLyBCYWNrU3BhY2VcclxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnQlMgLSBCYWNrU3BhY2UnKTtcclxuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1RFWFQnKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLndyaXRlU2NyZWVuLmJhY2tTcGFjZSgpO1xyXG4gICAgaWYgKHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5KSB7XHJcbiAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2NBT0YgKCkgeyAvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT2ZmKVxyXG5cclxuICB9XHJcblxyXG4gIGNjQU9OICgpIHsgLy8gUmVzZXJ2ZWQgKGZvcm1lcmx5IEFsYXJtIE9uKVxyXG5cclxuICB9XHJcblxyXG4gIGNjREVSICgpIHsgLy8gRGVsZXRlIHRvIEVuZCBvZiBSb3dcclxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnREVSLSBEZWxldGUgdG8gRW5kIG9mIFJvdycpO1xyXG4gICAgdGhpcy53cml0ZVNjcmVlbi5jbGVhclRvRW5kT2ZSb3coKTtcclxuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgY2NSVSAobnJSb3dzOiBudW1iZXIgfCBudWxsKSB7IC8vIFJvbGwtVXAgQ2FwdGlvbnMtMiwzLG9yIDQgUm93c1xyXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdSVSgnICsgbnJSb3dzICsgJykgLSBSb2xsIFVwJyk7XHJcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XHJcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfUk9MTC1VUCcpO1xyXG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRSb2xsVXBSb3dzKG5yUm93cyk7XHJcbiAgfVxyXG5cclxuICBjY0ZPTiAoKSB7IC8vIEZsYXNoIE9uXHJcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0ZPTiAtIEZsYXNoIE9uJyk7XHJcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbih7IGZsYXNoOiB0cnVlIH0pO1xyXG4gIH1cclxuXHJcbiAgY2NSREMgKCkgeyAvLyBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcgKHN3aXRjaCBtb2RlIHRvIFBhaW50T24pXHJcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JEQyAtIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZycpO1xyXG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BBSU5ULU9OJyk7XHJcbiAgfVxyXG5cclxuICBjY1RSICgpIHsgLy8gVGV4dCBSZXN0YXJ0IGluIHRleHQgbW9kZSAobm90IHN1cHBvcnRlZCwgaG93ZXZlcilcclxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnVFInKTtcclxuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XHJcbiAgfVxyXG5cclxuICBjY1JURCAoKSB7IC8vIFJlc3VtZSBUZXh0IERpc3BsYXkgaW4gVGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxyXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdSVEQnKTtcclxuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XHJcbiAgfVxyXG5cclxuICBjY0VETSAoKSB7IC8vIEVyYXNlIERpc3BsYXllZCBNZW1vcnlcclxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xyXG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcclxuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcclxuICB9XHJcblxyXG4gIGNjQ1IgKCkgeyAvLyBDYXJyaWFnZSBSZXR1cm5cclxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnQ1IgLSBDYXJyaWFnZSBSZXR1cm4nKTtcclxuICAgIHRoaXMud3JpdGVTY3JlZW4ucm9sbFVwKCk7XHJcbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XHJcbiAgfVxyXG5cclxuICBjY0VOTSAoKSB7IC8vIEVyYXNlIE5vbi1EaXNwbGF5ZWQgTWVtb3J5XHJcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0VOTSAtIEVyYXNlIE5vbi1kaXNwbGF5ZWQgTWVtb3J5Jyk7XHJcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xyXG4gIH1cclxuXHJcbiAgY2NFT0MgKCkgeyAvLyBFbmQgb2YgQ2FwdGlvbiAoRmxpcCBNZW1vcmllcylcclxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRU9DIC0gRW5kIE9mIENhcHRpb24nKTtcclxuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcclxuICAgICAgbGV0IHRtcCA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xyXG4gICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xyXG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IHRtcDtcclxuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xyXG4gICAgICBsb2dnZXIubG9nKCdURVhUJywgJ0RJU1A6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCgpKTtcclxuICAgIH1cclxuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcclxuICB9XHJcblxyXG4gIGNjVE8gKG5yQ29sczogbnVtYmVyKSB7IC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcclxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnVE8oJyArIG5yQ29scyArICcpIC0gVGFiIE9mZnNldCcpO1xyXG4gICAgdGhpcy53cml0ZVNjcmVlbi5tb3ZlQ3Vyc29yKG5yQ29scyk7XHJcbiAgfVxyXG5cclxuICBjY01JRFJPVyAoc2Vjb25kQnl0ZTogbnVtYmVyKSB7IC8vIFBhcnNlIE1JRFJPVyBjb21tYW5kXHJcbiAgICBsZXQgc3R5bGVzOiBQYXJ0aWFsPFBlblN0eWxlcz4gPSB7IGZsYXNoOiBmYWxzZSB9O1xyXG4gICAgc3R5bGVzLnVuZGVybGluZSA9IHNlY29uZEJ5dGUgJSAyID09PSAxO1xyXG4gICAgc3R5bGVzLml0YWxpY3MgPSBzZWNvbmRCeXRlID49IDB4MmU7XHJcbiAgICBpZiAoIXN0eWxlcy5pdGFsaWNzKSB7XHJcbiAgICAgIGxldCBjb2xvckluZGV4ID0gTWF0aC5mbG9vcihzZWNvbmRCeXRlIC8gMikgLSAweDEwO1xyXG4gICAgICBsZXQgY29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJ107XHJcbiAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gY29sb3JzW2NvbG9ySW5kZXhdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xyXG4gICAgfVxyXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdNSURST1c6ICcgKyBKU09OLnN0cmluZ2lmeShzdHlsZXMpKTtcclxuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHN0eWxlcyk7XHJcbiAgfVxyXG5cclxuICBvdXRwdXREYXRhVXBkYXRlIChkaXNwYXRjaCA9IGZhbHNlKSB7XHJcbiAgICBsZXQgdCA9IGxvZ2dlci50aW1lO1xyXG4gICAgaWYgKHQgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xyXG4gICAgICBpZiAodGhpcy5jdWVTdGFydFRpbWUgPT09IG51bGwgJiYgIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkgeyAvLyBTdGFydCBvZiBhIG5ldyBjdWVcclxuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5lcXVhbHModGhpcy5sYXN0T3V0cHV0U2NyZWVuKSkge1xyXG4gICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lISwgdCwgdGhpcy5sYXN0T3V0cHV0U2NyZWVuKTtcclxuICAgICAgICAgIGlmIChkaXNwYXRjaCAmJiB0aGlzLm91dHB1dEZpbHRlci5kaXNwYXRjaEN1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5kaXNwYXRjaEN1ZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpID8gbnVsbCA6IHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5jb3B5KHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGN1ZVNwbGl0QXRUaW1lICh0OiBudW1iZXIpIHtcclxuICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xyXG4gICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xyXG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUpIHtcclxuICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSEsIHQsIHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIFBBQ0RhdGEge1xyXG4gIHJvdzogbnVtYmVyO1xyXG4gIGluZGVudDogbnVtYmVyIHwgbnVsbDtcclxuICBjb2xvcjogc3RyaW5nIHwgbnVsbDtcclxuICB1bmRlcmxpbmU6IGJvb2xlYW47XHJcbiAgaXRhbGljczogYm9vbGVhbjtcclxufVxyXG5cclxuY2xhc3MgQ2VhNjA4UGFyc2VyIHtcclxuICBmaWVsZDogbnVtYmVyO1xyXG4gIG91dHB1dHM6IE91dHB1dEZpbHRlcltdO1xyXG4gIGNoYW5uZWxzOiBDZWE2MDhDaGFubmVsW107XHJcbiAgY3VyckNoTnI6IG51bWJlcjtcclxuICBsYXN0Q21kQTogbnVtYmVyIHwgbnVsbDtcclxuICBsYXN0Q21kQjogbnVtYmVyIHwgbnVsbDtcclxuICBsYXN0VGltZTogbnVtYmVyIHwgbnVsbDtcclxuICBkYXRhQ291bnRlcnM6IHsgJ3BhZGRpbmcnOiBudW1iZXI7ICdjaGFyJzogbnVtYmVyOyAnY21kJzogbnVtYmVyOyAnb3RoZXInOiBudW1iZXI7IH07XHJcbiAgY29uc3RydWN0b3IgKGZpZWxkOiBudW1iZXIsIG91dDE6IE91dHB1dEZpbHRlciwgb3V0MjogT3V0cHV0RmlsdGVyKSB7XHJcbiAgICB0aGlzLmZpZWxkID0gZmllbGQgfHwgMTtcclxuICAgIHRoaXMub3V0cHV0cyA9IFtvdXQxLCBvdXQyXTtcclxuICAgIHRoaXMuY2hhbm5lbHMgPSBbbmV3IENlYTYwOENoYW5uZWwoMSwgb3V0MSksIG5ldyBDZWE2MDhDaGFubmVsKDIsIG91dDIpXTtcclxuICAgIHRoaXMuY3VyckNoTnIgPSAtMTsgLy8gV2lsbCBiZSAxIG9yIDJcclxuICAgIHRoaXMubGFzdENtZEEgPSBudWxsOyAvLyBGaXJzdCBieXRlIG9mIGxhc3QgY29tbWFuZFxyXG4gICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7IC8vIFNlY29uZCBieXRlIG9mIGxhc3QgY29tbWFuZFxyXG4gICAgdGhpcy5sYXN0VGltZSA9IG51bGw7XHJcbiAgICB0aGlzLmRhdGFDb3VudGVycyA9IHsgJ3BhZGRpbmcnOiAwLCAnY2hhcic6IDAsICdjbWQnOiAwLCAnb3RoZXInOiAwIH07XHJcbiAgfVxyXG5cclxuICBnZXRIYW5kbGVyIChpbmRleDogbnVtYmVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tpbmRleF0uZ2V0SGFuZGxlcigpO1xyXG4gIH1cclxuXHJcbiAgc2V0SGFuZGxlciAoaW5kZXg6IG51bWJlciwgbmV3SGFuZGxlcjogT3V0cHV0RmlsdGVyKSB7XHJcbiAgICB0aGlzLmNoYW5uZWxzW2luZGV4XS5zZXRIYW5kbGVyKG5ld0hhbmRsZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiBBZGQgZGF0YSBmb3IgdGltZSB0IGluIGZvcm1zIG9mIGxpc3Qgb2YgYnl0ZXMgKHVuc2lnbmVkIGludHMpLiBUaGUgYnl0ZXMgYXJlIHRyZWF0ZWQgYXMgcGFpcnMuXHJcbiAgICAgKi9cclxuICBhZGREYXRhICh0OiBudW1iZXIgfCBudWxsLCBieXRlTGlzdDogbnVtYmVyW10pIHtcclxuICAgIGxldCBjbWRGb3VuZDogYm9vbGVhbiwgYTogbnVtYmVyLCBiOiBudW1iZXIsXHJcbiAgICAgIGNoYXJzRm91bmQ6IG51bWJlcltdIHwgYm9vbGVhbiB8IG51bGwgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLmxhc3RUaW1lID0gdDtcclxuICAgIGxvZ2dlci5zZXRUaW1lKHQpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZUxpc3QubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgYSA9IGJ5dGVMaXN0W2ldICYgMHg3ZjtcclxuICAgICAgYiA9IGJ5dGVMaXN0W2kgKyAxXSAmIDB4N2Y7XHJcbiAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcclxuICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5wYWRkaW5nICs9IDI7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnREFUQScsICdbJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pICsgJ10gLT4gKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XHJcbiAgICAgIH1cclxuICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQ21kKGEsIGIpO1xyXG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XHJcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlTWlkcm93KGEsIGIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XHJcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlUEFDKGEsIGIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XHJcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghY21kRm91bmQpIHtcclxuICAgICAgICBjaGFyc0ZvdW5kID0gdGhpcy5wYXJzZUNoYXJzKGEsIGIpO1xyXG4gICAgICAgIGlmIChjaGFyc0ZvdW5kKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5jdXJyQ2hOciAmJiB0aGlzLmN1cnJDaE5yID49IDApIHtcclxuICAgICAgICAgICAgbGV0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW3RoaXMuY3VyckNoTnIgLSAxXTtcclxuICAgICAgICAgICAgY2hhbm5lbC5pbnNlcnRDaGFycyhjaGFyc0ZvdW5kKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1dBUk5JTkcnLCAnTm8gY2hhbm5lbCBmb3VuZCB5ZXQuIFRFWFQtTU9ERT8nKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNtZEZvdW5kKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMuY21kICs9IDI7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2hhcnNGb3VuZCkge1xyXG4gICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLmNoYXIgKz0gMjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5vdGhlciArPSAyO1xyXG4gICAgICAgIGxvZ2dlci5sb2coJ1dBUk5JTkcnLCAnQ291bGRuXFwndCBwYXJzZSBjbGVhbmVkIGRhdGEgJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgb3JpZzogJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiBQYXJzZSBDb21tYW5kLlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIGEgY29tbWFuZCB3YXMgZm91bmRcclxuICAgICAqL1xyXG4gIHBhcnNlQ21kIChhOiBudW1iZXIsIGI6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgbGV0IGNoTnI6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIGxldCBjb25kMSA9IChhID09PSAweDE0IHx8IGEgPT09IDB4MUMpICYmIChiID49IDB4MjAgJiYgYiA8PSAweDJGKTtcclxuICAgIGxldCBjb25kMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MUYpICYmIChiID49IDB4MjEgJiYgYiA8PSAweDIzKTtcclxuICAgIGlmICghKGNvbmQxIHx8IGNvbmQyKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xyXG4gICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcclxuICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7IC8vIFJlcGVhdGVkIGNvbW1hbmRzIGFyZSBkcm9wcGVkIChvbmNlKVxyXG4gICAgICBsb2dnZXIubG9nKCdERUJVRycsICdSZXBlYXRlZCBjb21tYW5kICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSBpcyBkcm9wcGVkJyk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MTcpIHtcclxuICAgICAgY2hOciA9IDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjaE5yID0gMjtcclxuICAgIH0gLy8gKGEgPT09IDB4MUMgfHwgYT09PSAweDFmKVxyXG5cclxuICAgIGxldCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XHJcblxyXG4gICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykge1xyXG4gICAgICBpZiAoYiA9PT0gMHgyMCkge1xyXG4gICAgICAgIGNoYW5uZWwuY2NSQ0woKTtcclxuICAgICAgfSBlbHNlIGlmIChiID09PSAweDIxKSB7XHJcbiAgICAgICAgY2hhbm5lbC5jY0JTKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMikge1xyXG4gICAgICAgIGNoYW5uZWwuY2NBT0YoKTtcclxuICAgICAgfSBlbHNlIGlmIChiID09PSAweDIzKSB7XHJcbiAgICAgICAgY2hhbm5lbC5jY0FPTigpO1xyXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjQpIHtcclxuICAgICAgICBjaGFubmVsLmNjREVSKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNSkge1xyXG4gICAgICAgIGNoYW5uZWwuY2NSVSgyKTtcclxuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI2KSB7XHJcbiAgICAgICAgY2hhbm5lbC5jY1JVKDMpO1xyXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjcpIHtcclxuICAgICAgICBjaGFubmVsLmNjUlUoNCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOCkge1xyXG4gICAgICAgIGNoYW5uZWwuY2NGT04oKTtcclxuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI5KSB7XHJcbiAgICAgICAgY2hhbm5lbC5jY1JEQygpO1xyXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkEpIHtcclxuICAgICAgICBjaGFubmVsLmNjVFIoKTtcclxuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJCKSB7XHJcbiAgICAgICAgY2hhbm5lbC5jY1JURCgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkMpIHtcclxuICAgICAgICBjaGFubmVsLmNjRURNKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyRCkge1xyXG4gICAgICAgIGNoYW5uZWwuY2NDUigpO1xyXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkUpIHtcclxuICAgICAgICBjaGFubmVsLmNjRU5NKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyRikge1xyXG4gICAgICAgIGNoYW5uZWwuY2NFT0MoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHsgLy8gYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxyXG4gICAgICBjaGFubmVsLmNjVE8oYiAtIDB4MjApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5sYXN0Q21kQSA9IGE7XHJcbiAgICB0aGlzLmxhc3RDbWRCID0gYjtcclxuICAgIHRoaXMuY3VyckNoTnIgPSBjaE5yO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICAqIFBhcnNlIG1pZHJvdyBzdHlsaW5nIGNvbW1hbmRcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgcGFyc2VNaWRyb3cgKGE6IG51bWJlciwgYjogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICBsZXQgY2hOcjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgaWYgKCgoYSA9PT0gMHgxMSkgfHwgKGEgPT09IDB4MTkpKSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmKSB7XHJcbiAgICAgIGlmIChhID09PSAweDExKSB7XHJcbiAgICAgICAgY2hOciA9IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hOciA9IDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjaE5yICE9PSB0aGlzLmN1cnJDaE5yKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnTWlzbWF0Y2ggY2hhbm5lbCBpbiBtaWRyb3cgcGFyc2luZycpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOciAtIDFdO1xyXG4gICAgICBjaGFubmVsLmNjTUlEUk9XKGIpO1xyXG4gICAgICBsb2dnZXIubG9nKCdERUJVRycsICdNSURST1cgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICAvKipcclxuICAgICAqIFBhcnNlIFByZWFibGUgQWNjZXNzIENvZGVzIChUYWJsZSA1MykuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGVsbHMgaWYgUEFDIGZvdW5kXHJcbiAgICAgKi9cclxuICBwYXJzZVBBQyAoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgIGxldCBjaE5yOiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuICAgIGxldCByb3c6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIGxldCBjYXNlMSA9ICgoYSA+PSAweDExICYmIGEgPD0gMHgxNykgfHwgKGEgPj0gMHgxOSAmJiBhIDw9IDB4MUYpKSAmJiAoYiA+PSAweDQwICYmIGIgPD0gMHg3Rik7XHJcbiAgICBsZXQgY2FzZTIgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiAoYiA+PSAweDQwICYmIGIgPD0gMHg1Rik7XHJcbiAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhID09PSB0aGlzLmxhc3RDbWRBICYmIGIgPT09IHRoaXMubGFzdENtZEIpIHtcclxuICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XHJcbiAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xyXG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gUmVwZWF0ZWQgY29tbWFuZHMgYXJlIGRyb3BwZWQgKG9uY2UpXHJcbiAgICB9XHJcblxyXG4gICAgY2hOciA9IChhIDw9IDB4MTcpID8gMSA6IDI7XHJcblxyXG4gICAgaWYgKGIgPj0gMHg0MCAmJiBiIDw9IDB4NUYpIHtcclxuICAgICAgcm93ID0gKGNoTnIgPT09IDEpID8gcm93c0xvd0NoMVthXSA6IHJvd3NMb3dDaDJbYV07XHJcbiAgICB9IGVsc2UgeyAvLyAweDYwIDw9IGIgPD0gMHg3RlxyXG4gICAgICByb3cgPSAoY2hOciA9PT0gMSkgPyByb3dzSGlnaENoMVthXSA6IHJvd3NIaWdoQ2gyW2FdO1xyXG4gICAgfVxyXG4gICAgbGV0IHBhY0RhdGEgPSB0aGlzLmludGVycHJldFBBQyhyb3chLCBiKTtcclxuICAgIGxldCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XHJcbiAgICBjaGFubmVsLnNldFBBQyhwYWNEYXRhKTtcclxuICAgIHRoaXMubGFzdENtZEEgPSBhO1xyXG4gICAgdGhpcy5sYXN0Q21kQiA9IGI7XHJcbiAgICB0aGlzLmN1cnJDaE5yID0gY2hOcjtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiBJbnRlcnByZXQgdGhlIHNlY29uZCBieXRlIG9mIHRoZSBwYWMsIGFuZCByZXR1cm4gdGhlIGluZm9ybWF0aW9uLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gcGFjRGF0YSB3aXRoIHN0eWxlIHBhcmFtZXRlcnMuXHJcbiAgICAgKi9cclxuICBpbnRlcnByZXRQQUMgKHJvdzogbnVtYmVyLCBieXRlOiBudW1iZXIpOiBQQUNEYXRhIHtcclxuICAgIGxldCBwYWNJbmRleCA9IGJ5dGU7XHJcbiAgICBsZXQgcGFjRGF0YTogUEFDRGF0YSA9IHsgY29sb3I6IG51bGwsIGl0YWxpY3M6IGZhbHNlLCBpbmRlbnQ6IG51bGwsIHVuZGVybGluZTogZmFsc2UsIHJvdzogcm93IH07XHJcblxyXG4gICAgaWYgKGJ5dGUgPiAweDVGKSB7XHJcbiAgICAgIHBhY0luZGV4ID0gYnl0ZSAtIDB4NjA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDQwO1xyXG4gICAgfVxyXG5cclxuICAgIHBhY0RhdGEudW5kZXJsaW5lID0gKHBhY0luZGV4ICYgMSkgPT09IDE7XHJcbiAgICBpZiAocGFjSW5kZXggPD0gMHhkKSB7XHJcbiAgICAgIHBhY0RhdGEuY29sb3IgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnd2hpdGUnXVtNYXRoLmZsb29yKHBhY0luZGV4IC8gMildO1xyXG4gICAgfSBlbHNlIGlmIChwYWNJbmRleCA8PSAweGYpIHtcclxuICAgICAgcGFjRGF0YS5pdGFsaWNzID0gdHJ1ZTtcclxuICAgICAgcGFjRGF0YS5jb2xvciA9ICd3aGl0ZSc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYWNEYXRhLmluZGVudCA9IChNYXRoLmZsb29yKChwYWNJbmRleCAtIDB4MTApIC8gMikpICogNDtcclxuICAgIH1cclxuICAgIHJldHVybiBwYWNEYXRhOyAvLyBOb3RlIHRoYXQgcm93IGhhcyB6ZXJvIG9mZnNldC4gVGhlIHNwZWMgdXNlcyAxLlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxyXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCAxIHRvIDIgY29kZXMgY29ycmVzcG9uZGluZyB0byBjaGFycywgaWYgZm91bmQuIG51bGwgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgcGFyc2VDaGFycyAoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXJbXSB8IG51bGwge1xyXG4gICAgbGV0IGNoYW5uZWxOcjogbnVtYmVyIHwgbnVsbCA9IG51bGwsXHJcbiAgICAgIGNoYXJDb2RlczogbnVtYmVyW10gfCBudWxsID0gbnVsbCxcclxuICAgICAgY2hhckNvZGUxOiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICBpZiAoYSA+PSAweDE5KSB7XHJcbiAgICAgIGNoYW5uZWxOciA9IDI7XHJcbiAgICAgIGNoYXJDb2RlMSA9IGEgLSA4O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2hhbm5lbE5yID0gMTtcclxuICAgICAgY2hhckNvZGUxID0gYTtcclxuICAgIH1cclxuICAgIGlmIChjaGFyQ29kZTEgPj0gMHgxMSAmJiBjaGFyQ29kZTEgPD0gMHgxMykge1xyXG4gICAgICAvLyBTcGVjaWFsIGNoYXJhY3RlclxyXG4gICAgICBsZXQgb25lQ29kZSA9IGI7XHJcbiAgICAgIGlmIChjaGFyQ29kZTEgPT09IDB4MTEpIHtcclxuICAgICAgICBvbmVDb2RlID0gYiArIDB4NTA7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUxID09PSAweDEyKSB7XHJcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDcwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9uZUNvZGUgPSBiICsgMHg5MDtcclxuICAgICAgfVxyXG5cclxuICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdTcGVjaWFsIGNoYXIgXFwnJyArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgJ1xcJyBpbiBjaGFubmVsICcgKyBjaGFubmVsTnIpO1xyXG4gICAgICBjaGFyQ29kZXMgPSBbb25lQ29kZV07XHJcbiAgICB9IGVsc2UgaWYgKGEgPj0gMHgyMCAmJiBhIDw9IDB4N2YpIHtcclxuICAgICAgY2hhckNvZGVzID0gKGIgPT09IDApID8gW2FdIDogW2EsIGJdO1xyXG4gICAgfVxyXG4gICAgaWYgKGNoYXJDb2Rlcykge1xyXG4gICAgICBsZXQgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcclxuICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnQ2hhciBjb2RlcyA9ICAnICsgaGV4Q29kZXMuam9pbignLCcpKTtcclxuICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XHJcbiAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoYXJDb2RlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAgKiBQYXJzZSBleHRlbmRlZCBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBuZXcgZm9yZWdyb3VuZCBjb2xvciBibGFjay5cclxuICAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcmUgZm91bmRcclxuICAgICovXHJcbiAgcGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyAoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgIGxldCBia2dEYXRhOiBQYXJ0aWFsPFBlblN0eWxlcz4sXHJcbiAgICAgIGluZGV4OiBudW1iZXIsXHJcbiAgICAgIGNoTnI6IG51bWJlcixcclxuICAgICAgY2hhbm5lbDogQ2VhNjA4Q2hhbm5lbDtcclxuXHJcbiAgICBsZXQgY2FzZTEgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiAoYiA+PSAweDIwICYmIGIgPD0gMHgyZik7XHJcbiAgICBsZXQgY2FzZTIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiAoYiA+PSAweDJkICYmIGIgPD0gMHgyZik7XHJcbiAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGJrZ0RhdGEgPSB7fTtcclxuICAgIGlmIChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpIHtcclxuICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChiIC0gMHgyMCkgLyAyKTtcclxuICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yc1tpbmRleF07XHJcbiAgICAgIGlmIChiICUgMiA9PT0gMSkge1xyXG4gICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJrZ0RhdGEuYmFja2dyb3VuZCArICdfc2VtaSc7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZCkge1xyXG4gICAgICBia2dEYXRhLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYmtnRGF0YS5mb3JlZ3JvdW5kID0gJ2JsYWNrJztcclxuICAgICAgaWYgKGIgPT09IDB4MmYpIHtcclxuICAgICAgICBia2dEYXRhLnVuZGVybGluZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNoTnIgPSAoYSA8IDB4MTgpID8gMSA6IDI7XHJcbiAgICBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XHJcbiAgICBjaGFubmVsLnNldEJrZ0RhdGEoYmtnRGF0YSk7XHJcbiAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcclxuICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICAqIFJlc2V0IHN0YXRlIG9mIHBhcnNlciBhbmQgaXRzIGNoYW5uZWxzLlxyXG4gICAgICovXHJcbiAgcmVzZXQgKCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5yZXNldCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcclxuICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyIHRoZSBnZW5lcmF0aW9uIG9mIGEgY3VlLCBhbmQgdGhlIHN0YXJ0IG9mIGEgbmV3IG9uZSBpZiBkaXNwbGF5U2NyZWVucyBhcmUgbm90IGVtcHR5LlxyXG4gICAgICovXHJcbiAgY3VlU3BsaXRBdFRpbWUgKHQ6IG51bWJlcikge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5jdWVTcGxpdEF0VGltZSh0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2VhNjA4UGFyc2VyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy91dGlscy9jZWEtNjA4LXBhcnNlci50cyIsImltcG9ydCB7IENhcHRpb25TY3JlZW4gfSBmcm9tICcuL2NlYS02MDgtcGFyc2VyJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE91dHB1dEZpbHRlciB7XHJcbiAgdGltZWxpbmVDb250cm9sbGVyOiBhbnk7XHJcbiAgdHJhY2tOYW1lOiBzdHJpbmc7XHJcbiAgc3RhcnRUaW1lOiBudW1iZXIgfCBudWxsO1xyXG4gIGVuZFRpbWU6IG51bWJlciB8IG51bGw7XHJcbiAgc2NyZWVuOiBDYXB0aW9uU2NyZWVuIHwgbnVsbDtcclxuXHJcbiAgLy8gVE9ETyh0eXBlc2NyaXB0LXRpbWVsaW5lQ29udHJvbGxlcilcclxuICBjb25zdHJ1Y3RvciAodGltZWxpbmVDb250cm9sbGVyOiBhbnksIHRyYWNrTmFtZTogc3RyaW5nKSB7XHJcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlciA9IHRpbWVsaW5lQ29udHJvbGxlcjtcclxuICAgIHRoaXMudHJhY2tOYW1lID0gdHJhY2tOYW1lO1xyXG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xyXG4gICAgdGhpcy5lbmRUaW1lID0gbnVsbDtcclxuICAgIHRoaXMuc2NyZWVuID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGRpc3BhdGNoQ3VlICgpIHtcclxuICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIuYWRkQ3Vlcyh0aGlzLnRyYWNrTmFtZSwgdGhpcy5zdGFydFRpbWUsIHRoaXMuZW5kVGltZSwgdGhpcy5zY3JlZW4pO1xyXG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgbmV3Q3VlIChzdGFydFRpbWU6IG51bWJlciwgZW5kVGltZTogbnVtYmVyLCBzY3JlZW46IENhcHRpb25TY3JlZW4pIHtcclxuICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCB8fCB0aGlzLnN0YXJ0VGltZSA+IHN0YXJ0VGltZSkge1xyXG4gICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmVuZFRpbWUgPSBlbmRUaW1lO1xyXG4gICAgdGhpcy5zY3JlZW4gPSBzY3JlZW47XHJcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5jcmVhdGVDYXB0aW9uc1RyYWNrKHRoaXMudHJhY2tOYW1lKTtcclxuICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMvb3V0cHV0LWZpbHRlci50cyIsImltcG9ydCBWVFRQYXJzZXIgZnJvbSAnLi92dHRwYXJzZXInO1xyXG5pbXBvcnQgeyB1dGY4QXJyYXlUb1N0ciB9IGZyb20gJy4uL2RlbXV4L2lkMyc7XHJcblxyXG4vLyBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggaXMgbm90IHN1cHBvcnRlZCBpbiBJRTExXHJcbmNvbnN0IHN0YXJ0c1dpdGggPSBmdW5jdGlvbiAoaW5wdXRTdHJpbmcsIHNlYXJjaFN0cmluZywgcG9zaXRpb24pIHtcclxuICByZXR1cm4gaW5wdXRTdHJpbmcuc3Vic3RyKHBvc2l0aW9uIHx8IDAsIHNlYXJjaFN0cmluZy5sZW5ndGgpID09PSBzZWFyY2hTdHJpbmc7XHJcbn07XHJcblxyXG5jb25zdCBjdWVTdHJpbmcybWlsbGlzID0gZnVuY3Rpb24gKHRpbWVTdHJpbmcpIHtcclxuICBsZXQgdHMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigtMykpO1xyXG4gIGxldCBzZWNzID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTYsIDIpKTtcclxuICBsZXQgbWlucyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC05LCAyKSk7XHJcbiAgbGV0IGhvdXJzID0gdGltZVN0cmluZy5sZW5ndGggPiA5ID8gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoMCwgdGltZVN0cmluZy5pbmRleE9mKCc6JykpKSA6IDA7XHJcblxyXG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHRzKSB8fCAhTnVtYmVyLmlzRmluaXRlKHNlY3MpIHx8ICFOdW1iZXIuaXNGaW5pdGUobWlucykgfHwgIU51bWJlci5pc0Zpbml0ZShob3VycykpIHtcclxuICAgIHRocm93IEVycm9yKGBNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiBMb2NhbDoke3RpbWVTdHJpbmd9YCk7XHJcbiAgfVxyXG5cclxuICB0cyArPSAxMDAwICogc2VjcztcclxuICB0cyArPSA2MCAqIDEwMDAgKiBtaW5zO1xyXG4gIHRzICs9IDYwICogNjAgKiAxMDAwICogaG91cnM7XHJcblxyXG4gIHJldHVybiB0cztcclxufTtcclxuXHJcbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2hcclxuY29uc3QgaGFzaCA9IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgbGV0IGhhc2ggPSA1MzgxO1xyXG4gIGxldCBpID0gdGV4dC5sZW5ndGg7XHJcbiAgd2hpbGUgKGkpIHtcclxuICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHRleHQuY2hhckNvZGVBdCgtLWkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIChoYXNoID4+PiAwKS50b1N0cmluZygpO1xyXG59O1xyXG5cclxuY29uc3QgY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpIHtcclxuICBsZXQgY3VyckNDID0gdnR0Q0NzW2NjXTtcclxuICBsZXQgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xyXG5cclxuICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBkaXNjb250aW51aXR5IG9yIGN1ZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCBzaW5jZSB0aGUgbGFzdCBkaXNjb250aW51aXR5XHJcbiAgLy8gT2Zmc2V0ID0gY3VycmVudCBkaXNjb250aW51aXR5IHRpbWVcclxuICBpZiAoIXByZXZDQyB8fCAoIXByZXZDQy5uZXcgJiYgY3VyckNDLm5ldykpIHtcclxuICAgIHZ0dENDcy5jY09mZnNldCA9IHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XHJcbiAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBUaGVyZSBoYXZlIGJlZW4gZGlzY29udGludWl0aWVzIHNpbmNlIGN1ZXMgd2VyZSBsYXN0IHBhcnNlZC5cclxuICAvLyBPZmZzZXQgPSB0aW1lIGVsYXBzZWRcclxuICB3aGlsZSAocHJldkNDICYmIHByZXZDQy5uZXcpIHtcclxuICAgIHZ0dENDcy5jY09mZnNldCArPSBjdXJyQ0Muc3RhcnQgLSBwcmV2Q0Muc3RhcnQ7XHJcbiAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XHJcbiAgICBjdXJyQ0MgPSBwcmV2Q0M7XHJcbiAgICBwcmV2Q0MgPSB2dHRDQ3NbY3VyckNDLnByZXZDQ107XHJcbiAgfVxyXG5cclxuICB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0ID0gcHJlc2VudGF0aW9uVGltZTtcclxufTtcclxuXHJcbmNvbnN0IFdlYlZUVFBhcnNlciA9IHtcclxuICBwYXJzZTogZnVuY3Rpb24gKHZ0dEJ5dGVBcnJheSwgc3luY1BUUywgdnR0Q0NzLCBjYywgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcclxuICAgIC8vIENvbnZlcnQgYnl0ZUFycmF5IGludG8gc3RyaW5nLCByZXBsYWNpbmcgYW55IHNvbWV3aGF0IGV4b3RpYyBsaW5lZmVlZHMgd2l0aCBcIlxcblwiLCB0aGVuIHNwbGl0IG9uIHRoYXQgY2hhcmFjdGVyLlxyXG4gICAgbGV0IHJlID0gL1xcclxcbnxcXG5cXHJ8XFxufFxcci9nO1xyXG4gICAgLy8gVWludDhBcnJheS5wcm90b3R5cGUucmVkdWNlIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBJRTExXHJcbiAgICBsZXQgdnR0TGluZXMgPSB1dGY4QXJyYXlUb1N0cihuZXcgVWludDhBcnJheSh2dHRCeXRlQXJyYXkpKS50cmltKCkucmVwbGFjZShyZSwgJ1xcbicpLnNwbGl0KCdcXG4nKTtcclxuXHJcbiAgICBsZXQgY3VlVGltZSA9ICcwMDowMC4wMDAnO1xyXG4gICAgbGV0IG1wZWdUcyA9IDA7XHJcbiAgICBsZXQgbG9jYWxUaW1lID0gMDtcclxuICAgIGxldCBwcmVzZW50YXRpb25UaW1lID0gMDtcclxuICAgIGxldCBjdWVzID0gW107XHJcbiAgICBsZXQgcGFyc2luZ0Vycm9yO1xyXG4gICAgbGV0IGluSGVhZGVyID0gdHJ1ZTtcclxuICAgIGxldCB0aW1lc3RhbXBNYXAgPSBmYWxzZTtcclxuICAgIC8vIGxldCBWVFRDdWUgPSBWVFRDdWUgfHwgd2luZG93LlRleHRUcmFja0N1ZTtcclxuXHJcbiAgICAvLyBDcmVhdGUgcGFyc2VyIG9iamVjdCB1c2luZyBWVFRDdWUgd2l0aCBUZXh0VHJhY2tDdWUgZmFsbGJhY2sgb24gY2VydGFpbiBicm93c2Vycy5cclxuICAgIGxldCBwYXJzZXIgPSBuZXcgVlRUUGFyc2VyKCk7XHJcblxyXG4gICAgcGFyc2VyLm9uY3VlID0gZnVuY3Rpb24gKGN1ZSkge1xyXG4gICAgICAvLyBBZGp1c3QgY3VlIHRpbWluZzsgY2xhbXAgY3VlcyB0byBzdGFydCBubyBlYXJsaWVyIHRoYW4gLSBhbmQgZHJvcCBjdWVzIHRoYXQgZG9uJ3QgZW5kIGFmdGVyIC0gMCBvbiB0aW1lbGluZS5cclxuICAgICAgbGV0IGN1cnJDQyA9IHZ0dENDc1tjY107XHJcbiAgICAgIGxldCBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQ7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgb2Zmc2V0cyBmb3IgbmV3IGRpc2NvbnRpbnVpdGllc1xyXG4gICAgICBpZiAoY3VyckNDICYmIGN1cnJDQy5uZXcpIHtcclxuICAgICAgICBpZiAobG9jYWxUaW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIC8vIFdoZW4gbG9jYWwgdGltZSBpcyBwcm92aWRlZCwgb2Zmc2V0ID0gZGlzY29udGludWl0eSBzdGFydCB0aW1lIC0gbG9jYWwgdGltZVxyXG4gICAgICAgICAgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0ID0gY3VyckNDLnN0YXJ0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjYWxjdWxhdGVPZmZzZXQodnR0Q0NzLCBjYywgcHJlc2VudGF0aW9uVGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocHJlc2VudGF0aW9uVGltZSkge1xyXG4gICAgICAgIC8vIElmIHdlIGhhdmUgTVBFR1RTLCBvZmZzZXQgPSBwcmVzZW50YXRpb24gdGltZSArIGRpc2NvbnRpbnVpdHkgb2Zmc2V0XHJcbiAgICAgICAgY3VlT2Zmc2V0ID0gcHJlc2VudGF0aW9uVGltZSAtIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aW1lc3RhbXBNYXApIHtcclxuICAgICAgICBjdWUuc3RhcnRUaW1lICs9IGN1ZU9mZnNldCAtIGxvY2FsVGltZTtcclxuICAgICAgICBjdWUuZW5kVGltZSArPSBjdWVPZmZzZXQgLSBsb2NhbFRpbWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBoYXNoIGlkIGZvciBhIGN1ZSBiYXNlZCBvbiBzdGFydC9lbmQgdGltZXMgYW5kIHRleHQuXHJcbiAgICAgIC8vIFRoaXMgaGVscHMgdGltZWxpbmUtY29udHJvbGxlciB0byBhdm9pZCBzaG93aW5nIHJlcGVhdGVkIGNhcHRpb25zLlxyXG4gICAgICBjdWUuaWQgPSBoYXNoKGN1ZS5zdGFydFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKGN1ZS5lbmRUaW1lLnRvU3RyaW5nKCkpICsgaGFzaChjdWUudGV4dCk7XHJcblxyXG4gICAgICAvLyBGaXggZW5jb2Rpbmcgb2Ygc3BlY2lhbCBjaGFyYWN0ZXJzLiBUT0RPOiBUZXN0IHdpdGggYWxsIHNvcnRzIG9mIHdlaXJkIGNoYXJhY3RlcnMuXHJcbiAgICAgIGN1ZS50ZXh0ID0gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudChjdWUudGV4dCkpO1xyXG4gICAgICBpZiAoY3VlLmVuZFRpbWUgPiAwKSB7XHJcbiAgICAgICAgY3Vlcy5wdXNoKGN1ZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgcGFyc2luZ0Vycm9yID0gZTtcclxuICAgIH07XHJcblxyXG4gICAgcGFyc2VyLm9uZmx1c2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChwYXJzaW5nRXJyb3IgJiYgZXJyb3JDYWxsQmFjaykge1xyXG4gICAgICAgIGVycm9yQ2FsbEJhY2socGFyc2luZ0Vycm9yKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY2FsbEJhY2soY3Vlcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEdvIHRocm91Z2ggY29udGVudHMgbGluZSBieSBsaW5lLlxyXG4gICAgdnR0TGluZXMuZm9yRWFjaChsaW5lID0+IHtcclxuICAgICAgaWYgKGluSGVhZGVyKSB7XHJcbiAgICAgICAgLy8gTG9vayBmb3IgWC1USU1FU1RBTVAtTUFQIGluIGhlYWRlci5cclxuICAgICAgICBpZiAoc3RhcnRzV2l0aChsaW5lLCAnWC1USU1FU1RBTVAtTUFQPScpKSB7XHJcbiAgICAgICAgICAvLyBPbmNlIGZvdW5kLCBubyBtb3JlIGFyZSBhbGxvd2VkIGFueXdheSwgc28gc3RvcCBzZWFyY2hpbmcuXHJcbiAgICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgdGltZXN0YW1wTWFwID0gdHJ1ZTtcclxuICAgICAgICAgIC8vIEV4dHJhY3QgTE9DQUwgYW5kIE1QRUdUUy5cclxuICAgICAgICAgIGxpbmUuc3Vic3RyKDE2KS5zcGxpdCgnLCcpLmZvckVhY2godGltZXN0YW1wID0+IHtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTE9DQUw6JykpIHtcclxuICAgICAgICAgICAgICBjdWVUaW1lID0gdGltZXN0YW1wLnN1YnN0cig2KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydHNXaXRoKHRpbWVzdGFtcCwgJ01QRUdUUzonKSkge1xyXG4gICAgICAgICAgICAgIG1wZWdUcyA9IHBhcnNlSW50KHRpbWVzdGFtcC5zdWJzdHIoNykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzdWJ0aXRsZSBvZmZzZXQgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICAgICAgICBpZiAoc3luY1BUUyArICgodnR0Q0NzW2NjXS5zdGFydCAqIDkwMDAwKSB8fCAwKSA8IDApIHtcclxuICAgICAgICAgICAgICBzeW5jUFRTICs9IDg1ODk5MzQ1OTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWRqdXN0IE1QRUdUUyBieSBzeW5jIFBUUy5cclxuICAgICAgICAgICAgbXBlZ1RzIC09IHN5bmNQVFM7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgY3VlIHRpbWUgdG8gc2Vjb25kc1xyXG4gICAgICAgICAgICBsb2NhbFRpbWUgPSBjdWVTdHJpbmcybWlsbGlzKGN1ZVRpbWUpIC8gMTAwMDtcclxuICAgICAgICAgICAgLy8gQ29udmVydCBNUEVHVFMgdG8gc2Vjb25kcyBmcm9tIDkwa0h6LlxyXG4gICAgICAgICAgICBwcmVzZW50YXRpb25UaW1lID0gbXBlZ1RzIC8gOTAwMDA7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcE1hcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBwYXJzaW5nRXJyb3IgPSBlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gUmV0dXJuIHdpdGhvdXQgcGFyc2luZyBYLVRJTUVTVEFNUC1NQVAgbGluZS5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGVsc2UgaWYgKGxpbmUgPT09ICcnKSB7XHJcbiAgICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBQYXJzZSBsaW5lIGJ5IGRlZmF1bHQuXHJcbiAgICAgIHBhcnNlci5wYXJzZShsaW5lICsgJ1xcbicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcGFyc2VyLmZsdXNoKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgV2ViVlRUUGFyc2VyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy91dGlscy93ZWJ2dHQtcGFyc2VyLmpzIiwiaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcbmltcG9ydCB7IGNvbXB1dGVSZWxvYWRJbnRlcnZhbCB9IGZyb20gJy4vbGV2ZWwtaGVscGVyJztcclxuaW1wb3J0IHsgY2xlYXJDdXJyZW50Q3VlcyB9IGZyb20gJy4uL3V0aWxzL3RleHR0cmFjay11dGlscyc7XHJcblxyXG5jbGFzcyBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcbiAgY29uc3RydWN0b3IgKGhscykge1xyXG4gICAgc3VwZXIoaGxzLFxyXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcclxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxyXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FERUQsXHJcbiAgICAgIEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURFRCk7XHJcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xyXG4gICAgdGhpcy50cmFja0lkID0gLTE7XHJcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcclxuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBzdWJ0aXRsZURpc3BsYXkgRW5hYmxlL2Rpc2FibGUgc3VidGl0bGUgZGlzcGxheSByZW5kZXJpbmdcclxuICAgICAqL1xyXG4gICAgdGhpcy5zdWJ0aXRsZURpc3BsYXkgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2VlcHMgcmVmZXJlbmNlIHRvIGEgZGVmYXVsdCB0cmFjayBpZCB3aGVuIG1lZGlhIGhhcyBub3QgYmVlbiBhdHRhY2hlZCB5ZXRcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSAoKSB7XHJcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8vIExpc3RlbiBmb3Igc3VidGl0bGUgdHJhY2sgY2hhbmdlLCB0aGVuIGV4dHJhY3QgdGhlIGN1cnJlbnQgdHJhY2sgSUQuXHJcbiAgb25NZWRpYUF0dGFjaGVkIChkYXRhKSB7XHJcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcclxuICAgIGlmICghdGhpcy5tZWRpYSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZSh0aGlzLnF1ZXVlZERlZmF1bHRUcmFjaykpIHtcclxuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2s7XHJcbiAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIgPSB0aGlzLl9vblRleHRUcmFja3NDaGFuZ2VkLmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nID0gISh0aGlzLm1lZGlhLnRleHRUcmFja3MgJiYgJ29uY2hhbmdlJyBpbiB0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xyXG4gICAgaWYgKHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xyXG4gICAgICB0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lcigpO1xyXG4gICAgICB9LCA1MDApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcclxuICAgIGlmICghdGhpcy5tZWRpYSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xyXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lcik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZSh0aGlzLnN1YnRpdGxlVHJhY2spKSB7XHJcbiAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gdGhpcy5zdWJ0aXRsZVRyYWNrO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRleHRUcmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xyXG4gICAgLy8gQ2xlYXIgbG9hZGVkIGN1ZXMgb24gbWVkaWEgZGV0YWNobWVudCBmcm9tIHRyYWNrc1xyXG4gICAgdGV4dFRyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4ge1xyXG4gICAgICBjbGVhckN1cnJlbnRDdWVzKHRyYWNrKTtcclxuICAgIH0pO1xyXG4gICAgLy8gRGlzYWJsZSBhbGwgc3VidGl0bGUgdHJhY2tzIGJlZm9yZSBkZXRhY2htZW50IHNvIHdoZW4gcmVhdHRhY2hlZCBvbmx5IHRyYWNrcyBpbiB0aGF0IGNvbnRlbnQgYXJlIGVuYWJsZWQuXHJcbiAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSAtMTtcclxuICAgIHRoaXMubWVkaWEgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gRmlyZWQgd2hlbmV2ZXIgYSBuZXcgbWFuaWZlc3QgaXMgbG9hZGVkLlxyXG4gIG9uTWFuaWZlc3RMb2FkZWQgKGRhdGEpIHtcclxuICAgIGxldCB0cmFja3MgPSBkYXRhLnN1YnRpdGxlcyB8fCBbXTtcclxuICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xyXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgeyBzdWJ0aXRsZVRyYWNrczogdHJhY2tzIH0pO1xyXG5cclxuICAgIC8vIGxvb3AgdGhyb3VnaCBhdmFpbGFibGUgc3VidGl0bGUgdHJhY2tzIGFuZCBhdXRvc2VsZWN0IGRlZmF1bHQgaWYgbmVlZGVkXHJcbiAgICAvLyBUT0RPOiBpbXByb3ZlIHNlbGVjdGlvbiBsb2dpYyB0byBoYW5kbGUgZm9yY2VkLCBldGNcclxuICAgIHRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcclxuICAgICAgaWYgKHRyYWNrLmRlZmF1bHQpIHtcclxuICAgICAgICAvLyBzZXR0aW5nIHRoaXMuc3VidGl0bGVUcmFjayB3aWxsIHRyaWdnZXIgaW50ZXJuYWwgbG9naWNcclxuICAgICAgICAvLyBpZiBtZWRpYSBoYXMgbm90IGJlZW4gYXR0YWNoZWQgeWV0LCBpdCB3aWxsIGZhaWxcclxuICAgICAgICAvLyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBkZWZhdWx0IHRyYWNrIGlkXHJcbiAgICAgICAgLy8gYW5kIHdlJ2xsIHNldCBzdWJ0aXRsZVRyYWNrIHdoZW4gb25NZWRpYUF0dGFjaGVkIGlzIHRyaWdnZXJlZFxyXG4gICAgICAgIGlmICh0aGlzLm1lZGlhKSB7XHJcbiAgICAgICAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSB0cmFjay5pZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSB0cmFjay5pZDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGVkIChkYXRhKSB7XHJcbiAgICBjb25zdCB7IGlkLCBkZXRhaWxzIH0gPSBkYXRhO1xyXG4gICAgY29uc3QgeyB0cmFja0lkLCB0cmFja3MgfSA9IHRoaXM7XHJcbiAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0cmFja3NbdHJhY2tJZF07XHJcbiAgICBpZiAoaWQgPj0gdHJhY2tzLmxlbmd0aCB8fCBpZCAhPT0gdHJhY2tJZCB8fCAhY3VycmVudFRyYWNrIHx8IHRoaXMuc3RvcHBlZCkge1xyXG4gICAgICB0aGlzLl9jbGVhclJlbG9hZFRpbWVyKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBsb2dnZXIubG9nKGBzdWJ0aXRsZSB0cmFjayAke2lkfSBsb2FkZWRgKTtcclxuICAgIGlmIChkZXRhaWxzLmxpdmUpIHtcclxuICAgICAgY29uc3QgcmVsb2FkSW50ZXJ2YWwgPSBjb21wdXRlUmVsb2FkSW50ZXJ2YWwoY3VycmVudFRyYWNrLmRldGFpbHMsIGRldGFpbHMsIGRhdGEuc3RhdHMudHJlcXVlc3QpO1xyXG4gICAgICBsb2dnZXIubG9nKGBSZWxvYWRpbmcgbGl2ZSBzdWJ0aXRsZSBwbGF5bGlzdCBpbiAke3JlbG9hZEludGVydmFsfW1zYCk7XHJcbiAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLl9sb2FkQ3VycmVudFRyYWNrKCk7XHJcbiAgICAgIH0sIHJlbG9hZEludGVydmFsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2NsZWFyUmVsb2FkVGltZXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXJ0TG9hZCAoKSB7XHJcbiAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2xvYWRDdXJyZW50VHJhY2soKTtcclxuICB9XHJcblxyXG4gIHN0b3BMb2FkICgpIHtcclxuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XHJcbiAgICB0aGlzLl9jbGVhclJlbG9hZFRpbWVyKCk7XHJcbiAgfVxyXG5cclxuICAvKiogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xyXG4gIGdldCBzdWJ0aXRsZVRyYWNrcyAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFja3M7XHJcbiAgfVxyXG5cclxuICAvKiogZ2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpICoqL1xyXG4gIGdldCBzdWJ0aXRsZVRyYWNrICgpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XHJcbiAgfVxyXG5cclxuICAvKiogc2VsZWN0IGEgc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cyoqL1xyXG4gIHNldCBzdWJ0aXRsZVRyYWNrIChzdWJ0aXRsZVRyYWNrSWQpIHtcclxuICAgIGlmICh0aGlzLnRyYWNrSWQgIT09IHN1YnRpdGxlVHJhY2tJZCkge1xyXG4gICAgICB0aGlzLl90b2dnbGVUcmFja01vZGVzKHN1YnRpdGxlVHJhY2tJZCk7XHJcbiAgICAgIHRoaXMuX3NldFN1YnRpdGxlVHJhY2tJbnRlcm5hbChzdWJ0aXRsZVRyYWNrSWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2NsZWFyUmVsb2FkVGltZXIgKCkge1xyXG4gICAgaWYgKHRoaXMudGltZXIpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xyXG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9sb2FkQ3VycmVudFRyYWNrICgpIHtcclxuICAgIGNvbnN0IHsgdHJhY2tJZCwgdHJhY2tzLCBobHMgfSA9IHRoaXM7XHJcbiAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0cmFja3NbdHJhY2tJZF07XHJcbiAgICBpZiAodHJhY2tJZCA8IDAgfHwgIWN1cnJlbnRUcmFjayB8fCAoY3VycmVudFRyYWNrLmRldGFpbHMgJiYgIWN1cnJlbnRUcmFjay5kZXRhaWxzLmxpdmUpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxvZ2dlci5sb2coYExvYWRpbmcgc3VidGl0bGUgdHJhY2sgJHt0cmFja0lkfWApO1xyXG4gICAgaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BRElORywgeyB1cmw6IGN1cnJlbnRUcmFjay51cmwsIGlkOiB0cmFja0lkIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzYWJsZXMgdGhlIG9sZCBzdWJ0aXRsZVRyYWNrIGFuZCBzZXRzIGN1cnJlbnQgbW9kZSBvbiB0aGUgbmV4dCBzdWJ0aXRsZVRyYWNrLlxyXG4gICAqIFRoaXMgb3BlcmF0ZXMgb24gdGhlIERPTSB0ZXh0VHJhY2tzLlxyXG4gICAqIEEgdmFsdWUgb2YgLTEgd2lsbCBkaXNhYmxlIGFsbCBzdWJ0aXRsZSB0cmFja3MuXHJcbiAgICogQHBhcmFtIG5ld0lkIC0gVGhlIGlkIG9mIHRoZSBuZXh0IHRyYWNrIHRvIGVuYWJsZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3RvZ2dsZVRyYWNrTW9kZXMgKG5ld0lkKSB7XHJcbiAgICBjb25zdCB7IG1lZGlhLCBzdWJ0aXRsZURpc3BsYXksIHRyYWNrSWQgfSA9IHRoaXM7XHJcbiAgICBpZiAoIW1lZGlhKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0ZXh0VHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3MobWVkaWEudGV4dFRyYWNrcyk7XHJcbiAgICBpZiAobmV3SWQgPT09IC0xKSB7XHJcbiAgICAgIFtdLnNsaWNlLmNhbGwodGV4dFRyYWNrcykuZm9yRWFjaCh0cmFjayA9PiB7XHJcbiAgICAgICAgdHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3Qgb2xkVHJhY2sgPSB0ZXh0VHJhY2tzW3RyYWNrSWRdO1xyXG4gICAgICBpZiAob2xkVHJhY2spIHtcclxuICAgICAgICBvbGRUcmFjay5tb2RlID0gJ2Rpc2FibGVkJztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5leHRUcmFjayA9IHRleHRUcmFja3NbbmV3SWRdO1xyXG4gICAgaWYgKG5leHRUcmFjaykge1xyXG4gICAgICBuZXh0VHJhY2subW9kZSA9IHN1YnRpdGxlRGlzcGxheSA/ICdzaG93aW5nJyA6ICdoaWRkZW4nO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgdmFsaWRhdGluZyB0aGUgc3VidGl0bGUgaW5kZXggYW5kIHBlcmlvZGljYWxseSByZWxvYWRpbmcgaWYgbGl2ZS5cclxuICAgICAqIERpc3BhdGNoZXMgdGhlIFNVQlRJVExFX1RSQUNLX1NXSVRDSCBldmVudCwgd2hpY2ggaW5zdHJ1Y3RzIHRoZSBzdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlciB0byBsb2FkIHRoZSBzZWxlY3RlZCB0cmFjay5cclxuICAgICAqIEBwYXJhbSBuZXdJZCAtIFRoZSBpZCBvZiB0aGUgc3VidGl0bGUgdHJhY2sgdG8gYWN0aXZhdGUuXHJcbiAgICAgKi9cclxuICBfc2V0U3VidGl0bGVUcmFja0ludGVybmFsIChuZXdJZCkge1xyXG4gICAgY29uc3QgeyBobHMsIHRyYWNrcyB9ID0gdGhpcztcclxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG5ld0lkKSB8fCBuZXdJZCA8IC0xIHx8IG5ld0lkID49IHRyYWNrcy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xyXG4gICAgbG9nZ2VyLmxvZyhgU3dpdGNoaW5nIHRvIHN1YnRpdGxlIHRyYWNrICR7bmV3SWR9YCk7XHJcbiAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHsgaWQ6IG5ld0lkIH0pO1xyXG4gICAgdGhpcy5fbG9hZEN1cnJlbnRUcmFjaygpO1xyXG4gIH1cclxuXHJcbiAgX29uVGV4dFRyYWNrc0NoYW5nZWQgKCkge1xyXG4gICAgLy8gTWVkaWEgaXMgdW5kZWZpbmVkIHdoZW4gc3dpdGNoaW5nIHN0cmVhbXMgdmlhIGxvYWRTb3VyY2UoKVxyXG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgdHJhY2tJZCA9IC0xO1xyXG4gICAgbGV0IHRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XHJcbiAgICBmb3IgKGxldCBpZCA9IDA7IGlkIDwgdHJhY2tzLmxlbmd0aDsgaWQrKykge1xyXG4gICAgICBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnaGlkZGVuJykge1xyXG4gICAgICAgIC8vIERvIG5vdCBicmVhayBpbiBjYXNlIHRoZXJlIGlzIGEgZm9sbG93aW5nIHRyYWNrIHdpdGggc2hvd2luZy5cclxuICAgICAgICB0cmFja0lkID0gaWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnc2hvd2luZycpIHtcclxuICAgICAgICB0cmFja0lkID0gaWQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXR0aW5nIGN1cnJlbnQgc3VidGl0bGVUcmFjayB3aWxsIGludm9rZSBjb2RlLlxyXG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdHJhY2tJZDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbHRlclN1YnRpdGxlVHJhY2tzICh0ZXh0VHJhY2tMaXN0KSB7XHJcbiAgbGV0IHRyYWNrcyA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgdHJhY2sgPSB0ZXh0VHJhY2tMaXN0W2ldO1xyXG4gICAgLy8gRWRnZSBhZGRzIGEgdHJhY2sgd2l0aG91dCBhIGxhYmVsOyB3ZSBkb24ndCB3YW50IHRvIHVzZSBpdFxyXG4gICAgaWYgKHRyYWNrLmtpbmQgPT09ICdzdWJ0aXRsZXMnICYmIHRyYWNrLmxhYmVsKSB7XHJcbiAgICAgIHRyYWNrcy5wdXNoKHRleHRUcmFja0xpc3RbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJhY2tzO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyLmpzIiwiLyoqXHJcbiAqIEBjbGFzcyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJcclxuICovXHJcblxyXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcclxuaW1wb3J0IERlY3J5cHRlciBmcm9tICcuLi9jcnlwdC9kZWNyeXB0ZXInO1xyXG5pbXBvcnQgeyBCdWZmZXJIZWxwZXIgfSBmcm9tICcuLi91dGlscy9idWZmZXItaGVscGVyJztcclxuaW1wb3J0IHsgZmluZEZyYWdtZW50QnlQRFQsIGZpbmRGcmFnbWVudEJ5UFRTIH0gZnJvbSAnLi9mcmFnbWVudC1maW5kZXJzJztcclxuaW1wb3J0IHsgRnJhZ21lbnRTdGF0ZSB9IGZyb20gJy4vZnJhZ21lbnQtdHJhY2tlcic7XHJcbmltcG9ydCBCYXNlU3RyZWFtQ29udHJvbGxlciwgeyBTdGF0ZSB9IGZyb20gJy4vYmFzZS1zdHJlYW0tY29udHJvbGxlcic7XHJcbmltcG9ydCB7IG1lcmdlU3VidGl0bGVQbGF5bGlzdHMgfSBmcm9tICcuL2xldmVsLWhlbHBlcic7XHJcblxyXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSB3aW5kb3c7XHJcbmNvbnN0IFRJQ0tfSU5URVJWQUwgPSA1MDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXHJcblxyXG5leHBvcnQgY2xhc3MgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgQmFzZVN0cmVhbUNvbnRyb2xsZXIge1xyXG4gIGNvbnN0cnVjdG9yIChobHMsIGZyYWdtZW50VHJhY2tlcikge1xyXG4gICAgc3VwZXIoaGxzLFxyXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcclxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxyXG4gICAgICBFdmVudC5FUlJPUixcclxuICAgICAgRXZlbnQuS0VZX0xPQURFRCxcclxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXHJcbiAgICAgIEV2ZW50LlNVQlRJVExFX1RSQUNLU19VUERBVEVELFxyXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsXHJcbiAgICAgIEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURFRCxcclxuICAgICAgRXZlbnQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsXHJcbiAgICAgIEV2ZW50LkxFVkVMX1VQREFURUQpO1xyXG5cclxuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xyXG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XHJcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xyXG4gICAgdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xyXG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IC0xO1xyXG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKGhscywgaGxzLmNvbmZpZyk7XHJcbiAgICAvLyBsYXN0QVZTdGFydCBzdG9yZXMgdGhlIHRpbWUgaW4gc2Vjb25kcyBmb3IgdGhlIHN0YXJ0IHRpbWUgb2YgYSBsZXZlbCBsb2FkXHJcbiAgICB0aGlzLmxhc3RBVlN0YXJ0ID0gMDtcclxuICAgIHRoaXMuX29uTWVkaWFTZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgb25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQgKGRhdGEpIHtcclxuICAgIGNvbnN0IHsgZnJhZywgc3VjY2VzcyB9ID0gZGF0YTtcclxuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcclxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBidWZmZXJlZCA9IHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF07XHJcbiAgICBpZiAoIWJ1ZmZlcmVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUvdXBkYXRlIGEgYnVmZmVyZWQgYXJyYXkgbWF0Y2hpbmcgdGhlIGludGVyZmFjZSB1c2VkIGJ5IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm9cclxuICAgIC8vIHNvIHdlIGNhbiByZS11c2UgdGhlIGxvZ2ljIHVzZWQgdG8gZGV0ZWN0IGhvdyBtdWNoIGhhdmUgYmVlbiBidWZmZXJlZFxyXG4gICAgbGV0IHRpbWVSYW5nZTtcclxuICAgIGNvbnN0IGZyYWdTdGFydCA9IGZyYWcuc3RhcnQ7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChmcmFnU3RhcnQgPj0gYnVmZmVyZWRbaV0uc3RhcnQgJiYgZnJhZ1N0YXJ0IDw9IGJ1ZmZlcmVkW2ldLmVuZCkge1xyXG4gICAgICAgIHRpbWVSYW5nZSA9IGJ1ZmZlcmVkW2ldO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZnJhZ0VuZCA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xyXG4gICAgaWYgKHRpbWVSYW5nZSkge1xyXG4gICAgICB0aW1lUmFuZ2UuZW5kID0gZnJhZ0VuZDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRpbWVSYW5nZSA9IHtcclxuICAgICAgICBzdGFydDogZnJhZ1N0YXJ0LFxyXG4gICAgICAgIGVuZDogZnJhZ0VuZFxyXG4gICAgICB9O1xyXG4gICAgICBidWZmZXJlZC5wdXNoKHRpbWVSYW5nZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbk1lZGlhQXR0YWNoZWQgKHsgbWVkaWEgfSkge1xyXG4gICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xyXG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMuX29uTWVkaWFTZWVraW5nKTtcclxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYURldGFjaGluZyAoKSB7XHJcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5fb25NZWRpYVNlZWtpbmcpO1xyXG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XHJcbiAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gLTE7XHJcbiAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4ge1xyXG4gICAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkW3RyYWNrLmlkXSA9IFtdO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcclxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgc29tZXRoaW5nIGdvZXMgd3JvbmcsIHByb2NlZWQgdG8gbmV4dCBmcmFnLCBpZiB3ZSB3ZXJlIHByb2Nlc3Npbmcgb25lLlxyXG4gIG9uRXJyb3IgKGRhdGEpIHtcclxuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xyXG4gICAgLy8gZG9uJ3QgaGFuZGxlIGVycm9yIG5vdCByZWxhdGVkIHRvIHN1YnRpdGxlIGZyYWdtZW50XHJcbiAgICBpZiAoIWZyYWcgfHwgZnJhZy50eXBlICE9PSAnc3VidGl0bGUnKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gIH1cclxuXHJcbiAgLy8gR290IGFsbCBuZXcgc3VidGl0bGUgdHJhY2tzLlxyXG4gIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkIChkYXRhKSB7XHJcbiAgICBsb2dnZXIubG9nKCdzdWJ0aXRsZSB0cmFja3MgdXBkYXRlZCcpO1xyXG4gICAgdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xyXG4gICAgdGhpcy50cmFja3MgPSBkYXRhLnN1YnRpdGxlVHJhY2tzO1xyXG4gICAgdGhpcy50cmFja3MuZm9yRWFjaCgodHJhY2spID0+IHtcclxuICAgICAgdGhpcy50cmFja3NCdWZmZXJlZFt0cmFjay5pZF0gPSBbXTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgb25TdWJ0aXRsZVRyYWNrU3dpdGNoIChkYXRhKSB7XHJcbiAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gZGF0YS5pZDtcclxuXHJcbiAgICBpZiAoIXRoaXMudHJhY2tzIHx8ICF0aGlzLnRyYWNrcy5sZW5ndGggfHwgdGhpcy5jdXJyZW50VHJhY2tJZCA9PT0gLTEpIHtcclxuICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiB0cmFjayBoYXMgdGhlIG5lY2Vzc2FyeSBkZXRhaWxzIHRvIGxvYWQgZnJhZ21lbnRzXHJcbiAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLmN1cnJlbnRUcmFja0lkXTtcclxuICAgIGlmIChjdXJyZW50VHJhY2sgJiYgY3VycmVudFRyYWNrLmRldGFpbHMpIHtcclxuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEdvdCBhIG5ldyBzZXQgb2Ygc3VidGl0bGUgZnJhZ21lbnRzLlxyXG4gIG9uU3VidGl0bGVUcmFja0xvYWRlZCAoZGF0YSkge1xyXG4gICAgY29uc3QgeyBpZCwgZGV0YWlscyB9ID0gZGF0YTtcclxuICAgIGNvbnN0IHsgY3VycmVudFRyYWNrSWQsIHRyYWNrcyB9ID0gdGhpcztcclxuICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRyYWNrc1tjdXJyZW50VHJhY2tJZF07XHJcbiAgICBpZiAoaWQgPj0gdHJhY2tzLmxlbmd0aCB8fCBpZCAhPT0gY3VycmVudFRyYWNrSWQgfHwgIWN1cnJlbnRUcmFjaykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRldGFpbHMubGl2ZSkge1xyXG4gICAgICBtZXJnZVN1YnRpdGxlUGxheWxpc3RzKGN1cnJlbnRUcmFjay5kZXRhaWxzLCBkZXRhaWxzLCB0aGlzLmxhc3RBVlN0YXJ0KTtcclxuICAgIH1cclxuICAgIGN1cnJlbnRUcmFjay5kZXRhaWxzID0gZGV0YWlscztcclxuICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XHJcbiAgfVxyXG5cclxuICBvbktleUxvYWRlZCAoKSB7XHJcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkZyYWdMb2FkZWQgKGRhdGEpIHtcclxuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcclxuICAgIGNvbnN0IGRlY3J5cHREYXRhID0gZGF0YS5mcmFnLmRlY3J5cHRkYXRhO1xyXG4gICAgY29uc3QgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcclxuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xyXG5cclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgJiZcclxuICAgICAgICBmcmFnQ3VycmVudCAmJlxyXG4gICAgICAgIGRhdGEuZnJhZy50eXBlID09PSAnc3VidGl0bGUnICYmXHJcbiAgICAgICAgZnJhZ0N1cnJlbnQuc24gPT09IGRhdGEuZnJhZy5zbikge1xyXG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgZGVjcnlwdGVkXHJcbiAgICAgIGlmIChkYXRhLnBheWxvYWQuYnl0ZUxlbmd0aCA+IDAgJiYgKGRlY3J5cHREYXRhICYmIGRlY3J5cHREYXRhLmtleSAmJiBkZWNyeXB0RGF0YS5tZXRob2QgPT09ICdBRVMtMTI4JykpIHtcclxuICAgICAgICBsZXQgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcblxyXG4gICAgICAgIC8vIGRlY3J5cHQgdGhlIHN1YnRpdGxlc1xyXG4gICAgICAgIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZGF0YS5wYXlsb2FkLCBkZWNyeXB0RGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0RGF0YS5pdi5idWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XHJcbiAgICAgICAgICBsZXQgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19ERUNSWVBURUQsIHsgZnJhZzogZnJhZ0xvYWRlZCwgcGF5bG9hZDogZGVjcnlwdGVkRGF0YSwgc3RhdHM6IHsgdHN0YXJ0OiBzdGFydFRpbWUsIHRkZWNyeXB0OiBlbmRUaW1lIH0gfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uTGV2ZWxVcGRhdGVkICh7IGRldGFpbHMgfSkge1xyXG4gICAgY29uc3QgZnJhZ3MgPSBkZXRhaWxzLmZyYWdtZW50cztcclxuICAgIHRoaXMubGFzdEFWU3RhcnQgPSBmcmFncy5sZW5ndGggPyBmcmFnc1swXS5zdGFydCA6IDA7XHJcbiAgfVxyXG5cclxuICBkb1RpY2sgKCkge1xyXG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XHJcbiAgICBjYXNlIFN0YXRlLklETEU6IHtcclxuICAgICAgY29uc3QgeyBjb25maWcsIGN1cnJlbnRUcmFja0lkLCBmcmFnbWVudFRyYWNrZXIsIG1lZGlhLCB0cmFja3MgfSA9IHRoaXM7XHJcbiAgICAgIGlmICghdHJhY2tzIHx8ICF0cmFja3NbY3VycmVudFRyYWNrSWRdIHx8ICF0cmFja3NbY3VycmVudFRyYWNrSWRdLmRldGFpbHMpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgeyBtYXhCdWZmZXJIb2xlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIH0gPSBjb25maWc7XHJcbiAgICAgIGNvbnN0IG1heENvbmZpZ0J1ZmZlciA9IE1hdGgubWluKGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgsIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xyXG4gICAgICBjb25zdCBidWZmZXJlZEluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvKHRoaXMuX2dldEJ1ZmZlcmVkKCksIG1lZGlhLmN1cnJlbnRUaW1lLCBtYXhCdWZmZXJIb2xlKTtcclxuICAgICAgY29uc3QgeyBlbmQ6IGJ1ZmZlckVuZCwgbGVuOiBidWZmZXJMZW4gfSA9IGJ1ZmZlcmVkSW5mbztcclxuXHJcbiAgICAgIGNvbnN0IHRyYWNrRGV0YWlscyA9IHRyYWNrc1tjdXJyZW50VHJhY2tJZF0uZGV0YWlscztcclxuICAgICAgY29uc3QgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cztcclxuICAgICAgY29uc3QgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGg7XHJcbiAgICAgIGNvbnN0IGVuZCA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLmR1cmF0aW9uO1xyXG5cclxuICAgICAgaWYgKGJ1ZmZlckxlbiA+IG1heENvbmZpZ0J1ZmZlcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGZvdW5kRnJhZztcclxuICAgICAgY29uc3QgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XHJcbiAgICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcclxuICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIHRyYWNrRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcclxuICAgICAgICAgIGZvdW5kRnJhZyA9IGZpbmRGcmFnbWVudEJ5UERUKGZyYWdtZW50cywgZnJhZ1ByZXZpb3VzLmVuZFByb2dyYW1EYXRlVGltZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZm91bmRGcmFnKSB7XHJcbiAgICAgICAgICBmb3VuZEZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZvdW5kRnJhZyAmJiBmb3VuZEZyYWcuZW5jcnlwdGVkKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyBrZXkgZm9yICR7Zm91bmRGcmFnLnNufWApO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcclxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FESU5HLCB7IGZyYWc6IGZvdW5kRnJhZyB9KTtcclxuICAgICAgfSBlbHNlIGlmIChmb3VuZEZyYWcgJiYgZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZvdW5kRnJhZykgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCkge1xyXG4gICAgICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXHJcbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZvdW5kRnJhZztcclxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xyXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FESU5HLCB7IGZyYWc6IGZvdW5kRnJhZyB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RvcExvYWQgKCkge1xyXG4gICAgdGhpcy5sYXN0QVZTdGFydCA9IDA7XHJcbiAgICBzdXBlci5zdG9wTG9hZCgpO1xyXG4gIH1cclxuXHJcbiAgX2dldEJ1ZmZlcmVkICgpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYWNrc0J1ZmZlcmVkW3RoaXMuY3VycmVudFRyYWNrSWRdIHx8IFtdO1xyXG4gIH1cclxuXHJcbiAgb25NZWRpYVNlZWtpbmcgKCkge1xyXG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xyXG4gIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyLmpzIiwiLyoqXHJcbiAqIEBhdXRob3IgU3RlcGhhbiBIZXNzZSA8ZGlzcGFyYXRAZ21haWwuY29tPiB8IDx0Y2hha2FiYW1AZ21haWwuY29tPlxyXG4gKlxyXG4gKiBEUk0gc3VwcG9ydCBmb3IgSGxzLmpzXHJcbiAqL1xyXG5cclxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcclxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XHJcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XHJcblxyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgeyBFTUVDb250cm9sbGVyQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcclxuaW1wb3J0IHsgS2V5U3lzdGVtcywgTWVkaWFLZXlGdW5jIH0gZnJvbSAnLi4vdXRpbHMvbWVkaWFrZXlzLWhlbHBlcic7XHJcblxyXG5jb25zdCBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTID0gMztcclxuXHJcbi8qKlxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25cclxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdWRpb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIGF1ZGlvIGNvZGVjcyB0byBzdXBwb3J0XHJcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdmlkZW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCB2aWRlbyBjb2RlY3MgdG8gc3VwcG9ydFxyXG4gKiBAcGFyYW0ge29iamVjdH0gZHJtU3lzdGVtT3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzL3JlcXVpcmVtZW50cyBmb3IgdGhlIGtleS1zeXN0ZW1cclxuICogQHJldHVybnMge0FycmF5PE1lZGlhU3lzdGVtQ29uZmlndXJhdGlvbj59IEFuIGFycmF5IG9mIHN1cHBvcnRlZCBjb25maWd1cmF0aW9uc1xyXG4gKi9cclxuXHJcbmNvbnN0IGNyZWF0ZVdpZGV2aW5lTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyA9IGZ1bmN0aW9uIChhdWRpb0NvZGVjczogc3RyaW5nW10sIHZpZGVvQ29kZWNzOiBzdHJpbmdbXSk6IE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbltdIHsgLyoganNoaW50IGlnbm9yZTpsaW5lICovXHJcbiAgY29uc3QgYmFzZUNvbmZpZzogTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9uID0ge1xyXG4gICAgLy8gaW5pdERhdGFUeXBlczogWydrZXlpZHMnLCAnbXA0J10sXHJcbiAgICAvLyBsYWJlbDogXCJcIixcclxuICAgIC8vIHBlcnNpc3RlbnRTdGF0ZTogXCJub3QtYWxsb3dlZFwiLCAvLyBvciBcInJlcXVpcmVkXCIgP1xyXG4gICAgLy8gZGlzdGluY3RpdmVJZGVudGlmaWVyOiBcIm5vdC1hbGxvd2VkXCIsIC8vIG9yIFwicmVxdWlyZWRcIiA/XHJcbiAgICAvLyBzZXNzaW9uVHlwZXM6IFsndGVtcG9yYXJ5J10sXHJcbiAgICB2aWRlb0NhcGFiaWxpdGllczogW10gLy8geyBjb250ZW50VHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUVcIicgfVxyXG4gIH07XHJcblxyXG4gIHZpZGVvQ29kZWNzLmZvckVhY2goKGNvZGVjKSA9PiB7XHJcbiAgICBiYXNlQ29uZmlnLnZpZGVvQ2FwYWJpbGl0aWVzIS5wdXNoKHtcclxuICAgICAgY29udGVudFR5cGU6IGB2aWRlby9tcDQ7IGNvZGVjcz1cIiR7Y29kZWN9XCJgXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIFtcclxuICAgIGJhc2VDb25maWdcclxuICBdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBpZGVhIGhlcmUgaXMgdG8gaGFuZGxlIGtleS1zeXN0ZW0gKGFuZCB0aGVpciByZXNwZWN0aXZlIHBsYXRmb3Jtcykgc3BlY2lmaWMgY29uZmlndXJhdGlvbiBkaWZmZXJlbmNlc1xyXG4gKiBpbiBvcmRlciB0byB3b3JrIHdpdGggdGhlIGxvY2FsIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyBtZXRob2QuXHJcbiAqXHJcbiAqIFdlIGNhbiBhbHNvIHJ1bGUtb3V0IHBsYXRmb3JtLXJlbGF0ZWQga2V5LXN5c3RlbSBzdXBwb3J0IGF0IHRoaXMgcG9pbnQgYnkgdGhyb3dpbmcgYW4gZXJyb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW0gSWRlbnRpZmllciBmb3IgdGhlIGtleS1zeXN0ZW0sIHNlZSBgS2V5U3lzdGVtc2AgZW51bVxyXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF1ZGlvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgYXVkaW8gY29kZWNzIHRvIHN1cHBvcnRcclxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB2aWRlb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIHZpZGVvIGNvZGVjcyB0byBzdXBwb3J0XHJcbiAqIEB0aHJvd3Mgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBhIHVua25vd24ga2V5IHN5c3RlbSBpcyBwYXNzZWRcclxuICogQHJldHVybnMge0FycmF5PE1lZGlhU3lzdGVtQ29uZmlndXJhdGlvbj59IEEgbm9uLWVtcHR5IEFycmF5IG9mIE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbiBvYmplY3RzXHJcbiAqL1xyXG5jb25zdCBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zID0gZnVuY3Rpb24gKGtleVN5c3RlbTogS2V5U3lzdGVtcywgYXVkaW9Db2RlY3M6IHN0cmluZ1tdLCB2aWRlb0NvZGVjczogc3RyaW5nW10pOiBNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25bXSB7XHJcbiAgc3dpdGNoIChrZXlTeXN0ZW0pIHtcclxuICBjYXNlIEtleVN5c3RlbXMuV0lERVZJTkU6XHJcbiAgICByZXR1cm4gY3JlYXRlV2lkZXZpbmVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcyk7XHJcbiAgZGVmYXVsdDpcclxuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBrZXktc3lzdGVtOiAke2tleVN5c3RlbX1gKTtcclxuICB9XHJcbn07XHJcblxyXG5pbnRlcmZhY2UgTWVkaWFLZXlzTGlzdEl0ZW0ge1xyXG4gIG1lZGlhS2V5cz86IE1lZGlhS2V5cyxcclxuICBtZWRpYUtleXNTZXNzaW9uPzogTWVkaWFLZXlTZXNzaW9uLFxyXG4gIG1lZGlhS2V5c1Nlc3Npb25Jbml0aWFsaXplZDogYm9vbGVhbjtcclxuICBtZWRpYUtleVN5c3RlbUFjY2VzczogTWVkaWFLZXlTeXN0ZW1BY2Nlc3M7XHJcbiAgbWVkaWFLZXlTeXN0ZW1Eb21haW46IEtleVN5c3RlbXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBlbmNyeXB0ZWQgbWVkaWEgZXh0ZW5zaW9ucyAoRU1FKVxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbmNyeXB0ZWRfTWVkaWFfRXh0ZW5zaW9uc19BUElcclxuICpcclxuICogQGNsYXNzXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuY2xhc3MgRU1FQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XHJcbiAgcHJpdmF0ZSBfd2lkZXZpbmVMaWNlbnNlVXJsPzogc3RyaW5nO1xyXG4gIHByaXZhdGUgX2xpY2Vuc2VYaHJTZXR1cD86ICh4aHI6IFhNTEh0dHBSZXF1ZXN0LCB1cmw6IHN0cmluZykgPT4gdm9pZDtcclxuICBwcml2YXRlIF9lbWVFbmFibGVkOiBib29sZWFuO1xyXG4gIHByaXZhdGUgX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzczogTWVkaWFLZXlGdW5jIHwgbnVsbFxyXG5cclxuICBwcml2YXRlIF9jb25maWc6IEVNRUNvbnRyb2xsZXJDb25maWc7XHJcbiAgcHJpdmF0ZSBfbWVkaWFLZXlzTGlzdDogTWVkaWFLZXlzTGlzdEl0ZW1bXSA9IFtdO1xyXG4gIHByaXZhdGUgX21lZGlhOiBIVE1MTWVkaWFFbGVtZW50IHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBfaGFzU2V0TWVkaWFLZXlzOiBib29sZWFuID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSBfcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQ6IG51bWJlciA9IDA7XHJcblxyXG4gIC8qKlxyXG4gICAgICogQGNvbnN0cnVjdHNcclxuICAgICAqIEBwYXJhbSB7SGxzfSBobHMgT3VyIEhscy5qcyBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgY29uc3RydWN0b3IgKGhscykge1xyXG4gICAgc3VwZXIoaGxzLFxyXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcclxuICAgICAgRXZlbnQuTUVESUFfREVUQUNIRUQsXHJcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRFxyXG4gICAgKTtcclxuICAgIHRoaXMuX2NvbmZpZyA9IGhscy5jb25maWc7XHJcblxyXG4gICAgdGhpcy5fd2lkZXZpbmVMaWNlbnNlVXJsID0gdGhpcy5fY29uZmlnLndpZGV2aW5lTGljZW5zZVVybDtcclxuICAgIHRoaXMuX2xpY2Vuc2VYaHJTZXR1cCA9IHRoaXMuX2NvbmZpZy5saWNlbnNlWGhyU2V0dXA7XHJcbiAgICB0aGlzLl9lbWVFbmFibGVkID0gdGhpcy5fY29uZmlnLmVtZUVuYWJsZWQ7XHJcbiAgICB0aGlzLl9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPSB0aGlzLl9jb25maWcucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW0gSWRlbnRpZmllciBmb3IgdGhlIGtleS1zeXN0ZW0sIHNlZSBgS2V5U3lzdGVtc2AgZW51bVxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IExpY2Vuc2Ugc2VydmVyIFVSTCBmb3Iga2V5LXN5c3RlbSAoaWYgYW55IGNvbmZpZ3VyZWQsIG90aGVyd2lzZSBjYXVzZXMgZXJyb3IpXHJcbiAgICogQHRocm93cyBpZiBhIHVuc3VwcG9ydGVkIGtleXN5c3RlbSBpcyBwYXNzZWRcclxuICAgKi9cclxuICBnZXRMaWNlbnNlU2VydmVyVXJsIChrZXlTeXN0ZW06IEtleVN5c3RlbXMpOiBzdHJpbmcge1xyXG4gICAgc3dpdGNoIChrZXlTeXN0ZW0pIHtcclxuICAgIGNhc2UgS2V5U3lzdGVtcy5XSURFVklORTpcclxuICAgICAgaWYgKCF0aGlzLl93aWRldmluZUxpY2Vuc2VVcmwpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5fd2lkZXZpbmVMaWNlbnNlVXJsO1xyXG4gICAgfVxyXG5cclxuICAgIHRocm93IG5ldyBFcnJvcihgbm8gbGljZW5zZSBzZXJ2ZXIgVVJMIGNvbmZpZ3VyZWQgZm9yIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cImApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiBSZXF1ZXN0cyBhY2Nlc3Mgb2JqZWN0IGFuZCBhZGRzIGl0IHRvIG91ciBsaXN0IHVwb24gc3VjY2Vzc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW0gU3lzdGVtIElEIChzZWUgYEtleVN5c3RlbXNgKVxyXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdWRpb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIGF1ZGlvIGNvZGVjcyB0byBzdXBwb3J0XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHZpZGVvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgdmlkZW8gY29kZWNzIHRvIHN1cHBvcnRcclxuICAgICAqIEB0aHJvd3MgV2hlbiBhIHVuc3VwcG9ydGVkIEtleVN5c3RlbSBpcyBwYXNzZWRcclxuICAgICAqL1xyXG4gIHByaXZhdGUgX2F0dGVtcHRLZXlTeXN0ZW1BY2Nlc3MgKGtleVN5c3RlbTogS2V5U3lzdGVtcywgYXVkaW9Db2RlY3M6IHN0cmluZ1tdLCB2aWRlb0NvZGVjczogc3RyaW5nW10pIHtcclxuICAgIC8vIFRPRE86IGFkZCBvdGhlciBEUk0gXCJvcHRpb25zXCJcclxuXHJcbiAgICAvLyBUaGlzIGNhbiB0aHJvdywgYnV0IGlzIGNhdWdodCBpbiBldmVudCBoYW5kbGVyIGNhbGxwYXRoXHJcbiAgICBjb25zdCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MgPSBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKTtcclxuXHJcbiAgICBsb2dnZXIubG9nKCdSZXF1ZXN0aW5nIGVuY3J5cHRlZCBtZWRpYSBrZXktc3lzdGVtIGFjY2VzcycpO1xyXG5cclxuICAgIC8vIGV4cGVjdGluZyBpbnRlcmZhY2UgbGlrZSB3aW5kb3cubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1xyXG4gICAgdGhpcy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MpXHJcbiAgICAgIC50aGVuKChtZWRpYUtleVN5c3RlbUFjY2VzcykgPT4ge1xyXG4gICAgICAgIHRoaXMuX29uTWVkaWFLZXlTeXN0ZW1BY2Nlc3NPYnRhaW5lZChrZXlTeXN0ZW0sIG1lZGlhS2V5U3lzdGVtQWNjZXNzKTtcclxuICAgICAgfSlcclxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBvYnRhaW4ga2V5LXN5c3RlbSBcIiR7a2V5U3lzdGVtfVwiIGFjY2VzczpgLCBlcnIpO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIGdldCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgKCkge1xyXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgZnVuY3Rpb24gY29uZmlndXJlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3M7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICAqIEhhbmRsZXMgb2J0YWluaW5nIGFjY2VzcyB0byBhIGtleS1zeXN0ZW1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5U3lzdGVtXHJcbiAgICAgKiBAcGFyYW0ge01lZGlhS2V5U3lzdGVtQWNjZXNzfSBtZWRpYUtleVN5c3RlbUFjY2VzcyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFLZXlTeXN0ZW1BY2Nlc3NcclxuICAgICAqL1xyXG4gIHByaXZhdGUgX29uTWVkaWFLZXlTeXN0ZW1BY2Nlc3NPYnRhaW5lZCAoa2V5U3lzdGVtOiBLZXlTeXN0ZW1zLCBtZWRpYUtleVN5c3RlbUFjY2VzczogTWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcclxuICAgIGxvZ2dlci5sb2coYEFjY2VzcyBmb3Iga2V5LXN5c3RlbSBcIiR7a2V5U3lzdGVtfVwiIG9idGFpbmVkYCk7XHJcblxyXG4gICAgY29uc3QgbWVkaWFLZXlzTGlzdEl0ZW06IE1lZGlhS2V5c0xpc3RJdGVtID0ge1xyXG4gICAgICBtZWRpYUtleXNTZXNzaW9uSW5pdGlhbGl6ZWQ6IGZhbHNlLFxyXG4gICAgICBtZWRpYUtleVN5c3RlbUFjY2VzczogbWVkaWFLZXlTeXN0ZW1BY2Nlc3MsXHJcbiAgICAgIG1lZGlhS2V5U3lzdGVtRG9tYWluOiBrZXlTeXN0ZW1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5fbWVkaWFLZXlzTGlzdC5wdXNoKG1lZGlhS2V5c0xpc3RJdGVtKTtcclxuXHJcbiAgICBtZWRpYUtleVN5c3RlbUFjY2Vzcy5jcmVhdGVNZWRpYUtleXMoKVxyXG4gICAgICAudGhlbigobWVkaWFLZXlzKSA9PiB7XHJcbiAgICAgICAgbWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzID0gbWVkaWFLZXlzO1xyXG5cclxuICAgICAgICBsb2dnZXIubG9nKGBNZWRpYS1rZXlzIGNyZWF0ZWQgZm9yIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cImApO1xyXG5cclxuICAgICAgICB0aGlzLl9vbk1lZGlhS2V5c0NyZWF0ZWQoKTtcclxuICAgICAgfSlcclxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgbWVkaWEta2V5czonLCBlcnIpO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMga2V5LWNyZWF0aW9uIChyZXByZXNlbnRzIGFjY2VzcyB0byBDRE0pLiBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIGtleS1zZXNzaW9ucyB1cG9uIHRoaXNcclxuICAgKiBmb3IgYWxsIGV4aXN0aW5nIGtleXMgd2hlcmUgbm8gc2Vzc2lvbiBleGlzdHMgeWV0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBwcml2YXRlIF9vbk1lZGlhS2V5c0NyZWF0ZWQgKCkge1xyXG4gICAgLy8gY2hlY2sgZm9yIGFsbCBrZXktbGlzdCBpdGVtcyBpZiBhIHNlc3Npb24gZXhpc3RzLCBvdGhlcndpc2UsIGNyZWF0ZSBvbmVcclxuICAgIHRoaXMuX21lZGlhS2V5c0xpc3QuZm9yRWFjaCgobWVkaWFLZXlzTGlzdEl0ZW0pID0+IHtcclxuICAgICAgaWYgKCFtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uKSB7XHJcbiAgICAgICAgLy8gbWVkaWFLZXlzIGlzIGRlZmluaXRlbHkgaW5pdGlhbGl6ZWQgaGVyZVxyXG4gICAgICAgIG1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb24gPSBtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXMhLmNyZWF0ZVNlc3Npb24oKTtcclxuICAgICAgICB0aGlzLl9vbk5ld01lZGlhS2V5U2Vzc2lvbihtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVNlc3Npb25cclxuICAgICAqL1xyXG4gIHByaXZhdGUgX29uTmV3TWVkaWFLZXlTZXNzaW9uIChrZXlTZXNzaW9uOiBNZWRpYUtleVNlc3Npb24pIHtcclxuICAgIGxvZ2dlci5sb2coYE5ldyBrZXktc3lzdGVtIHNlc3Npb24gJHtrZXlTZXNzaW9uLnNlc3Npb25JZH1gKTtcclxuXHJcbiAgICBrZXlTZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQ6IE1lZGlhS2V5TWVzc2FnZUV2ZW50KSA9PiB7XHJcbiAgICAgIHRoaXMuX29uS2V5U2Vzc2lvbk1lc3NhZ2Uoa2V5U2Vzc2lvbiwgZXZlbnQubWVzc2FnZSk7XHJcbiAgICB9LCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7TWVkaWFLZXlTZXNzaW9ufSBrZXlTZXNzaW9uXHJcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gbWVzc2FnZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgX29uS2V5U2Vzc2lvbk1lc3NhZ2UgKGtleVNlc3Npb246IE1lZGlhS2V5U2Vzc2lvbiwgbWVzc2FnZTogQXJyYXlCdWZmZXIpIHtcclxuICAgIGxvZ2dlci5sb2coJ0dvdCBFTUUgbWVzc2FnZSBldmVudCwgY3JlYXRpbmcgbGljZW5zZSByZXF1ZXN0Jyk7XHJcblxyXG4gICAgdGhpcy5fcmVxdWVzdExpY2Vuc2UobWVzc2FnZSwgKGRhdGE6IEFycmF5QnVmZmVyKSA9PiB7XHJcbiAgICAgIGxvZ2dlci5sb2coYFJlY2VpdmVkIGxpY2Vuc2UgZGF0YSAobGVuZ3RoOiAke2RhdGEgPyBkYXRhLmJ5dGVMZW5ndGggOiBkYXRhfSksIHVwZGF0aW5nIGtleS1zZXNzaW9uYCk7XHJcbiAgICAgIGtleVNlc3Npb24udXBkYXRlKGRhdGEpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbml0RGF0YVR5cGVcclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfG51bGx9IGluaXREYXRhXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfb25NZWRpYUVuY3J5cHRlZCA9IChlOiBNZWRpYUVuY3J5cHRlZEV2ZW50KSA9PiB7XHJcbiAgICBsb2dnZXIubG9nKGBNZWRpYSBpcyBlbmNyeXB0ZWQgdXNpbmcgXCIke2UuaW5pdERhdGFUeXBlfVwiIGluaXQgZGF0YSB0eXBlYCk7XHJcblxyXG4gICAgdGhpcy5fYXR0ZW1wdFNldE1lZGlhS2V5cygpO1xyXG4gICAgdGhpcy5fZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oZS5pbml0RGF0YVR5cGUsIGUuaW5pdERhdGEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBwcml2YXRlIF9hdHRlbXB0U2V0TWVkaWFLZXlzICgpIHtcclxuICAgIGlmICghdGhpcy5fbWVkaWEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gc2V0IG1lZGlhS2V5cyB3aXRob3V0IGZpcnN0IGF0dGFjaGluZyBhIG1lZGlhIGVsZW1lbnQnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX2hhc1NldE1lZGlhS2V5cykge1xyXG4gICAgICAvLyBGSVhNRTogc2VlIGlmIHdlIGNhbi93YW50L25lZWQtdG8gcmVhbGx5IHRvIGRlYWwgd2l0aCBzZXZlcmFsIHBvdGVudGlhbCBrZXktc2Vzc2lvbnM/XHJcbiAgICAgIGNvbnN0IGtleXNMaXN0SXRlbSA9IHRoaXMuX21lZGlhS2V5c0xpc3RbMF07XHJcbiAgICAgIGlmICgha2V5c0xpc3RJdGVtIHx8ICFrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzKSB7XHJcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdGYXRhbDogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBubyBDRE0gYWNjZXNzIG9yIG5vIGtleXMgaGF2ZSBiZWVuIG9idGFpbmVkIHlldCcpO1xyXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcclxuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcclxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0tFWVMsXHJcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbG9nZ2VyLmxvZygnU2V0dGluZyBrZXlzIGZvciBlbmNyeXB0ZWQgbWVkaWEnKTtcclxuXHJcbiAgICAgIHRoaXMuX21lZGlhLnNldE1lZGlhS2V5cyhrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzKTtcclxuICAgICAgdGhpcy5faGFzU2V0TWVkaWFLZXlzID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24gKGluaXREYXRhVHlwZTogc3RyaW5nLCBpbml0RGF0YTogQXJyYXlCdWZmZXIgfCBudWxsKSB7XHJcbiAgICAvLyBGSVhNRTogc2VlIGlmIHdlIGNhbi93YW50L25lZWQtdG8gcmVhbGx5IHRvIGRlYWwgd2l0aCBzZXZlcmFsIHBvdGVudGlhbCBrZXktc2Vzc2lvbnM/XHJcbiAgICBjb25zdCBrZXlzTGlzdEl0ZW0gPSB0aGlzLl9tZWRpYUtleXNMaXN0WzBdO1xyXG4gICAgaWYgKCFrZXlzTGlzdEl0ZW0pIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKCdGYXRhbDogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBub3QgYW55IGtleS1zeXN0ZW0gYWNjZXNzIGhhcyBiZWVuIG9idGFpbmVkIHlldCcpO1xyXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XHJcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxyXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0FDQ0VTUyxcclxuICAgICAgICBmYXRhbDogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbkluaXRpYWxpemVkKSB7XHJcbiAgICAgIGxvZ2dlci53YXJuKCdLZXktU2Vzc2lvbiBhbHJlYWR5IGluaXRpYWxpemVkIGJ1dCByZXF1ZXN0ZWQgYWdhaW4nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGtleVNlc3Npb24gPSBrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbjtcclxuICAgIGlmICgha2V5U2Vzc2lvbikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhdGFsOiBNZWRpYSBpcyBlbmNyeXB0ZWQgYnV0IG5vIGtleS1zZXNzaW9uIGV4aXN0aW5nJyk7XHJcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcclxuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXHJcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fU0VTU0lPTixcclxuICAgICAgICBmYXRhbDogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGluaXREYXRhIGlzIG51bGwgaWYgdGhlIG1lZGlhIGlzIG5vdCBDT1JTLXNhbWUtb3JpZ2luXHJcbiAgICBpZiAoIWluaXREYXRhKSB7XHJcbiAgICAgIGxvZ2dlci53YXJuKCdGYXRhbDogaW5pdERhdGEgcmVxdWlyZWQgZm9yIGdlbmVyYXRpbmcgYSBrZXkgc2Vzc2lvbiBpcyBudWxsJyk7XHJcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcclxuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXHJcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fSU5JVF9EQVRBLFxyXG4gICAgICAgIGZhdGFsOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbG9nZ2VyLmxvZyhgR2VuZXJhdGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0IGZvciBcIiR7aW5pdERhdGFUeXBlfVwiIGluaXQgZGF0YSB0eXBlYCk7XHJcbiAgICBrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbkluaXRpYWxpemVkID0gdHJ1ZTtcclxuXHJcbiAgICBrZXlTZXNzaW9uLmdlbmVyYXRlUmVxdWVzdChpbml0RGF0YVR5cGUsIGluaXREYXRhKVxyXG4gICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdLZXktc2Vzc2lvbiBnZW5lcmF0aW9uIHN1Y2NlZWRlZCcpO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0OicsIGVycik7XHJcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xyXG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxyXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fU0VTU0lPTixcclxuICAgICAgICAgIGZhdGFsOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBMaWNlbnNlIHNlcnZlciBVUkxcclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBrZXlNZXNzYWdlIE1lc3NhZ2UgZGF0YSBpc3N1ZWQgYnkga2V5LXN5c3RlbVxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCB3aGVuIFhIUiBoYXMgc3VjY2VlZGVkXHJcbiAgICogQHJldHVybnMge1hNTEh0dHBSZXF1ZXN0fSBVbnNlbnQgKGJ1dCBvcGVuZWQgc3RhdGUpIFhIUiBvYmplY3RcclxuICAgKiBAdGhyb3dzIGlmIFhNTEh0dHBSZXF1ZXN0IGNvbnN0cnVjdGlvbiBmYWlsZWRcclxuICAgKi9cclxuICBwcml2YXRlIF9jcmVhdGVMaWNlbnNlWGhyICh1cmw6IHN0cmluZywga2V5TWVzc2FnZTogQXJyYXlCdWZmZXIsIGNhbGxiYWNrOiAoZGF0YTogQXJyYXlCdWZmZXIpID0+IHZvaWQpOiBYTUxIdHRwUmVxdWVzdCB7XHJcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgIGNvbnN0IGxpY2Vuc2VYaHJTZXR1cCA9IHRoaXMuX2xpY2Vuc2VYaHJTZXR1cDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAobGljZW5zZVhoclNldHVwKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGxpY2Vuc2VYaHJTZXR1cCh4aHIsIHVybCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgLy8gbGV0J3MgdHJ5IHRvIG9wZW4gYmVmb3JlIHJ1bm5pbmcgc2V0dXBcclxuICAgICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcclxuICAgICAgICAgIGxpY2Vuc2VYaHJTZXR1cCh4aHIsIHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIGlmIGxpY2Vuc2VYaHJTZXR1cCBkaWQgbm90IHlldCBjYWxsIG9wZW4sIGxldCdzIGRvIGl0IG5vd1xyXG4gICAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XHJcbiAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB1cmwsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIC8vIElFMTEgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB4aHIub3BlbiBpZiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBhbiBIVFRQIHJlc291cmNlIG92ZXIgSFRUUFNcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpc3N1ZSBzZXR0aW5nIHVwIEtleVN5c3RlbSBsaWNlbnNlIFhIUiAke2V9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmVjYXVzZSB3ZSBzZXQgcmVzcG9uc2VUeXBlIHRvIEFycmF5QnVmZmVyIGhlcmUsIGNhbGxiYWNrIGlzIHR5cGVkIGFzIGhhbmRsaW5nIG9ubHkgYXJyYXkgYnVmZmVyc1xyXG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID1cclxuICAgICAgICB0aGlzLl9vbkxpY2Vuc2VSZXF1ZXN0UmVhZHlTdGFnZUNoYW5nZS5iaW5kKHRoaXMsIHhociwgdXJsLCBrZXlNZXNzYWdlLCBjYWxsYmFjayk7XHJcbiAgICByZXR1cm4geGhyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fSB4aHJcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIExpY2Vuc2Ugc2VydmVyIFVSTFxyXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGtleU1lc3NhZ2UgTWVzc2FnZSBkYXRhIGlzc3VlZCBieSBrZXktc3lzdGVtXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gWEhSIGhhcyBzdWNjZWVkZWRcclxuICAgKi9cclxuICBwcml2YXRlIF9vbkxpY2Vuc2VSZXF1ZXN0UmVhZHlTdGFnZUNoYW5nZSAoeGhyOiBYTUxIdHRwUmVxdWVzdCwgdXJsOiBzdHJpbmcsIGtleU1lc3NhZ2U6IEFycmF5QnVmZmVyLCBjYWxsYmFjazogKGRhdGE6IEFycmF5QnVmZmVyKSA9PiB2b2lkKSB7XHJcbiAgICBzd2l0Y2ggKHhoci5yZWFkeVN0YXRlKSB7XHJcbiAgICBjYXNlIDQ6XHJcbiAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XHJcbiAgICAgICAgbG9nZ2VyLmxvZygnTGljZW5zZSByZXF1ZXN0IHN1Y2NlZWRlZCcpO1xyXG5cclxuICAgICAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSAhPT0gJ2FycmF5YnVmZmVyJykge1xyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ3hociByZXNwb25zZSB0eXBlIHdhcyBub3Qgc2V0IHRvIHRoZSBleHBlY3RlZCBhcnJheWJ1ZmZlciBmb3IgbGljZW5zZSByZXF1ZXN0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxiYWNrKHhoci5yZXNwb25zZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBMaWNlbnNlIFJlcXVlc3QgWEhSIGZhaWxlZCAoJHt1cmx9KS4gU3RhdHVzOiAke3hoci5zdGF0dXN9ICgke3hoci5zdGF0dXNUZXh0fSlgKTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCsrO1xyXG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA+IE1BWF9MSUNFTlNFX1JFUVVFU1RfRkFJTFVSRVMpIHtcclxuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcclxuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxyXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVELFxyXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBhdHRlbXB0c0xlZnQgPSBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTIC0gdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgKyAxO1xyXG4gICAgICAgIGxvZ2dlci53YXJuKGBSZXRyeWluZyBsaWNlbnNlIHJlcXVlc3QsICR7YXR0ZW1wdHNMZWZ0fSBhdHRlbXB0cyBsZWZ0YCk7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdExpY2Vuc2Uoa2V5TWVzc2FnZSwgY2FsbGJhY2spO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge01lZGlhS2V5c0xpc3RJdGVtfSBrZXlzTGlzdEl0ZW1cclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBrZXlNZXNzYWdlXHJcbiAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBDaGFsbGVuZ2UgZGF0YSBwb3N0ZWQgdG8gbGljZW5zZSBzZXJ2ZXJcclxuICAgKiBAdGhyb3dzIGlmIEtleVN5c3RlbSBpcyB1bnN1cHBvcnRlZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2dlbmVyYXRlTGljZW5zZVJlcXVlc3RDaGFsbGVuZ2UgKGtleXNMaXN0SXRlbTogTWVkaWFLZXlzTGlzdEl0ZW0sIGtleU1lc3NhZ2U6IEFycmF5QnVmZmVyKTogQXJyYXlCdWZmZXIge1xyXG4gICAgc3dpdGNoIChrZXlzTGlzdEl0ZW0ubWVkaWFLZXlTeXN0ZW1Eb21haW4pIHtcclxuICAgIC8vIGNhc2UgS2V5U3lzdGVtcy5QTEFZUkVBRFk6XHJcbiAgICAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnRFZGdlL0RlbW9zL2Jsb2IvbWFzdGVyL2VtZS9zY3JpcHRzL2RlbW8uanNcclxuICAgIC8qXHJcbiAgICAgIGlmICh0aGlzLmxpY2Vuc2VUeXBlICE9PSB0aGlzLkxJQ0VOU0VfVFlQRV9XSURFVklORSkge1xyXG4gICAgICAgIC8vIEZvciBQbGF5UmVhZHkgQ0RNcywgd2UgbmVlZCB0byBkaWcgdGhlIENoYWxsZW5nZSBvdXQgb2YgdGhlIFhNTC5cclxuICAgICAgICB2YXIga2V5TWVzc2FnZVhtbCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoa2V5TWVzc2FnZSkpLCAnYXBwbGljYXRpb24veG1sJyk7XHJcbiAgICAgICAgaWYgKGtleU1lc3NhZ2VYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0NoYWxsZW5nZScpWzBdKSB7XHJcbiAgICAgICAgICAgIGNoYWxsZW5nZSA9IGF0b2Ioa2V5TWVzc2FnZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnQ2hhbGxlbmdlJylbMF0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93ICdDYW5ub3QgZmluZCA8Q2hhbGxlbmdlPiBpbiBrZXkgbWVzc2FnZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoZWFkZXJOYW1lcyA9IGtleU1lc3NhZ2VYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ25hbWUnKTtcclxuICAgICAgICB2YXIgaGVhZGVyVmFsdWVzID0ga2V5TWVzc2FnZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmFsdWUnKTtcclxuICAgICAgICBpZiAoaGVhZGVyTmFtZXMubGVuZ3RoICE9PSBoZWFkZXJWYWx1ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdNaXNtYXRjaGVkIGhlYWRlciA8bmFtZT4vPHZhbHVlPiBwYWlyIGluIGtleSBtZXNzYWdlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXJOYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lc1tpXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSwgaGVhZGVyVmFsdWVzW2ldLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICAqL1xyXG4gICAgY2FzZSBLZXlTeXN0ZW1zLldJREVWSU5FOlxyXG4gICAgICAvLyBGb3IgV2lkZXZpbmUgQ0RNcywgdGhlIGNoYWxsZW5nZSBpcyB0aGUga2V5TWVzc2FnZS5cclxuICAgICAgcmV0dXJuIGtleU1lc3NhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBrZXktc3lzdGVtOiAke2tleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbn1gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIGtleU1lc3NhZ2VcclxuICAgKiBAcGFyYW0gY2FsbGJhY2tcclxuICAgKi9cclxuICBwcml2YXRlIF9yZXF1ZXN0TGljZW5zZSAoa2V5TWVzc2FnZTogQXJyYXlCdWZmZXIsIGNhbGxiYWNrOiAoZGF0YTogQXJyYXlCdWZmZXIpID0+IHZvaWQpIHtcclxuICAgIGxvZ2dlci5sb2coJ1JlcXVlc3RpbmcgY29udGVudCBsaWNlbnNlIGZvciBrZXktc3lzdGVtJyk7XHJcblxyXG4gICAgY29uc3Qga2V5c0xpc3RJdGVtID0gdGhpcy5fbWVkaWFLZXlzTGlzdFswXTtcclxuICAgIGlmICgha2V5c0xpc3RJdGVtKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcignRmF0YWwgZXJyb3I6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm8ga2V5LXN5c3RlbSBhY2Nlc3MgaGFzIGJlZW4gb2J0YWluZWQgeWV0Jyk7XHJcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcclxuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXHJcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fQUNDRVNTLFxyXG4gICAgICAgIGZhdGFsOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdXJsID0gdGhpcy5nZXRMaWNlbnNlU2VydmVyVXJsKGtleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbik7XHJcbiAgICAgIGNvbnN0IHhociA9IHRoaXMuX2NyZWF0ZUxpY2Vuc2VYaHIodXJsLCBrZXlNZXNzYWdlLCBjYWxsYmFjayk7XHJcbiAgICAgIGxvZ2dlci5sb2coYFNlbmRpbmcgbGljZW5zZSByZXF1ZXN0IHRvIFVSTDogJHt1cmx9YCk7XHJcbiAgICAgIGNvbnN0IGNoYWxsZW5nZSA9IHRoaXMuX2dlbmVyYXRlTGljZW5zZVJlcXVlc3RDaGFsbGVuZ2Uoa2V5c0xpc3RJdGVtLCBrZXlNZXNzYWdlKTtcclxuICAgICAgeGhyLnNlbmQoY2hhbGxlbmdlKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsdXJlIHJlcXVlc3RpbmcgRFJNIGxpY2Vuc2U6ICR7ZX1gKTtcclxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xyXG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcclxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVELFxyXG4gICAgICAgIGZhdGFsOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25NZWRpYUF0dGFjaGVkIChkYXRhOiB7IG1lZGlhOiBIVE1MTWVkaWFFbGVtZW50OyB9KSB7XHJcbiAgICBpZiAoIXRoaXMuX2VtZUVuYWJsZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1lZGlhID0gZGF0YS5tZWRpYTtcclxuXHJcbiAgICAvLyBrZWVwIHJlZmVyZW5jZSBvZiBtZWRpYVxyXG4gICAgdGhpcy5fbWVkaWEgPSBtZWRpYTtcclxuXHJcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmNyeXB0ZWQnLCB0aGlzLl9vbk1lZGlhRW5jcnlwdGVkKTtcclxuICB9XHJcblxyXG4gIG9uTWVkaWFEZXRhY2hlZCAoKSB7XHJcbiAgICBpZiAodGhpcy5fbWVkaWEpIHtcclxuICAgICAgdGhpcy5fbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5jcnlwdGVkJywgdGhpcy5fb25NZWRpYUVuY3J5cHRlZCk7XHJcbiAgICAgIHRoaXMuX21lZGlhID0gbnVsbDsgLy8gcmVsZWFzZSByZWZlcmVuY2VcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFRPRE86IFVzZSBtYW5pZmVzdCB0eXBlcyBoZXJlIHdoZW4gdGhleSBhcmUgZGVmaW5lZFxyXG4gIG9uTWFuaWZlc3RQYXJzZWQgKGRhdGE6IGFueSkge1xyXG4gICAgaWYgKCF0aGlzLl9lbWVFbmFibGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhdWRpb0NvZGVjcyA9IGRhdGEubGV2ZWxzLm1hcCgobGV2ZWwpID0+IGxldmVsLmF1ZGlvQ29kZWMpO1xyXG4gICAgY29uc3QgdmlkZW9Db2RlY3MgPSBkYXRhLmxldmVscy5tYXAoKGxldmVsKSA9PiBsZXZlbC52aWRlb0NvZGVjKTtcclxuXHJcbiAgICB0aGlzLl9hdHRlbXB0S2V5U3lzdGVtQWNjZXNzKEtleVN5c3RlbXMuV0lERVZJTkUsIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcyk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFTUVDb250cm9sbGVyO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGxzLmpzL3NyYy9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyLnRzIiwiaW1wb3J0IFhockxvYWRlciBmcm9tICcuL3hoci1sb2FkZXInO1xyXG5pbXBvcnQgeyBPYnNlcnZlciB9IGZyb20gJy4uL29ic2VydmVyJztcclxuXHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XHJcbmltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcclxuXHJcbmNsYXNzIFhockFlc0xvYWRlciBleHRlbmRzIFhockxvYWRlciB7XHJcbiAgY29uc3RydWN0b3IgKGNvbmZpZykge1xyXG4gICAgc3VwZXIoY29uZmlnKTtcclxuICAgIGlmIChjb25maWcgJiYgY29uZmlnLmFlc1NldHVwKSB7XHJcbiAgICAgIHRoaXMuYWVzU2V0dXAgPSBjb25maWcuYWVzU2V0dXA7XHJcbiAgICB9XHJcbiAgICB0aGlzLm9ic2VydmVyID0gbmV3IE9ic2VydmVyKCk7XHJcbiAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIodGhpcy5vYnNlcnZlciwgY29uZmlnKTtcclxuICB9XHJcbiAgc3RyMmFiIChzdHIpIHtcclxuICAgIGxldCBidWYgPSBuZXcgQXJyYXlCdWZmZXIoc3RyLmxlbmd0aCk7IC8vIDIgYnl0ZXMgZm9yIGVhY2ggY2hhclxyXG4gICAgbGV0IGJ1ZlZpZXcgPSBuZXcgVWludDhBcnJheShidWYpO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIHN0ckxlbiA9IHN0ci5sZW5ndGg7IGkgPCBzdHJMZW47IGkrKykge1xyXG4gICAgICBidWZWaWV3W2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnVmO1xyXG4gIH1cclxuICBhYjJzdHIgKGJ1Zikge1xyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoYnVmKSk7XHJcbiAgfVxyXG4gIGxvYWQgKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XHJcbiAgICBsZXQgbmVlZENvbnZlcnRUb1N0ciA9IGNvbnRleHQucmVzcG9uc2VUeXBlICE9PSAnYXJyYXlidWZmZXInO1xyXG4gICAgY29udGV4dC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG4gICAgc3VwZXIubG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcyk7XHJcbiAgICBsZXQgb25TdWNjZXNzID0gdGhpcy5jYWxsYmFja3Mub25TdWNjZXNzO1xyXG4gICAgdGhpcy5jYWxsYmFja3Mub25TdWNjZXNzID0gKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgeGhyKSA9PiB7XHJcbiAgICAgIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQocmVzcG9uc2UuZGF0YSwgdGhpcy5zdHIyYWIodGhpcy5hZXNTZXR1cC5rZXkpLCB0aGlzLnN0cjJhYih0aGlzLmFlc1NldHVwLml2KSwgKGRlY3J5cHRlZERhdGEpID0+IHtcclxuICAgICAgICByZXNwb25zZS5kYXRhID0gbmVlZENvbnZlcnRUb1N0ciA/IHRoaXMuYWIyc3RyKGRlY3J5cHRlZERhdGEpIDogZGVjcnlwdGVkRGF0YTtcclxuICAgICAgICBpZiAodHlwZW9mIG9uU3VjY2VzcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgb25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgeGhyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFhockFlc0xvYWRlcjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hscy5qcy9zcmMvdXRpbHMveGhyLWFlcy1sb2FkZXIuanMiXSwic291cmNlUm9vdCI6IiJ9
